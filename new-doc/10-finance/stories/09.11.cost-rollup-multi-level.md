# 09.11 - Cost Rollup & Multi-Level BOM

**Priority**: P0 (Phase 2)
**Story Points**: M (Medium)
**Type**: backend
**Phase**: 2 (Advanced Costing)
**Model**: OPUS

**State:** ready
**Estimate:** M (3-4 days)
**Primary PRD:** `docs/1-BASELINE/product/modules/finance.md` (FR-9.1.5, FR-9.1.7)
**Architecture:** `docs/1-BASELINE/architecture/modules/finance.md` (cost_rollups recursive)

---

## Goal

Implement recursive BOM cost rollup to calculate total product cost through multi-level BOM structures. Support sub-assembly costing where intermediate products have their own BOMs, enabling accurate cost calculation for complex product hierarchies.

---

## User Story

As a **Finance Manager**, I want to **calculate costs through multi-level BOMs where sub-assemblies have their own BOMs** so that **I can accurately cost complex products with intermediate assemblies**.

As a **Cost Accountant**, I want to **see cost breakdown at each BOM level** so that **I can identify cost drivers at each assembly stage**.

---

## MVP Scope

**MVP Includes**:
- Recursive BOM cost traversal
- Sub-assembly cost calculation
- Multi-level cost aggregation
- BOM level tracking (0 = finished good, 1+ = sub-assembly)
- Cost rollup caching
- Bottom-up cost calculation
- Integration with 09.5 BOM costing
- Multi-level cost breakdown API

**Deferred to Phase 3**:
- Cost rollup approval workflow
- Cost impact simulation on BOM changes
- Automated recalculation on sub-assembly cost changes

---

## Dependencies

| Dependency | Story/Epic | Type | Status |
|------------|------------|------|--------|
| 01.1 | Org Context | HARD | Ready |
| 02.2 | BOM CRUD | HARD | Ready |
| 02.4 | BOM Versioning | HARD | Ready |
| 09.2 | Standard Costs | HARD | Ready |
| 09.5 | BOM Costing | HARD | Ready |

---

## Database Migration

```sql
-- Migration: add_multi_level_cost_rollup.sql

-- Add columns to cost_rollups for multi-level tracking
ALTER TABLE cost_rollups
ADD COLUMN IF NOT EXISTS parent_rollup_id UUID REFERENCES cost_rollups(id),
ADD COLUMN IF NOT EXISTS bom_level INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS is_sub_assembly BOOLEAN NOT NULL DEFAULT false,
ADD COLUMN IF NOT EXISTS sub_assembly_count INTEGER NOT NULL DEFAULT 0;

CREATE INDEX idx_cost_rollups_parent ON cost_rollups(parent_rollup_id);
CREATE INDEX idx_cost_rollups_level ON cost_rollups(org_id, bom_level);

-- Function: Recursive BOM cost rollup
CREATE OR REPLACE FUNCTION calculate_multi_level_bom_cost(
    p_org_id UUID,
    p_bom_id UUID,
    p_effective_date DATE DEFAULT CURRENT_DATE,
    p_current_level INTEGER DEFAULT 0
)
RETURNS TABLE (
    bom_id UUID,
    bom_level INTEGER,
    material_cost NUMERIC,
    labor_cost NUMERIC,
    overhead_cost NUMERIC,
    total_cost NUMERIC,
    sub_assembly_details JSONB
) AS $$
DECLARE
    v_material_cost NUMERIC := 0;
    v_labor_cost NUMERIC := 0;
    v_overhead_cost NUMERIC := 0;
    v_total_cost NUMERIC := 0;
    v_sub_assembly_cost NUMERIC := 0;
    v_bom_item RECORD;
    v_routing_op RECORD;
    v_sub_assembly_details JSONB := '[]'::jsonb;
    v_sub_rollup RECORD;
BEGIN
    -- Iterate through BOM items
    FOR v_bom_item IN
        SELECT
            bi.id,
            bi.product_id,
            bi.quantity,
            bi.uom,
            p.name AS product_name,
            p.is_manufactured
        FROM bom_items bi
        JOIN products p ON p.id = bi.product_id
        WHERE bi.bom_id = p_bom_id
        AND bi.org_id = p_org_id
        ORDER BY bi.sequence
    LOOP
        -- Check if item is a manufactured sub-assembly
        IF v_bom_item.is_manufactured THEN
            -- Get active BOM for sub-assembly
            DECLARE
                v_sub_bom_id UUID;
            BEGIN
                SELECT b.id INTO v_sub_bom_id
                FROM boms b
                WHERE b.product_id = v_bom_item.product_id
                AND b.org_id = p_org_id
                AND b.status = 'active'
                AND p_effective_date BETWEEN b.effective_from AND COALESCE(b.effective_to, '9999-12-31')
                LIMIT 1;

                IF v_sub_bom_id IS NOT NULL THEN
                    -- Recursively calculate sub-assembly cost
                    SELECT * INTO v_sub_rollup
                    FROM calculate_multi_level_bom_cost(
                        p_org_id,
                        v_sub_bom_id,
                        p_effective_date,
                        p_current_level + 1
                    );

                    v_sub_assembly_cost := v_sub_rollup.total_cost * v_bom_item.quantity;
                    v_material_cost := v_material_cost + v_sub_assembly_cost;

                    -- Track sub-assembly details
                    v_sub_assembly_details := v_sub_assembly_details ||
                        jsonb_build_object(
                            'bom_item_id', v_bom_item.id,
                            'product_id', v_bom_item.product_id,
                            'product_name', v_bom_item.product_name,
                            'quantity', v_bom_item.quantity,
                            'unit_cost', v_sub_rollup.total_cost,
                            'total_cost', v_sub_assembly_cost,
                            'bom_level', p_current_level + 1,
                            'breakdown', v_sub_rollup.sub_assembly_details
                        );
                END IF;
            END;
        ELSE
            -- Regular material/ingredient - get standard cost
            DECLARE
                v_item_cost NUMERIC;
            BEGIN
                SELECT COALESCE(sc.total_cost, 0) INTO v_item_cost
                FROM standard_costs sc
                WHERE sc.item_id = v_bom_item.product_id
                AND sc.org_id = p_org_id
                AND p_effective_date BETWEEN sc.effective_from AND COALESCE(sc.effective_to, '9999-12-31')
                AND sc.status = 'active'
                ORDER BY sc.effective_from DESC
                LIMIT 1;

                v_material_cost := v_material_cost + (v_item_cost * v_bom_item.quantity);
            END;
        END IF;
    END LOOP;

    -- Add labor cost from routing
    FOR v_routing_op IN
        SELECT ro.standard_hours, ro.hourly_rate
        FROM boms b
        LEFT JOIN routings r ON r.id = b.routing_id
        LEFT JOIN routing_operations ro ON ro.routing_id = r.id
        WHERE b.id = p_bom_id
        AND b.org_id = p_org_id
    LOOP
        v_labor_cost := v_labor_cost + (v_routing_op.standard_hours * COALESCE(v_routing_op.hourly_rate, 30));
    END LOOP;

    -- Calculate overhead (from finance_settings or default 150% of labor)
    DECLARE
        v_overhead_rate NUMERIC := 1.5;
    BEGIN
        SELECT overhead_allocation_rate INTO v_overhead_rate
        FROM finance_settings
        WHERE org_id = p_org_id;

        v_overhead_cost := v_labor_cost * COALESCE(v_overhead_rate, 1.5);
    END;

    v_total_cost := v_material_cost + v_labor_cost + v_overhead_cost;

    RETURN QUERY SELECT
        p_bom_id,
        p_current_level,
        v_material_cost,
        v_labor_cost,
        v_overhead_cost,
        v_total_cost,
        v_sub_assembly_details;
END;
$$ LANGUAGE plpgsql;

-- Function: Batch recalculate all BOM costs
CREATE OR REPLACE FUNCTION recalculate_all_bom_costs(p_org_id UUID)
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER := 0;
    v_bom RECORD;
    v_rollup RECORD;
BEGIN
    FOR v_bom IN
        SELECT id, product_id
        FROM boms
        WHERE org_id = p_org_id
        AND status = 'active'
        ORDER BY created_at
    LOOP
        SELECT * INTO v_rollup
        FROM calculate_multi_level_bom_cost(p_org_id, v_bom.id);

        INSERT INTO cost_rollups (
            org_id, product_id, bom_id, bom_level,
            material_cost, labor_cost, overhead_cost, total_cost,
            currency_id, calculation_method, effective_date
        )
        VALUES (
            p_org_id, v_bom.product_id, v_bom.id, v_rollup.bom_level,
            v_rollup.material_cost, v_rollup.labor_cost,
            v_rollup.overhead_cost, v_rollup.total_cost,
            (SELECT id FROM currencies WHERE org_id = p_org_id AND is_base = true LIMIT 1),
            'standard', CURRENT_DATE
        )
        ON CONFLICT (org_id, bom_id, effective_date)
        DO UPDATE SET
            material_cost = EXCLUDED.material_cost,
            labor_cost = EXCLUDED.labor_cost,
            overhead_cost = EXCLUDED.overhead_cost,
            total_cost = EXCLUDED.total_cost,
            updated_at = now();

        v_count := v_count + 1;
    END LOOP;

    RETURN v_count;
END;
$$ LANGUAGE plpgsql;
```

---

## API Endpoints

### GET /api/finance/bom-costs/:bomId/multi-level
Get multi-level BOM cost breakdown.

**Response:**
```json
{
  "bom_id": "uuid",
  "product_id": "uuid",
  "product_name": "Pizza Margherita",
  "bom_level": 0,
  "material_cost": 8.50,
  "labor_cost": 2.00,
  "overhead_cost": 3.00,
  "total_cost": 13.50,
  "unit_cost": 13.50,
  "sub_assemblies": [
    {
      "bom_item_id": "uuid",
      "product_id": "uuid",
      "product_name": "Pizza Dough (Sub-assembly)",
      "quantity": 1,
      "unit_cost": 3.50,
      "total_cost": 3.50,
      "bom_level": 1,
      "breakdown": {
        "material_cost": 2.50,
        "labor_cost": 0.50,
        "overhead_cost": 0.50
      }
    },
    {
      "bom_item_id": "uuid",
      "product_name": "Tomato Sauce",
      "quantity": 0.2,
      "unit_cost": 5.00,
      "total_cost": 1.00,
      "bom_level": 0
    }
  ]
}
```

### POST /api/finance/bom-costs/recalculate-all
Recalculate all BOM costs (admin only).

**Request:**
```json
{
  "effective_date": "2026-01-15"
}
```

**Response:**
```json
{
  "success": true,
  "count": 127,
  "duration_ms": 2350
}
```

---

## Service Layer

### BOMCostService (extend from 09.5)

```typescript
export class BOMCostService {
  // NEW methods for multi-level

  static async calculateMultiLevelCost(
    bomId: string,
    effectiveDate?: Date
  ): Promise<MultiLevelBOMCostResult> {
    const { data, error } = await supabase.rpc(
      'calculate_multi_level_bom_cost',
      {
        p_org_id: getOrgId(),
        p_bom_id: bomId,
        p_effective_date: effectiveDate || new Date(),
        p_current_level: 0
      }
    );

    if (error) throw new Error(`Multi-level cost calculation failed: ${error.message}`);
    return data;
  }

  static async getMultiLevelCostBreakdown(bomId: string) {
    const response = await fetch(`/api/finance/bom-costs/${bomId}/multi-level`);
    if (!response.ok) throw new Error('Failed to fetch multi-level breakdown');
    return response.json();
  }

  static async recalculateAllBOMCosts(): Promise<number> {
    const { data, error } = await supabase.rpc('recalculate_all_bom_costs', {
      p_org_id: getOrgId()
    });

    if (error) throw new Error(`Batch recalculation failed: ${error.message}`);
    return data;
  }

  static async getCostByLevel(bomId: string): Promise<BOMCostByLevel[]> {
    const { data, error } = await supabase
      .from('cost_rollups')
      .select('*, products(name)')
      .eq('bom_id', bomId)
      .order('bom_level', { ascending: true });

    if (error) throw new Error(`Failed to fetch cost by level: ${error.message}`);
    return data;
  }
}
```

---

## Acceptance Criteria

### AC-1: Multi-Level BOM Cost Calculation
```gherkin
Given multi-level BOM structure:
  | Level | Product | Type | Quantity | Unit Cost |
  | 0 | Pizza Margherita | finished | 1 | ? |
  | 1 | Pizza Dough | sub-assembly | 1 | 3.50 |
  | 2 | Flour | ingredient | 0.5kg | 2.00/kg |
  | 2 | Yeast | ingredient | 10g | 0.05/g |
  | 1 | Tomato Sauce | ingredient | 0.2L | 5.00/L |
  | 1 | Mozzarella | ingredient | 0.15kg | 20.00/kg |
When calculating multi-level cost
Then Pizza Dough sub-assembly cost = 1.00 + 0.50 (materials) + labor + overhead = 3.50
And Pizza Margherita total = 3.50 + 1.00 + 3.00 + labor + overhead = 13.50
```

### AC-2: Recursive Sub-Assembly Resolution
```gherkin
Given BOM with 3 levels:
  - Level 0: Final Product
  - Level 1: 2 sub-assemblies
  - Level 2: Raw materials
When calculating cost
Then calculation starts at Level 2 (bottom-up)
And Level 1 costs include Level 2 aggregated costs
And Level 0 includes all sub-assembly costs
```

### AC-3: Cost Breakdown API
```gherkin
Given GET /api/finance/bom-costs/:bomId/multi-level
When requesting multi-level breakdown
Then response includes:
  - Top-level cost summary
  - Sub-assembly array with nested breakdown
  - BOM level for each item
  - Material/labor/overhead split at each level
```

### AC-4: Batch Recalculation
```gherkin
Given 100 BOMs with multi-level structures
When POST /api/finance/bom-costs/recalculate-all
Then all BOMs recalculated bottom-up
And cost_rollups updated for all levels
And operation completes in < 5 seconds
```

---

## Performance Requirements

- Multi-level cost calculation (3 levels, 50 items): < 1s
- Batch recalculation (100 BOMs): < 5s
- API response (multi-level breakdown): < 500ms
- Database recursion depth limit: 10 levels

---

## Testing

### Unit Tests
- Recursive cost calculation (2, 3, 5 levels)
- Sub-assembly cost aggregation
- Cost rollup caching
- Circular BOM detection
- Missing standard cost handling

### Integration Tests
- Multi-level API endpoints
- Batch recalculation
- Cost update propagation

### Edge Cases
- Circular BOM reference (should error)
- Missing BOM for sub-assembly
- Inactive BOM for sub-assembly
- Zero quantity sub-assembly

---

## Deliverables

- [ ] Extended `cost_rollups` table (parent_rollup_id, bom_level)
- [ ] `calculate_multi_level_bom_cost()` function
- [ ] `recalculate_all_bom_costs()` function
- [ ] API: GET multi-level breakdown
- [ ] API: POST batch recalculate
- [ ] Extended BOMCostService
- [ ] Multi-level cost breakdown UI component
- [ ] Tests: Unit, integration, edge cases

---

## Definition of Done

- [ ] Multi-level BOM cost calculated correctly (3+ levels)
- [ ] Sub-assembly costs aggregated bottom-up
- [ ] Circular BOM detection prevents infinite loops
- [ ] API returns nested cost breakdown
- [ ] Batch recalculation completes < 5s (100 BOMs)
- [ ] Tests pass (unit, integration, edge cases)
- [ ] Performance benchmarks met
- [ ] Documentation updated

---

**Created**: 2026-01-15 | **Complexity**: M (3-4 days) | **Phase**: 2
