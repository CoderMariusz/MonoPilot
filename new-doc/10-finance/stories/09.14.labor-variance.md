# 09.14 - Labor Variance

**Priority**: P0 (Phase 2)
**Story Points**: M (Medium)
**Type**: fullstack
**Phase**: 2 (Advanced Costing)
**Model**: OPUS

**State:** ready
**Estimate:** M (3-4 days)
**Primary PRD:** `docs/1-BASELINE/product/modules/finance.md` (FR-9.4.3, FR-9.4.4, FR-FIN-053)
**Architecture:** `docs/1-BASELINE/architecture/modules/finance.md` (cost_variances)

---

## Goal

Implement labor cost variance analysis decomposed into **rate variance** (paying more/less per hour than standard) and **efficiency variance** (working more/fewer hours than standard). Enable drill-down by operation and worker to identify labor cost drivers and productivity issues.

---

## User Story

As a **Finance Manager**, I want to **decompose labor cost variance into rate and efficiency components** so that **I can identify whether variance is due to wage differences (rate) or productivity issues (efficiency)**.

As a **Production Manager**, I want to **see labor efficiency variance by operation and shift** so that **I can identify bottlenecks, training needs, or equipment issues affecting productivity**.

---

## MVP Scope

**MVP Includes**:
- Labor rate variance (LRV) calculation
- Labor efficiency variance (LEV) calculation
- Variance decomposition per operation
- Variance breakdown by worker (optional)
- Shift-level variance tracking
- Integration with 09.4 labor cost tracking
- Labor variance breakdown API
- Labor variance report UI

**Deferred to Phase 3**:
- Variance root cause categorization
- Variance approval workflow
- Automated variance alerts (threshold-based)
- Variance trend analysis by shift/worker

---

## Dependencies

| Dependency | Story/Epic | Type | Status |
|------------|------------|------|--------|
| 01.1 | Org Context | HARD | Ready |
| 02.3 | Routings | HARD | Ready |
| 04.3 | Operation Time Tracking | HARD | Ready |
| 09.1 | Finance Settings | HARD | Ready |
| 09.4 | Labor Cost Tracking | HARD | Ready |
| 09.6 | WO Cost Summary | HARD | Ready |

---

## Database Migration

```sql
-- Migration: create_labor_variance.sql

-- Extend cost_variances for labor variance
ALTER TABLE cost_variances
ADD COLUMN IF NOT EXISTS operation_id UUID REFERENCES routing_operations(id),
ADD COLUMN IF NOT EXISTS user_id UUID REFERENCES users(id),
ADD COLUMN IF NOT EXISTS shift TEXT,
ADD COLUMN IF NOT EXISTS standard_rate NUMERIC(15,4),
ADD COLUMN IF NOT EXISTS actual_rate NUMERIC(15,4),
ADD COLUMN IF NOT EXISTS standard_hours NUMERIC(15,4),
ADD COLUMN IF NOT EXISTS actual_hours NUMERIC(15,4),
ADD COLUMN IF NOT EXISTS rate_variance_amount NUMERIC(15,2),
ADD COLUMN IF NOT EXISTS efficiency_variance_amount NUMERIC(15,2);

CREATE INDEX idx_cost_variances_operation ON cost_variances(operation_id);
CREATE INDEX idx_cost_variances_user ON cost_variances(user_id);
CREATE INDEX idx_cost_variances_shift ON cost_variances(org_id, shift);

-- Function: Calculate labor rate variance
CREATE OR REPLACE FUNCTION calculate_labor_rate_variance(
    p_org_id UUID,
    p_work_order_id UUID,
    p_operation_id UUID,
    p_actual_rate NUMERIC,
    p_standard_rate NUMERIC,
    p_actual_hours NUMERIC
)
RETURNS NUMERIC AS $$
BEGIN
    -- LRV = (Actual Rate - Standard Rate) × Actual Hours
    RETURN (p_actual_rate - p_standard_rate) * p_actual_hours;
END;
$$ LANGUAGE plpgsql;

-- Function: Calculate labor efficiency variance
CREATE OR REPLACE FUNCTION calculate_labor_efficiency_variance(
    p_org_id UUID,
    p_work_order_id UUID,
    p_operation_id UUID,
    p_actual_hours NUMERIC,
    p_standard_hours NUMERIC,
    p_standard_rate NUMERIC
)
RETURNS NUMERIC AS $$
BEGIN
    -- LEV = (Actual Hours - Standard Hours) × Standard Rate
    RETURN (p_actual_hours - p_standard_hours) * p_standard_rate;
END;
$$ LANGUAGE plpgsql;

-- Function: Calculate labor variance for work order
CREATE OR REPLACE FUNCTION calculate_work_order_labor_variance(
    p_org_id UUID,
    p_work_order_id UUID
)
RETURNS TABLE (
    operation_id UUID,
    operation_name TEXT,
    user_id UUID,
    user_name TEXT,
    shift TEXT,
    standard_rate NUMERIC,
    actual_rate NUMERIC,
    standard_hours NUMERIC,
    actual_hours NUMERIC,
    rate_variance NUMERIC,
    efficiency_variance NUMERIC,
    total_variance NUMERIC
) AS $$
DECLARE
    v_wo RECORD;
    v_routing_op RECORD;
    v_labor RECORD;
    v_standard_rate NUMERIC;
    v_actual_rate NUMERIC;
    v_standard_hours NUMERIC;
    v_actual_hours NUMERIC;
    v_rate_variance NUMERIC;
    v_efficiency_variance NUMERIC;
BEGIN
    -- Get work order and routing
    SELECT wo.*, b.routing_id
    INTO v_wo
    FROM work_orders wo
    LEFT JOIN boms b ON b.id = wo.bom_snapshot_id
    WHERE wo.id = p_work_order_id
    AND wo.org_id = p_org_id;

    IF v_wo IS NULL THEN
        RAISE EXCEPTION 'Work order not found';
    END IF;

    IF v_wo.routing_id IS NULL THEN
        RAISE EXCEPTION 'No routing assigned to work order';
    END IF;

    -- Iterate through routing operations
    FOR v_routing_op IN
        SELECT ro.id, ro.operation_name, ro.standard_hours, ro.hourly_rate
        FROM routing_operations ro
        WHERE ro.routing_id = v_wo.routing_id
        AND ro.org_id = p_org_id
        ORDER BY ro.sequence
    LOOP
        -- Get standard rate and hours
        v_standard_rate := COALESCE(v_routing_op.hourly_rate, 30.00);
        v_standard_hours := v_routing_op.standard_hours * v_wo.qty_planned;

        -- Get actual labor for this operation
        SELECT
            COALESCE(SUM(lc.hours_actual), 0) AS total_hours,
            COALESCE(AVG(lc.hourly_rate), 0) AS avg_rate,
            u.id AS user_id,
            u.full_name AS user_name,
            ol.shift
        INTO v_labor
        FROM labor_costs lc
        LEFT JOIN users u ON u.id = lc.user_id
        LEFT JOIN operation_labor ol ON ol.work_order_id = lc.work_order_id AND ol.operation_id = lc.operation_id
        WHERE lc.work_order_id = p_work_order_id
        AND lc.operation_id = v_routing_op.id
        AND lc.org_id = p_org_id
        GROUP BY u.id, u.full_name, ol.shift;

        v_actual_hours := COALESCE(v_labor.total_hours, 0);
        v_actual_rate := COALESCE(v_labor.avg_rate, v_standard_rate);

        -- Calculate variances
        v_rate_variance := calculate_labor_rate_variance(
            p_org_id, p_work_order_id, v_routing_op.id,
            v_actual_rate, v_standard_rate, v_actual_hours
        );

        v_efficiency_variance := calculate_labor_efficiency_variance(
            p_org_id, p_work_order_id, v_routing_op.id,
            v_actual_hours, v_standard_hours, v_standard_rate
        );

        -- Return variance breakdown
        RETURN QUERY SELECT
            v_routing_op.id,
            v_routing_op.operation_name,
            v_labor.user_id,
            v_labor.user_name,
            v_labor.shift,
            v_standard_rate,
            v_actual_rate,
            v_standard_hours,
            v_actual_hours,
            v_rate_variance,
            v_efficiency_variance,
            (v_rate_variance + v_efficiency_variance) AS total_variance;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Trigger: Auto-create labor variance on WO completion
CREATE OR REPLACE FUNCTION trigger_create_labor_variance()
RETURNS TRIGGER AS $$
DECLARE
    v_variance RECORD;
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        FOR v_variance IN
            SELECT * FROM calculate_work_order_labor_variance(NEW.org_id, NEW.id)
        LOOP
            -- Insert rate variance
            IF v_variance.rate_variance != 0 THEN
                INSERT INTO cost_variances (
                    org_id, work_order_id, variance_type,
                    operation_id, user_id, shift,
                    standard_rate, actual_rate,
                    standard_hours, actual_hours,
                    variance_amount, rate_variance_amount,
                    currency_id, status
                )
                VALUES (
                    NEW.org_id, NEW.id, 'labor_rate',
                    v_variance.operation_id, v_variance.user_id, v_variance.shift,
                    v_variance.standard_rate, v_variance.actual_rate,
                    v_variance.standard_hours, v_variance.actual_hours,
                    v_variance.rate_variance, v_variance.rate_variance,
                    (SELECT id FROM currencies WHERE org_id = NEW.org_id AND is_base = true LIMIT 1),
                    'identified'
                );
            END IF;

            -- Insert efficiency variance
            IF v_variance.efficiency_variance != 0 THEN
                INSERT INTO cost_variances (
                    org_id, work_order_id, variance_type,
                    operation_id, user_id, shift,
                    standard_rate, actual_rate,
                    standard_hours, actual_hours,
                    variance_amount, efficiency_variance_amount,
                    currency_id, status
                )
                VALUES (
                    NEW.org_id, NEW.id, 'labor_efficiency',
                    v_variance.operation_id, v_variance.user_id, v_variance.shift,
                    v_variance.standard_rate, v_variance.actual_rate,
                    v_variance.standard_hours, v_variance.actual_hours,
                    v_variance.efficiency_variance, v_variance.efficiency_variance,
                    (SELECT id FROM currencies WHERE org_id = NEW.org_id AND is_base = true LIMIT 1),
                    'identified'
                );
            END IF;
        END LOOP;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER wo_labor_variance
    AFTER UPDATE ON work_orders
    FOR EACH ROW
    EXECUTE FUNCTION trigger_create_labor_variance();
```

---

## API Endpoints

### GET /api/finance/work-order-costs/:workOrderId/labor-breakdown
Get labor variance breakdown (rate vs efficiency).

**Response:**
```json
{
  "work_order_id": "uuid",
  "work_order_number": "WO-2026-001",
  "product_name": "Chocolate Bar 100g",
  "summary": {
    "total_labor_variance": 8.00,
    "rate_variance": 0.00,
    "efficiency_variance": 8.00,
    "favorable_count": 0,
    "unfavorable_count": 2
  },
  "operations": [
    {
      "operation_id": "uuid",
      "operation_name": "Mixing",
      "user_id": "uuid",
      "user_name": "John Smith",
      "shift": "day",
      "standard_rate": 30.00,
      "actual_rate": 30.00,
      "standard_hours": 0.0833,
      "actual_hours": 0.10,
      "rate_variance": {
        "amount": 0.00,
        "percent": 0.0,
        "status": "neutral"
      },
      "efficiency_variance": {
        "amount": 0.50,
        "percent": 20.0,
        "status": "unfavorable"
      },
      "total_variance": {
        "amount": 0.50,
        "percent": 20.0,
        "status": "unfavorable"
      }
    }
  ]
}
```

### GET /api/finance/variances/labor
List labor variances with filters.

**Query Params:**
- `work_order_id` (optional)
- `operation_id` (optional)
- `user_id` (optional)
- `shift` (optional)
- `variance_type` (optional: labor_rate, labor_efficiency)
- `status` (optional)
- `from_date`, `to_date`

### GET /api/finance/reports/labor-variance
Labor variance report.

**Query Params:**
- `from_date`, `to_date`
- `group_by` (optional: operation, shift, user, work_order)

**Response:**
```json
{
  "summary": {
    "total_rate_variance": 0.00,
    "total_efficiency_variance": 800.00,
    "total_labor_variance": 800.00,
    "variance_count": 45
  },
  "by_operation": [
    {
      "operation_id": "uuid",
      "operation_name": "Mixing",
      "rate_variance": 0.00,
      "efficiency_variance": 150.00,
      "total_variance": 150.00,
      "work_order_count": 12
    }
  ],
  "by_shift": [
    {
      "shift": "day",
      "rate_variance": 0.00,
      "efficiency_variance": 500.00,
      "total_variance": 500.00
    },
    {
      "shift": "night",
      "rate_variance": 50.00,
      "efficiency_variance": 250.00,
      "total_variance": 300.00
    }
  ]
}
```

---

## Service Layer

### LaborVarianceService

```typescript
export class LaborVarianceService {
  static async getLaborVarianceBreakdown(workOrderId: string) {
    const response = await fetch(
      `/api/finance/work-order-costs/${workOrderId}/labor-breakdown`
    );
    if (!response.ok) throw new Error('Failed to fetch labor breakdown');
    return response.json();
  }

  static async getLaborVariances(filters?: {
    workOrderId?: string;
    operationId?: string;
    userId?: string;
    shift?: string;
    varianceType?: 'labor_rate' | 'labor_efficiency';
    status?: string;
    fromDate?: Date;
    toDate?: Date;
  }) {
    const params = new URLSearchParams();
    if (filters?.workOrderId) params.set('work_order_id', filters.workOrderId);
    if (filters?.operationId) params.set('operation_id', filters.operationId);
    if (filters?.userId) params.set('user_id', filters.userId);
    if (filters?.shift) params.set('shift', filters.shift);
    if (filters?.varianceType) params.set('variance_type', filters.varianceType);
    if (filters?.status) params.set('status', filters.status);
    if (filters?.fromDate) params.set('from_date', filters.fromDate.toISOString());
    if (filters?.toDate) params.set('to_date', filters.toDate.toISOString());

    const response = await fetch(`/api/finance/variances/labor?${params}`);
    if (!response.ok) throw new Error('Failed to fetch labor variances');
    return response.json();
  }

  static async getLaborVarianceReport(filters: {
    fromDate: Date;
    toDate: Date;
    groupBy?: 'operation' | 'shift' | 'user' | 'work_order';
  }) {
    const params = new URLSearchParams({
      from_date: filters.fromDate.toISOString(),
      to_date: filters.toDate.toISOString(),
      group_by: filters.groupBy || 'operation'
    });

    const response = await fetch(`/api/finance/reports/labor-variance?${params}`);
    if (!response.ok) throw new Error('Failed to fetch variance report');
    return response.json();
  }

  static async calculateVarianceForWorkOrder(workOrderId: string) {
    const { data, error } = await supabase.rpc(
      'calculate_work_order_labor_variance',
      {
        p_org_id: getOrgId(),
        p_work_order_id: workOrderId
      }
    );

    if (error) throw error;
    return data;
  }
}
```

---

## Components

### LaborVarianceBreakdownCard
Displays rate vs efficiency variance breakdown on WO detail page.

```tsx
<LaborVarianceBreakdownCard workOrderId={woId}>
  <VarianceSummary
    totalVariance={8.00}
    rateVariance={0.00}
    efficiencyVariance={8.00}
  />
  <VarianceOperationsTable operations={[...]}>
    <VarianceStatusBadge status="unfavorable" />
  </VarianceOperationsTable>
</LaborVarianceBreakdownCard>
```

---

## Acceptance Criteria

### AC-1: Labor Rate Variance Calculation
```gherkin
Given standard rate = 30.00 PLN/hr
And actual rate = 32.00 PLN/hr (overtime)
And actual hours = 10
When calculating labor rate variance
Then LRV = (32.00 - 30.00) × 10 = 20.00 PLN (unfavorable)
```

### AC-2: Labor Efficiency Variance Calculation
```gherkin
Given standard hours = 5.0
And actual hours = 6.0
And standard rate = 30.00 PLN/hr
When calculating labor efficiency variance
Then LEV = (6.0 - 5.0) × 30.00 = 30.00 PLN (unfavorable)
```

### AC-3: Variance Breakdown by Operation
```gherkin
Given work order with 3 operations
When GET /api/finance/work-order-costs/:woId/labor-breakdown
Then response includes:
  - Summary (total rate/efficiency variance)
  - Per-operation breakdown with LRV and LEV
  - Worker and shift details
  - Favorable/unfavorable status
```

### AC-4: Auto-Create Variance on WO Completion
```gherkin
Given work order status changes to "completed"
When labor variance exists (LRV or LEV != 0)
Then cost_variances records created:
  - One for labor_rate variance (if rate variance)
  - One for labor_efficiency variance (if efficiency variance)
And status = "identified"
```

---

## Performance Requirements

- Variance calculation: < 300ms (20 operations)
- Breakdown API: < 500ms
- Variance report (1 month): < 2s
- Auto-variance trigger: < 500ms

---

## Testing

### Unit Tests
- LRV formula
- LEV formula
- Variance status (favorable/unfavorable)
- Zero variance handling

### Integration Tests
- Variance breakdown API
- Auto-create on WO completion
- Multi-operation variance aggregation

### Edge Cases
- Zero standard rate (should use default)
- Zero actual hours (should handle)
- Missing routing operation (should handle)
- Negative variance (favorable)

---

## Deliverables

- [ ] Extended `cost_variances` table
- [ ] `calculate_labor_rate_variance()` function
- [ ] `calculate_labor_efficiency_variance()` function
- [ ] `calculate_work_order_labor_variance()` function
- [ ] Auto-create variance trigger
- [ ] API: Labor variance breakdown
- [ ] API: Labor variance list
- [ ] API: Labor variance report
- [ ] LaborVarianceService with 4 methods
- [ ] LaborVarianceBreakdownCard component
- [ ] Tests: Unit, integration, edge cases

---

## Definition of Done

- [ ] LRV calculated correctly
- [ ] LEV calculated correctly
- [ ] Variance decomposition works per operation
- [ ] Auto-create variance on WO completion
- [ ] API returns rate vs efficiency breakdown
- [ ] Variance report generates < 2s
- [ ] UI displays variance breakdown by operation
- [ ] Tests pass (unit, integration, edge cases)
- [ ] Performance benchmarks met
- [ ] Documentation updated

---

**Created**: 2026-01-15 | **Complexity**: M (3-4 days) | **Phase**: 2
