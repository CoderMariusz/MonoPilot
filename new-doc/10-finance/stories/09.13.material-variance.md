# 09.13 - Material Variance

**Priority**: P0 (Phase 2)
**Story Points**: M (Medium)
**Type**: fullstack
**Phase**: 2 (Advanced Costing)
**Model**: OPUS

**State:** ready
**Estimate:** M (3-4 days)
**Primary PRD:** `docs/1-BASELINE/product/modules/finance.md` (FR-9.4.1, FR-9.4.2, FR-FIN-052)
**Architecture:** `docs/1-BASELINE/architecture/modules/finance.md` (cost_variances)

---

## Goal

Implement material cost variance analysis decomposed into **price variance** (paying more/less than standard) and **quantity variance** (using more/less than standard). Enable drill-down to lot-level cost details and provide actionable variance reporting for procurement and production optimization.

---

## User Story

As a **Finance Manager**, I want to **decompose material cost variance into price and quantity components** so that **I can identify whether variance is due to procurement issues (price) or production efficiency (usage)**.

As a **Production Manager**, I want to **see material usage variance by BOM component** so that **I can identify overpour, spillage, or yield issues and take corrective action**.

---

## MVP Scope

**MVP Includes**:
- Material price variance (MPV) calculation
- Material quantity variance (MQV) calculation
- Variance decomposition per BOM component
- Lot-level cost tracking
- Variance status tracking
- Integration with 09.6 WO cost summary
- Material variance breakdown API
- Material variance report UI

**Deferred to Phase 3**:
- Variance root cause categorization
- Variance approval workflow
- Automated variance alerts (threshold-based)
- Variance trend analysis dashboard

---

## Dependencies

| Dependency | Story/Epic | Type | Status |
|------------|------------|------|--------|
| 01.1 | Org Context | HARD | Ready |
| 02.1 | Products | HARD | Ready |
| 02.2 | BOMs | HARD | Ready |
| 04.2 | Material Consumption | HARD | Ready |
| 09.2 | Standard Costs | HARD | Ready |
| 09.3 | Material Cost Tracking | HARD | Ready |
| 09.6 | WO Cost Summary | HARD | Ready |

---

## Database Migration

```sql
-- Migration: create_material_variance.sql

-- Extend cost_variances table for material variance
ALTER TABLE cost_variances
ADD COLUMN IF NOT EXISTS bom_item_id UUID REFERENCES bom_items(id),
ADD COLUMN IF NOT EXISTS product_id UUID REFERENCES products(id),
ADD COLUMN IF NOT EXISTS lot_number TEXT,
ADD COLUMN IF NOT EXISTS standard_price NUMERIC(15,4),
ADD COLUMN IF NOT EXISTS actual_price NUMERIC(15,4),
ADD COLUMN IF NOT EXISTS standard_quantity NUMERIC(15,4),
ADD COLUMN IF NOT EXISTS actual_quantity NUMERIC(15,4),
ADD COLUMN IF NOT EXISTS price_variance_amount NUMERIC(15,2),
ADD COLUMN IF NOT EXISTS quantity_variance_amount NUMERIC(15,2);

CREATE INDEX idx_cost_variances_product ON cost_variances(product_id);
CREATE INDEX idx_cost_variances_bom_item ON cost_variances(bom_item_id);
CREATE INDEX idx_cost_variances_type ON cost_variances(org_id, variance_type);

-- Function: Calculate material price variance
CREATE OR REPLACE FUNCTION calculate_material_price_variance(
    p_org_id UUID,
    p_work_order_id UUID,
    p_product_id UUID,
    p_actual_price NUMERIC,
    p_standard_price NUMERIC,
    p_actual_quantity NUMERIC
)
RETURNS NUMERIC AS $$
BEGIN
    -- MPV = (Actual Price - Standard Price) × Actual Quantity
    RETURN (p_actual_price - p_standard_price) * p_actual_quantity;
END;
$$ LANGUAGE plpgsql;

-- Function: Calculate material quantity variance
CREATE OR REPLACE FUNCTION calculate_material_quantity_variance(
    p_org_id UUID,
    p_work_order_id UUID,
    p_product_id UUID,
    p_actual_quantity NUMERIC,
    p_standard_quantity NUMERIC,
    p_standard_price NUMERIC
)
RETURNS NUMERIC AS $$
BEGIN
    -- MQV = (Actual Quantity - Standard Quantity) × Standard Price
    RETURN (p_actual_quantity - p_standard_quantity) * p_standard_price;
END;
$$ LANGUAGE plpgsql;

-- Function: Calculate material variance for work order
CREATE OR REPLACE FUNCTION calculate_work_order_material_variance(
    p_org_id UUID,
    p_work_order_id UUID
)
RETURNS TABLE (
    bom_item_id UUID,
    product_id UUID,
    product_name TEXT,
    standard_price NUMERIC,
    actual_price NUMERIC,
    standard_quantity NUMERIC,
    actual_quantity NUMERIC,
    price_variance NUMERIC,
    quantity_variance NUMERIC,
    total_variance NUMERIC
) AS $$
DECLARE
    v_wo RECORD;
    v_bom_item RECORD;
    v_consumption RECORD;
    v_standard_cost NUMERIC;
    v_actual_cost NUMERIC;
    v_standard_qty NUMERIC;
    v_actual_qty NUMERIC;
    v_price_variance NUMERIC;
    v_qty_variance NUMERIC;
BEGIN
    -- Get work order and BOM
    SELECT wo.*, wo.bom_snapshot_id AS bom_id
    INTO v_wo
    FROM work_orders wo
    WHERE wo.id = p_work_order_id
    AND wo.org_id = p_org_id;

    IF v_wo IS NULL THEN
        RAISE EXCEPTION 'Work order not found';
    END IF;

    -- Iterate through BOM items
    FOR v_bom_item IN
        SELECT bi.id, bi.product_id, bi.quantity, p.name
        FROM bom_items bi
        JOIN products p ON p.id = bi.product_id
        WHERE bi.bom_id = v_wo.bom_id
        AND bi.org_id = p_org_id
    LOOP
        -- Get standard cost
        SELECT COALESCE(sc.total_cost, 0) INTO v_standard_cost
        FROM standard_costs sc
        WHERE sc.item_id = v_bom_item.product_id
        AND sc.org_id = p_org_id
        AND v_wo.start_date BETWEEN sc.effective_from AND COALESCE(sc.effective_to, '9999-12-31')
        AND sc.status = 'active'
        ORDER BY sc.effective_from DESC
        LIMIT 1;

        -- Get standard quantity (BOM qty × WO planned qty)
        v_standard_qty := v_bom_item.quantity * v_wo.qty_planned;

        -- Get actual consumption
        SELECT
            COALESCE(SUM(mcc.quantity), 0) AS actual_qty,
            COALESCE(SUM(mcc.total_cost), 0) AS actual_cost
        INTO v_consumption
        FROM material_consumption mc
        JOIN material_consumption_costs mcc ON mcc.consumption_id = mc.id
        WHERE mc.work_order_id = p_work_order_id
        AND mc.product_id = v_bom_item.product_id
        AND mc.org_id = p_org_id;

        v_actual_qty := v_consumption.actual_qty;
        v_actual_cost := v_consumption.actual_cost / NULLIF(v_actual_qty, 0);

        -- Calculate variances
        v_price_variance := calculate_material_price_variance(
            p_org_id, p_work_order_id, v_bom_item.product_id,
            v_actual_cost, v_standard_cost, v_actual_qty
        );

        v_qty_variance := calculate_material_quantity_variance(
            p_org_id, p_work_order_id, v_bom_item.product_id,
            v_actual_qty, v_standard_qty, v_standard_cost
        );

        -- Return variance breakdown
        RETURN QUERY SELECT
            v_bom_item.id,
            v_bom_item.product_id,
            v_bom_item.name,
            v_standard_cost,
            v_actual_cost,
            v_standard_qty,
            v_actual_qty,
            v_price_variance,
            v_qty_variance,
            (v_price_variance + v_qty_variance) AS total_variance;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Trigger: Auto-create material variance on WO completion
CREATE OR REPLACE FUNCTION trigger_create_material_variance()
RETURNS TRIGGER AS $$
DECLARE
    v_variance RECORD;
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        FOR v_variance IN
            SELECT * FROM calculate_work_order_material_variance(NEW.org_id, NEW.id)
        LOOP
            -- Insert price variance
            IF v_variance.price_variance != 0 THEN
                INSERT INTO cost_variances (
                    org_id, work_order_id, variance_type,
                    bom_item_id, product_id,
                    standard_price, actual_price,
                    standard_quantity, actual_quantity,
                    variance_amount, price_variance_amount,
                    currency_id, status
                )
                VALUES (
                    NEW.org_id, NEW.id, 'material_price',
                    v_variance.bom_item_id, v_variance.product_id,
                    v_variance.standard_price, v_variance.actual_price,
                    v_variance.standard_quantity, v_variance.actual_quantity,
                    v_variance.price_variance, v_variance.price_variance,
                    (SELECT id FROM currencies WHERE org_id = NEW.org_id AND is_base = true LIMIT 1),
                    'identified'
                );
            END IF;

            -- Insert quantity variance
            IF v_variance.quantity_variance != 0 THEN
                INSERT INTO cost_variances (
                    org_id, work_order_id, variance_type,
                    bom_item_id, product_id,
                    standard_price, actual_price,
                    standard_quantity, actual_quantity,
                    variance_amount, quantity_variance_amount,
                    currency_id, status
                )
                VALUES (
                    NEW.org_id, NEW.id, 'material_usage',
                    v_variance.bom_item_id, v_variance.product_id,
                    v_variance.standard_price, v_variance.actual_price,
                    v_variance.standard_quantity, v_variance.actual_quantity,
                    v_variance.quantity_variance, v_variance.quantity_variance,
                    (SELECT id FROM currencies WHERE org_id = NEW.org_id AND is_base = true LIMIT 1),
                    'identified'
                );
            END IF;
        END LOOP;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER wo_material_variance
    AFTER UPDATE ON work_orders
    FOR EACH ROW
    EXECUTE FUNCTION trigger_create_material_variance();
```

---

## API Endpoints

### GET /api/finance/work-order-costs/:workOrderId/material-breakdown
Get material variance breakdown (price vs quantity).

**Response:**
```json
{
  "work_order_id": "uuid",
  "work_order_number": "WO-2026-001",
  "product_name": "Chocolate Bar 100g",
  "summary": {
    "total_material_variance": 15.50,
    "price_variance": 5.20,
    "quantity_variance": 10.30,
    "favorable_count": 2,
    "unfavorable_count": 3
  },
  "items": [
    {
      "bom_item_id": "uuid",
      "product_id": "uuid",
      "product_name": "Cocoa Powder",
      "standard_price": 0.05,
      "actual_price": 0.052,
      "standard_quantity": 30,
      "actual_quantity": 32,
      "price_variance": {
        "amount": 0.064,
        "percent": 4.0,
        "status": "unfavorable"
      },
      "quantity_variance": {
        "amount": 0.10,
        "percent": 6.67,
        "status": "unfavorable"
      },
      "total_variance": {
        "amount": 0.164,
        "percent": 10.93,
        "status": "unfavorable"
      }
    }
  ]
}
```

### GET /api/finance/variances/material
List material variances with filters.

**Query Params:**
- `work_order_id` (optional)
- `product_id` (optional)
- `variance_type` (optional: material_price, material_usage)
- `status` (optional)
- `from_date`, `to_date`

**Response:**
```json
{
  "data": [
    {
      "id": "uuid",
      "work_order_id": "uuid",
      "work_order_number": "WO-2026-001",
      "variance_type": "material_price",
      "product_name": "Cocoa Powder",
      "variance_amount": 0.064,
      "variance_percent": 4.0,
      "status": "identified",
      "created_at": "2026-01-15T10:30:00Z"
    }
  ],
  "pagination": {...}
}
```

### GET /api/finance/reports/material-variance
Material variance report.

**Query Params:**
- `from_date`, `to_date`
- `group_by` (optional: product, work_order, variance_type)

**Response:**
```json
{
  "summary": {
    "total_price_variance": 520.00,
    "total_quantity_variance": 1030.00,
    "total_material_variance": 1550.00,
    "variance_count": 45
  },
  "by_product": [
    {
      "product_id": "uuid",
      "product_name": "Cocoa Powder",
      "price_variance": 64.00,
      "quantity_variance": 150.00,
      "total_variance": 214.00,
      "work_order_count": 12
    }
  ]
}
```

---

## Service Layer

### MaterialVarianceService

```typescript
export class MaterialVarianceService {
  static async getMaterialVarianceBreakdown(workOrderId: string) {
    const response = await fetch(
      `/api/finance/work-order-costs/${workOrderId}/material-breakdown`
    );
    if (!response.ok) throw new Error('Failed to fetch material breakdown');
    return response.json();
  }

  static async getMaterialVariances(filters?: {
    workOrderId?: string;
    productId?: string;
    varianceType?: 'material_price' | 'material_usage';
    status?: string;
    fromDate?: Date;
    toDate?: Date;
  }) {
    const params = new URLSearchParams();
    if (filters?.workOrderId) params.set('work_order_id', filters.workOrderId);
    if (filters?.productId) params.set('product_id', filters.productId);
    if (filters?.varianceType) params.set('variance_type', filters.varianceType);
    if (filters?.status) params.set('status', filters.status);
    if (filters?.fromDate) params.set('from_date', filters.fromDate.toISOString());
    if (filters?.toDate) params.set('to_date', filters.toDate.toISOString());

    const response = await fetch(`/api/finance/variances/material?${params}`);
    if (!response.ok) throw new Error('Failed to fetch material variances');
    return response.json();
  }

  static async getMaterialVarianceReport(filters: {
    fromDate: Date;
    toDate: Date;
    groupBy?: 'product' | 'work_order' | 'variance_type';
  }) {
    const params = new URLSearchParams({
      from_date: filters.fromDate.toISOString(),
      to_date: filters.toDate.toISOString(),
      group_by: filters.groupBy || 'product'
    });

    const response = await fetch(`/api/finance/reports/material-variance?${params}`);
    if (!response.ok) throw new Error('Failed to fetch variance report');
    return response.json();
  }

  static async calculateVarianceForWorkOrder(workOrderId: string) {
    const { data, error } = await supabase.rpc(
      'calculate_work_order_material_variance',
      {
        p_org_id: getOrgId(),
        p_work_order_id: workOrderId
      }
    );

    if (error) throw error;
    return data;
  }
}
```

---

## Components

### MaterialVarianceBreakdownCard
Displays price vs quantity variance breakdown on WO detail page.

```tsx
<MaterialVarianceBreakdownCard workOrderId={woId}>
  <VarianceSummary
    totalVariance={15.50}
    priceVariance={5.20}
    quantityVariance={10.30}
  />
  <VarianceItemsTable items={[...]}>
    <VarianceStatusBadge status="unfavorable" />
  </VarianceItemsTable>
</MaterialVarianceBreakdownCard>
```

---

## Acceptance Criteria

### AC-1: Material Price Variance Calculation
```gherkin
Given standard price = 0.05 PLN/g
And actual price = 0.052 PLN/g
And actual quantity = 32g
When calculating material price variance
Then MPV = (0.052 - 0.05) × 32 = 0.064 PLN (unfavorable)
```

### AC-2: Material Quantity Variance Calculation
```gherkin
Given standard quantity = 30g
And actual quantity = 32g
And standard price = 0.05 PLN/g
When calculating material quantity variance
Then MQV = (32 - 30) × 0.05 = 0.10 PLN (unfavorable)
```

### AC-3: Variance Decomposition API
```gherkin
Given GET /api/finance/work-order-costs/:woId/material-breakdown
When requesting breakdown
Then response includes:
  - Summary (total price/quantity variance)
  - Per-item breakdown with MPV and MQV
  - Favorable/unfavorable status
  - Variance percentages
```

### AC-4: Auto-Create Variance on WO Completion
```gherkin
Given work order status changes to "completed"
When material variance exists (MPV or MQV != 0)
Then cost_variances records created:
  - One for material_price variance
  - One for material_usage variance
And status = "identified"
```

---

## Performance Requirements

- Variance calculation: < 300ms (100 BOM items)
- Breakdown API: < 500ms
- Variance report (1 month): < 2s
- Auto-variance trigger: < 500ms

---

## Testing

### Unit Tests
- MPV formula
- MQV formula
- Variance status (favorable/unfavorable)
- Zero variance handling

### Integration Tests
- Variance breakdown API
- Auto-create on WO completion
- Multi-item variance aggregation

### Edge Cases
- Zero standard price (should error)
- Zero actual quantity (should handle)
- Missing standard cost (should handle)
- Negative variance (favorable)

---

## Deliverables

- [ ] Extended `cost_variances` table
- [ ] `calculate_material_price_variance()` function
- [ ] `calculate_material_quantity_variance()` function
- [ ] `calculate_work_order_material_variance()` function
- [ ] Auto-create variance trigger
- [ ] API: Material variance breakdown
- [ ] API: Material variance list
- [ ] API: Material variance report
- [ ] MaterialVarianceService with 4 methods
- [ ] MaterialVarianceBreakdownCard component
- [ ] Tests: Unit, integration, edge cases

---

## Definition of Done

- [ ] MPV calculated correctly
- [ ] MQV calculated correctly
- [ ] Variance decomposition works per BOM item
- [ ] Auto-create variance on WO completion
- [ ] API returns price vs quantity breakdown
- [ ] Variance report generates < 2s
- [ ] UI displays variance breakdown
- [ ] Tests pass (unit, integration, edge cases)
- [ ] Performance benchmarks met
- [ ] Documentation updated

---

**Created**: 2026-01-15 | **Complexity**: M (3-4 days) | **Phase**: 2
