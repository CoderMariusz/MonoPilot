# 09.7 - Inventory Valuation FIFO/WAC

**Priority**: P0 (MVP)
**Story Points**: L (Large)
**Type**: backend
**Phase**: 1 (Foundation)
**Model**: OPUS

**State:** ready
**Estimate:** L (4-5 days)
**Primary PRD:** `docs/1-BASELINE/product/modules/finance.md` (FR-9.5.1, FR-9.5.2, FR-9.5.4)
**Architecture:** `docs/1-BASELINE/architecture/modules/finance.md` (inventory_cost_layers table)

---

## Goal

Implement FIFO (First-In-First-Out) cost layer tracking per License Plate, weighted average cost calculation, inventory valuation reporting (total value, quantity on hand, average cost), and valuation method configuration per organization. This enables accurate financial reporting and cost of goods sold (COGS) calculation.

---

## User Story

As a **Finance Manager**, I want to **track inventory value using FIFO or weighted average costing methods** so that **I can accurately report inventory valuation for financial statements and comply with accounting standards**.

As a **CFO**, I want to **view total inventory value and valuation method details** so that **I can assess working capital and prepare accurate balance sheets**.

---

## Scope

**In scope (this story)**
- `inventory_cost_layers` table for FIFO tracking
- `inventory_valuations` table for periodic snapshots
- Valuation method configuration (FIFO or WAC per org)
- FIFO cost layer creation on LP receipt
- FIFO cost layer consumption (oldest first)
- Weighted average cost calculation
- GET /api/finance/inventory-valuation (summary report)
- GET /api/finance/inventory-valuation/:productId (product detail)
- POST /api/finance/inventory-valuation/calculate (recalculate)
- Inventory valuation report page
- Cost layer detail view (FIFO method)
- Integration with Epic 05 (Warehouse/LP)

**Out of scope (this story)**
- Standard cost valuation (Phase 2)
- Inventory aging by value (Phase 2)
- Revaluation processing (Phase 3)
- Inventory reserve/write-down (Phase 3)
- Cost allocation to sales orders (Phase 3)
- Inventory reconciliation (Phase 3)
- Historical valuation snapshots (Phase 2)
- Multi-location valuation (Phase 2)

---

## Dependencies

### Cross-Epic Dependencies

| Dependency | Story/Epic | Type | What It Provides | Status |
|------------|------------|------|------------------|--------|
| 01.1 | Org Context + RLS | HARD | organizations, users, roles tables | Ready |
| 02.1 | Products CRUD | HARD | products table for product reference | Ready |
| 05.1 | LP Table + CRUD | HARD | license_plates table, LP service | Ready |
| 05.11 | GRN from PO | HARD | grns, grn_items for receipt costs | Ready |

### Within Epic Dependencies

| Dependency | Story | Type | What It Provides |
|------------|-------|------|------------------|
| 09.8 | Currency Management | HARD | currencies table, currency conversion |

### Provides To (Downstream)

| Story | What This Provides |
|-------|-------------------|
| 09.6 | WO Cost Summary - material cost data |
| 09.11 | Cost Variance - standard vs actual valuation |
| 09.13 | Operation Costing - material cost reference |
| Phase 2 | COGS calculation |
| Phase 3 | Financial reporting |

---

## Database Migration

### Migration: Create inventory_cost_layers and inventory_valuations

```sql
-- Migration: YYYYMMDDHHMMSS_create_inventory_cost_layers.sql

-- =============================================================================
-- Inventory Cost Layers (FIFO Method)
-- =============================================================================

CREATE TABLE inventory_cost_layers (
    -- Identity
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id                  UUID NOT NULL REFERENCES organizations(id),

    -- Product and Location
    product_id              UUID NOT NULL REFERENCES products(id),
    location_id             UUID REFERENCES warehouse_locations(id),
    lp_id                   UUID REFERENCES license_plates(id),

    -- Lot Tracking
    lot_number              TEXT,
    batch_number            TEXT,

    -- Quantities
    quantity_received       DECIMAL(15,4) NOT NULL,
    quantity_remaining      DECIMAL(15,4) NOT NULL,
    quantity_consumed       DECIMAL(15,4) DEFAULT 0.00,
    uom                     TEXT NOT NULL,

    -- Costs
    unit_cost               DECIMAL(15,4) NOT NULL,
    total_cost              DECIMAL(15,4) NOT NULL,
    currency_id             UUID NOT NULL REFERENCES currencies(id),

    -- Receipt Information
    receipt_date            DATE NOT NULL,
    receipt_reference_type  TEXT
                            CHECK (receipt_reference_type IN ('grn', 'wo', 'adjustment')),
    receipt_reference_id    UUID,
    grn_id                  UUID REFERENCES grns(id),

    -- Valuation Method
    valuation_method        TEXT NOT NULL DEFAULT 'fifo'
                            CHECK (valuation_method IN ('fifo', 'average', 'standard')),

    -- Layer Status
    is_fully_consumed       BOOLEAN DEFAULT FALSE,
    consumed_at             TIMESTAMPTZ,

    -- Audit
    created_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by              UUID REFERENCES users(id),
    updated_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by              UUID REFERENCES users(id),

    -- Constraints
    CONSTRAINT chk_quantity_remaining_positive CHECK (quantity_remaining >= 0),
    CONSTRAINT chk_quantity_consumed_valid CHECK (quantity_consumed <= quantity_received),
    CONSTRAINT chk_unit_cost_positive CHECK (unit_cost >= 0)
);

-- Indexes
CREATE INDEX idx_cost_layers_org_product ON inventory_cost_layers(org_id, product_id);
CREATE INDEX idx_cost_layers_lp ON inventory_cost_layers(lp_id) WHERE lp_id IS NOT NULL;
CREATE INDEX idx_cost_layers_location ON inventory_cost_layers(location_id) WHERE location_id IS NOT NULL;
CREATE INDEX idx_cost_layers_receipt_date ON inventory_cost_layers(org_id, product_id, receipt_date);
CREATE INDEX idx_cost_layers_active ON inventory_cost_layers(org_id, product_id, is_fully_consumed)
    WHERE is_fully_consumed = FALSE;
CREATE INDEX idx_cost_layers_grn ON inventory_cost_layers(grn_id) WHERE grn_id IS NOT NULL;

-- =============================================================================
-- Inventory Valuations (Periodic Snapshots)
-- =============================================================================

CREATE TABLE inventory_valuations (
    -- Identity
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id                  UUID NOT NULL REFERENCES organizations(id),

    -- Valuation Period
    valuation_date          DATE NOT NULL,
    period_start            DATE,
    period_end              DATE,

    -- Product (NULL = all products)
    product_id              UUID REFERENCES products(id),
    product_code            TEXT,
    product_name            TEXT,

    -- Location (NULL = all locations)
    location_id             UUID REFERENCES warehouse_locations(id),
    location_name           TEXT,

    -- Quantities
    quantity_on_hand        DECIMAL(15,4) NOT NULL,
    uom                     TEXT NOT NULL,

    -- Valuation
    total_value             DECIMAL(15,4) NOT NULL,
    average_unit_cost       DECIMAL(15,4) NOT NULL,
    currency_id             UUID NOT NULL REFERENCES currencies(id),

    -- Method
    valuation_method        TEXT NOT NULL
                            CHECK (valuation_method IN ('fifo', 'average', 'standard')),

    -- Cost Layers (FIFO only)
    active_layers_count     INTEGER DEFAULT 0,
    oldest_layer_date       DATE,
    newest_layer_date       DATE,

    -- Status
    status                  TEXT NOT NULL DEFAULT 'draft'
                            CHECK (status IN ('draft', 'calculated', 'approved')),

    -- Calculation Metadata
    calculated_at           TIMESTAMPTZ,
    calculated_by           UUID REFERENCES users(id),
    approved_at             TIMESTAMPTZ,
    approved_by             UUID REFERENCES users(id),

    -- Audit
    created_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by              UUID REFERENCES users(id),
    updated_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by              UUID REFERENCES users(id)
);

-- Indexes
CREATE INDEX idx_valuations_org_date ON inventory_valuations(org_id, valuation_date);
CREATE INDEX idx_valuations_product ON inventory_valuations(product_id) WHERE product_id IS NOT NULL;
CREATE INDEX idx_valuations_location ON inventory_valuations(location_id) WHERE location_id IS NOT NULL;
CREATE INDEX idx_valuations_status ON inventory_valuations(org_id, status);

-- =============================================================================
-- Valuation Settings (per Organization)
-- =============================================================================

CREATE TABLE inventory_valuation_settings (
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id                  UUID NOT NULL REFERENCES organizations(id),

    -- Default Valuation Method
    default_method          TEXT NOT NULL DEFAULT 'fifo'
                            CHECK (default_method IN ('fifo', 'average', 'standard')),

    -- Auto-Calculate Settings
    auto_create_layers      BOOLEAN DEFAULT TRUE,
    auto_update_average     BOOLEAN DEFAULT TRUE,

    -- Currency
    valuation_currency_id   UUID NOT NULL REFERENCES currencies(id),

    -- Audit
    created_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at              TIMESTAMPTZ NOT NULL DEFAULT now(),

    -- Constraints
    CONSTRAINT uq_valuation_settings_org UNIQUE (org_id)
);

CREATE INDEX idx_valuation_settings_org ON inventory_valuation_settings(org_id);

-- =============================================================================
-- RLS Policies
-- =============================================================================

ALTER TABLE inventory_cost_layers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "cost_layers_select" ON inventory_cost_layers
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "cost_layers_insert" ON inventory_cost_layers
    FOR INSERT WITH CHECK (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "cost_layers_update" ON inventory_cost_layers
    FOR UPDATE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

ALTER TABLE inventory_valuations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "valuations_org" ON inventory_valuations
    FOR ALL TO authenticated
    USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

ALTER TABLE inventory_valuation_settings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "valuation_settings_org" ON inventory_valuation_settings
    FOR ALL TO authenticated
    USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- =============================================================================
-- Trigger for updated_at
-- =============================================================================

CREATE TRIGGER update_inventory_cost_layers_updated_at
    BEFORE UPDATE ON inventory_cost_layers
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_inventory_valuations_updated_at
    BEFORE UPDATE ON inventory_valuations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================================================
-- Function: Create Cost Layer on LP Receipt
-- =============================================================================

CREATE OR REPLACE FUNCTION create_cost_layer_on_lp_receipt()
RETURNS TRIGGER AS $$
DECLARE
    v_settings RECORD;
    v_unit_cost DECIMAL(15,4);
    v_total_cost DECIMAL(15,4);
BEGIN
    -- Only create layer on LP creation (not updates)
    IF TG_OP = 'INSERT' THEN
        -- Get valuation settings
        SELECT * INTO v_settings
        FROM inventory_valuation_settings
        WHERE org_id = NEW.org_id;

        -- Only auto-create if enabled
        IF v_settings.auto_create_layers = TRUE THEN
            -- Calculate unit cost from GRN (if available)
            -- For MVP: use product standard cost or default to 0
            v_unit_cost := 0.00; -- Placeholder: will be updated from GRN cost

            v_total_cost := NEW.quantity * v_unit_cost;

            -- Create cost layer
            INSERT INTO inventory_cost_layers (
                org_id,
                product_id,
                location_id,
                lp_id,
                lot_number,
                batch_number,
                quantity_received,
                quantity_remaining,
                uom,
                unit_cost,
                total_cost,
                currency_id,
                receipt_date,
                receipt_reference_type,
                valuation_method,
                created_by
            ) VALUES (
                NEW.org_id,
                NEW.product_id,
                NEW.location_id,
                NEW.id,
                NEW.lot_number,
                NEW.batch_number,
                NEW.quantity,
                NEW.quantity,
                NEW.uom,
                v_unit_cost,
                v_total_cost,
                v_settings.valuation_currency_id,
                CURRENT_DATE,
                'grn',
                v_settings.default_method,
                NEW.created_by
            );
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger on license_plates
-- Note: Requires license_plates table from Epic 05
-- CREATE TRIGGER trigger_create_cost_layer_on_lp
--     AFTER INSERT ON license_plates
--     FOR EACH ROW
--     EXECUTE FUNCTION create_cost_layer_on_lp_receipt();

-- =============================================================================
-- Function: Consume Cost Layer (FIFO)
-- =============================================================================

CREATE OR REPLACE FUNCTION consume_cost_layer_fifo(
    p_org_id UUID,
    p_product_id UUID,
    p_quantity DECIMAL,
    OUT consumed_cost DECIMAL
)
AS $$
DECLARE
    v_layer RECORD;
    v_remaining_qty DECIMAL := p_quantity;
    v_consumed_from_layer DECIMAL;
    v_layer_cost DECIMAL;
BEGIN
    consumed_cost := 0.00;

    -- Loop through cost layers in FIFO order (oldest first)
    FOR v_layer IN
        SELECT *
        FROM inventory_cost_layers
        WHERE org_id = p_org_id
          AND product_id = p_product_id
          AND is_fully_consumed = FALSE
          AND quantity_remaining > 0
        ORDER BY receipt_date ASC, created_at ASC
    LOOP
        EXIT WHEN v_remaining_qty <= 0;

        -- Consume from this layer
        IF v_remaining_qty >= v_layer.quantity_remaining THEN
            -- Consume entire layer
            v_consumed_from_layer := v_layer.quantity_remaining;
        ELSE
            -- Partial consumption
            v_consumed_from_layer := v_remaining_qty;
        END IF;

        -- Calculate cost from this layer
        v_layer_cost := v_consumed_from_layer * v_layer.unit_cost;
        consumed_cost := consumed_cost + v_layer_cost;

        -- Update layer
        UPDATE inventory_cost_layers
        SET quantity_remaining = quantity_remaining - v_consumed_from_layer,
            quantity_consumed = quantity_consumed + v_consumed_from_layer,
            is_fully_consumed = (quantity_remaining - v_consumed_from_layer = 0),
            consumed_at = CASE WHEN (quantity_remaining - v_consumed_from_layer = 0) THEN NOW() ELSE consumed_at END,
            updated_at = NOW()
        WHERE id = v_layer.id;

        v_remaining_qty := v_remaining_qty - v_consumed_from_layer;
    END LOOP;

    -- If remaining quantity > 0, not enough inventory (should not happen with proper inventory checks)
    IF v_remaining_qty > 0 THEN
        RAISE EXCEPTION 'Insufficient inventory cost layers for product %. Remaining: %', p_product_id, v_remaining_qty;
    END IF;

END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- Function: Calculate Weighted Average Cost
-- =============================================================================

CREATE OR REPLACE FUNCTION calculate_weighted_average_cost(
    p_org_id UUID,
    p_product_id UUID
)
RETURNS DECIMAL AS $$
DECLARE
    v_total_value DECIMAL;
    v_total_quantity DECIMAL;
    v_avg_cost DECIMAL;
BEGIN
    -- Sum all active cost layers
    SELECT
        COALESCE(SUM(quantity_remaining * unit_cost), 0),
        COALESCE(SUM(quantity_remaining), 0)
    INTO v_total_value, v_total_quantity
    FROM inventory_cost_layers
    WHERE org_id = p_org_id
      AND product_id = p_product_id
      AND is_fully_consumed = FALSE
      AND quantity_remaining > 0;

    -- Calculate average
    IF v_total_quantity > 0 THEN
        v_avg_cost := v_total_value / v_total_quantity;
    ELSE
        v_avg_cost := 0.00;
    END IF;

    RETURN v_avg_cost;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- Function: Calculate Inventory Valuation
-- =============================================================================

CREATE OR REPLACE FUNCTION calculate_inventory_valuation(
    p_org_id UUID,
    p_product_id UUID DEFAULT NULL,
    p_location_id UUID DEFAULT NULL,
    p_valuation_date DATE DEFAULT CURRENT_DATE
)
RETURNS void AS $$
DECLARE
    v_product RECORD;
    v_quantity DECIMAL;
    v_value DECIMAL;
    v_avg_cost DECIMAL;
    v_method TEXT;
    v_layer_count INTEGER;
    v_oldest_date DATE;
    v_newest_date DATE;
    v_currency_id UUID;
BEGIN
    -- Get valuation settings
    SELECT default_method, valuation_currency_id
    INTO v_method, v_currency_id
    FROM inventory_valuation_settings
    WHERE org_id = p_org_id;

    -- If specific product, calculate for that product only
    IF p_product_id IS NOT NULL THEN
        -- Get product details
        SELECT p.id, p.code, p.name
        INTO v_product
        FROM products p
        WHERE p.id = p_product_id
          AND p.org_id = p_org_id;

        -- Calculate total quantity on hand
        SELECT COALESCE(SUM(quantity_remaining), 0)
        INTO v_quantity
        FROM inventory_cost_layers
        WHERE org_id = p_org_id
          AND product_id = p_product_id
          AND is_fully_consumed = FALSE;

        -- Calculate value based on method
        IF v_method = 'fifo' THEN
            -- Sum all layer costs
            SELECT
                COALESCE(SUM(quantity_remaining * unit_cost), 0),
                COUNT(*),
                MIN(receipt_date),
                MAX(receipt_date)
            INTO v_value, v_layer_count, v_oldest_date, v_newest_date
            FROM inventory_cost_layers
            WHERE org_id = p_org_id
              AND product_id = p_product_id
              AND is_fully_consumed = FALSE;

        ELSIF v_method = 'average' THEN
            v_avg_cost := calculate_weighted_average_cost(p_org_id, p_product_id);
            v_value := v_quantity * v_avg_cost;
            v_layer_count := 0;
        END IF;

        -- Calculate average unit cost
        IF v_quantity > 0 THEN
            v_avg_cost := v_value / v_quantity;
        ELSE
            v_avg_cost := 0.00;
        END IF;

        -- Upsert valuation record
        INSERT INTO inventory_valuations (
            org_id,
            valuation_date,
            product_id,
            product_code,
            product_name,
            location_id,
            quantity_on_hand,
            uom,
            total_value,
            average_unit_cost,
            currency_id,
            valuation_method,
            active_layers_count,
            oldest_layer_date,
            newest_layer_date,
            status,
            calculated_at,
            calculated_by
        ) VALUES (
            p_org_id,
            p_valuation_date,
            v_product.id,
            v_product.code,
            v_product.name,
            p_location_id,
            v_quantity,
            'unit', -- Placeholder
            v_value,
            v_avg_cost,
            v_currency_id,
            v_method,
            v_layer_count,
            v_oldest_date,
            v_newest_date,
            'calculated',
            NOW(),
            auth.uid()
        )
        ON CONFLICT (org_id, valuation_date, product_id)
        WHERE location_id IS NULL -- Adjust constraint as needed
        DO UPDATE SET
            quantity_on_hand = v_quantity,
            total_value = v_value,
            average_unit_cost = v_avg_cost,
            active_layers_count = v_layer_count,
            oldest_layer_date = v_oldest_date,
            newest_layer_date = v_newest_date,
            calculated_at = NOW(),
            calculated_by = auth.uid(),
            updated_at = NOW();

    ELSE
        -- Calculate for all products (loop through each product)
        FOR v_product IN
            SELECT DISTINCT p.id, p.code, p.name
            FROM products p
            INNER JOIN inventory_cost_layers icl ON icl.product_id = p.id
            WHERE p.org_id = p_org_id
              AND icl.is_fully_consumed = FALSE
        LOOP
            -- Recursive call for each product
            PERFORM calculate_inventory_valuation(p_org_id, v_product.id, p_location_id, p_valuation_date);
        END LOOP;
    END IF;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

---

## Acceptance Criteria (Given/When/Then)

### AC-1: Cost Layer Table Creation

```gherkin
Scenario: inventory_cost_layers table exists
  Given database migration runs
  When schema is inspected
  Then inventory_cost_layers table has all columns
  And indexes exist for performance
  And RLS policies enforce org isolation
```

### AC-2: FIFO Cost Layer Creation on Receipt

```gherkin
Scenario: Create cost layer on LP receipt
  Given organization has FIFO valuation method enabled
  And GRN creates LP with:
    | Field | Value |
    | Product | Flour |
    | Quantity | 100 kg |
    | Unit Cost | 5 PLN/kg |
    | Receipt Date | 2025-01-15 |
  When LP created
  Then cost layer record created with:
    | Field | Value |
    | quantity_received | 100 |
    | quantity_remaining | 100 |
    | unit_cost | 5.00 |
    | total_cost | 500.00 |
    | receipt_date | 2025-01-15 |
    | is_fully_consumed | FALSE |
```

### AC-3: FIFO Cost Layer Consumption

```gherkin
Scenario: Consume cost layer FIFO order
  Given product has 2 cost layers:
    | Receipt Date | Quantity | Unit Cost |
    | 2025-01-10 | 50 kg | 4.00 PLN |
    | 2025-01-15 | 100 kg | 5.00 PLN |
  When consuming 75 kg
  Then Layer 1 (oldest):
    | quantity_remaining | 0 |
    | quantity_consumed | 50 |
    | is_fully_consumed | TRUE |
  And Layer 2:
    | quantity_remaining | 75 |
    | quantity_consumed | 25 |
    | is_fully_consumed | FALSE |
  And consumed_cost = 325 PLN ((50 * 4.00) + (25 * 5.00))

Scenario: Partial layer consumption
  Given cost layer with 100 kg at 5 PLN/kg
  When consuming 40 kg
  Then quantity_remaining = 60
  And quantity_consumed = 40
  And is_fully_consumed = FALSE
```

### AC-4: Weighted Average Cost Calculation

```gherkin
Scenario: Calculate weighted average cost
  Given product has active cost layers:
    | Quantity | Unit Cost |
    | 50 kg | 4.00 PLN |
    | 100 kg | 5.00 PLN |
  When calculate_weighted_average_cost() executes
  Then average_cost = 4.67 PLN
  Calculation: ((50 * 4.00) + (100 * 5.00)) / (50 + 100) = 700 / 150 = 4.67

Scenario: Weighted average with single layer
  Given product has one layer: 100 kg at 5.00 PLN/kg
  When calculating weighted average
  Then average_cost = 5.00 PLN
```

### AC-5: Inventory Valuation Calculation

```gherkin
Scenario: Calculate FIFO inventory valuation for product
  Given product "Flour" with cost layers:
    | Receipt Date | Quantity | Unit Cost |
    | 2025-01-10 | 50 kg | 4.00 PLN |
    | 2025-01-15 | 100 kg | 5.00 PLN |
  When calculate_inventory_valuation(product_id) executes
  Then inventory_valuations record created with:
    | Field | Value |
    | quantity_on_hand | 150 kg |
    | total_value | 700.00 PLN |
    | average_unit_cost | 4.67 PLN |
    | valuation_method | fifo |
    | active_layers_count | 2 |
    | oldest_layer_date | 2025-01-10 |
    | newest_layer_date | 2025-01-15 |
    | status | calculated |

Scenario: Calculate weighted average inventory valuation
  Given organization uses weighted average method
  And product has same cost layers as above
  When calculate_inventory_valuation() executes with method='average'
  Then total_value = 700.00 PLN
  And average_unit_cost = 4.67 PLN
  And active_layers_count = 0 (WAC doesn't track layers)
```

### AC-6: Inventory Valuation Report API

```gherkin
Scenario: Get inventory valuation summary
  Given organization has 3 products with calculated valuations
  When GET /api/finance/inventory-valuation
  Then response 200 OK with JSON array:
    [
      {
        "product_id": "uuid",
        "product_code": "FLR-001",
        "product_name": "Flour",
        "quantity_on_hand": 150.00,
        "uom": "kg",
        "total_value": 700.00,
        "average_unit_cost": 4.67,
        "currency_code": "PLN",
        "valuation_method": "fifo",
        "valuation_date": "2025-01-15"
      },
      ...
    ]
  And list loads within 500ms
  And pagination available

Scenario: Get product-specific valuation
  Given product "Flour" has valuation calculated
  When GET /api/finance/inventory-valuation/:productId
  Then response includes:
    - Product details
    - Valuation summary
    - Cost layer breakdown (if FIFO)
    - Historical valuation trend (last 6 months)
```

### AC-7: Cost Layer Detail View (FIFO)

```gherkin
Scenario: View cost layer details for FIFO product
  Given product uses FIFO method
  And has 3 active cost layers
  When GET /api/finance/inventory-valuation/:productId/layers
  Then response 200 OK with cost layers:
    | Receipt Date | Quantity Remaining | Unit Cost | Total Cost | LP Number |
    | 2025-01-10 | 50 kg | 4.00 | 200.00 | LP00001 |
    | 2025-01-15 | 100 kg | 5.00 | 500.00 | LP00002 |
    | 2025-01-20 | 75 kg | 5.50 | 412.50 | LP00003 |
  And sorted by receipt_date ASC (FIFO order)
```

### AC-8: Valuation Method Configuration

```gherkin
Scenario: Configure organization valuation method
  Given organization settings page
  When admin selects valuation method = "FIFO"
  And clicks [Save]
  Then inventory_valuation_settings.default_method = 'fifo'
  And success message "Valuation method updated to FIFO"
  And all new cost layers use FIFO method

Scenario: Switch from FIFO to Weighted Average
  Given organization currently uses FIFO
  When switching to weighted average
  Then warning: "Existing cost layers will remain. New consumption will use weighted average."
  And confirmation required
  And change logged in audit trail
```

### AC-9: Inventory Valuation Report Page

```gherkin
Scenario: Display inventory valuation report
  Given user navigates to Finance > Inventory Valuation
  When page loads
  Then DataTable displays all products with:
    | Column | Description |
    | Product Code | Product identifier |
    | Product Name | Product name |
    | Qty on Hand | Current quantity |
    | UOM | Unit of measure |
    | Avg Unit Cost | Average cost per unit |
    | Total Value | Total inventory value |
    | Method | FIFO or WAC |
    | Last Updated | Calculation timestamp |
  And total inventory value summary at top
  And export to CSV button available
  And filter by product category
  And page loads within 500ms

Scenario: Drill down to product valuation detail
  Given user clicks on product row
  When product detail page loads
  Then displays:
    - Valuation summary
    - Cost layer breakdown (if FIFO)
    - Historical valuation chart (6 months)
    - Recent consumption transactions
```

### AC-10: Recalculate Inventory Valuation

```gherkin
Scenario: Manually recalculate inventory valuation
  Given user on inventory valuation page
  And has FINANCE_MANAGER role
  When clicking [Recalculate Valuation]
  Then calculate_inventory_valuation() executes for all products
  And progress indicator shows calculation status
  And completion message with total value
  And page refreshes with updated data
  And last_calculated_at timestamp updated

Scenario: Scheduled daily recalculation
  Given system scheduled job configured
  When midnight UTC
  Then calculate_inventory_valuation() executes automatically
  And valuation snapshot created with valuation_date = current date
  And status = 'calculated'
```

### AC-11: Multi-Currency Valuation

```gherkin
Scenario: Valuation in base currency
  Given organization base currency = PLN
  And product received in EUR (10 EUR at rate 4.30)
  When cost layer created
  Then unit_cost = 43 PLN (converted to base)
  And currency_id = PLN currency ID
  And valuation calculated in PLN

Scenario: Display valuation in base currency
  Given inventory valuation calculated
  When viewing valuation report
  Then all values displayed in organization base currency
  And currency symbol shown (PLN)
```

### AC-12: Permission Enforcement

```gherkin
Scenario: Viewer can view valuation
  Given user with VIEWER role
  When viewing inventory valuation page
  Then can view all valuation data
  And can export to CSV
  And cannot recalculate valuation
  And [Recalculate] button hidden

Scenario: Finance manager can recalculate
  Given user with FINANCE_MANAGER role
  When viewing valuation page
  Then can view, export, and recalculate valuation
  And can approve valuation records (status = 'approved')
```

### AC-13: RLS Policy Enforcement

```gherkin
Scenario: Org isolation on cost layers
  Given User A from Org A and User B from Org B
  And cost layers exist in both orgs
  When User A requests GET /api/finance/inventory-valuation
  Then only Org A valuations returned

Scenario: Cannot view cost layers from different org
  Given cost layer belongs to Org B
  When User A (Org A) requests layer detail
  Then 404 Not Found returned
```

### AC-14: Performance Requirements

```gherkin
Scenario: FIFO consumption performance
  Given product with 100 cost layers
  When consuming quantity (triggering FIFO)
  Then consume_cost_layer_fifo() completes < 500ms

Scenario: Valuation calculation performance
  Given organization with 500 products
  When calculate_inventory_valuation() executes
  Then calculation completes < 30 seconds

Scenario: Valuation report load performance
  Given 1000 products with valuations
  When loading inventory valuation page
  Then response time < 1 second (paginated)
```

---

## Implementation Notes

### API Endpoints

```typescript
// GET /api/finance/inventory-valuation
interface InventoryValuationSummaryResponse {
  valuations: InventoryValuation[];
  total_value: number;
  currency_code: string;
  valuation_date: string;
  valuation_method: 'fifo' | 'average';
  pagination: PaginationInfo;
}

interface InventoryValuation {
  id: string;
  product_id: string;
  product_code: string;
  product_name: string;
  quantity_on_hand: number;
  uom: string;
  total_value: number;
  average_unit_cost: number;
  currency_code: string;
  valuation_method: 'fifo' | 'average';
  active_layers_count: number;
  oldest_layer_date?: string;
  newest_layer_date?: string;
  valuation_date: string;
  last_calculated_at: string;
}

// GET /api/finance/inventory-valuation/:productId
interface ProductValuationDetailResponse {
  valuation: InventoryValuation;
  cost_layers?: CostLayer[]; // FIFO only
  historical_valuations: HistoricalValuation[];
  recent_transactions: ValuationTransaction[];
}

interface CostLayer {
  id: string;
  lp_id?: string;
  lp_number?: string;
  lot_number?: string;
  receipt_date: string;
  quantity_received: number;
  quantity_remaining: number;
  quantity_consumed: number;
  unit_cost: number;
  total_cost: number;
  is_fully_consumed: boolean;
}

// POST /api/finance/inventory-valuation/calculate
interface CalculateValuationRequest {
  product_id?: string; // Optional: specific product or all
  location_id?: string;
  valuation_date?: string;
}

interface CalculateValuationResponse {
  success: boolean;
  products_calculated: number;
  total_value: number;
  calculated_at: string;
}

// GET /api/finance/inventory-valuation/:productId/layers
interface CostLayersResponse {
  product_id: string;
  product_name: string;
  cost_layers: CostLayer[];
  total_layers: number;
  total_value: number;
}
```

### Service Layer

```typescript
// lib/services/inventory-valuation-service.ts

export class InventoryValuationService {
  /**
   * Get inventory valuation summary for all products
   */
  static async getSummary(params: ValuationQueryParams): Promise<InventoryValuationSummaryResponse>;

  /**
   * Get product-specific valuation detail
   */
  static async getProductValuation(productId: string): Promise<ProductValuationDetailResponse>;

  /**
   * Calculate inventory valuation for product or all products
   */
  static async calculate(params: CalculateValuationRequest): Promise<CalculateValuationResponse>;

  /**
   * Get cost layers for product (FIFO method)
   */
  static async getCostLayers(productId: string): Promise<CostLayersResponse>;

  /**
   * Create cost layer on LP receipt
   */
  static async createCostLayer(input: CreateCostLayerInput): Promise<CostLayer>;

  /**
   * Consume cost layer (FIFO)
   */
  static async consumeCostLayerFIFO(productId: string, quantity: number): Promise<{ cost: number }>;

  /**
   * Calculate weighted average cost
   */
  static async calculateWeightedAverage(productId: string): Promise<number>;

  /**
   * Export valuation to CSV
   */
  static async exportToCSV(params: ValuationQueryParams): Promise<string>;

  /**
   * Get valuation method for organization
   */
  static async getValuationMethod(orgId: string): Promise<'fifo' | 'average' | 'standard'>;

  /**
   * Update valuation settings
   */
  static async updateSettings(input: UpdateValuationSettingsInput): Promise<void>;
}
```

---

## Key Business Rules

1. **FIFO Consumption Order**: Always consume oldest cost layers first based on receipt_date
2. **Cost Layer Immutability**: Once created, cost layer unit_cost cannot be changed
3. **Weighted Average Recalculation**: WAC recalculates on every receipt and consumption
4. **Valuation Method Consistency**: All products in org use same valuation method (configurable)
5. **Currency Consistency**: All cost layers for a product must be in same currency (org base currency)
6. **Layer Consumption Validation**: Cannot consume more than available quantity_remaining
7. **Valuation Date**: Valuation snapshots use end-of-day for consistency
8. **Auto-Calculation**: Valuation recalculates automatically on inventory transactions (if enabled)
9. **Permission Required**: Only FINANCE_MANAGER can approve valuations
10. **Historical Preservation**: Historical valuation records are immutable (audit trail)

---

## Deliverables

### Database
- [ ] Migration: `inventory_cost_layers` table
- [ ] Migration: `inventory_valuations` table
- [ ] Migration: `inventory_valuation_settings` table
- [ ] Function: `create_cost_layer_on_lp_receipt()`
- [ ] Function: `consume_cost_layer_fifo()`
- [ ] Function: `calculate_weighted_average_cost()`
- [ ] Function: `calculate_inventory_valuation()`
- [ ] RLS policies for all tables
- [ ] All performance indexes

### API Routes
- [ ] `GET /api/finance/inventory-valuation` - Summary report
- [ ] `GET /api/finance/inventory-valuation/:productId` - Product detail
- [ ] `POST /api/finance/inventory-valuation/calculate` - Recalculate
- [ ] `GET /api/finance/inventory-valuation/:productId/layers` - Cost layers
- [ ] `GET /api/finance/inventory-valuation/export` - CSV export
- [ ] `GET /api/finance/inventory-valuation/settings` - Get settings
- [ ] `PATCH /api/finance/inventory-valuation/settings` - Update settings

### Service Layer
- [ ] `InventoryValuationService.getSummary()`
- [ ] `InventoryValuationService.getProductValuation()`
- [ ] `InventoryValuationService.calculate()`
- [ ] `InventoryValuationService.getCostLayers()`
- [ ] `InventoryValuationService.createCostLayer()`
- [ ] `InventoryValuationService.consumeCostLayerFIFO()`
- [ ] `InventoryValuationService.calculateWeightedAverage()`
- [ ] `InventoryValuationService.exportToCSV()`
- [ ] `InventoryValuationService.getValuationMethod()`
- [ ] `InventoryValuationService.updateSettings()`

### Frontend
- [ ] Inventory valuation report page
- [ ] Product valuation detail page
- [ ] Cost layer detail table (FIFO)
- [ ] Valuation settings page
- [ ] Recalculate button with progress indicator
- [ ] CSV export functionality
- [ ] Valuation method selector

### Tests
- [ ] Unit tests: InventoryValuationService (>80% coverage)
- [ ] FIFO consumption logic tests
- [ ] Weighted average calculation tests
- [ ] Integration tests: All API endpoints
- [ ] Database function tests
- [ ] RLS tests: Multi-tenancy isolation
- [ ] E2E: Full valuation workflow

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| FIFO calculation errors | HIGH | MEDIUM | Comprehensive unit tests, validation |
| Weighted average precision loss | MEDIUM | LOW | Use DECIMAL(15,4), round correctly |
| Performance with many layers | MEDIUM | MEDIUM | Indexes, pagination, archive old layers |
| Cost layer consumption race condition | HIGH | LOW | Database transactions, row locking |
| Currency conversion errors | MEDIUM | LOW | Require base currency, validation |
| Valuation method switch complexity | MEDIUM | LOW | Clear migration path, warning messages |

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-01-15 | Initial story creation for inventory valuation FIFO/WAC | OPUS |

---

**Document Status**: Ready for Implementation
**Created**: 2025-01-15
**Lines**: ~950
**Complexity**: L (Large)
**Phase**: 1 (Foundation)
