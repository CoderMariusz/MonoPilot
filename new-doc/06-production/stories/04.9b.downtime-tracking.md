# 04.9b - Downtime Tracking

**Story ID:** 04.9b
**Epic:** 04 - Production
**Phase:** Phase 2
**Complexity:** L (Large)
**Estimate:** 4 days
**Type:** Backend + Frontend
**State:** ready

**Primary PRD:** `docs/1-BASELINE/product/modules/PRODUCTION.md` (FR-PROD-019)
**UX Wireframes:** PROD-010 (Downtime Log Modal), PROD-011 (Downtime History)

## PRD References

| FR ID | Requirement | Priority | Phase | Covered |
|-------|-------------|----------|-------|---------|
| FR-PROD-019 | Downtime Tracking | P1 | Phase 2 | Yes |
| FR-PROD-022b | Downtime Analysis Report | P1 | Phase 2 | Partial (Pareto only) |

## User Story

**As a** production operator,
**I want** to log and track machine downtime with categories and reasons,
**So that** I can accurately record production interruptions for OEE calculation and analysis.

**As a** production manager,
**I want** to view downtime history and analytics,
**So that** I can identify patterns, optimize maintenance schedules, and reduce unplanned downtime.

## Goal

Implement comprehensive downtime tracking that captures machine interruptions with categorization, duration calculation, and integration with WO pause functionality. Enable both manual logging and automatic downtime creation from WO pause events.

## Scope

**In scope:**
- Downtime logging (manual entry via modal)
- Downtime categories (planned: maintenance, changeover, break, no schedule; unplanned: breakdown, material wait, quality issue, operator absence)
- Downtime reason codes (configurable dropdown)
- Start/end timestamp tracking with duration calculation
- Machine status integration (update machine status on downtime)
- Active downtime indicator on dashboard
- Downtime history table with filters
- Auto-integration with WO pause (optional linkage)
- Downtime alerts (duration threshold exceeded)
- Basic downtime analytics (Pareto chart by category/reason)
- Production settings: enable_downtime_tracking toggle
- Scanner workflow for downtime logging

**Out of scope:**
- OEE calculation integration (04.9a - OEE Calculation)
- Shift management integration (04.9c - Shift Management)
- Machine integration (04.10 - Machine Integration)
- Predictive maintenance
- Downtime cost tracking
- Maintenance scheduling

## Dependencies

| Story | Requirement | Status |
|-------|-------------|--------|
| 01.10 | Machines CRUD | Required - provides machines table |
| 04.2b | WO Pause/Resume | Optional - integration for auto-downtime |
| 04.5 | Production Settings | Required - enable_downtime_tracking flag |
| 01.1 | Org Context + Base RLS | Required - provides auth context |

## Acceptance Criteria (Given/When/Then)

### Downtime Configuration

#### AC-1: Enable Downtime Tracking
- GIVEN admin navigates to `/settings/production-execution`, WHEN page loads, THEN "Enable Downtime Tracking" toggle displays with current value.
- GIVEN enable_downtime_tracking = false, WHEN user views production pages, THEN "Log Downtime" button is hidden.
- GIVEN enable_downtime_tracking = true, WHEN user views production pages, THEN "Log Downtime" button is visible.

#### AC-2: Downtime Categories
- GIVEN user opens downtime modal, WHEN category dropdown clicked, THEN 9 categories display: Breakdown, Changeover, Maintenance, Material Wait, Quality Issue, Operator Absence, Break, No Schedule, Other.
- GIVEN category "Changeover" selected, WHEN saved, THEN is_planned = true automatically.
- GIVEN category "Breakdown" selected, WHEN saved, THEN is_planned = false automatically.

### Downtime Logging (Manual)

#### AC-3: Log Downtime Start
- GIVEN enable_downtime_tracking = true, WHEN user clicks "Log Downtime", THEN modal opens with: machine dropdown, category dropdown, reason code dropdown, notes field.
- GIVEN user selects Machine A and category "Breakdown", WHEN "Start Downtime" clicked, THEN downtime record created with started_at = now, ended_at = NULL.
- GIVEN user submits without selecting category, WHEN validation runs, THEN error "Category is required" displays.
- GIVEN user submits without selecting machine, WHEN validation runs, THEN error "Machine is required" displays.

#### AC-4: Log Downtime End
- GIVEN active downtime exists for Machine A, WHEN user clicks "End Downtime", THEN confirmation modal displays with duration preview.
- GIVEN downtime started at 10:00, WHEN "End Downtime" clicked at 10:45, THEN duration_minutes = 45.
- GIVEN downtime ended, WHEN dashboard refreshes, THEN Machine A no longer shows "Down" indicator.

#### AC-5: Full Downtime Entry (Start + End)
- GIVEN user opens downtime modal, WHEN "Log Past Downtime" selected, THEN start time and end time pickers display.
- GIVEN user enters start = 09:00 and end = 09:30, WHEN saved, THEN duration_minutes = 30 calculated automatically.
- GIVEN user enters end time before start time, WHEN validation runs, THEN error "End time must be after start time" displays.

#### AC-6: Reason Codes
- GIVEN category "Breakdown" selected, WHEN reason code dropdown opens, THEN breakdown-specific reasons display: Motor Failure, Electrical Issue, Mechanical Jam, Sensor Malfunction, Other.
- GIVEN category "Material Wait" selected, WHEN reason code dropdown opens, THEN material-specific reasons display: Raw Material Shortage, Packaging Shortage, Quality Hold, Supplier Delay, Other.
- GIVEN reason code selected, WHEN saved, THEN reason_code stored in downtime record.

### Machine Status Integration

#### AC-7: Machine Status Update
- GIVEN Machine A status = "Active", WHEN downtime logged with category "Breakdown", THEN Machine A status changes to "Offline".
- GIVEN Machine A status = "Active", WHEN downtime logged with category "Maintenance", THEN Machine A status changes to "Maintenance".
- GIVEN Machine A has active downtime, WHEN downtime ended, THEN Machine A status changes to "Active".

### Dashboard Integration

#### AC-8: Active Downtime Indicator
- GIVEN Machine A has active downtime (ended_at IS NULL), WHEN dashboard loads, THEN "Machine Down" alert displays with machine name and duration counter.
- GIVEN active downtime exists for 45 minutes, WHEN dashboard refreshes, THEN duration counter shows "45 min" (live updating).
- GIVEN downtime duration > 30 minutes, WHEN threshold exceeded, THEN notification sent to manager role.

#### AC-9: Downtime KPI
- GIVEN today's downtime = 120 minutes across all machines, WHEN dashboard loads, THEN "Downtime Today" KPI card shows "2h 0m".
- GIVEN no downtime today, WHEN dashboard loads, THEN "Downtime Today" KPI card shows "0m".

### WO Pause Integration

#### AC-10: Auto-Create Downtime from WO Pause
- GIVEN WO is running on Machine A AND enable_downtime_tracking = true, WHEN WO paused with reason "Machine Breakdown", THEN downtime record auto-created for Machine A with category "Breakdown".
- GIVEN downtime auto-created from WO pause, WHEN downtime record viewed, THEN wo_id field links to the paused WO.
- GIVEN WO resumed, WHEN auto-created downtime exists, THEN downtime ended_at set automatically.

#### AC-11: Manual Downtime Unlinked to WO
- GIVEN user logs downtime without active WO, WHEN saved, THEN wo_id = NULL in downtime record.
- GIVEN downtime modal open, WHEN active WOs exist on selected machine, THEN optional "Link to WO" dropdown displays.

### Downtime History

#### AC-12: View Downtime History
- GIVEN user navigates to `/production/downtime`, WHEN page loads, THEN downtime history table displays within 2 seconds.
- GIVEN downtime history table, WHEN rendered, THEN columns show: Machine, Category, Reason, Started At, Ended At, Duration, Planned/Unplanned, Logged By.
- GIVEN 100 downtime records exist, WHEN page loads, THEN pagination shows 25 records per page.

#### AC-13: Filter Downtime History
- GIVEN downtime history displayed, WHEN user filters by machine "Machine A", THEN only Machine A downtimes display.
- GIVEN downtime history displayed, WHEN user filters by category "Breakdown", THEN only breakdown downtimes display.
- GIVEN downtime history displayed, WHEN user filters by date range "Last 7 days", THEN only downtimes in range display.
- GIVEN downtime history displayed, WHEN user filters by "Unplanned only", THEN only is_planned = false records display.

#### AC-14: Edit/Delete Downtime
- GIVEN user has Manager or Admin role, WHEN viewing downtime history, THEN "Edit" and "Delete" actions visible.
- GIVEN user clicks "Edit" on downtime record, WHEN modal opens, THEN all fields editable (category, reason, times, notes).
- GIVEN user clicks "Delete" on downtime record, WHEN confirmed, THEN record soft-deleted (is_deleted = true).
- GIVEN user has Operator role, WHEN viewing downtime history, THEN "Edit" and "Delete" actions hidden.

### Downtime Analytics

#### AC-15: Downtime Pareto Chart
- GIVEN user views `/production/downtime/analytics`, WHEN page loads, THEN Pareto chart displays categories sorted by total duration (highest first).
- GIVEN Pareto chart rendered, WHEN displayed, THEN cumulative percentage line overlays bars.
- GIVEN filter "Last 30 days" applied, WHEN chart regenerates, THEN only data in range included.

#### AC-16: Downtime Summary Stats
- GIVEN analytics page loaded, WHEN summary section rendered, THEN displays: Total Downtime Hours, Unplanned %, Average Duration, Top Reason.
- GIVEN 10 downtime events exist with total = 600 minutes, WHEN summary calculated, THEN "Total Downtime: 10h" displays.

### Scanner Workflow

#### AC-17: Scanner Downtime Logging
- GIVEN operator on scanner device, WHEN "Log Downtime" tapped, THEN large touch-friendly modal opens.
- GIVEN scanner modal open, WHEN category selected, THEN large buttons display (min 64px height).
- GIVEN downtime logged via scanner, WHEN confirmed, THEN visual feedback (green check) displays.
- GIVEN active downtime on scanner, WHEN "End Downtime" tapped, THEN duration shows with confirmation.

### Multi-tenancy

#### AC-18: RLS Enforcement
- GIVEN User A from Org A, WHEN requesting downtime logs, THEN only Org A downtimes returned.
- GIVEN User A from Org A, WHEN attempting to view Org B downtime, THEN 404 Not Found returns (not 403).

## Technical Specification

### Database Schema

#### downtime_logs table

```sql
CREATE TABLE downtime_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  machine_id UUID NOT NULL REFERENCES machines(id),
  wo_id UUID REFERENCES work_orders(id) ON DELETE SET NULL,

  -- Downtime classification
  category VARCHAR(50) NOT NULL,  -- breakdown, changeover, maintenance, material_wait, quality_issue, operator_absence, break, no_schedule, other
  reason_code VARCHAR(100),        -- specific reason within category
  is_planned BOOLEAN NOT NULL DEFAULT false,

  -- Timestamps
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ,
  duration_minutes INTEGER,       -- Calculated on end

  -- Details
  notes TEXT,

  -- User tracking
  logged_by UUID NOT NULL REFERENCES users(id),
  ended_by UUID REFERENCES users(id),

  -- Soft delete
  is_deleted BOOLEAN DEFAULT false,
  deleted_at TIMESTAMPTZ,
  deleted_by UUID REFERENCES users(id),

  -- Audit
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT duration_nonnegative CHECK (duration_minutes IS NULL OR duration_minutes >= 0)
);

-- Indexes
CREATE INDEX idx_downtime_logs_org_id ON downtime_logs(org_id);
CREATE INDEX idx_downtime_logs_machine_id ON downtime_logs(machine_id);
CREATE INDEX idx_downtime_logs_wo_id ON downtime_logs(wo_id);
CREATE INDEX idx_downtime_logs_category ON downtime_logs(category);
CREATE INDEX idx_downtime_logs_started_at ON downtime_logs(started_at);
CREATE INDEX idx_downtime_logs_active ON downtime_logs(machine_id) WHERE ended_at IS NULL AND is_deleted = false;
```

#### downtime_reason_codes table (configurable reasons)

```sql
CREATE TABLE downtime_reason_codes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  category VARCHAR(50) NOT NULL,   -- Links to downtime_logs.category
  code VARCHAR(50) NOT NULL,
  label VARCHAR(100) NOT NULL,
  description TEXT,
  is_active BOOLEAN DEFAULT true,
  sort_order INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(org_id, category, code)
);

CREATE INDEX idx_downtime_reason_codes_org_category ON downtime_reason_codes(org_id, category);
```

#### production_settings extension

```sql
-- Add downtime settings to production_settings
ALTER TABLE production_settings
  ADD COLUMN IF NOT EXISTS enable_downtime_tracking BOOLEAN DEFAULT false,
  ADD COLUMN IF NOT EXISTS downtime_alert_threshold_minutes INTEGER DEFAULT 30;
```

### RLS Policies

```sql
-- Enable RLS
ALTER TABLE downtime_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE downtime_reason_codes ENABLE ROW LEVEL SECURITY;

-- downtime_logs: Org-scoped access
CREATE POLICY "downtime_logs_select" ON downtime_logs
FOR SELECT TO authenticated
USING (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND is_deleted = false
);

CREATE POLICY "downtime_logs_insert" ON downtime_logs
FOR INSERT TO authenticated
WITH CHECK (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
);

CREATE POLICY "downtime_logs_update" ON downtime_logs
FOR UPDATE TO authenticated
USING (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid())
      IN ('SUPER_ADMIN', 'ADMIN', 'PROD_MANAGER')
);

CREATE POLICY "downtime_logs_delete" ON downtime_logs
FOR DELETE TO authenticated
USING (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid())
      IN ('SUPER_ADMIN', 'ADMIN', 'PROD_MANAGER')
);

-- downtime_reason_codes: Org-scoped access
CREATE POLICY "downtime_reason_codes_select" ON downtime_reason_codes
FOR SELECT TO authenticated
USING (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND is_active = true
);

CREATE POLICY "downtime_reason_codes_insert" ON downtime_reason_codes
FOR INSERT TO authenticated
WITH CHECK (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid())
      IN ('SUPER_ADMIN', 'ADMIN')
);

CREATE POLICY "downtime_reason_codes_update" ON downtime_reason_codes
FOR UPDATE TO authenticated
USING (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid())
      IN ('SUPER_ADMIN', 'ADMIN')
);
```

### API Endpoints

```
# Downtime Logging
POST   /api/production/downtime                    - Log new downtime
PUT    /api/production/downtime/:id/end            - End active downtime
GET    /api/production/downtime/active             - Get active downtimes
GET    /api/production/downtime/history            - Get downtime history (paginated)
GET    /api/production/downtime/:id                - Get single downtime record
PUT    /api/production/downtime/:id                - Update downtime record (Manager+)
DELETE /api/production/downtime/:id                - Soft delete downtime (Manager+)

# Reason Codes
GET    /api/production/downtime/reason-codes       - Get reason codes by category
POST   /api/production/downtime/reason-codes       - Create reason code (Admin)
PUT    /api/production/downtime/reason-codes/:id   - Update reason code (Admin)

# Analytics
GET    /api/production/downtime/analytics/summary  - Summary stats
GET    /api/production/downtime/analytics/pareto   - Pareto chart data

# Dashboard KPI
GET    /api/production/dashboard/downtime-kpi      - Today's downtime summary
```

### Service Methods

**Location:** `lib/services/downtime-service.ts`

```typescript
interface DowntimeService {
  // Configuration
  isDowntimeTrackingEnabled(orgId: string): Promise<boolean>;
  getDowntimeCategories(): DowntimeCategory[];
  getReasonCodes(orgId: string, category: string): Promise<ReasonCode[]>;

  // Downtime CRUD
  logDowntime(data: LogDowntimeInput): Promise<DowntimeLog>;
  endDowntime(id: string, userId: string): Promise<DowntimeLog>;
  getActiveDowntimes(orgId: string): Promise<DowntimeLog[]>;
  getActiveDowntimeByMachine(machineId: string, orgId: string): Promise<DowntimeLog | null>;
  getDowntimeHistory(params: DowntimeHistoryParams): Promise<DowntimeHistoryResponse>;
  getDowntimeById(id: string, orgId: string): Promise<DowntimeLog>;
  updateDowntime(id: string, data: UpdateDowntimeInput): Promise<DowntimeLog>;
  deleteDowntime(id: string, userId: string): Promise<void>;

  // Duration calculation
  calculateDuration(startedAt: Date, endedAt: Date): number;

  // Machine status integration
  updateMachineStatusOnDowntime(machineId: string, category: string): Promise<void>;
  updateMachineStatusOnEnd(machineId: string): Promise<void>;

  // WO Pause integration
  createDowntimeFromWOPause(woId: string, machineId: string, pauseReason: string): Promise<DowntimeLog>;
  endDowntimeFromWOResume(woId: string): Promise<void>;

  // Analytics
  getDowntimeSummary(orgId: string, dateRange: DateRange): Promise<DowntimeSummary>;
  getParetoByCategoryData(orgId: string, dateRange: DateRange): Promise<ParetoData[]>;
  getDashboardKPI(orgId: string): Promise<DowntimeKPI>;

  // Alerts
  checkDowntimeAlerts(orgId: string): Promise<DowntimeAlert[]>;
}

interface DowntimeCategory {
  code: string;
  label: string;
  is_planned: boolean;
}

interface LogDowntimeInput {
  org_id: string;
  machine_id: string;
  category: string;
  reason_code?: string;
  notes?: string;
  wo_id?: string;
  started_at?: Date;      // Defaults to now
  ended_at?: Date;        // If provided, calculates duration immediately
  logged_by: string;
}

interface DowntimeHistoryParams {
  org_id: string;
  machine_id?: string;
  category?: string;
  is_planned?: boolean;
  date_from?: Date;
  date_to?: Date;
  page?: number;
  limit?: number;
}

interface DowntimeSummary {
  total_minutes: number;
  total_events: number;
  unplanned_percent: number;
  avg_duration_minutes: number;
  top_category: string;
  top_reason: string;
}

interface ParetoData {
  category: string;
  total_minutes: number;
  event_count: number;
  cumulative_percent: number;
}

interface DowntimeKPI {
  today_total_minutes: number;
  active_count: number;
  unplanned_minutes: number;
  machines_down: string[];  // Machine names currently down
}
```

### Zod Validation Schemas

**Location:** `lib/validation/downtime-schema.ts`

```typescript
import { z } from 'zod';

export const downtimeCategorySchema = z.enum([
  'breakdown',
  'changeover',
  'maintenance',
  'material_wait',
  'quality_issue',
  'operator_absence',
  'break',
  'no_schedule',
  'other'
]);

export const logDowntimeSchema = z.object({
  machine_id: z.string().uuid('Invalid machine ID'),
  category: downtimeCategorySchema,
  reason_code: z.string().max(100).optional(),
  notes: z.string().max(1000).optional(),
  wo_id: z.string().uuid().optional().nullable(),
  started_at: z.string().datetime().optional(),  // ISO string
  ended_at: z.string().datetime().optional(),    // ISO string
}).refine(
  (data) => {
    if (data.started_at && data.ended_at) {
      return new Date(data.ended_at) > new Date(data.started_at);
    }
    return true;
  },
  { message: 'End time must be after start time', path: ['ended_at'] }
);

export const endDowntimeSchema = z.object({
  ended_at: z.string().datetime().optional(),  // Defaults to now
});

export const updateDowntimeSchema = z.object({
  category: downtimeCategorySchema.optional(),
  reason_code: z.string().max(100).optional().nullable(),
  notes: z.string().max(1000).optional().nullable(),
  started_at: z.string().datetime().optional(),
  ended_at: z.string().datetime().optional().nullable(),
}).refine(
  (data) => {
    if (data.started_at && data.ended_at) {
      return new Date(data.ended_at) > new Date(data.started_at);
    }
    return true;
  },
  { message: 'End time must be after start time', path: ['ended_at'] }
);

export const downtimeHistoryParamsSchema = z.object({
  machine_id: z.string().uuid().optional(),
  category: downtimeCategorySchema.optional(),
  is_planned: z.coerce.boolean().optional(),
  date_from: z.string().datetime().optional(),
  date_to: z.string().datetime().optional(),
  page: z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(100).default(25),
});

export const createReasonCodeSchema = z.object({
  category: downtimeCategorySchema,
  code: z.string()
    .min(1, 'Code is required')
    .max(50, 'Code must be 50 characters or less')
    .regex(/^[A-Z0-9_]+$/, 'Code must be uppercase alphanumeric with underscores'),
  label: z.string()
    .min(1, 'Label is required')
    .max(100, 'Label must be 100 characters or less'),
  description: z.string().max(500).optional(),
  sort_order: z.number().int().min(0).default(0),
});

export type DowntimeCategory = z.infer<typeof downtimeCategorySchema>;
export type LogDowntimeInput = z.infer<typeof logDowntimeSchema>;
export type EndDowntimeInput = z.infer<typeof endDowntimeSchema>;
export type UpdateDowntimeInput = z.infer<typeof updateDowntimeSchema>;
export type DowntimeHistoryParams = z.infer<typeof downtimeHistoryParamsSchema>;
export type CreateReasonCodeInput = z.infer<typeof createReasonCodeSchema>;
```

### Downtime Categories Reference

```typescript
export const DOWNTIME_CATEGORIES: DowntimeCategory[] = [
  // Unplanned (is_planned = false)
  { code: 'breakdown', label: 'Breakdown', is_planned: false },
  { code: 'material_wait', label: 'Material Wait', is_planned: false },
  { code: 'quality_issue', label: 'Quality Issue', is_planned: false },
  { code: 'operator_absence', label: 'Operator Absence', is_planned: false },
  { code: 'other', label: 'Other', is_planned: false },

  // Planned (is_planned = true)
  { code: 'changeover', label: 'Changeover', is_planned: true },
  { code: 'maintenance', label: 'Maintenance', is_planned: true },
  { code: 'break', label: 'Break', is_planned: true },
  { code: 'no_schedule', label: 'No Schedule', is_planned: true },
];

export const DEFAULT_REASON_CODES = {
  breakdown: [
    { code: 'MOTOR_FAILURE', label: 'Motor Failure' },
    { code: 'ELECTRICAL_ISSUE', label: 'Electrical Issue' },
    { code: 'MECHANICAL_JAM', label: 'Mechanical Jam' },
    { code: 'SENSOR_MALFUNCTION', label: 'Sensor Malfunction' },
    { code: 'OTHER_BREAKDOWN', label: 'Other' },
  ],
  material_wait: [
    { code: 'RAW_MATERIAL_SHORTAGE', label: 'Raw Material Shortage' },
    { code: 'PACKAGING_SHORTAGE', label: 'Packaging Shortage' },
    { code: 'QUALITY_HOLD', label: 'Quality Hold' },
    { code: 'SUPPLIER_DELAY', label: 'Supplier Delay' },
    { code: 'OTHER_MATERIAL', label: 'Other' },
  ],
  quality_issue: [
    { code: 'OUT_OF_SPEC', label: 'Product Out of Spec' },
    { code: 'CONTAMINATION', label: 'Contamination' },
    { code: 'LAB_HOLD', label: 'Lab Hold' },
    { code: 'QUALITY_CHECK', label: 'Quality Check' },
    { code: 'OTHER_QUALITY', label: 'Other' },
  ],
  changeover: [
    { code: 'PRODUCT_CHANGE', label: 'Product Change' },
    { code: 'SIZE_CHANGE', label: 'Size Change' },
    { code: 'CLEANING', label: 'Cleaning' },
    { code: 'SETUP', label: 'Setup' },
  ],
  maintenance: [
    { code: 'SCHEDULED_PM', label: 'Scheduled PM' },
    { code: 'CALIBRATION', label: 'Calibration' },
    { code: 'LUBRICATION', label: 'Lubrication' },
    { code: 'INSPECTION', label: 'Inspection' },
  ],
};
```

## UI Components

### Pages

- `app/(authenticated)/production/downtime/page.tsx` - Downtime history page
- `app/(authenticated)/production/downtime/analytics/page.tsx` - Downtime analytics
- `app/(authenticated)/scanner/downtime/page.tsx` - Scanner downtime workflow

### Components

**Location:** `components/production/downtime/`

```
DowntimeLogModal.tsx           - Log downtime modal (desktop)
DowntimeEndModal.tsx           - End downtime confirmation modal
DowntimeHistoryTable.tsx       - Downtime history data table
DowntimeFilters.tsx            - Filter controls (machine, category, date)
DowntimeCategorySelect.tsx     - Category dropdown with planned/unplanned indicator
DowntimeReasonSelect.tsx       - Reason code dropdown (filtered by category)
DowntimeDurationBadge.tsx      - Duration display with live counter for active
DowntimeCategoryBadge.tsx      - Category badge with color (planned=blue, unplanned=red)
ActiveDowntimeCard.tsx         - Dashboard card for active downtime
DowntimeKPICard.tsx            - Dashboard KPI card
DowntimeParetoChart.tsx        - Pareto chart component (Recharts)
DowntimeSummaryStats.tsx       - Summary statistics panel
DowntimeEditModal.tsx          - Edit downtime record modal (Manager+)
DeleteDowntimeDialog.tsx       - Confirmation dialog for deletion

# Scanner components
ScannerDowntimeModal.tsx       - Touch-friendly downtime modal
ScannerCategoryButtons.tsx     - Large category selection buttons
ScannerDowntimeConfirmation.tsx - Confirmation with visual feedback
```

### Component Specifications

**DowntimeLogModal.tsx**
```tsx
interface DowntimeLogModalProps {
  open: boolean;
  onClose: () => void;
  onSuccess: (downtime: DowntimeLog) => void;
  machineId?: string;        // Pre-select machine if provided
  woId?: string;             // Auto-link to WO if provided
  mode: 'start' | 'full';    // Start only vs full entry with end time
}

// Form fields:
// - Machine dropdown (required)
// - Category dropdown (required)
// - Reason code dropdown (optional, filtered by category)
// - Start time picker (optional for 'start' mode, required for 'full')
// - End time picker (only in 'full' mode)
// - Notes textarea (optional)
// - Link to WO dropdown (optional)
```

**DowntimeCategoryBadge.tsx**
```tsx
const CATEGORY_CONFIG: Record<string, { label: string; color: string; planned: boolean }> = {
  breakdown: { label: 'Breakdown', color: 'red', planned: false },
  changeover: { label: 'Changeover', color: 'blue', planned: true },
  maintenance: { label: 'Maintenance', color: 'blue', planned: true },
  material_wait: { label: 'Material Wait', color: 'orange', planned: false },
  quality_issue: { label: 'Quality Issue', color: 'yellow', planned: false },
  operator_absence: { label: 'Operator Absence', color: 'gray', planned: false },
  break: { label: 'Break', color: 'green', planned: true },
  no_schedule: { label: 'No Schedule', color: 'slate', planned: true },
  other: { label: 'Other', color: 'gray', planned: false },
};
```

**ActiveDowntimeCard.tsx**
```tsx
interface ActiveDowntimeCardProps {
  downtimes: ActiveDowntime[];
  onEndDowntime: (id: string) => void;
}

// Display:
// - Machine name
// - Category badge
// - Live duration counter (updates every second)
// - "End Downtime" button
```

### UI Patterns

**Downtime History Table:**
```
+------------------------------------------------------------------+
| Machine    | Category    | Reason      | Start    | End     | Dur |
|------------|-------------|-------------|----------|---------|-----|
| Mixer-01   | Breakdown   | Motor Fail  | 09:15    | 09:45   | 30m |
| Filler-02  | Changeover  | Product     | 10:00    | 10:20   | 20m |
| Oven-01    | Breakdown   | --Active--  | 11:30    | --      | 45m |
+------------------------------------------------------------------+
```

**Dashboard Active Downtime Alert:**
```
+----------------------------------------+
| MACHINE DOWN                    [Live] |
| Oven-01 - Breakdown                    |
| Duration: 45 min (counting...)         |
| Started: 11:30 AM                       |
| [End Downtime]                         |
+----------------------------------------+
```

## Test Cases

### Unit Tests

**downtime-service.test.ts**
```typescript
describe('DowntimeService', () => {
  describe('logDowntime', () => {
    it('creates downtime with started_at = now when not provided');
    it('calculates duration when both start and end provided');
    it('sets is_planned based on category');
    it('rejects invalid category');
    it('updates machine status to appropriate value');
  });

  describe('endDowntime', () => {
    it('sets ended_at and calculates duration');
    it('rejects if downtime already ended');
    it('updates machine status back to Active');
    it('calculates duration correctly (rounded to minutes)');
  });

  describe('calculateDuration', () => {
    it('calculates 45 minutes correctly');
    it('handles midnight crossing');
    it('returns 0 for same start/end');
  });

  describe('getActiveDowntimes', () => {
    it('returns only records with ended_at IS NULL');
    it('filters by org_id');
    it('excludes is_deleted = true records');
  });

  describe('createDowntimeFromWOPause', () => {
    it('maps WO pause reason to downtime category');
    it('links downtime to WO');
    it('uses WO machine for downtime');
  });

  describe('getParetoByCategoryData', () => {
    it('sorts categories by total_minutes descending');
    it('calculates cumulative_percent correctly');
    it('filters by date range');
  });
});
```

### Integration Tests

**downtime-api.test.ts**
```typescript
describe('Downtime API', () => {
  describe('POST /api/production/downtime', () => {
    it('creates downtime with valid data');
    it('returns 400 when category missing');
    it('returns 400 when machine_id missing');
    it('returns 403 when downtime tracking disabled');
    it('updates machine status on creation');
  });

  describe('PUT /api/production/downtime/:id/end', () => {
    it('ends active downtime successfully');
    it('returns 400 when already ended');
    it('calculates duration correctly');
    it('updates machine status to Active');
  });

  describe('GET /api/production/downtime/history', () => {
    it('returns paginated results');
    it('filters by machine_id');
    it('filters by category');
    it('filters by is_planned');
    it('filters by date range');
    it('enforces RLS (org-scoped)');
  });

  describe('GET /api/production/downtime/active', () => {
    it('returns only active (ended_at IS NULL) downtimes');
    it('includes machine details');
  });

  describe('PUT /api/production/downtime/:id', () => {
    it('allows Manager to update');
    it('returns 403 for Operator role');
    it('recalculates duration on time change');
  });

  describe('DELETE /api/production/downtime/:id', () => {
    it('soft deletes (sets is_deleted = true)');
    it('returns 403 for Operator role');
  });

  describe('GET /api/production/downtime/analytics/pareto', () => {
    it('returns categories sorted by total_minutes');
    it('includes cumulative_percent');
    it('respects date range filter');
  });
});
```

### E2E Tests

**downtime-tracking.spec.ts**
```typescript
describe('Downtime Tracking', () => {
  it('logs downtime and displays in history');
  it('ends active downtime with duration calculation');
  it('filters history by machine');
  it('filters history by category');
  it('shows active downtime on dashboard');
  it('Manager can edit downtime record');
  it('Manager can delete downtime record');
  it('Operator cannot edit/delete downtime');
  it('Pareto chart displays with correct data');
  it('dashboard KPI shows today total');
});

describe('Downtime Scanner Workflow', () => {
  it('logs downtime via scanner interface');
  it('shows large touch-friendly buttons');
  it('ends downtime with visual confirmation');
});

describe('WO Pause Integration', () => {
  it('creates downtime when WO paused with breakdown reason');
  it('ends downtime when WO resumed');
  it('links downtime record to WO');
});
```

## Implementation Notes

### WO Pause to Downtime Category Mapping

```typescript
const WO_PAUSE_TO_DOWNTIME_CATEGORY: Record<string, string> = {
  'machine_breakdown': 'breakdown',
  'material_shortage': 'material_wait',
  'break': 'break',
  'quality_issue': 'quality_issue',
  'other': 'other',
};
```

### Machine Status Updates

| Downtime Category | Machine Status Set To |
|-------------------|----------------------|
| breakdown | OFFLINE |
| maintenance | MAINTENANCE |
| changeover | MAINTENANCE |
| material_wait | (no change) |
| quality_issue | (no change) |
| operator_absence | (no change) |
| break | (no change) |
| no_schedule | (no change) |
| other | (no change) |

### Performance Considerations

- Use database-level duration calculation for accuracy
- Index on `(org_id, ended_at)` for active downtime queries
- Consider materialized view for analytics (daily aggregation)
- Debounce live duration counter updates (1 second interval)

## Deliverables

**Database:**
- [ ] Migration: `downtime_logs` table
- [ ] Migration: `downtime_reason_codes` table
- [ ] Migration: Add `enable_downtime_tracking`, `downtime_alert_threshold_minutes` to `production_settings`
- [ ] RLS policies for both tables
- [ ] Seed default reason codes per category

**API Routes:**
- [ ] `app/api/production/downtime/route.ts` - POST (log), GET (history)
- [ ] `app/api/production/downtime/[id]/route.ts` - GET, PUT, DELETE
- [ ] `app/api/production/downtime/[id]/end/route.ts` - PUT (end downtime)
- [ ] `app/api/production/downtime/active/route.ts` - GET
- [ ] `app/api/production/downtime/reason-codes/route.ts` - GET, POST
- [ ] `app/api/production/downtime/analytics/summary/route.ts` - GET
- [ ] `app/api/production/downtime/analytics/pareto/route.ts` - GET
- [ ] `app/api/production/dashboard/downtime-kpi/route.ts` - GET

**Services:**
- [ ] `lib/services/downtime-service.ts` - Business logic

**Validation:**
- [ ] `lib/validation/downtime-schema.ts` - Zod schemas

**Components:**
- [ ] DowntimeLogModal.tsx
- [ ] DowntimeEndModal.tsx
- [ ] DowntimeHistoryTable.tsx
- [ ] DowntimeFilters.tsx
- [ ] DowntimeCategorySelect.tsx
- [ ] DowntimeReasonSelect.tsx
- [ ] DowntimeDurationBadge.tsx (with live counter)
- [ ] DowntimeCategoryBadge.tsx
- [ ] ActiveDowntimeCard.tsx
- [ ] DowntimeKPICard.tsx
- [ ] DowntimeParetoChart.tsx
- [ ] DowntimeSummaryStats.tsx
- [ ] DowntimeEditModal.tsx
- [ ] DeleteDowntimeDialog.tsx
- [ ] ScannerDowntimeModal.tsx
- [ ] ScannerCategoryButtons.tsx

**Pages:**
- [ ] `/production/downtime` - History page
- [ ] `/production/downtime/analytics` - Analytics page
- [ ] `/scanner/downtime` - Scanner workflow

**Tests:**
- [ ] Unit tests for downtime-service (>80% coverage)
- [ ] Integration tests for all API endpoints
- [ ] E2E tests for critical flows

## Definition of Done

- [ ] Migration creates `downtime_logs` and `downtime_reason_codes` tables
- [ ] Production settings extended with downtime tracking toggle
- [ ] RLS policies enforce org isolation (ADR-013 pattern)
- [ ] API endpoints for full CRUD + analytics
- [ ] `downtime-service.ts` with all service methods
- [ ] Zod validation schemas for all inputs
- [ ] Log downtime modal with category/reason/machine selection
- [ ] End downtime flow with duration calculation
- [ ] Downtime history page with filters and pagination
- [ ] Active downtime indicator on production dashboard
- [ ] Machine status updates automatically on downtime start/end
- [ ] WO Pause integration creates/ends downtime automatically
- [ ] Pareto chart displays categories by total duration
- [ ] Scanner workflow with touch-friendly interface
- [ ] Manager/Admin can edit/delete downtime records
- [ ] Operator can only view and log downtime
- [ ] enable_downtime_tracking toggle controls feature visibility
- [ ] Alert threshold triggers notification when exceeded
- [ ] Unit test coverage >= 80%
- [ ] Integration tests pass
- [ ] E2E tests pass
- [ ] Performance: History page loads < 2 seconds for 1000 records

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-01-14 | Initial story creation | ARCHITECT-AGENT |
