# 04.9c - Machine Integration

**Story ID:** 04.9c
**Epic:** 04 - Production
**Phase:** 2 (OEE & Analytics)
**Complexity:** L (Large)
**Estimate:** 5 days
**Type:** Full-stack
**State:** ready
**Priority:** P2

**Primary PRD:** `docs/1-BASELINE/product/modules/PRODUCTION.md` (FR-PROD-020)
**UX Wireframes:** PROD-020 (Machine Dashboard, Counter Entry)

## PRD References

| FR ID | Requirement | Priority | Phase | Covered |
|-------|-------------|----------|-------|---------|
| FR-PROD-020 | Machine Integration | P1 | Phase 2 | Yes |

## User Story

**As a** Production Manager,
**I want** to monitor machine status, counters, and alarms in real-time,
**So that** I can track machine performance, identify issues quickly, and feed accurate data into OEE calculations.

**As an** Operator,
**I want** to update machine counters and status from the production floor,
**So that** machine performance data is captured accurately without complex integrations.

## Goal

Implement basic machine integration for data collection including machine status monitoring, production counters (good/reject counts), cycle time tracking, and alarm/event logging. Support manual entry as MVP with architecture ready for OPC-UA/Modbus/MQTT integration patterns in future phases.

## Scope

**In scope:**
- Machine status monitoring (Idle, Running, Stopped, Down, Changeover)
- Production counters (good_count, reject_count, cycle_counter)
- Cycle time tracking (last_cycle_time, avg_cycle_time)
- Manual counter entry via desktop UI
- Machine status updates via desktop UI
- Alarm/event logging and display
- Real-time machine status dashboard
- Machine utilization calculation
- Counter snapshots per shift/WO
- Integration patterns preparation (OPC-UA/Modbus/MQTT data models)

**Out of scope:**
- Actual OPC-UA protocol implementation (Phase 3)
- Modbus/TCP integration (Phase 3)
- MQTT broker connection (Phase 3)
- PLC direct connection (Phase 3)
- IoT sensor integration (Phase 3)
- Scanner-based counter entry (later story)
- Predictive maintenance alerts (Phase 3)
- Energy consumption monitoring (Phase 3)

## Dependencies

| Story | Requirement | Status |
|-------|-------------|--------|
| 01.10 | Machines CRUD | Required - provides machines table |
| 04.9b | Downtime Tracking | Optional - auto-downtime on alarm |
| 04.9a | OEE Calculation | Optional - feeds counter data to OEE |

## Acceptance Criteria (Given/When/Then)

### Machine Status Monitoring (FR-PROD-020)

#### Status Values
- GIVEN machine exists, WHEN status queried, THEN status is one of: IDLE, RUNNING, STOPPED, DOWN, CHANGEOVER.
- GIVEN machine status is IDLE, WHEN WO assigned and started, THEN machine status auto-changes to RUNNING.
- GIVEN machine status is RUNNING, WHEN WO completes, THEN machine status changes to IDLE.
- GIVEN machine status changes to DOWN, WHEN downtime tracking enabled (04.9b), THEN auto-create downtime_logs entry.

#### Manual Status Update
- GIVEN operator views machine on dashboard, WHEN clicks "Update Status", THEN status selection modal displays.
- GIVEN operator selects new status, WHEN confirmed, THEN status updates within 500ms.
- GIVEN status updated, WHEN recorded, THEN timestamp and user_id captured for audit.
- GIVEN machine integration_type = "MANUAL", WHEN status viewed, THEN "Update Status" button visible.

#### Status Dashboard
- GIVEN production machines page, WHEN loaded, THEN all machines display with current status badges.
- GIVEN machine status = "DOWN", WHEN displayed, THEN red badge with "Down" label shown.
- GIVEN machine status = "RUNNING", WHEN displayed, THEN green badge with "Running" label shown.
- GIVEN machine status = "IDLE", WHEN displayed, THEN gray badge with "Idle" label shown.
- GIVEN machine status = "CHANGEOVER", WHEN displayed, THEN yellow badge with "Changeover" label shown.
- GIVEN machine status = "STOPPED", WHEN displayed, THEN orange badge with "Stopped" label shown.

### Production Counters

#### Counter Values
- GIVEN machine has cycle_counter = 1000 at shift start, WHEN shift ends with cycle_counter = 1500, THEN cycles_this_shift = 500.
- GIVEN machine good_counter = 490 AND reject_counter = 10, WHEN quality rate calculated, THEN rate = 98.0% (490/500).
- GIVEN counter updated, WHEN recorded, THEN timestamp captured for trend analysis.

#### Manual Counter Entry
- GIVEN operator views machine detail, WHEN clicks "Update Counters", THEN counter entry form displays.
- GIVEN counter form displayed, WHEN rendered, THEN fields show: cycle_counter, good_counter, reject_counter, cycle_time_seconds.
- GIVEN operator enters good_counter = 500, reject_counter = 10, WHEN saved, THEN counters updated with timestamp.
- GIVEN operator enters negative counter value, WHEN submitting, THEN validation error "Counter must be positive" displays.
- GIVEN counter entry saved, WHEN audit queried, THEN entry includes user_id, timestamp, previous values, new values.

#### Counter Snapshots
- GIVEN machine assigned to WO, WHEN WO starts, THEN counter snapshot created with wo_id and start values.
- GIVEN WO completes, WHEN completion recorded, THEN counter snapshot updated with end values.
- GIVEN shift ends, WHEN shift_id provided, THEN counter snapshot created for shift totals.
- GIVEN counter snapshots exist, WHEN queried by WO, THEN units_produced = end_good_counter - start_good_counter.

#### Counter Validation
- GIVEN new cycle_counter < previous cycle_counter, WHEN submitted, THEN warning "Counter decreased - verify reset?" displays.
- GIVEN counter reset confirmed, WHEN saved, THEN reset flag set on counter_entry record.
- GIVEN good_counter + reject_counter != cycle_counter, WHEN submitted, THEN warning "Counts don't match cycle counter" displays.

### Cycle Time Tracking

#### Cycle Time Recording
- GIVEN machine completes cycle, WHEN cycle time recorded, THEN last_cycle_time_seconds updated.
- GIVEN multiple cycles recorded, WHEN avg_cycle_time calculated, THEN average of last 100 cycles returned.
- GIVEN product has ideal_cycle_time = 10 seconds, WHEN actual avg_cycle_time = 12 seconds, THEN performance efficiency = 83.3%.
- GIVEN cycle time data available, WHEN trend chart rendered, THEN shows cycle time variation over time.

#### Manual Cycle Time Entry
- GIVEN operator on counter entry form, WHEN cycle_time_seconds field visible, THEN accepts positive integer.
- GIVEN cycle_time_seconds = 0, WHEN submitted, THEN validation error "Cycle time must be greater than 0" displays.
- GIVEN cycle_time_seconds entered, WHEN saved, THEN value recorded with timestamp for trending.

### Alarm/Event Integration

#### Alarm Logging
- GIVEN machine alarm occurs, WHEN logged, THEN alarm_events entry created with machine_id, alarm_code, timestamp.
- GIVEN alarm_active = true, WHEN dashboard loaded, THEN alarm indicator displays on machine card.
- GIVEN alarm cleared, WHEN alarm_active = false, THEN alarm indicator removed from machine card.
- GIVEN alarm logged with severity = "CRITICAL", WHEN displayed, THEN red flashing indicator shown.
- GIVEN alarm logged with severity = "WARNING", WHEN displayed, THEN yellow indicator shown.

#### Alarm History
- GIVEN user views machine detail, WHEN alarms tab clicked, THEN alarm history table displays.
- GIVEN alarm history displayed, WHEN rendered, THEN columns show: Timestamp, Code, Description, Severity, Duration.
- GIVEN alarm with duration, WHEN calculated, THEN duration = cleared_at - triggered_at.
- GIVEN alarm filter by date range, WHEN applied, THEN only alarms in range displayed.

#### Manual Alarm Entry
- GIVEN operator on machine detail, WHEN clicks "Log Alarm", THEN alarm entry form displays.
- GIVEN alarm form, WHEN rendered, THEN fields show: alarm_code, description, severity (dropdown).
- GIVEN alarm submitted, WHEN saved, THEN alarm_active = true until explicitly cleared.
- GIVEN operator clicks "Clear Alarm" on active alarm, WHEN confirmed, THEN alarm_active = false, cleared_at = now.

### Real-Time Machine Dashboard

#### Dashboard Layout
- GIVEN user navigates to /production/machines, WHEN page loads, THEN machine status grid displays within 500ms.
- GIVEN machine dashboard displayed, WHEN rendered, THEN each machine card shows: Name, Status badge, Current WO, Counters summary.
- GIVEN multiple machines, WHEN displayed, THEN machines sorted by: Down first, then Running, then Idle.
- GIVEN dashboard auto-refresh enabled, WHEN interval elapsed, THEN machine statuses refresh without page reload.

#### Machine Card Details
- GIVEN machine card displayed, WHEN rendered, THEN shows: current_wo (if any), good/reject counts, last_cycle_time.
- GIVEN machine has active alarm, WHEN card displayed, THEN alarm icon with tooltip shows alarm_code.
- GIVEN machine is DOWN, WHEN card displayed, THEN downtime duration counter shows (live updating).
- GIVEN machine card clicked, WHEN detail modal opens, THEN full counter history and status history displayed.

#### Dashboard Filters
- GIVEN machine dashboard displayed, WHEN filter by status = "DOWN", THEN only DOWN machines displayed.
- GIVEN machine dashboard displayed, WHEN filter by line applied, THEN only machines on that line displayed.
- GIVEN search input, WHEN machine code/name entered, THEN matching machines filtered within 200ms.

### Machine Utilization

#### Utilization Calculation
- GIVEN machine operating_time = 420 min AND shift_duration = 480 min, WHEN utilization calculated, THEN utilization = 87.5%.
- GIVEN machine status history for shift, WHEN aggregated, THEN operating_time = total RUNNING + CHANGEOVER time.
- GIVEN utilization calculated, WHEN displayed, THEN percentage shown with color coding (green >= 80%, yellow 50-80%, red < 50%).

#### Utilization Chart
- GIVEN machine detail view, WHEN utilization section displayed, THEN hourly utilization bar chart rendered.
- GIVEN 8-hour shift, WHEN chart rendered, THEN 8 bars displayed (one per hour).
- GIVEN utilization data, WHEN tooltip hovered, THEN shows: hour, operating_minutes, downtime_minutes, utilization %.

### Integration Patterns Preparation

#### Data Model for Future Integration
- GIVEN machine created, WHEN integration_type field set, THEN accepts: MANUAL, OPC_UA, MODBUS, MQTT, API.
- GIVEN integration_type = "OPC_UA", WHEN displayed, THEN "Configure OPC-UA" section shown (disabled in MVP).
- GIVEN integration_type = "MANUAL", WHEN displayed, THEN manual entry buttons shown.

#### Integration Configuration (Deferred)
- GIVEN OPC-UA integration (future), WHEN configured, THEN fields stored: server_url, node_ids, polling_interval.
- GIVEN Modbus integration (future), WHEN configured, THEN fields stored: host, port, register_addresses.
- GIVEN MQTT integration (future), WHEN configured, THEN fields stored: broker_url, topic_patterns, qos.

#### Manual Fallback
- GIVEN any integration_type, WHEN auto-sync fails, THEN manual entry always available as fallback.
- GIVEN integration error logged, WHEN displayed, THEN warning "Integration unavailable - manual entry enabled" shown.

### Multi-tenancy
- GIVEN User A from Org A, WHEN querying machines, THEN only Org A machines returned.
- GIVEN counter entry submitted, WHEN stored, THEN org_id from user context applied.
- GIVEN alarm logged, WHEN stored, THEN org_id from user context applied.

## Technical Specification

### Database Schema

#### machine_counters table (extends existing)

```sql
CREATE TABLE machine_counters (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  machine_id UUID NOT NULL REFERENCES machines(id) ON DELETE CASCADE,
  wo_id UUID REFERENCES work_orders(id) ON DELETE SET NULL,
  shift_id UUID REFERENCES shifts(id) ON DELETE SET NULL,

  -- Counter values
  cycle_counter INTEGER NOT NULL DEFAULT 0,
  good_counter INTEGER NOT NULL DEFAULT 0,
  reject_counter INTEGER NOT NULL DEFAULT 0,

  -- Cycle time
  cycle_time_seconds INTEGER,

  -- Status at time of reading
  status TEXT NOT NULL DEFAULT 'IDLE',

  -- Alarm state
  alarm_active BOOLEAN DEFAULT false,
  alarm_code VARCHAR(50),

  -- Metadata
  timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  is_reset BOOLEAN DEFAULT false,
  notes TEXT,

  -- Audit
  created_by UUID REFERENCES users(id),

  CONSTRAINT machine_counters_org_machine_idx UNIQUE (org_id, machine_id, timestamp)
);

-- Indexes for performance
CREATE INDEX idx_machine_counters_machine_id ON machine_counters(machine_id);
CREATE INDEX idx_machine_counters_wo_id ON machine_counters(wo_id);
CREATE INDEX idx_machine_counters_shift_id ON machine_counters(shift_id);
CREATE INDEX idx_machine_counters_timestamp ON machine_counters(timestamp);
CREATE INDEX idx_machine_counters_org_machine_time ON machine_counters(org_id, machine_id, timestamp DESC);
```

#### machine_status_history table

```sql
CREATE TABLE machine_status_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  machine_id UUID NOT NULL REFERENCES machines(id) ON DELETE CASCADE,
  wo_id UUID REFERENCES work_orders(id) ON DELETE SET NULL,

  -- Status transition
  previous_status TEXT,
  new_status TEXT NOT NULL,

  -- Duration tracking
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ,
  duration_minutes INTEGER,

  -- Metadata
  reason TEXT,
  notes TEXT,

  -- Audit
  changed_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_machine_status_history_machine_id ON machine_status_history(machine_id);
CREATE INDEX idx_machine_status_history_started_at ON machine_status_history(started_at);
CREATE INDEX idx_machine_status_history_org_machine ON machine_status_history(org_id, machine_id);
```

#### alarm_events table

```sql
CREATE TABLE alarm_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  machine_id UUID NOT NULL REFERENCES machines(id) ON DELETE CASCADE,
  wo_id UUID REFERENCES work_orders(id) ON DELETE SET NULL,

  -- Alarm identification
  alarm_code VARCHAR(50) NOT NULL,
  description TEXT,
  severity TEXT NOT NULL DEFAULT 'WARNING', -- 'INFO', 'WARNING', 'CRITICAL'

  -- Alarm lifecycle
  triggered_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  cleared_at TIMESTAMPTZ,
  duration_minutes INTEGER,
  is_active BOOLEAN DEFAULT true,

  -- Resolution
  resolution_notes TEXT,
  cleared_by UUID REFERENCES users(id),

  -- Audit
  logged_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_alarm_events_machine_id ON alarm_events(machine_id);
CREATE INDEX idx_alarm_events_triggered_at ON alarm_events(triggered_at);
CREATE INDEX idx_alarm_events_is_active ON alarm_events(is_active);
CREATE INDEX idx_alarm_events_org_machine ON alarm_events(org_id, machine_id);
```

#### counter_snapshots table

```sql
CREATE TABLE counter_snapshots (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  machine_id UUID NOT NULL REFERENCES machines(id) ON DELETE CASCADE,

  -- Context
  wo_id UUID REFERENCES work_orders(id) ON DELETE CASCADE,
  shift_id UUID REFERENCES shifts(id) ON DELETE SET NULL,
  snapshot_type TEXT NOT NULL, -- 'WO_START', 'WO_END', 'SHIFT_START', 'SHIFT_END'

  -- Counter values at snapshot
  cycle_counter INTEGER NOT NULL,
  good_counter INTEGER NOT NULL,
  reject_counter INTEGER NOT NULL,

  -- Calculated (for WO_END/SHIFT_END)
  cycles_produced INTEGER,
  good_produced INTEGER,
  rejects_produced INTEGER,

  -- Timestamp
  snapshot_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Audit
  created_by UUID REFERENCES users(id)
);

-- Indexes
CREATE INDEX idx_counter_snapshots_machine_id ON counter_snapshots(machine_id);
CREATE INDEX idx_counter_snapshots_wo_id ON counter_snapshots(wo_id);
CREATE INDEX idx_counter_snapshots_shift_id ON counter_snapshots(shift_id);
```

#### machines table extension

```sql
-- Add integration and status fields to existing machines table
ALTER TABLE machines ADD COLUMN IF NOT EXISTS
  integration_type TEXT DEFAULT 'MANUAL' CHECK (integration_type IN ('MANUAL', 'OPC_UA', 'MODBUS', 'MQTT', 'API'));

ALTER TABLE machines ADD COLUMN IF NOT EXISTS
  current_status TEXT DEFAULT 'IDLE' CHECK (current_status IN ('IDLE', 'RUNNING', 'STOPPED', 'DOWN', 'CHANGEOVER'));

ALTER TABLE machines ADD COLUMN IF NOT EXISTS
  current_wo_id UUID REFERENCES work_orders(id) ON DELETE SET NULL;

ALTER TABLE machines ADD COLUMN IF NOT EXISTS
  last_counter_update TIMESTAMPTZ;

ALTER TABLE machines ADD COLUMN IF NOT EXISTS
  last_status_change TIMESTAMPTZ;

-- Integration configuration (JSON for flexibility)
ALTER TABLE machines ADD COLUMN IF NOT EXISTS
  integration_config JSONB DEFAULT '{}';
```

### RLS Policies

```sql
-- machine_counters: Org-scoped access
CREATE POLICY "machine_counters_select" ON machine_counters
FOR SELECT TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

CREATE POLICY "machine_counters_insert" ON machine_counters
FOR INSERT TO authenticated
WITH CHECK (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- machine_status_history: Org-scoped access
CREATE POLICY "machine_status_history_select" ON machine_status_history
FOR SELECT TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

CREATE POLICY "machine_status_history_insert" ON machine_status_history
FOR INSERT TO authenticated
WITH CHECK (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- alarm_events: Org-scoped access with role-based write
CREATE POLICY "alarm_events_select" ON alarm_events
FOR SELECT TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

CREATE POLICY "alarm_events_insert" ON alarm_events
FOR INSERT TO authenticated
WITH CHECK (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

CREATE POLICY "alarm_events_update" ON alarm_events
FOR UPDATE TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- counter_snapshots: Org-scoped read-only for most, system insert
CREATE POLICY "counter_snapshots_select" ON counter_snapshots
FOR SELECT TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

CREATE POLICY "counter_snapshots_insert" ON counter_snapshots
FOR INSERT TO authenticated
WITH CHECK (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));
```

### API Endpoints

```
# Machine Status
GET    /api/production/machines/status                    - All machines with current status
GET    /api/production/machines/:id/status                - Single machine status
POST   /api/production/machines/:id/status                - Update machine status
GET    /api/production/machines/:id/status-history        - Status change history

# Machine Counters
GET    /api/production/machines/:id/counters              - Current counter values
POST   /api/production/machines/:id/counters              - Record counter entry
GET    /api/production/machines/:id/counters/history      - Counter history
GET    /api/production/machines/:id/counters/by-wo/:woId  - Counters for specific WO

# Counter Snapshots
POST   /api/production/machines/:id/counters/snapshot     - Create counter snapshot
GET    /api/production/machines/:id/counters/snapshots    - List snapshots

# Alarms
GET    /api/production/machines/:id/alarms                - Alarm history
GET    /api/production/machines/:id/alarms/active         - Active alarms
POST   /api/production/machines/:id/alarms                - Log alarm
PUT    /api/production/machines/:id/alarms/:alarmId/clear - Clear alarm

# Utilization
GET    /api/production/machines/:id/utilization           - Utilization metrics
GET    /api/production/machines/:id/utilization/hourly    - Hourly breakdown

# Dashboard
GET    /api/production/machines/dashboard                 - Dashboard data (all machines)
```

### Service Methods

**Location:** `lib/services/machine-integration-service.ts`

```typescript
interface MachineIntegrationService {
  // Status Management
  getMachineStatus(machineId: string): Promise<MachineStatus>;
  updateMachineStatus(machineId: string, status: MachineStatusType, reason?: string): Promise<void>;
  getStatusHistory(machineId: string, options?: StatusHistoryOptions): Promise<StatusHistoryEntry[]>;

  // Counter Management
  getCurrentCounters(machineId: string): Promise<MachineCounters>;
  recordCounters(machineId: string, counters: CounterEntry): Promise<MachineCounters>;
  getCounterHistory(machineId: string, options?: CounterHistoryOptions): Promise<CounterEntry[]>;
  getCountersByWO(machineId: string, woId: string): Promise<WOCounterSummary>;

  // Counter Snapshots
  createSnapshot(machineId: string, type: SnapshotType, contextId?: string): Promise<CounterSnapshot>;
  getSnapshots(machineId: string, options?: SnapshotOptions): Promise<CounterSnapshot[]>;
  calculateProduction(startSnapshot: CounterSnapshot, endSnapshot: CounterSnapshot): ProductionSummary;

  // Alarm Management
  logAlarm(machineId: string, alarm: AlarmEntry): Promise<AlarmEvent>;
  clearAlarm(alarmId: string, notes?: string): Promise<void>;
  getActiveAlarms(machineId: string): Promise<AlarmEvent[]>;
  getAlarmHistory(machineId: string, options?: AlarmHistoryOptions): Promise<AlarmEvent[]>;

  // Utilization
  calculateUtilization(machineId: string, period: TimePeriod): Promise<UtilizationMetrics>;
  getHourlyUtilization(machineId: string, date: Date): Promise<HourlyUtilization[]>;

  // Dashboard
  getMachinesDashboard(): Promise<MachineDashboardData[]>;

  // Helpers
  validateCounterTransition(previous: MachineCounters, current: CounterEntry): CounterValidation;
  calculateQualityRate(good: number, reject: number): number;
  calculateCycleTimeAverage(machineId: string, count?: number): Promise<number>;
}

interface MachineStatus {
  machine_id: string;
  current_status: MachineStatusType;
  current_wo_id?: string;
  current_wo_number?: string;
  last_status_change: string;
  last_counter_update?: string;
  has_active_alarm: boolean;
  active_alarm_code?: string;
}

type MachineStatusType = 'IDLE' | 'RUNNING' | 'STOPPED' | 'DOWN' | 'CHANGEOVER';

interface MachineCounters {
  machine_id: string;
  cycle_counter: number;
  good_counter: number;
  reject_counter: number;
  cycle_time_seconds?: number;
  quality_rate: number;
  timestamp: string;
}

interface CounterEntry {
  cycle_counter: number;
  good_counter: number;
  reject_counter: number;
  cycle_time_seconds?: number;
  wo_id?: string;
  shift_id?: string;
  is_reset?: boolean;
  notes?: string;
}

interface AlarmEntry {
  alarm_code: string;
  description?: string;
  severity: 'INFO' | 'WARNING' | 'CRITICAL';
  wo_id?: string;
}

interface AlarmEvent extends AlarmEntry {
  id: string;
  machine_id: string;
  triggered_at: string;
  cleared_at?: string;
  duration_minutes?: number;
  is_active: boolean;
  resolution_notes?: string;
}

interface UtilizationMetrics {
  machine_id: string;
  period_start: string;
  period_end: string;
  total_minutes: number;
  operating_minutes: number;
  idle_minutes: number;
  down_minutes: number;
  changeover_minutes: number;
  utilization_percent: number;
}

interface MachineDashboardData {
  id: string;
  code: string;
  name: string;
  type: string;
  current_status: MachineStatusType;
  current_wo_id?: string;
  current_wo_number?: string;
  counters: {
    cycle_counter: number;
    good_counter: number;
    reject_counter: number;
    quality_rate: number;
  };
  last_cycle_time_seconds?: number;
  has_active_alarm: boolean;
  active_alarm?: {
    code: string;
    severity: string;
    triggered_at: string;
  };
  downtime_duration_minutes?: number;
}
```

### Zod Validation Schemas

**Location:** `lib/validation/machine-integration.ts`

```typescript
import { z } from 'zod';

// Status types
export const machineStatusTypeSchema = z.enum([
  'IDLE',
  'RUNNING',
  'STOPPED',
  'DOWN',
  'CHANGEOVER'
]);

export const integrationTypeSchema = z.enum([
  'MANUAL',
  'OPC_UA',
  'MODBUS',
  'MQTT',
  'API'
]);

export const alarmSeveritySchema = z.enum([
  'INFO',
  'WARNING',
  'CRITICAL'
]);

export const snapshotTypeSchema = z.enum([
  'WO_START',
  'WO_END',
  'SHIFT_START',
  'SHIFT_END'
]);

// Update status request
export const updateMachineStatusSchema = z.object({
  status: machineStatusTypeSchema,
  reason: z.string().max(500).optional(),
  wo_id: z.string().uuid().optional(),
});

// Counter entry request
export const counterEntrySchema = z.object({
  cycle_counter: z.number().int().min(0, 'Counter must be positive'),
  good_counter: z.number().int().min(0, 'Counter must be positive'),
  reject_counter: z.number().int().min(0, 'Counter must be positive'),
  cycle_time_seconds: z.number().int().min(1, 'Cycle time must be greater than 0').optional(),
  wo_id: z.string().uuid().optional(),
  shift_id: z.string().uuid().optional(),
  is_reset: z.boolean().default(false),
  notes: z.string().max(500).optional(),
});

// Alarm entry request
export const alarmEntrySchema = z.object({
  alarm_code: z.string()
    .min(1, 'Alarm code is required')
    .max(50, 'Alarm code must be 50 characters or less'),
  description: z.string().max(500).optional(),
  severity: alarmSeveritySchema.default('WARNING'),
  wo_id: z.string().uuid().optional(),
});

// Clear alarm request
export const clearAlarmSchema = z.object({
  resolution_notes: z.string().max(500).optional(),
});

// Counter snapshot request
export const createSnapshotSchema = z.object({
  snapshot_type: snapshotTypeSchema,
  wo_id: z.string().uuid().optional(),
  shift_id: z.string().uuid().optional(),
});

// Query params
export const counterHistoryParamsSchema = z.object({
  start_date: z.string().datetime().optional(),
  end_date: z.string().datetime().optional(),
  wo_id: z.string().uuid().optional(),
  shift_id: z.string().uuid().optional(),
  limit: z.number().int().min(1).max(1000).default(100),
});

export const alarmHistoryParamsSchema = z.object({
  start_date: z.string().datetime().optional(),
  end_date: z.string().datetime().optional(),
  severity: alarmSeveritySchema.optional(),
  is_active: z.boolean().optional(),
  limit: z.number().int().min(1).max(1000).default(100),
});

export const statusHistoryParamsSchema = z.object({
  start_date: z.string().datetime().optional(),
  end_date: z.string().datetime().optional(),
  status: machineStatusTypeSchema.optional(),
  limit: z.number().int().min(1).max(1000).default(100),
});

// Type exports
export type MachineStatusType = z.infer<typeof machineStatusTypeSchema>;
export type IntegrationType = z.infer<typeof integrationTypeSchema>;
export type AlarmSeverity = z.infer<typeof alarmSeveritySchema>;
export type SnapshotType = z.infer<typeof snapshotTypeSchema>;
export type UpdateMachineStatusInput = z.infer<typeof updateMachineStatusSchema>;
export type CounterEntryInput = z.infer<typeof counterEntrySchema>;
export type AlarmEntryInput = z.infer<typeof alarmEntrySchema>;
export type ClearAlarmInput = z.infer<typeof clearAlarmSchema>;
export type CreateSnapshotInput = z.infer<typeof createSnapshotSchema>;
```

## UI Components

### Pages

- `app/(authenticated)/production/machines/page.tsx` - Machine status dashboard
- `app/(authenticated)/production/machines/[id]/page.tsx` - Machine detail view

### Components

**Location:** `components/production/machines/`

```
MachineStatusDashboard.tsx     - Grid of machine cards with status
MachineStatusCard.tsx          - Individual machine status card
MachineStatusBadge.tsx         - Status badge with color coding
MachineDetailView.tsx          - Full machine detail with tabs
CounterEntryForm.tsx           - Form for manual counter entry
CounterHistoryTable.tsx        - Counter reading history
StatusUpdateModal.tsx          - Modal for status change
AlarmLogForm.tsx               - Form for manual alarm entry
AlarmClearModal.tsx            - Modal to clear alarm with notes
AlarmHistoryTable.tsx          - Alarm event history table
ActiveAlarmIndicator.tsx       - Alarm indicator on machine card
UtilizationChart.tsx           - Hourly utilization bar chart
CycleTimeChart.tsx             - Cycle time trend chart
QualityRateDisplay.tsx         - Quality rate gauge/display
MachineFilters.tsx             - Filter controls (status, line, search)
DowntimeDurationCounter.tsx    - Live downtime counter display
```

### Component Details

**MachineStatusDashboard.tsx**
```tsx
interface MachineStatusDashboardProps {
  machines: MachineDashboardData[];
  onStatusUpdate: (machineId: string, status: MachineStatusType) => void;
  onViewDetail: (machineId: string) => void;
  isLoading: boolean;
  autoRefresh: boolean;
  refreshInterval: number;
}
// Grid layout with cards, sortable by status (DOWN first)
// Auto-refresh support
// Filter/search bar
```

**MachineStatusCard.tsx**
```tsx
interface MachineStatusCardProps {
  machine: MachineDashboardData;
  onStatusUpdate: (status: MachineStatusType) => void;
  onViewDetail: () => void;
}
// Card showing: name, status badge, WO, counters summary
// Active alarm indicator with tooltip
// Live downtime counter when DOWN
// Quick actions: Update Status, View Details
```

**MachineStatusBadge.tsx**
```tsx
const STATUS_CONFIG: Record<MachineStatusType, { label: string; color: string; icon: Icon }> = {
  IDLE: { label: 'Idle', color: 'gray', icon: PauseIcon },
  RUNNING: { label: 'Running', color: 'green', icon: PlayIcon },
  STOPPED: { label: 'Stopped', color: 'orange', icon: StopIcon },
  DOWN: { label: 'Down', color: 'red', icon: AlertTriangleIcon },
  CHANGEOVER: { label: 'Changeover', color: 'yellow', icon: RefreshCwIcon },
};
```

**CounterEntryForm.tsx**
```tsx
interface CounterEntryFormProps {
  machineId: string;
  currentCounters?: MachineCounters;
  onSubmit: (data: CounterEntryInput) => void;
  onCancel: () => void;
  isLoading: boolean;
}
// Fields: cycle_counter, good_counter, reject_counter, cycle_time_seconds
// Validation warnings for counter decreases
// Show previous values for reference
// Reset checkbox with confirmation
```

**UtilizationChart.tsx**
```tsx
interface UtilizationChartProps {
  machineId: string;
  date: Date;
  data: HourlyUtilization[];
}
// Bar chart with 8-24 bars (configurable)
// Color coding: green (running), yellow (changeover), red (down), gray (idle)
// Tooltip with breakdown
```

### UI Patterns

**Machine Status Card Layout:**
```
+------------------------------------------+
| [Status Badge] MIX-001                   |
| Primary Mixer                            |
+------------------------------------------+
| WO: WO-2025-001 (Running)               |
| Good: 490  Reject: 10  (98.0%)          |
| Cycle Time: 12s                          |
+------------------------------------------+
| [ALARM] ERR-001: Temperature High        |
+------------------------------------------+
| [Update Status] [View Details]           |
+------------------------------------------+
```

**Counter Entry Form:**
```
+------------------------------------------+
| Update Counters - MIX-001                |
+------------------------------------------+
| Previous Values:                         |
| Cycle: 1000  Good: 980  Reject: 20      |
+------------------------------------------+
| New Values:                              |
| Cycle Counter: [_________]               |
| Good Counter:  [_________]               |
| Reject Counter:[_________]               |
| Cycle Time (s):[_________]               |
|                                          |
| [ ] Counter Reset                        |
| Notes: [______________________]          |
+------------------------------------------+
| [Cancel]                    [Save]       |
+------------------------------------------+
```

## Test Cases

### Unit Tests

**machine-integration-service.test.ts**
```typescript
describe('MachineIntegrationService', () => {
  describe('updateMachineStatus', () => {
    it('updates status and creates history entry');
    it('auto-sets DOWN status when alarm with CRITICAL severity logged');
    it('calculates duration when status changes');
    it('links to WO when provided');
  });

  describe('recordCounters', () => {
    it('saves counter entry with timestamp');
    it('calculates quality rate correctly');
    it('warns when counter decreases without reset flag');
    it('validates good + reject <= cycle_counter');
  });

  describe('createSnapshot', () => {
    it('creates WO_START snapshot with current counters');
    it('calculates production on WO_END snapshot');
    it('creates SHIFT_START/END snapshots');
  });

  describe('logAlarm', () => {
    it('creates alarm event with is_active = true');
    it('links to WO when provided');
    it('creates downtime entry when downtime tracking enabled');
  });

  describe('clearAlarm', () => {
    it('sets is_active = false and cleared_at');
    it('calculates duration_minutes');
    it('stores resolution_notes');
  });

  describe('calculateUtilization', () => {
    it('calculates correct utilization percentage');
    it('aggregates status durations correctly');
    it('handles multi-day periods');
  });

  describe('validateCounterTransition', () => {
    it('returns valid for increasing counters');
    it('returns warning for decreasing counters');
    it('returns valid for reset with flag');
    it('returns warning for mismatched totals');
  });
});
```

### Integration Tests

**machine-integration-api.test.ts**
```typescript
describe('Machine Integration API', () => {
  describe('POST /machines/:id/status', () => {
    it('updates machine status successfully');
    it('creates status history entry');
    it('returns 404 for unknown machine');
    it('returns 400 for invalid status');
  });

  describe('POST /machines/:id/counters', () => {
    it('records counter entry successfully');
    it('calculates quality rate in response');
    it('validates counter values');
    it('returns warning for counter decrease');
  });

  describe('POST /machines/:id/alarms', () => {
    it('creates alarm event successfully');
    it('sets machine alarm_active flag');
    it('returns 400 for missing alarm_code');
  });

  describe('PUT /machines/:id/alarms/:alarmId/clear', () => {
    it('clears alarm successfully');
    it('calculates duration');
    it('returns 404 for unknown alarm');
  });

  describe('GET /machines/dashboard', () => {
    it('returns all machines with status');
    it('includes active alarm info');
    it('respects org isolation');
  });

  describe('GET /machines/:id/utilization', () => {
    it('returns utilization metrics');
    it('calculates from status history');
    it('respects date range params');
  });
});
```

### E2E Tests

**machine-integration.spec.ts**
```typescript
describe('Machine Integration', () => {
  it('displays machine status dashboard');
  it('shows correct status badges for each state');
  it('updates machine status via modal');
  it('records counter entry via form');
  it('displays counter history');
  it('logs alarm and shows indicator');
  it('clears alarm with notes');
  it('displays alarm history');
  it('shows utilization chart');
  it('filters machines by status');
  it('searches machines by code/name');
  it('auto-refreshes dashboard');
  it('shows live downtime counter for DOWN machines');
});
```

## Security Considerations

1. **Counter Validation**
   - Prevent negative values
   - Warn on unexpected decreases
   - Audit all counter changes with user_id

2. **Status Changes**
   - Log all status transitions
   - Require reason for DOWN status
   - Track who made changes

3. **Alarm Management**
   - Only logged_by user or admin can clear
   - Audit alarm lifecycle
   - Critical alarms require acknowledgment

4. **Multi-tenancy**
   - RLS on all tables
   - org_id validated on all writes
   - No cross-org machine access

## Deliverables

- [ ] `machine_counters` table migration
- [ ] `machine_status_history` table migration
- [ ] `alarm_events` table migration
- [ ] `counter_snapshots` table migration
- [ ] `machines` table extension migration
- [ ] RLS policies for all new tables
- [ ] Machine integration service (`lib/services/machine-integration-service.ts`)
- [ ] Zod schemas (`lib/validation/machine-integration.ts`)
- [ ] API routes for status management
- [ ] API routes for counter management
- [ ] API routes for alarm management
- [ ] API routes for utilization
- [ ] MachineStatusDashboard component
- [ ] MachineStatusCard component
- [ ] MachineStatusBadge component
- [ ] CounterEntryForm component
- [ ] StatusUpdateModal component
- [ ] AlarmLogForm component
- [ ] AlarmClearModal component
- [ ] AlarmHistoryTable component
- [ ] UtilizationChart component
- [ ] Machine dashboard page
- [ ] Machine detail page
- [ ] Unit tests (>85% coverage)
- [ ] Integration tests
- [ ] E2E tests

## Definition of Done

- [ ] Machine status updated via UI within 500ms
- [ ] Status history tracked with user, timestamp, duration
- [ ] Counter entry form validates positive values
- [ ] Counter decrease warning displayed when applicable
- [ ] Counter snapshots created on WO start/end
- [ ] Quality rate calculated correctly (good / total)
- [ ] Alarms logged with code, severity, timestamp
- [ ] Active alarm indicator displays on machine card
- [ ] Alarm cleared with notes and duration calculated
- [ ] Utilization chart displays hourly breakdown
- [ ] Dashboard auto-refreshes at configured interval
- [ ] DOWN machines show live downtime counter
- [ ] Filters work for status, line, search
- [ ] RLS prevents cross-org access
- [ ] All status changes logged with user_id
- [ ] Integration_type field supports future patterns
- [ ] Unit test coverage >= 85%
- [ ] Integration tests pass
- [ ] E2E tests pass

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2026-01-14 | Initial story creation | ARCHITECT-AGENT |
