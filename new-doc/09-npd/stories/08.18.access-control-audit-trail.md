# 08.18 - Access Control & Audit Trail

**Priority**: P1 (High - Security & Compliance)
**Story Points**: M (Medium)
**Type**: backend
**Phase**: 3 (Enterprise Features)
**Model**: SONNET

**State**: ready
**Estimate**: M (3-5 days)
**Primary PRD**: `docs/1-BASELINE/product/modules/npd.md` (FR-NPD-63, 64, 65, 66, 67, 68, 69)
**Architecture**: `docs/1-BASELINE/architecture/modules/npd.md`
**Security**: `docs/1-BASELINE/architecture/security/rls-policies.md`
**Dependencies**: 08.2, 08.4, 08.7, 08.8, 01.1

---

## Goal

Implement granular RLS (Row-Level Security) policies for NPD module based on role-based access control (NPD_LEAD, R&D, REGULATORY, FINANCE, PRODUCTION, ADMIN) and comprehensive audit trail logging to track all formulation changes, gate transitions, and approvals for compliance, traceability, and security.

---

## Food Safety Compliance

This story is **critical for compliance and security**:

- [x] **FDA 21 CFR Part 11** - Audit trail provides electronic signature compliance
- [x] **HACCP Compliance** - Change tracking ensures formulation integrity
- [x] **ISO 9001** - Audit trail required for quality management documentation
- [x] **Data Security** - RLS policies prevent unauthorized access to sensitive formulations
- [x] **Traceability** - Full change history from formulation to production

**Regulatory Context:**
- FDA requires audit trails for all product formulation changes
- HACCP plans demand documented approval trails
- ISO 9001 clause 7.5 requires document control and traceability
- Intellectual property protection requires access control on formulations
- Audit logs support internal/external audits and compliance investigations

---

## MVP Scope

This story implements Phase 3 (Enterprise Features) security and compliance. RLS policies enforce role-based access control at the database level, while audit trails provide complete traceability for regulatory submissions and internal audits.

**MVP Includes**:
- RLS policies per NPD role (6 roles: NPD_LEAD, R&D, REGULATORY, FINANCE, PRODUCTION, ADMIN)
- Role-based CRUD permissions on NPD tables
- Audit trail table (npd_audit_log) - immutable
- Audit log for formulation changes (what changed, old/new values)
- Audit log for gate transitions (gate advance, approval, rejection)
- Audit log for approvals/rejections (costing, compliance)
- GET /api/npd/audit-trail (filter by project, user, date, event_type)
- Automatic audit logging via database triggers (preferred) or service layer

**Deferred to Phase 4+**:
- Real-time audit log streaming (WebSockets)
- Audit log export to external SIEM systems
- Granular field-level permissions (column-level RLS)
- Time-based access control (e.g., read-only after 90 days)

---

## User Story

As a **System Admin**, I want to **enforce role-based access control on NPD data** so that **users only access data appropriate to their role (R&D can't see Finance costing, Production can't edit formulations)**.

As a **Quality Director**, I want to **view complete audit trail of formulation changes** so that **I can verify compliance and trace product development history for regulatory submissions**.

As a **Regulatory Specialist**, I want to **audit who uploaded compliance documents** so that **I can ensure document authenticity and accountability**.

---

## Scope

**In scope (this story)**
- RLS policies for 6 NPD roles: NPD_LEAD, R&D, REGULATORY, FINANCE, PRODUCTION, ADMIN
- Role permissions matrix (CRUD per table per role)
- npd_audit_log table (immutable, append-only)
- Audit log events:
  - Formulation created/updated/deleted
  - Formulation item added/removed/changed
  - Gate advanced/approved/rejected
  - Costing submitted/approved/rejected
  - Compliance doc uploaded/deleted
  - Project status changed
- Audit log captures: who, when, what changed, old/new values
- GET /api/npd/audit-trail (filter by project_id, user_id, event_type, date_from, date_to)
- Database triggers for automatic audit logging

**Out of scope (this story)**
- Real-time audit streaming (Phase 4)
- SIEM integration (Phase 4)
- Column-level RLS (Phase 4)
- Audit log retention policies (Phase 4)
- Audit log tamper detection (Phase 4)

---

## Dependencies

### Cross-Epic Dependencies

| Dependency | Story/Epic | Type | What It Provides | Status |
|------------|------------|------|------------------|--------|
| 01.1 | Org Context + RLS | HARD | organizations, users, user_roles tables | Ready |

### Within Epic Dependencies

| Dependency | Story | Type | What It Provides |
|------------|-------|------|------------------|
| 08.2 | NPD Projects CRUD | HARD | npd_projects table |
| 08.4 | Formulations CRUD | HARD | npd_formulations table |
| 08.7 | Formulation Costing | HARD | npd_costing table |
| 08.8 | Compliance Documents | HARD | npd_compliance_documents table |

### Provides To (Downstream)

| Story | What This Provides |
|-------|-------------------|
| All NPD stories | RLS policies enforce access control across all NPD features |
| 08.16 | Audit trail data for compliance reports |

---

## Database Migration

```sql
-- Migration: YYYYMMDDHHMMSS_create_npd_audit_trail.sql

-- =============================================================================
-- Audit Trail Table (Immutable, Append-Only)
-- =============================================================================

CREATE TABLE npd_audit_log (
    id SERIAL PRIMARY KEY,
    org_id UUID NOT NULL REFERENCES organizations(id),
    user_id UUID NOT NULL REFERENCES auth.users(id),
    event_type VARCHAR(50) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,  -- npd_project, npd_formulation, npd_costing, etc.
    entity_id INTEGER NOT NULL,
    entity_name VARCHAR(200),          -- Project name, formulation number, etc. (for readability)
    action VARCHAR(20) NOT NULL        -- INSERT, UPDATE, DELETE
        CHECK (action IN ('INSERT', 'UPDATE', 'DELETE')),
    old_values JSONB,                  -- Old values (for UPDATE)
    new_values JSONB,                  -- New values (for INSERT/UPDATE)
    changed_fields TEXT[],             -- Array of changed field names (for UPDATE)
    ip_address INET,                   -- User IP address
    user_agent TEXT,                   -- User agent string
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes for audit trail queries
CREATE INDEX idx_npd_audit_log_org_created ON npd_audit_log(org_id, created_at DESC);
CREATE INDEX idx_npd_audit_log_user ON npd_audit_log(user_id);
CREATE INDEX idx_npd_audit_log_entity ON npd_audit_log(entity_type, entity_id);
CREATE INDEX idx_npd_audit_log_event_type ON npd_audit_log(event_type);

-- Prevent updates/deletes on audit log (immutable)
CREATE RULE npd_audit_log_no_update AS
    ON UPDATE TO npd_audit_log
    DO INSTEAD NOTHING;

CREATE RULE npd_audit_log_no_delete AS
    ON DELETE TO npd_audit_log
    DO INSTEAD NOTHING;

-- =============================================================================
-- RLS Policies for Audit Log
-- =============================================================================

ALTER TABLE npd_audit_log ENABLE ROW LEVEL SECURITY;

-- Admins and Quality Directors can view all audit logs
CREATE POLICY "audit_log_admin_select" ON npd_audit_log
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND EXISTS (
            SELECT 1 FROM user_roles
            WHERE user_id = auth.uid()
            AND role IN ('ADMIN', 'QUALITY_DIRECTOR')
        )
    );

-- Users can view their own audit log entries
CREATE POLICY "audit_log_user_select" ON npd_audit_log
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND user_id = auth.uid()
    );

-- System can insert audit logs (via triggers or service layer)
CREATE POLICY "audit_log_system_insert" ON npd_audit_log
    FOR INSERT WITH CHECK (true);

-- =============================================================================
-- RLS Policies for NPD Tables (Role-Based Access Control)
-- =============================================================================

-- npd_projects: NPD_LEAD full access, R&D read assigned, FINANCE read all, PRODUCTION read launched
ALTER TABLE npd_projects ENABLE ROW LEVEL SECURITY;

CREATE POLICY "npd_projects_npd_lead_all" ON npd_projects
    FOR ALL USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND (
            owner_id = auth.uid()  -- Project owner (NPD Lead)
            OR EXISTS (
                SELECT 1 FROM user_roles
                WHERE user_id = auth.uid()
                AND role IN ('ADMIN', 'NPD_LEAD')
            )
        )
    );

CREATE POLICY "npd_projects_rd_select" ON npd_projects
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND EXISTS (
            SELECT 1 FROM user_roles
            WHERE user_id = auth.uid()
            AND role = 'R&D'
        )
        -- R&D can view projects with assigned formulations (via npd_formulations.assigned_to)
        AND EXISTS (
            SELECT 1 FROM npd_formulations f
            WHERE f.project_id = npd_projects.id
            AND f.assigned_to = auth.uid()
        )
    );

CREATE POLICY "npd_projects_finance_select" ON npd_projects
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND EXISTS (
            SELECT 1 FROM user_roles
            WHERE user_id = auth.uid()
            AND role = 'FINANCE'
        )
    );

CREATE POLICY "npd_projects_production_select" ON npd_projects
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND status = 'launched'
        AND EXISTS (
            SELECT 1 FROM user_roles
            WHERE user_id = auth.uid()
            AND role IN ('PRODUCTION_MANAGER', 'PRODUCTION_OPERATOR')
        )
    );

-- npd_formulations: NPD_LEAD full access, R&D edit assigned, others read-only
ALTER TABLE npd_formulations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "npd_formulations_npd_lead_all" ON npd_formulations
    FOR ALL USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND EXISTS (
            SELECT 1 FROM npd_projects p
            WHERE p.id = npd_formulations.project_id
            AND (p.owner_id = auth.uid() OR EXISTS (
                SELECT 1 FROM user_roles
                WHERE user_id = auth.uid()
                AND role IN ('ADMIN', 'NPD_LEAD')
            ))
        )
    );

CREATE POLICY "npd_formulations_rd_assigned" ON npd_formulations
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND assigned_to = auth.uid()
        AND EXISTS (
            SELECT 1 FROM user_roles
            WHERE user_id = auth.uid()
            AND role = 'R&D'
        )
    );

CREATE POLICY "npd_formulations_rd_update" ON npd_formulations
    FOR UPDATE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND assigned_to = auth.uid()
        AND status NOT IN ('locked', 'approved')  -- Cannot edit locked formulations
        AND EXISTS (
            SELECT 1 FROM user_roles
            WHERE user_id = auth.uid()
            AND role = 'R&D'
        )
    );

-- npd_costing: Finance can view/approve, NPD_LEAD can edit draft
ALTER TABLE npd_costing ENABLE ROW LEVEL SECURITY;

CREATE POLICY "npd_costing_npd_lead_all" ON npd_costing
    FOR ALL USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND EXISTS (
            SELECT 1 FROM npd_formulations f
            JOIN npd_projects p ON f.project_id = p.id
            WHERE f.id = npd_costing.formulation_id
            AND (p.owner_id = auth.uid() OR EXISTS (
                SELECT 1 FROM user_roles
                WHERE user_id = auth.uid()
                AND role IN ('ADMIN', 'NPD_LEAD')
            ))
        )
    );

CREATE POLICY "npd_costing_finance_select" ON npd_costing
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND EXISTS (
            SELECT 1 FROM user_roles
            WHERE user_id = auth.uid()
            AND role = 'FINANCE'
        )
    );

CREATE POLICY "npd_costing_finance_update" ON npd_costing
    FOR UPDATE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND status = 'submitted'
        AND EXISTS (
            SELECT 1 FROM user_roles
            WHERE user_id = auth.uid()
            AND role = 'FINANCE'
        )
    );

-- npd_compliance_documents: REGULATORY can upload/delete, others read-only
ALTER TABLE npd_compliance_documents ENABLE ROW LEVEL SECURITY;

CREATE POLICY "npd_compliance_docs_all_select" ON npd_compliance_documents
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "npd_compliance_docs_regulatory_all" ON npd_compliance_documents
    FOR ALL USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND EXISTS (
            SELECT 1 FROM user_roles
            WHERE user_id = auth.uid()
            AND role IN ('REGULATORY', 'ADMIN')
        )
    );

-- =============================================================================
-- Audit Triggers (Automatic Logging)
-- =============================================================================

-- Generic audit trigger function
CREATE OR REPLACE FUNCTION npd_audit_trigger_func()
RETURNS TRIGGER AS $$
DECLARE
    v_old_values JSONB;
    v_new_values JSONB;
    v_changed_fields TEXT[];
    v_entity_name TEXT;
    v_user_id UUID;
BEGIN
    -- Get current user ID
    v_user_id := auth.uid();

    -- Skip if no user (system operations)
    IF v_user_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- Determine entity name based on table
    IF TG_TABLE_NAME = 'npd_projects' THEN
        v_entity_name := COALESCE(NEW.name, OLD.name);
    ELSIF TG_TABLE_NAME = 'npd_formulations' THEN
        v_entity_name := COALESCE(NEW.formulation_number, OLD.formulation_number);
    ELSIF TG_TABLE_NAME = 'npd_costing' THEN
        v_entity_name := 'Costing #' || COALESCE(NEW.id, OLD.id)::TEXT;
    ELSIF TG_TABLE_NAME = 'npd_compliance_documents' THEN
        v_entity_name := COALESCE(NEW.filename, OLD.filename);
    END IF;

    -- Build old/new values and changed fields
    IF TG_OP = 'DELETE' THEN
        v_old_values := row_to_json(OLD)::JSONB;
        v_new_values := NULL;
        v_changed_fields := NULL;
    ELSIF TG_OP = 'UPDATE' THEN
        v_old_values := row_to_json(OLD)::JSONB;
        v_new_values := row_to_json(NEW)::JSONB;

        -- Find changed fields
        SELECT ARRAY_AGG(key)
        INTO v_changed_fields
        FROM jsonb_each(v_old_values) AS old_kv
        WHERE v_old_values->old_kv.key IS DISTINCT FROM v_new_values->old_kv.key;

    ELSIF TG_OP = 'INSERT' THEN
        v_old_values := NULL;
        v_new_values := row_to_json(NEW)::JSONB;
        v_changed_fields := NULL;
    END IF;

    -- Insert audit log entry
    INSERT INTO npd_audit_log (
        org_id,
        user_id,
        event_type,
        entity_type,
        entity_id,
        entity_name,
        action,
        old_values,
        new_values,
        changed_fields
    ) VALUES (
        COALESCE(NEW.org_id, OLD.org_id),
        v_user_id,
        'NPD.' || TG_TABLE_NAME || '.' || TG_OP,
        TG_TABLE_NAME,
        COALESCE(NEW.id, OLD.id),
        v_entity_name,
        TG_OP,
        v_old_values,
        v_new_values,
        v_changed_fields
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply trigger to NPD tables
CREATE TRIGGER npd_projects_audit_trigger
    AFTER INSERT OR UPDATE OR DELETE ON npd_projects
    FOR EACH ROW EXECUTE FUNCTION npd_audit_trigger_func();

CREATE TRIGGER npd_formulations_audit_trigger
    AFTER INSERT OR UPDATE OR DELETE ON npd_formulations
    FOR EACH ROW EXECUTE FUNCTION npd_audit_trigger_func();

CREATE TRIGGER npd_formulation_items_audit_trigger
    AFTER INSERT OR UPDATE OR DELETE ON npd_formulation_items
    FOR EACH ROW EXECUTE FUNCTION npd_audit_trigger_func();

CREATE TRIGGER npd_costing_audit_trigger
    AFTER INSERT OR UPDATE OR DELETE ON npd_costing
    FOR EACH ROW EXECUTE FUNCTION npd_audit_trigger_func();

CREATE TRIGGER npd_compliance_documents_audit_trigger
    AFTER INSERT OR UPDATE OR DELETE ON npd_compliance_documents
    FOR EACH ROW EXECUTE FUNCTION npd_audit_trigger_func();

CREATE TRIGGER npd_gate_checklists_audit_trigger
    AFTER INSERT OR UPDATE OR DELETE ON npd_gate_checklists
    FOR EACH ROW EXECUTE FUNCTION npd_audit_trigger_func();
```

---

## Acceptance Criteria (Given/When/Then)

### AC-1: RLS Policy - NPD_LEAD Role

```gherkin
Scenario: NPD_LEAD can CRUD own projects
  Given User A with NPD_LEAD role
  And User A owns project NPD-001
  When User A queries npd_projects
  Then User A sees NPD-001
  And User A can update NPD-001
  And User A can delete NPD-001

Scenario: NPD_LEAD can CRUD all formulations in own projects
  Given User A owns project NPD-001
  And formulation F1 belongs to NPD-001
  When User A queries npd_formulations
  Then User A sees F1
  And User A can update F1
  And User A can delete F1
```

### AC-2: RLS Policy - R&D Role

```gherkin
Scenario: R&D can view assigned formulations only
  Given User B with R&D role
  And formulation F1 assigned_to = User B
  And formulation F2 assigned_to = User C (different user)
  When User B queries npd_formulations
  Then User B sees F1
  And User B does NOT see F2

Scenario: R&D can edit assigned formulations (if not locked)
  Given formulation F1 assigned to User B
  And F1.status = 'draft' (not locked)
  When User B updates F1
  Then update succeeds

Scenario: R&D cannot edit locked formulations
  Given formulation F1 assigned to User B
  And F1.status = 'locked'
  When User B attempts to update F1
  Then error 403 "Cannot edit locked formulation"
  And RLS policy blocks update

Scenario: R&D can view parent project of assigned formulation
  Given formulation F1 assigned to User B
  And F1 belongs to project NPD-001
  When User B queries npd_projects with id = NPD-001
  Then User B sees NPD-001 (read-only)
```

### AC-3: RLS Policy - REGULATORY Role

```gherkin
Scenario: REGULATORY can upload compliance documents
  Given User C with REGULATORY role
  And project NPD-001 exists
  When User C uploads compliance doc to NPD-001
  Then upload succeeds
  And document visible to all users

Scenario: REGULATORY can delete compliance documents
  Given User C uploaded doc D1
  When User C deletes D1
  Then delete succeeds

Scenario: REGULATORY cannot edit formulations
  Given formulation F1 exists
  When User C (REGULATORY) attempts to update F1
  Then error 403 "REGULATORY role cannot edit formulations"
```

### AC-4: RLS Policy - FINANCE Role

```gherkin
Scenario: FINANCE can view all projects (read-only)
  Given User D with FINANCE role
  And 10 NPD projects exist
  When User D queries npd_projects
  Then User D sees all 10 projects
  And User D can read project details

Scenario: FINANCE can view all costing
  Given User D with FINANCE role
  And 5 costing records exist (various statuses)
  When User D queries npd_costing
  Then User D sees all 5 costing records

Scenario: FINANCE can approve submitted costing
  Given costing C1 with status = 'submitted'
  When User D (FINANCE) updates C1 to status = 'approved'
  Then update succeeds

Scenario: FINANCE cannot approve draft costing
  Given costing C1 with status = 'draft'
  When User D (FINANCE) attempts to update C1
  Then error 403 "Cannot approve draft costing"
  And RLS policy blocks update

Scenario: FINANCE cannot edit formulations
  Given formulation F1 exists
  When User D (FINANCE) attempts to update F1
  Then error 403 "FINANCE role cannot edit formulations"
```

### AC-5: RLS Policy - PRODUCTION Role

```gherkin
Scenario: PRODUCTION can view launched projects only
  Given User E with PRODUCTION_MANAGER role
  And project NPD-001 with status = 'launched'
  And project NPD-002 with status = 'development'
  When User E queries npd_projects
  Then User E sees NPD-001
  And User E does NOT see NPD-002

Scenario: PRODUCTION cannot edit NPD projects
  Given project NPD-001 with status = 'launched'
  When User E (PRODUCTION) attempts to update NPD-001
  Then error 403 "PRODUCTION role has read-only access"
```

### AC-6: RLS Policy - ADMIN Role

```gherkin
Scenario: ADMIN can view all NPD data
  Given User F with ADMIN role
  And 10 NPD projects exist
  When User F queries npd_projects
  Then User F sees all 10 projects

Scenario: ADMIN can CRUD all NPD data
  Given User F with ADMIN role
  And project NPD-001 exists
  When User F updates NPD-001
  Then update succeeds
  When User F deletes NPD-001
  Then delete succeeds
```

### AC-7: Audit Log - Formulation Changes

```gherkin
Scenario: Audit log captures formulation create
  Given User A creates formulation F1
  When formulation created
  Then npd_audit_log entry created:
    | org_id | User A org |
    | user_id | User A ID |
    | event_type | NPD.npd_formulations.INSERT |
    | entity_type | npd_formulations |
    | entity_id | F1 ID |
    | entity_name | F1 formulation_number |
    | action | INSERT |
    | old_values | NULL |
    | new_values | { formulation_number: "v1.0", ... } |
    | changed_fields | NULL |
    | created_at | NOW() |

Scenario: Audit log captures formulation update
  Given formulation F1 exists with target_cost = $10.00
  When User A updates F1.target_cost = $12.00
  Then npd_audit_log entry created:
    | event_type | NPD.npd_formulations.UPDATE |
    | action | UPDATE |
    | old_values | { target_cost: 10.00, ... } |
    | new_values | { target_cost: 12.00, ... } |
    | changed_fields | ["target_cost"] |

Scenario: Audit log captures formulation item change
  Given formulation F1 has item I1 (ingredient: Sugar, qty: 100g)
  When User A changes I1.qty = 150g
  Then npd_audit_log entry created for npd_formulation_items:
    | entity_type | npd_formulation_items |
    | old_values | { quantity: 100 } |
    | new_values | { quantity: 150 } |
    | changed_fields | ["quantity"] |
```

### AC-8: Audit Log - Gate Transitions

```gherkin
Scenario: Audit log captures gate advance
  Given project NPD-001 at gate G2
  When User A advances gate to G3
  Then npd_audit_log entry created:
    | event_type | NPD.npd_projects.UPDATE |
    | old_values | { current_gate: "G2", status: "feasibility" } |
    | new_values | { current_gate: "G3", status: "development" } |
    | changed_fields | ["current_gate", "status"] |
```

### AC-9: Audit Log - Approvals/Rejections

```gherkin
Scenario: Audit log captures costing approval
  Given costing C1 with status = 'submitted'
  When Finance approves C1
  Then npd_audit_log entry created:
    | event_type | NPD.npd_costing.UPDATE |
    | old_values | { status: "submitted", approved_by_id: null } |
    | new_values | { status: "approved", approved_by_id: "user-finance-123" } |
    | changed_fields | ["status", "approved_by_id", "approved_at"] |

Scenario: Audit log captures costing rejection
  Given costing C1 with status = 'submitted'
  When Finance rejects C1 with reason "Cost too high"
  Then npd_audit_log entry created:
    | old_values | { status: "submitted", rejected_by_id: null } |
    | new_values | { status: "rejected", rejected_by_id: "user-finance-123", rejection_reason: "Cost too high" } |
    | changed_fields | ["status", "rejected_by_id", "rejected_at", "rejection_reason"] |
```

### AC-10: Audit Log - Compliance Document Upload

```gherkin
Scenario: Audit log captures document upload
  Given User C (REGULATORY) uploads HACCP document
  When document uploaded
  Then npd_audit_log entry created:
    | event_type | NPD.npd_compliance_documents.INSERT |
    | entity_name | "HACCP-NPD-001.pdf" |
    | new_values | { filename: "HACCP-NPD-001.pdf", type: "HACCP", ... } |

Scenario: Audit log captures document deletion
  Given document D1 exists
  When User C deletes D1
  Then npd_audit_log entry created:
    | action | DELETE |
    | old_values | { filename: "HACCP-NPD-001.pdf", ... } |
    | new_values | NULL |
```

### AC-11: Audit Trail API

```gherkin
Scenario: Admin queries audit trail for project
  Given ADMIN user
  And 10 audit log entries for project NPD-001
  When GET /api/npd/audit-trail?project_id=123
  Then response 200 with:
    {
      "audit_logs": [
        {
          "id": 1,
          "user": { "id": "user-123", "name": "Jane Doe" },
          "event_type": "NPD.npd_formulations.UPDATE",
          "entity_type": "npd_formulations",
          "entity_name": "v2.0",
          "action": "UPDATE",
          "changed_fields": ["target_cost"],
          "old_values": { "target_cost": 10.00 },
          "new_values": { "target_cost": 12.00 },
          "created_at": "2025-01-15T14:30:00Z"
        },
        ...
      ],
      "pagination": { "total": 10, "page": 1, "limit": 20 }
    }

Scenario: Filter audit trail by user
  Given 5 audit entries by User A, 3 by User B
  When GET /api/npd/audit-trail?user_id=user-a-123
  Then only User A entries returned (5 entries)

Scenario: Filter audit trail by event type
  Given 3 INSERT events, 5 UPDATE events, 2 DELETE events
  When GET /api/npd/audit-trail?event_type=UPDATE
  Then only UPDATE events returned (5 entries)

Scenario: Filter audit trail by date range
  Given entries from Jan 1-15
  When GET /api/npd/audit-trail?date_from=2025-01-10&date_to=2025-01-12
  Then only entries from Jan 10-12 returned
```

### AC-12: Audit Trail Immutability

```gherkin
Scenario: Audit log entries cannot be updated
  Given audit log entry E1
  When attempting UPDATE on E1
  Then error "Audit log is immutable"
  And database rule prevents update

Scenario: Audit log entries cannot be deleted
  Given audit log entry E1
  When attempting DELETE on E1
  Then error "Audit log is immutable"
  And database rule prevents delete
```

### AC-13: Performance Requirements

```gherkin
Scenario: Audit trigger performance
  Given formulation update operation
  When update executes
  Then audit trigger completes < 50ms
  And does not block main transaction

Scenario: Audit trail query performance
  Given 10,000 audit log entries
  When GET /api/npd/audit-trail with filters
  Then response time < 500ms
  And pagination limits result set
```

---

## Implementation Notes

### API Endpoints

```typescript
// =============================================================================
// Audit Trail Endpoints
// =============================================================================

// GET /api/npd/audit-trail
interface AuditTrailRequest {
  project_id?: number;
  user_id?: string;
  event_type?: string;
  entity_type?: string;
  action?: 'INSERT' | 'UPDATE' | 'DELETE';
  date_from?: string; // ISO date
  date_to?: string;   // ISO date
  page?: number;
  limit?: number;
}

interface AuditTrailResponse {
  audit_logs: Array<{
    id: number;
    user: { id: string; name: string; email: string };
    event_type: string;
    entity_type: string;
    entity_id: number;
    entity_name: string;
    action: 'INSERT' | 'UPDATE' | 'DELETE';
    old_values?: Record<string, any>;
    new_values?: Record<string, any>;
    changed_fields?: string[];
    created_at: string;
  }>;
  pagination: {
    total: number;
    page: number;
    limit: number;
    pages: number;
  };
}
```

### Service Layer

```typescript
// lib/services/npd-audit-service.ts

export class NPDAuditService {
  /**
   * Get audit trail with filters
   */
  static async getAuditTrail(
    orgId: string,
    filters: AuditTrailFilters,
    page: number = 1,
    limit: number = 20
  ): Promise<PaginatedResult<AuditLogEntry>> {
    const {
      project_id,
      user_id,
      event_type,
      entity_type,
      action,
      date_from,
      date_to,
    } = filters;

    let query = `
      SELECT
        al.id,
        al.user_id,
        u.name AS user_name,
        u.email AS user_email,
        al.event_type,
        al.entity_type,
        al.entity_id,
        al.entity_name,
        al.action,
        al.old_values,
        al.new_values,
        al.changed_fields,
        al.created_at
      FROM npd_audit_log al
      LEFT JOIN users u ON al.user_id = u.id
      WHERE al.org_id = $1
    `;

    const values: any[] = [orgId];
    let paramIndex = 2;

    if (project_id) {
      // Join to find entries related to project
      query += ` AND (
        (al.entity_type = 'npd_projects' AND al.entity_id = $${paramIndex})
        OR (al.entity_type = 'npd_formulations' AND al.entity_id IN (
          SELECT id FROM npd_formulations WHERE project_id = $${paramIndex}
        ))
      )`;
      values.push(project_id);
      paramIndex++;
    }

    if (user_id) {
      query += ` AND al.user_id = $${paramIndex++}`;
      values.push(user_id);
    }

    if (event_type) {
      query += ` AND al.event_type = $${paramIndex++}`;
      values.push(event_type);
    }

    if (entity_type) {
      query += ` AND al.entity_type = $${paramIndex++}`;
      values.push(entity_type);
    }

    if (action) {
      query += ` AND al.action = $${paramIndex++}`;
      values.push(action);
    }

    if (date_from) {
      query += ` AND al.created_at >= $${paramIndex++}`;
      values.push(date_from);
    }

    if (date_to) {
      query += ` AND al.created_at <= $${paramIndex++}`;
      values.push(date_to);
    }

    query += ` ORDER BY al.created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
    values.push(limit, (page - 1) * limit);

    const result = await db.query(query, values);

    // Get total count
    const countResult = await db.query(
      `SELECT COUNT(*) FROM npd_audit_log al WHERE al.org_id = $1 ${/* ... same filters ... */}`,
      values.slice(0, values.length - 2) // Exclude LIMIT/OFFSET
    );

    return {
      data: result.rows.map(row => ({
        id: row.id,
        user: {
          id: row.user_id,
          name: row.user_name,
          email: row.user_email,
        },
        event_type: row.event_type,
        entity_type: row.entity_type,
        entity_id: row.entity_id,
        entity_name: row.entity_name,
        action: row.action,
        old_values: row.old_values,
        new_values: row.new_values,
        changed_fields: row.changed_fields,
        created_at: row.created_at,
      })),
      pagination: {
        total: parseInt(countResult.rows[0].count, 10),
        page,
        limit,
        pages: Math.ceil(parseInt(countResult.rows[0].count, 10) / limit),
      },
    };
  }

  /**
   * Get audit trail for specific entity
   */
  static async getEntityAuditTrail(
    entityType: string,
    entityId: number
  ): Promise<AuditLogEntry[]> {
    const result = await db.query(
      `SELECT
        al.*,
        u.name AS user_name,
        u.email AS user_email
       FROM npd_audit_log al
       LEFT JOIN users u ON al.user_id = u.id
       WHERE al.entity_type = $1
       AND al.entity_id = $2
       ORDER BY al.created_at DESC`,
      [entityType, entityId]
    );

    return result.rows;
  }
}
```

### Frontend Components

```
components/npd/audit/
  AuditTrailTable.tsx           -- Audit trail table with filters
  AuditTrailFilters.tsx         -- Filter controls
  AuditLogEntryModal.tsx        -- Modal to view full old/new values
  AuditLogEntryRow.tsx          -- Table row component
  AuditTrailExportButton.tsx    -- CSV export of audit trail
```

---

## Key Business Rules

1. **Immutable Audit Log**: Audit log entries cannot be updated or deleted (enforced by database rules)
2. **Automatic Logging**: All CUD operations on NPD tables automatically logged via triggers
3. **Role-Based Access**: RLS policies enforce role-based permissions at database level
4. **Org Isolation**: All RLS policies enforce org_id match
5. **Changed Fields Tracking**: UPDATE operations log array of changed field names
6. **Old/New Values**: Full JSON snapshots of old/new row values captured
7. **Admin-Only Audit Access**: Only ADMIN and QUALITY_DIRECTOR roles can view full audit trail
8. **User Self-Audit**: Users can view their own audit log entries
9. **Locked Formulations**: R&D cannot edit formulations with status = 'locked' or 'approved'
10. **Production Read-Only**: PRODUCTION role can only view launched projects (read-only)

---

## Deliverables

### Database
- [ ] Migration: npd_audit_log table with immutability rules
- [ ] Migration: RLS policies for all NPD tables (6 roles)
- [ ] Migration: Audit triggers on NPD tables
- [ ] Indexes for audit log queries

### API Routes
- [ ] `GET /api/npd/audit-trail` - Query audit trail with filters

### Service Layer
- [ ] `NPDAuditService.getAuditTrail()` - Fetch audit logs with filters
- [ ] `NPDAuditService.getEntityAuditTrail()` - Fetch entity-specific audit logs

### Frontend
- [ ] Audit trail page: `/npd/audit-trail`
- [ ] Audit trail table with filters
- [ ] Audit log entry modal (view old/new values)
- [ ] Export audit trail to CSV

### Tests
- [ ] Unit tests: NPDAuditService methods (>80% coverage)
- [ ] Integration tests: RLS policies enforce access control
- [ ] Integration tests: Audit triggers log all CUD operations
- [ ] E2E: Full audit trail query workflow
- [ ] Performance tests: Audit trigger <50ms, audit query <500ms

---

## Definition of Done

### Database
- [ ] npd_audit_log table created with immutability rules
- [ ] RLS policies created for all NPD tables
- [ ] Audit triggers created and tested
- [ ] Indexes optimize audit queries

### API
- [ ] Audit trail endpoint returns correct data
- [ ] Filters work correctly (project, user, event_type, date)
- [ ] Pagination works
- [ ] Response time <500ms

### Service
- [ ] Audit trail fetched with all filters
- [ ] Entity-specific audit trail works
- [ ] Old/new values captured correctly

### RLS
- [ ] NPD_LEAD can CRUD own projects
- [ ] R&D can view/edit assigned formulations only
- [ ] REGULATORY can upload compliance docs only
- [ ] FINANCE can view all, approve costing only
- [ ] PRODUCTION can view launched projects only
- [ ] ADMIN can access all data

### Audit
- [ ] All CUD operations logged automatically
- [ ] Changed fields tracked correctly
- [ ] Audit log immutable (no updates/deletes)
- [ ] Trigger performance <50ms

### Testing
- [ ] Unit tests: >80% coverage
- [ ] Integration tests: All RLS policies verified
- [ ] Integration tests: All audit triggers verified
- [ ] E2E tests: Full audit workflow
- [ ] Performance tests: Response times verified

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Audit log storage growth | MEDIUM | HIGH | Implement retention policy (90 days), archive to S3 after 1 year |
| Trigger performance overhead | MEDIUM | LOW | Async audit logging (deferred constraint trigger), optimize JSONB |
| RLS policy complexity | HIGH | MEDIUM | Comprehensive integration tests, manual QA verification |
| Audit log tampering | HIGH | LOW | Database immutability rules, periodic integrity checks |
| Missing audit entries | HIGH | LOW | Trigger on all NPD tables, unit tests verify trigger execution |

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2026-01-15 | Initial story creation for Access Control & Audit Trail | ARCHITECT-AGENT |

---

**Document Status**: Ready for Implementation
**Created**: 2026-01-15
**Lines**: ~980
**Complexity**: M (Medium)
**Phase**: 3 (Enterprise Features)
