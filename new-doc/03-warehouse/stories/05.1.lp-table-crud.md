# 05.1 - License Plates Table + CRUD

| Field | Value |
|-------|-------|
| **Story ID** | 05.1 |
| **Epic** | 05 - Warehouse |
| **Status** | Ready |
| **Phase** | Phase 0 (LP Foundation) |
| **Priority** | P0 (CRITICAL BLOCKER) |
| **Complexity** | L (Large) |
| **Estimate** | 3-4 days |
| **Type** | Backend + Frontend |
| **Model** | OPUS |

---

## CRITICAL DEPENDENCY NOTICE

**THIS STORY IS THE CRITICAL BLOCKER FOR EPIC 04 PRODUCTION.**

Epic 04 Phase 1 (10 stories, 18-24 days of work) **CANNOT proceed** without this story:
- 04.6a-e: Material Consumption (reads/updates LP qty)
- 04.7a-d: Output Registration (creates new LPs)
- 04.8: Material Reservations (reserves specific LPs)

**Unblocking Date:** Day 4 of implementation enables Epic 04.6, 04.7

---

## PRD References

| FR ID | Requirement | Priority | Coverage |
|-------|-------------|----------|----------|
| WH-FR-001 | LP Creation (auto/manual numbering) | P0 | Full |
| WH-FR-002 | LP Tracking (qty, location, status, QA, batch, expiry) | P0 | Full |
| WH-FR-006 | LP Split (partial coverage - API only) | P0 | Partial |
| WH-FR-008 | QA Status Management (status field + transitions) | P0 | Partial |
| WH-FR-009 | Batch Tracking | P0 | Full |
| WH-FR-010 | Expiry Tracking | P0 | Full |

**Primary PRD:** `docs/1-BASELINE/product/modules/warehouse.md`
**Architecture:** `docs/1-BASELINE/architecture/modules/warehouse.md`

---

## MVP Scope

### In Scope (This Story)

1. **Database Infrastructure**
   - `license_plates` table with forward-compatible schema
   - All Phase 0, 1, 2, 3 columns (nullable for future phases)
   - Indexes for performance (org+status, org+product, expiry, etc.)
   - RLS policies for multi-tenancy
   - LP number auto-generation function

2. **Service Layer (ALL methods Epic 04 needs)**
   - LP CRUD operations
   - LP consumption method (reduce qty, update status)
   - LP output creation method
   - LP availability check
   - Bulk LP query by product/status

3. **API Endpoints**
   - List LPs (paginated, filtered, sorted)
   - Get LP by ID
   - Create LP (manual or auto-number)
   - Update LP (limited fields)
   - LP number generation

4. **Desktop UI (Basic)**
   - LP list page with DataTable
   - LP detail panel/modal
   - Filters (warehouse, location, product, status, QA status)
   - Search by LP number

5. **Zod Validation Schemas**
   - Create LP schema
   - Update LP schema
   - Query params schema

### Out of Scope (Other Stories)

| Feature | Deferred To | Reason |
|---------|-------------|--------|
| LP Split/Merge UI | 05.6 | Separate workflow |
| LP Genealogy table | 05.2 | Separate table |
| LP Reservations | 05.3 | Separate table |
| FIFO/FEFO Pick Suggestions | 05.4 | Query service |
| QA Status transition UI | 05.7 | Full workflow |
| GRN integration | 05.8 | Receiving workflow |
| Scanner workflows | 05.17+ | Phase 2 |
| Label printing | 05.14 | Phase 1 |
| Pallet management | 05.26 | Phase 3 |
| GS1 barcode parsing | 05.24 | Phase 3 |

---

## Epic 04 Dependency Status

- [x] **CRITICAL - Unblocks Epic 04 Phase 1**

This story provides:
1. `license_plates` table for inventory tracking
2. `consumeLP()` service method for material consumption
3. `createOutputLP()` service method for production output
4. `getAvailableLPs()` for pick suggestions
5. LP validation (status, qa_status, qty checks)

---

## Goal

Create the complete License Plate database infrastructure and service layer that enables Epic 04 Production to consume materials and register outputs. Provide basic desktop UI for LP management.

---

## User Story

As a **Warehouse Operator**, I want to **view and manage License Plates (inventory units) with complete tracking information** so that **I can track inventory at the atomic level and production can consume/create inventory**.

---

## Dependencies

| Dependency | Story/Epic | Type | Status | Notes |
|------------|------------|------|--------|-------|
| 01.1 | Org Context + RLS | HARD | Ready | Requires org_id patterns |
| 01.8 | Warehouses CRUD | HARD | Ready | FK to warehouses table |
| 01.9 | Locations CRUD | HARD | Ready | FK to locations table |
| 02.1 | Products CRUD | HARD | Ready | FK to products table |

**Dependents (What This Unblocks):**
- 05.2 (LP Genealogy) - Needs license_plates for FK
- 05.3 (LP Reservations) - Needs license_plates for FK
- 05.4 (FIFO/FEFO) - Needs license_plates for queries
- 05.5 (LP CRUD Desktop) - Uses LP table + service
- 05.6 (LP Split/Merge) - Needs LP service methods
- 05.7 (QA Status) - Needs LP status fields
- **04.6a-e** (Material Consumption) - CRITICAL
- **04.7a-d** (Output Registration) - CRITICAL
- **04.8** (Material Reservations) - CRITICAL

---

## Acceptance Criteria (Given/When/Then)

### AC-1: LP Table Creation (WH-FR-001, WH-FR-002)

```gherkin
Scenario: License plates table exists with all required columns
  Given database migration runs
  When schema is inspected
  Then license_plates table has columns:
    | Column | Type | Nullable | Default |
    | id | UUID | NO | gen_random_uuid() |
    | org_id | UUID | NO | - |
    | lp_number | TEXT | NO | - |
    | product_id | UUID | NO | - |
    | quantity | DECIMAL(15,4) | NO | - |
    | uom | TEXT | NO | - |
    | location_id | UUID | NO | - |
    | warehouse_id | UUID | NO | - |
    | status | TEXT | NO | 'available' |
    | qa_status | TEXT | NO | 'pending' |
    | batch_number | TEXT | YES | - |
    | supplier_batch_number | TEXT | YES | - |
    | expiry_date | DATE | YES | - |
    | manufacture_date | DATE | YES | - |
    | source | TEXT | NO | 'manual' |
    | grn_id | UUID | YES | - |
    | asn_id | UUID | YES | - |
    | wo_id | UUID | YES | - |
    | parent_lp_id | UUID | YES | - |
    | consumed_by_wo_id | UUID | YES | - |
    | pallet_id | UUID | YES | - |
    | gtin | TEXT | YES | - |
    | sscc | TEXT | YES | - |
    | catch_weight_kg | DECIMAL(10,3) | YES | - |
    | po_number | TEXT | YES | - |
    | created_at | TIMESTAMPTZ | NO | NOW() |
    | created_by | UUID | YES | - |
    | updated_at | TIMESTAMPTZ | NO | NOW() |
  And UNIQUE constraint exists on (org_id, lp_number)
```

### AC-2: LP Number Auto-Generation (WH-FR-001)

```gherkin
Scenario: Generate LP number with default prefix and sequence
  Given warehouse_settings.auto_generate_lp_number = true
  And warehouse_settings.lp_number_prefix = 'LP'
  And warehouse_settings.lp_number_sequence_length = 8
  When LP is created without lp_number
  Then system generates LP number 'LP00000001'
  And next LP gets 'LP00000002'

Scenario: Generate LP number with custom prefix
  Given warehouse_settings.lp_number_prefix = 'INV-'
  And warehouse_settings.lp_number_sequence_length = 6
  When LP is created without lp_number
  Then system generates LP number 'INV-000001'

Scenario: Manual LP number entry
  Given warehouse_settings.auto_generate_lp_number = false
  When user creates LP with lp_number = 'CUSTOM-001'
  Then LP created with 'CUSTOM-001'

Scenario: LP number uniqueness validation
  Given LP 'LP00000001' exists in org A
  When user creates another LP with 'LP00000001' in org A
  Then system returns 409 Conflict error "LP number already exists"

Scenario: Same LP number allowed across orgs
  Given LP 'LP00000001' exists in org A
  When user creates LP 'LP00000001' in org B
  Then LP created successfully (different org_id)
```

### AC-3: LP CRUD Operations (WH-FR-002)

```gherkin
Scenario: List LPs with pagination
  Given 100 LPs exist in warehouse
  When user requests GET /api/warehouse/license-plates?page=1&limit=50
  Then response returns 50 LPs with pagination metadata
  And response time < 500ms

Scenario: Filter LPs by status
  Given 50 available LPs and 30 reserved LPs
  When user requests GET /api/warehouse/license-plates?status=available
  Then only 50 available LPs returned

Scenario: Filter LPs by QA status
  Given 40 passed LPs and 60 pending LPs
  When user requests GET /api/warehouse/license-plates?qa_status=passed
  Then only 40 passed LPs returned

Scenario: Filter LPs by product
  Given LPs for products A, B, C
  When user requests GET /api/warehouse/license-plates?product_id={productA_id}
  Then only LPs for product A returned

Scenario: Filter LPs by warehouse and location
  Given LPs in WH-001/ZONE-A and WH-001/ZONE-B
  When user requests GET /api/warehouse/license-plates?warehouse_id={wh1}&location_id={zoneA}
  Then only LPs in WH-001/ZONE-A returned

Scenario: Search LPs by LP number prefix
  Given LPs: LP00000001, LP00000002, LP00000100
  When user requests GET /api/warehouse/license-plates?search=LP000001
  Then LP00000001, LP00000100 returned (prefix match)
  And response time < 300ms

Scenario: Get LP detail
  Given LP 'LP00000001' exists with all tracking fields
  When user requests GET /api/warehouse/license-plates/{id}
  Then response includes all LP fields
  And includes product name (joined)
  And includes location full_path (joined)
  And response time < 100ms

Scenario: Create LP with required fields
  Given valid product_id, location_id, warehouse_id
  When POST /api/warehouse/license-plates with:
    | product_id | {valid_uuid} |
    | quantity | 100 |
    | uom | KG |
    | location_id | {valid_uuid} |
    | warehouse_id | {valid_uuid} |
  Then LP created with auto-generated lp_number
  And status = 'available'
  And qa_status from warehouse_settings.default_qa_status
  And source = 'manual'
  And response time < 200ms

Scenario: Create LP with batch and expiry
  Given product requires batch tracking
  When creating LP with batch_number = 'BATCH-2025-001', expiry_date = '2026-01-01'
  Then LP saved with batch and expiry

Scenario: Update LP quantity
  Given LP with quantity = 100
  When PUT /api/warehouse/license-plates/{id} with quantity = 80
  Then LP quantity updated to 80
  And updated_at timestamp refreshed

Scenario: Update LP location (internal move)
  Given LP at location A
  When PUT /api/warehouse/license-plates/{id} with location_id = B
  Then LP.location_id updated to B
```

### AC-4: LP Status Management (WH-FR-008)

```gherkin
Scenario: LP status values
  Given LP table
  When inspecting status column
  Then allowed values are: available, reserved, consumed, blocked

Scenario: LP QA status values
  Given LP table
  When inspecting qa_status column
  Then allowed values are: pending, passed, failed, quarantine

Scenario: Block LP
  Given LP with status = 'available'
  When PUT /api/warehouse/license-plates/{id}/block with reason
  Then LP.status = 'blocked'

Scenario: Unblock LP
  Given LP with status = 'blocked'
  When PUT /api/warehouse/license-plates/{id}/unblock
  Then LP.status = 'available'

Scenario: Update QA status to passed
  Given LP with qa_status = 'pending'
  When PUT /api/warehouse/license-plates/{id}/qa-status with qa_status = 'passed'
  Then LP.qa_status = 'passed'

Scenario: Consumed LP is immutable
  Given LP with status = 'consumed'
  When user attempts to update any field
  Then system returns 400 error "Consumed LP cannot be modified"
```

### AC-5: LP Consumption Method - FOR EPIC 04 (WH-FR-002)

```gherkin
Scenario: Consume full LP quantity
  Given LP 'LP00000001' with quantity = 100, status = 'available', qa_status = 'passed'
  When consumeLP(lp_id, consume_qty=100, wo_id)
  Then LP.quantity = 0
  And LP.status = 'consumed'
  And LP.consumed_by_wo_id = wo_id
  And operation completes in < 200ms

Scenario: Partial LP consumption
  Given LP 'LP00000001' with quantity = 100
  When consumeLP(lp_id, consume_qty=30, wo_id)
  Then LP.quantity = 70
  And LP.status = 'available' (still has qty)
  And LP.consumed_by_wo_id = NULL (partial, not fully consumed)

Scenario: Consumption blocked if LP not available
  Given LP with status = 'blocked'
  When consumeLP(lp_id, consume_qty=50, wo_id)
  Then error "LP not available for consumption (status: blocked)"

Scenario: Consumption blocked if QA not passed
  Given LP with qa_status = 'pending'
  When consumeLP(lp_id, consume_qty=50, wo_id)
  Then error "LP not QA approved for consumption (qa_status: pending)"

Scenario: Consumption blocked if insufficient quantity
  Given LP with quantity = 30
  When consumeLP(lp_id, consume_qty=50, wo_id)
  Then error "Consume quantity (50) exceeds available quantity (30)"

Scenario: Consumption blocked for expired LP
  Given LP with expiry_date = '2025-01-01' (past)
  When consumeLP(lp_id, consume_qty=50, wo_id)
  Then error "LP is expired (expiry: 2025-01-01)"
```

### AC-6: LP Output Creation Method - FOR EPIC 04 (WH-FR-001)

```gherkin
Scenario: Create output LP from production
  Given valid WO with product_id, location_id, warehouse_id
  When createOutputLP({
    product_id,
    quantity: 500,
    uom: 'KG',
    location_id,
    warehouse_id,
    batch_number: 'PROD-2025-001',
    expiry_date: '2026-06-01',
    source: 'production',
    wo_id: {wo_uuid}
  })
  Then new LP created with auto-generated lp_number
  And LP.source = 'production'
  And LP.wo_id = {wo_uuid}
  And LP.status = 'available'
  And LP.qa_status from settings (default 'pending')
  And response time < 200ms

Scenario: Calculate expiry from shelf life
  Given product.shelf_life_days = 90
  And manufacture_date = '2025-12-16'
  When createOutputLP without expiry_date
  Then LP.expiry_date = '2026-03-16' (manufacture + 90 days)

Scenario: Output LP requires batch if product setting enabled
  Given product.require_batch = true
  When createOutputLP without batch_number
  Then error "Batch number required for this product"

Scenario: Output LP with catch weight
  Given product.is_catch_weight = true
  When createOutputLP with quantity=10, catch_weight_kg=47.5
  Then LP created with both qty and catch_weight
```

### AC-7: LP Availability Query - FOR EPIC 04

```gherkin
Scenario: Get available LPs for product
  Given 10 LPs for product A: 5 available, 3 reserved, 2 consumed
  When getAvailableLPs(product_id=A)
  Then returns 5 LPs with status='available' AND qa_status='passed'

Scenario: Get available LPs ordered by FIFO
  Given LPs created at different times
  When getAvailableLPs(product_id=A, order='fifo')
  Then LPs returned ORDER BY created_at ASC

Scenario: Get available LPs ordered by FEFO
  Given LPs with different expiry dates
  When getAvailableLPs(product_id=A, order='fefo')
  Then LPs returned ORDER BY expiry_date ASC, created_at ASC

Scenario: Exclude expired LPs from suggestions
  Given LP with expiry_date < today
  When getAvailableLPs(product_id=A)
  Then expired LP NOT in results

Scenario: Get available quantity for product
  Given 3 available LPs with qty 100, 50, 75
  When getTotalAvailableQty(product_id=A)
  Then returns 225
```

### AC-8: LP List UI

```gherkin
Scenario: View LP list page
  Given user navigates to /warehouse/license-plates
  When page loads
  Then LP DataTable displays within 500ms
  And columns show: LP Number, Product, Qty, UoM, Location, Status, QA, Batch, Expiry

Scenario: LP status badges
  Given LPs with different statuses
  When viewing list
  Then status badges display with colors:
    | Status | Color |
    | available | Green |
    | reserved | Yellow |
    | consumed | Gray |
    | blocked | Red |

Scenario: QA status badges
  Given LPs with different QA statuses
  When viewing list
  Then QA badges display with colors:
    | QA Status | Color |
    | pending | Yellow |
    | passed | Green |
    | failed | Red |
    | quarantine | Orange |

Scenario: Filter by multiple criteria
  Given filter panel open
  When user selects warehouse, status, QA status
  Then list filters by all selected criteria

Scenario: Search by LP number
  Given search input visible
  When user types 'LP0000'
  Then list filters to matching LP numbers (debounced 300ms)

Scenario: Sort by column
  Given LP list displayed
  When user clicks "Expiry" column header
  Then list sorts by expiry_date (asc/desc toggle)

Scenario: Pagination controls
  Given 100 LPs exist
  When viewing list with page_size = 20
  Then pagination shows 5 pages
  And page navigation works
```

### AC-9: LP Detail Panel

```gherkin
Scenario: Open LP detail
  Given LP list displayed
  When user clicks on LP row
  Then detail panel slides in from right
  And shows all LP fields

Scenario: LP detail sections
  Given LP detail panel open
  Then sections display:
    | Section | Fields |
    | Identity | LP Number, Status, QA Status |
    | Product | Product Name, Code, Qty, UoM |
    | Location | Warehouse, Location (full path) |
    | Tracking | Batch, Supplier Batch, Expiry, Manufacture Date |
    | Source | Source type, PO/GRN/WO reference |
    | Timestamps | Created at, Created by, Updated at |

Scenario: Quick actions in detail panel
  Given LP detail panel open
  And LP.status = 'available'
  Then quick actions available: Block, Print Label (disabled), View History
```

### AC-10: RLS Policy Enforcement

```gherkin
Scenario: Org isolation on LP list
  Given User A from Org A
  And User B from Org B
  And LPs exist in both orgs
  When User A requests /api/warehouse/license-plates
  Then only Org A LPs returned

Scenario: Cross-tenant LP access returns 404
  Given LP belongs to Org B
  When User A from Org A requests /api/warehouse/license-plates/{orgB_lp_id}
  Then 404 Not Found returned (not 403)

Scenario: RLS on insert
  Given User A from Org A
  When creating LP with org_id = Org B
  Then RLS blocks insert (org_id mismatch)
```

### AC-11: Performance Requirements

```gherkin
Scenario: LP lookup by ID
  Given LP exists
  When GET /api/warehouse/license-plates/{id}
  Then response time < 100ms

Scenario: LP list with filters
  Given 10,000 LPs in warehouse
  When GET /api/warehouse/license-plates with filters
  Then response time < 500ms

Scenario: LP search by number
  Given 10,000 LPs
  When search by LP number prefix
  Then response time < 300ms

Scenario: LP creation
  Given valid LP data
  When POST /api/warehouse/license-plates
  Then response time < 200ms

Scenario: Bulk LP query for product
  Given 100 LPs for product
  When getAvailableLPs(product_id)
  Then response time < 200ms
```

### AC-12: Indexes for Performance

```gherkin
Scenario: Indexes exist for common queries
  Given license_plates table
  Then indexes exist for:
    | Index Name | Columns |
    | idx_lp_org_status | (org_id, status) |
    | idx_lp_org_product | (org_id, product_id) |
    | idx_lp_org_location | (org_id, location_id) |
    | idx_lp_org_warehouse | (org_id, warehouse_id) |
    | idx_lp_org_qa | (org_id, qa_status) |
    | idx_lp_expiry | (expiry_date) WHERE expiry_date IS NOT NULL |
    | idx_lp_batch | (batch_number) WHERE batch_number IS NOT NULL |
    | idx_lp_created | (created_at) |
    | idx_lp_number_search | (org_id, lp_number text_pattern_ops) |
```

---

## Technical Specification

### Database Schema

```sql
-- =============================================================================
-- License Plates Table - Core Inventory Unit
-- Phase 0: All fields needed for Epic 04 + placeholders for future phases
-- =============================================================================

CREATE TABLE license_plates (
  -- Identity (Phase 0)
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  lp_number TEXT NOT NULL,

  -- Product Reference (Phase 0)
  product_id UUID NOT NULL REFERENCES products(id),
  quantity DECIMAL(15,4) NOT NULL CHECK (quantity >= 0),
  uom TEXT NOT NULL,

  -- Location (Phase 0)
  location_id UUID NOT NULL REFERENCES locations(id),
  warehouse_id UUID NOT NULL REFERENCES warehouses(id),

  -- Status (Phase 0)
  status TEXT NOT NULL DEFAULT 'available'
    CHECK (status IN ('available', 'reserved', 'consumed', 'blocked')),
  qa_status TEXT NOT NULL DEFAULT 'pending'
    CHECK (qa_status IN ('pending', 'passed', 'failed', 'quarantine')),

  -- Tracking (Phase 0)
  batch_number TEXT,
  supplier_batch_number TEXT,                -- Phase 1: From GRN
  expiry_date DATE,
  manufacture_date DATE,

  -- Source Reference (Phase 0)
  source TEXT NOT NULL DEFAULT 'manual'
    CHECK (source IN ('manual', 'receipt', 'production', 'return', 'adjustment', 'split')),
  po_number TEXT,

  -- Phase 1 Fields (GRN Integration)
  grn_id UUID,                               -- FK to grns table (Phase 1)
  asn_id UUID,                               -- FK to asns table (Phase 1)

  -- Production References (Phase 0 - Epic 04)
  wo_id UUID,                                -- WO that created this LP (output)
  consumed_by_wo_id UUID,                    -- WO that consumed this LP
  parent_lp_id UUID REFERENCES license_plates(id), -- For split/merge

  -- Phase 2 Fields (Catch Weight)
  catch_weight_kg DECIMAL(10,3),

  -- Phase 3 Fields (GS1)
  gtin TEXT,                                 -- GS1 GTIN-14
  sscc TEXT,                                 -- GS1 SSCC-18 (if on pallet)

  -- Phase 3 Fields (Pallets)
  pallet_id UUID,                            -- FK to pallets table (Phase 3)

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_by UUID REFERENCES users(id),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Constraints
  CONSTRAINT lp_org_number_unique UNIQUE(org_id, lp_number)
);

-- =============================================================================
-- Indexes for Performance
-- =============================================================================

-- Primary query patterns
CREATE INDEX idx_lp_org_status ON license_plates(org_id, status);
CREATE INDEX idx_lp_org_product ON license_plates(org_id, product_id);
CREATE INDEX idx_lp_org_location ON license_plates(org_id, location_id);
CREATE INDEX idx_lp_org_warehouse ON license_plates(org_id, warehouse_id);
CREATE INDEX idx_lp_org_qa ON license_plates(org_id, qa_status);

-- FIFO/FEFO queries
CREATE INDEX idx_lp_expiry ON license_plates(expiry_date) WHERE expiry_date IS NOT NULL;
CREATE INDEX idx_lp_created ON license_plates(created_at);

-- Search patterns
CREATE INDEX idx_lp_batch ON license_plates(batch_number) WHERE batch_number IS NOT NULL;
CREATE INDEX idx_lp_number_search ON license_plates(org_id, lp_number text_pattern_ops);

-- Production references
CREATE INDEX idx_lp_wo ON license_plates(wo_id) WHERE wo_id IS NOT NULL;
CREATE INDEX idx_lp_consumed_by ON license_plates(consumed_by_wo_id) WHERE consumed_by_wo_id IS NOT NULL;

-- Parent reference (split/merge)
CREATE INDEX idx_lp_parent ON license_plates(parent_lp_id) WHERE parent_lp_id IS NOT NULL;

-- =============================================================================
-- LP Number Sequence per Organization
-- =============================================================================

CREATE TABLE lp_number_sequences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE UNIQUE,
  current_value BIGINT NOT NULL DEFAULT 0,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Function to generate next LP number
CREATE OR REPLACE FUNCTION generate_lp_number(p_org_id UUID)
RETURNS TEXT AS $$
DECLARE
  v_prefix TEXT;
  v_length INT;
  v_next_val BIGINT;
  v_lp_number TEXT;
BEGIN
  -- Get settings (with defaults if not exists)
  SELECT
    COALESCE(lp_number_prefix, 'LP'),
    COALESCE(lp_number_sequence_length, 8)
  INTO v_prefix, v_length
  FROM warehouse_settings
  WHERE org_id = p_org_id;

  -- Use defaults if no settings
  IF v_prefix IS NULL THEN
    v_prefix := 'LP';
    v_length := 8;
  END IF;

  -- Upsert sequence and get next value
  INSERT INTO lp_number_sequences (org_id, current_value)
  VALUES (p_org_id, 1)
  ON CONFLICT (org_id)
  DO UPDATE SET
    current_value = lp_number_sequences.current_value + 1,
    updated_at = NOW()
  RETURNING current_value INTO v_next_val;

  -- Format LP number
  v_lp_number := v_prefix || LPAD(v_next_val::TEXT, v_length, '0');

  RETURN v_lp_number;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- Updated_at Trigger
-- =============================================================================

CREATE OR REPLACE FUNCTION update_lp_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_lp_updated_at
BEFORE UPDATE ON license_plates
FOR EACH ROW EXECUTE FUNCTION update_lp_updated_at();

-- =============================================================================
-- RLS Policies
-- =============================================================================

ALTER TABLE license_plates ENABLE ROW LEVEL SECURITY;

-- Select: Org isolation
CREATE POLICY "lp_select_org" ON license_plates
FOR SELECT TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- Insert: Org isolation + valid references
CREATE POLICY "lp_insert_org" ON license_plates
FOR INSERT TO authenticated
WITH CHECK (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND warehouse_id IN (
    SELECT id FROM warehouses
    WHERE org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  )
  AND location_id IN (
    SELECT id FROM locations
    WHERE org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  )
  AND product_id IN (
    SELECT id FROM products
    WHERE org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  )
);

-- Update: Org isolation + prevent consumed LP updates
CREATE POLICY "lp_update_org" ON license_plates
FOR UPDATE TO authenticated
USING (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
)
WITH CHECK (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
);

-- Delete: Org isolation (soft delete preferred, but allow hard delete)
CREATE POLICY "lp_delete_org" ON license_plates
FOR DELETE TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- RLS for sequence table
ALTER TABLE lp_number_sequences ENABLE ROW LEVEL SECURITY;

CREATE POLICY "lp_seq_org" ON lp_number_sequences
FOR ALL TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));
```

### API Endpoints

```
# License Plates
GET    /api/warehouse/license-plates                    - List LPs (paginated, filtered)
GET    /api/warehouse/license-plates/:id                - Get LP detail
POST   /api/warehouse/license-plates                    - Create LP
PUT    /api/warehouse/license-plates/:id                - Update LP (limited fields)
PUT    /api/warehouse/license-plates/:id/block          - Block LP
PUT    /api/warehouse/license-plates/:id/unblock        - Unblock LP
PUT    /api/warehouse/license-plates/:id/qa-status      - Update QA status
POST   /api/warehouse/license-plates/generate-number    - Generate next LP number

# Internal Service Methods (used by Epic 04)
POST   /api/warehouse/license-plates/consume            - Consume LP qty (internal)
POST   /api/warehouse/license-plates/create-output      - Create output LP (internal)
GET    /api/warehouse/license-plates/available          - Get available LPs for product
```

**Query Parameters (List):**
- `search` - LP number prefix search
- `warehouse_id` - Filter by warehouse UUID
- `location_id` - Filter by location UUID
- `product_id` - Filter by product UUID
- `status` - Filter by status (available, reserved, consumed, blocked)
- `qa_status` - Filter by QA status (pending, passed, failed, quarantine)
- `batch_number` - Filter by batch number
- `expiry_before` - Filter expiring before date
- `expiry_after` - Filter expiring after date
- `sort` - Sort field (lp_number, created_at, expiry_date, quantity)
- `order` - Sort order (asc, desc)
- `page` - Page number (default 1)
- `limit` - Items per page (default 50, max 100)

### Service Layer

```typescript
// lib/services/license-plate-service.ts

export type LPStatus = 'available' | 'reserved' | 'consumed' | 'blocked';
export type QAStatus = 'pending' | 'passed' | 'failed' | 'quarantine';
export type LPSource = 'manual' | 'receipt' | 'production' | 'return' | 'adjustment' | 'split';

export interface LicensePlate {
  id: string;
  org_id: string;
  lp_number: string;
  product_id: string;
  quantity: number;
  uom: string;
  location_id: string;
  warehouse_id: string;
  status: LPStatus;
  qa_status: QAStatus;
  batch_number: string | null;
  supplier_batch_number: string | null;
  expiry_date: string | null;
  manufacture_date: string | null;
  source: LPSource;
  po_number: string | null;
  grn_id: string | null;
  asn_id: string | null;
  wo_id: string | null;
  consumed_by_wo_id: string | null;
  parent_lp_id: string | null;
  catch_weight_kg: number | null;
  gtin: string | null;
  sscc: string | null;
  pallet_id: string | null;
  created_at: string;
  created_by: string | null;
  updated_at: string;
  // Joined fields
  product?: { name: string; code: string };
  location?: { full_path: string };
  warehouse?: { name: string; code: string };
}

export interface LicensePlateListParams {
  search?: string;
  warehouse_id?: string;
  location_id?: string;
  product_id?: string;
  status?: LPStatus;
  qa_status?: QAStatus;
  batch_number?: string;
  expiry_before?: string;
  expiry_after?: string;
  sort?: 'lp_number' | 'created_at' | 'expiry_date' | 'quantity';
  order?: 'asc' | 'desc';
  page?: number;
  limit?: number;
}

export interface CreateLPInput {
  lp_number?: string;              // Optional if auto-generate enabled
  product_id: string;
  quantity: number;
  uom: string;
  location_id: string;
  warehouse_id: string;
  batch_number?: string;
  supplier_batch_number?: string;
  expiry_date?: string;
  manufacture_date?: string;
  source?: LPSource;
  po_number?: string;
  grn_id?: string;
  asn_id?: string;
  wo_id?: string;
  catch_weight_kg?: number;
  gtin?: string;
}

export interface UpdateLPInput {
  quantity?: number;
  location_id?: string;
  batch_number?: string;
  supplier_batch_number?: string;
  expiry_date?: string;
  manufacture_date?: string;
  catch_weight_kg?: number;
}

export interface ConsumeLPInput {
  lp_id: string;
  consume_qty: number;
  wo_id: string;
  operation_id?: string;           // Reference to wo_operations
}

export interface CreateOutputLPInput {
  product_id: string;
  quantity: number;
  uom: string;
  location_id: string;
  warehouse_id: string;
  wo_id: string;
  batch_number?: string;
  expiry_date?: string;
  manufacture_date?: string;
  qa_status?: QAStatus;
  catch_weight_kg?: number;
}

export interface PaginatedResult<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    total_pages: number;
  };
}

export class LicensePlateService {
  // ==========================================================================
  // CRUD Operations
  // ==========================================================================

  /**
   * List license plates with filtering, sorting, pagination
   */
  static async list(params: LicensePlateListParams): Promise<PaginatedResult<LicensePlate>>;

  /**
   * Get single license plate by ID
   */
  static async getById(id: string): Promise<LicensePlate | null>;

  /**
   * Create new license plate
   * Auto-generates LP number if not provided and auto_generate enabled
   */
  static async create(data: CreateLPInput): Promise<LicensePlate>;

  /**
   * Update license plate (limited fields)
   * Throws if LP is consumed
   */
  static async update(id: string, data: UpdateLPInput): Promise<LicensePlate>;

  /**
   * Generate next LP number for org
   */
  static async generateLPNumber(): Promise<string>;

  // ==========================================================================
  // Status Management
  // ==========================================================================

  /**
   * Block LP (set status to 'blocked')
   */
  static async block(id: string, reason?: string): Promise<LicensePlate>;

  /**
   * Unblock LP (set status back to 'available')
   */
  static async unblock(id: string): Promise<LicensePlate>;

  /**
   * Update QA status
   */
  static async updateQAStatus(id: string, qa_status: QAStatus): Promise<LicensePlate>;

  // ==========================================================================
  // Epic 04 Integration Methods - CRITICAL
  // ==========================================================================

  /**
   * Consume LP quantity for production
   * - Validates: status=available, qa_status=passed, sufficient qty, not expired
   * - Decrements quantity
   * - Sets consumed_by_wo_id if fully consumed
   * - Returns updated LP
   */
  static async consumeLP(input: ConsumeLPInput): Promise<LicensePlate>;

  /**
   * Reverse LP consumption (for corrections)
   * - Adds back consumed quantity
   * - Clears consumed_by_wo_id if was fully consumed
   */
  static async reverseConsumption(
    lp_id: string,
    restore_qty: number,
    wo_id: string
  ): Promise<LicensePlate>;

  /**
   * Create output LP from production
   * - Auto-generates LP number
   * - Sets source='production'
   * - Links to WO
   * - Calculates expiry from shelf life if not provided
   */
  static async createOutputLP(input: CreateOutputLPInput): Promise<LicensePlate>;

  /**
   * Get available LPs for product
   * - Filters: status=available, qa_status=passed, not expired
   * - Supports FIFO (created_at) and FEFO (expiry_date) ordering
   */
  static async getAvailableLPs(
    product_id: string,
    options?: {
      warehouse_id?: string;
      location_id?: string;
      order?: 'fifo' | 'fefo';
      limit?: number;
    }
  ): Promise<LicensePlate[]>;

  /**
   * Get total available quantity for product
   */
  static async getTotalAvailableQty(
    product_id: string,
    options?: {
      warehouse_id?: string;
      location_id?: string;
    }
  ): Promise<number>;

  /**
   * Validate LP for consumption
   * Returns { valid: boolean, errors: string[] }
   */
  static async validateForConsumption(
    lp_id: string,
    required_qty: number
  ): Promise<{ valid: boolean; errors: string[] }>;

  // ==========================================================================
  // Utility Methods
  // ==========================================================================

  /**
   * Check if LP exists and belongs to current org
   */
  static async exists(id: string): Promise<boolean>;

  /**
   * Check if LP number is available
   */
  static async isLPNumberAvailable(lp_number: string): Promise<boolean>;

  /**
   * Get LPs by product (all statuses)
   */
  static async getByProduct(product_id: string): Promise<LicensePlate[]>;

  /**
   * Get LPs by location
   */
  static async getByLocation(location_id: string): Promise<LicensePlate[]>;

  /**
   * Get LPs expiring within days
   */
  static async getExpiringWithinDays(days: number): Promise<LicensePlate[]>;
}
```

### Validation Schema (Zod)

```typescript
// lib/validation/license-plate.ts
import { z } from 'zod';

export const lpStatusEnum = z.enum(['available', 'reserved', 'consumed', 'blocked']);
export const qaStatusEnum = z.enum(['pending', 'passed', 'failed', 'quarantine']);
export const lpSourceEnum = z.enum(['manual', 'receipt', 'production', 'return', 'adjustment', 'split']);

export const createLPSchema = z.object({
  lp_number: z.string()
    .min(1, "LP number is required if manual entry")
    .max(50, "LP number max 50 characters")
    .optional(),
  product_id: z.string().uuid("Invalid product ID"),
  quantity: z.number()
    .positive("Quantity must be positive")
    .max(999999999, "Quantity too large"),
  uom: z.string()
    .min(1, "UoM is required")
    .max(20, "UoM max 20 characters"),
  location_id: z.string().uuid("Invalid location ID"),
  warehouse_id: z.string().uuid("Invalid warehouse ID"),
  batch_number: z.string().max(100).nullable().optional(),
  supplier_batch_number: z.string().max(100).nullable().optional(),
  expiry_date: z.string().datetime().nullable().optional()
    .or(z.string().regex(/^\d{4}-\d{2}-\d{2}$/).nullable().optional()),
  manufacture_date: z.string().datetime().nullable().optional()
    .or(z.string().regex(/^\d{4}-\d{2}-\d{2}$/).nullable().optional()),
  source: lpSourceEnum.default('manual'),
  po_number: z.string().max(50).nullable().optional(),
  grn_id: z.string().uuid().nullable().optional(),
  asn_id: z.string().uuid().nullable().optional(),
  wo_id: z.string().uuid().nullable().optional(),
  catch_weight_kg: z.number().positive().nullable().optional(),
  gtin: z.string().length(14, "GTIN must be 14 digits").nullable().optional(),
});

export const updateLPSchema = z.object({
  quantity: z.number().positive().max(999999999).optional(),
  location_id: z.string().uuid().optional(),
  batch_number: z.string().max(100).nullable().optional(),
  supplier_batch_number: z.string().max(100).nullable().optional(),
  expiry_date: z.string().nullable().optional(),
  manufacture_date: z.string().nullable().optional(),
  catch_weight_kg: z.number().positive().nullable().optional(),
});

export const consumeLPSchema = z.object({
  lp_id: z.string().uuid("Invalid LP ID"),
  consume_qty: z.number().positive("Consume quantity must be positive"),
  wo_id: z.string().uuid("Invalid WO ID"),
  operation_id: z.string().uuid().optional(),
});

export const createOutputLPSchema = z.object({
  product_id: z.string().uuid("Invalid product ID"),
  quantity: z.number().positive("Quantity must be positive"),
  uom: z.string().min(1, "UoM is required"),
  location_id: z.string().uuid("Invalid location ID"),
  warehouse_id: z.string().uuid("Invalid warehouse ID"),
  wo_id: z.string().uuid("Invalid WO ID"),
  batch_number: z.string().max(100).optional(),
  expiry_date: z.string().optional(),
  manufacture_date: z.string().optional(),
  qa_status: qaStatusEnum.default('pending'),
  catch_weight_kg: z.number().positive().optional(),
});

export const lpQuerySchema = z.object({
  search: z.string().min(1).optional(),
  warehouse_id: z.string().uuid().optional(),
  location_id: z.string().uuid().optional(),
  product_id: z.string().uuid().optional(),
  status: lpStatusEnum.optional(),
  qa_status: qaStatusEnum.optional(),
  batch_number: z.string().optional(),
  expiry_before: z.string().optional(),
  expiry_after: z.string().optional(),
  sort: z.enum(['lp_number', 'created_at', 'expiry_date', 'quantity']).default('created_at'),
  order: z.enum(['asc', 'desc']).default('desc'),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(50),
});

export const updateQAStatusSchema = z.object({
  qa_status: qaStatusEnum,
});

export const blockLPSchema = z.object({
  reason: z.string().max(500).optional(),
});

export type CreateLPInput = z.infer<typeof createLPSchema>;
export type UpdateLPInput = z.infer<typeof updateLPSchema>;
export type ConsumeLPInput = z.infer<typeof consumeLPSchema>;
export type CreateOutputLPInput = z.infer<typeof createOutputLPSchema>;
export type LPQueryParams = z.infer<typeof lpQuerySchema>;
```

---

## UI Components

```
app/(authenticated)/warehouse/
  license-plates/
    page.tsx                           -- LP list page

components/warehouse/license-plates/
  LPDataTable.tsx                      -- DataTable with sorting, pagination
  LPFilters.tsx                        -- Filter panel (warehouse, location, status, QA)
  LPSearchInput.tsx                    -- LP number search with debounce
  LPDetailPanel.tsx                    -- Slide-in panel for LP details
  LPStatusBadge.tsx                    -- Status badge (available/reserved/consumed/blocked)
  LPQAStatusBadge.tsx                  -- QA status badge (pending/passed/failed/quarantine)
  LPExpiryIndicator.tsx                -- Expiry date with warning colors
  LPRowActions.tsx                     -- Row actions dropdown
  LPQuickView.tsx                      -- Compact LP info for inline display
```

### Badge Colors (TailwindCSS)

| Status | Badge Class |
|--------|-------------|
| available | `bg-green-100 text-green-800` |
| reserved | `bg-yellow-100 text-yellow-800` |
| consumed | `bg-gray-100 text-gray-500` |
| blocked | `bg-red-100 text-red-800` |

| QA Status | Badge Class |
|-----------|-------------|
| pending | `bg-yellow-100 text-yellow-800` |
| passed | `bg-green-100 text-green-800` |
| failed | `bg-red-100 text-red-800` |
| quarantine | `bg-orange-100 text-orange-800` |

### Expiry Indicator Colors

| Condition | Color | Days |
|-----------|-------|------|
| Expired | Red | < 0 |
| Critical | Red | 0-7 |
| Warning | Yellow | 8-30 |
| Normal | Green | > 30 |

---

## Key Business Rules

1. **LP Number Uniqueness**: LP number must be unique within organization
2. **Auto-Generation**: LP number auto-generated from sequence with configurable prefix/length
3. **Status Transitions**:
   - available -> reserved (when allocated to WO/TO)
   - available -> consumed (when fully consumed by production)
   - available -> blocked (when quality hold)
   - reserved -> available (when released)
   - reserved -> consumed (when consumed from reservation)
   - blocked -> available (when unblocked)
4. **Consumed LP Immutable**: Once status = 'consumed', LP cannot be modified (except reversal)
5. **Consumption Validation**:
   - status must be 'available'
   - qa_status must be 'passed'
   - quantity >= consume_qty
   - expiry_date >= current_date
6. **Output LP Creation**:
   - Auto-generates LP number
   - source = 'production'
   - Links to WO via wo_id
   - Inherits QA status from settings
   - Calculates expiry from product shelf_life_days if not provided

---

## Deliverables

### Database
- [ ] Migration: `license_plates` table with all columns
- [ ] Migration: `lp_number_sequences` table
- [ ] Function: `generate_lp_number(org_id)`
- [ ] Trigger: `update_lp_updated_at`
- [ ] RLS policies for multi-tenancy
- [ ] All performance indexes

### API Routes
- [ ] `GET /api/warehouse/license-plates` - List with filters
- [ ] `GET /api/warehouse/license-plates/:id` - Get detail
- [ ] `POST /api/warehouse/license-plates` - Create
- [ ] `PUT /api/warehouse/license-plates/:id` - Update
- [ ] `PUT /api/warehouse/license-plates/:id/block` - Block
- [ ] `PUT /api/warehouse/license-plates/:id/unblock` - Unblock
- [ ] `PUT /api/warehouse/license-plates/:id/qa-status` - Update QA
- [ ] `POST /api/warehouse/license-plates/generate-number` - Generate number
- [ ] `POST /api/warehouse/license-plates/consume` - Consume (internal)
- [ ] `POST /api/warehouse/license-plates/create-output` - Create output (internal)
- [ ] `GET /api/warehouse/license-plates/available` - Get available

### Service Layer
- [ ] `LicensePlateService.list()`
- [ ] `LicensePlateService.getById()`
- [ ] `LicensePlateService.create()`
- [ ] `LicensePlateService.update()`
- [ ] `LicensePlateService.block()`
- [ ] `LicensePlateService.unblock()`
- [ ] `LicensePlateService.updateQAStatus()`
- [ ] `LicensePlateService.generateLPNumber()`
- [ ] `LicensePlateService.consumeLP()` - **CRITICAL FOR EPIC 04**
- [ ] `LicensePlateService.reverseConsumption()`
- [ ] `LicensePlateService.createOutputLP()` - **CRITICAL FOR EPIC 04**
- [ ] `LicensePlateService.getAvailableLPs()` - **CRITICAL FOR EPIC 04**
- [ ] `LicensePlateService.getTotalAvailableQty()`
- [ ] `LicensePlateService.validateForConsumption()`

### Validation
- [ ] `createLPSchema`
- [ ] `updateLPSchema`
- [ ] `consumeLPSchema`
- [ ] `createOutputLPSchema`
- [ ] `lpQuerySchema`

### Frontend
- [ ] LP list page (`/warehouse/license-plates`)
- [ ] LP DataTable with sorting/pagination
- [ ] LP filter panel
- [ ] LP search input
- [ ] LP detail panel
- [ ] Status/QA badges
- [ ] Expiry indicators

### Tests
- [ ] Unit tests: LP service methods (>80% coverage)
- [ ] Integration tests: All API endpoints
- [ ] RLS tests: Multi-tenancy isolation
- [ ] E2E: LP list, filter, detail view

---

## Test Cases

### Unit Tests

**File:** `__tests__/unit/services/license-plate-service.test.ts`

| Test Case | Description |
|-----------|-------------|
| `create()` generates LP number when auto enabled | Verify sequence increment |
| `create()` uses provided LP number when manual | Verify custom number saved |
| `create()` blocks duplicate LP number | 409 Conflict returned |
| `consumeLP()` decrements quantity | 100 - 30 = 70 |
| `consumeLP()` sets consumed status on full consume | qty=0 -> status=consumed |
| `consumeLP()` blocks if status != available | Error returned |
| `consumeLP()` blocks if qa_status != passed | Error returned |
| `consumeLP()` blocks if insufficient qty | Error returned |
| `consumeLP()` blocks if expired | Error returned |
| `createOutputLP()` generates LP number | Auto-generated |
| `createOutputLP()` sets source=production | Correct source |
| `createOutputLP()` links to WO | wo_id set |
| `createOutputLP()` calculates expiry | manufacture + shelf_life |
| `getAvailableLPs()` filters correctly | Only available+passed |
| `getAvailableLPs()` orders by FIFO | created_at ASC |
| `getAvailableLPs()` orders by FEFO | expiry_date ASC |
| `getAvailableLPs()` excludes expired | No past expiry |
| `block()` updates status to blocked | Status change |
| `unblock()` restores available status | Status change |
| `update()` blocks consumed LP changes | Error returned |

### Integration Tests

**File:** `__tests__/integration/api/warehouse/license-plates.test.ts`

| Test Case | Description |
|-----------|-------------|
| GET `/license-plates` returns paginated list | Pagination works |
| GET `/license-plates?status=available` filters | Status filter |
| GET `/license-plates?product_id=X` filters | Product filter |
| GET `/license-plates?search=LP000` searches | Prefix search |
| GET `/license-plates/:id` returns LP detail | Detail returned |
| GET `/license-plates/:id` with invalid ID returns 404 | Not found |
| POST `/license-plates` creates LP | LP created |
| POST `/license-plates` with duplicate number returns 409 | Conflict |
| PUT `/license-plates/:id` updates LP | LP updated |
| PUT `/license-plates/:id/block` blocks LP | Status=blocked |
| PUT `/license-plates/:id/unblock` unblocks LP | Status=available |
| PUT `/license-plates/:id/qa-status` updates QA | QA updated |
| Cross-org access returns 404 | RLS enforced |
| Response times meet requirements | < 500ms |

### E2E Tests

**File:** `__tests__/e2e/warehouse/license-plates.spec.ts`

| Test Case | Description |
|-----------|-------------|
| View LP list page | Page loads, table displays |
| Filter LPs by status | Filter applies, list updates |
| Search LPs by number | Search works with debounce |
| View LP detail panel | Panel opens, fields display |
| Sort LP list by column | Sorting toggles |
| Pagination works | Page navigation functions |

---

## Definition of Done

### Database
- [ ] `license_plates` table created with all columns
- [ ] `lp_number_sequences` table created
- [ ] `generate_lp_number()` function works correctly
- [ ] All indexes created for performance
- [ ] RLS policies enforce org isolation
- [ ] RLS prevents cross-tenant access (returns 404)

### API
- [ ] All endpoints return correct HTTP status codes
- [ ] Validation errors return 400 with messages
- [ ] Cross-tenant access returns 404
- [ ] Response times meet requirements:
  - LP lookup: < 100ms
  - LP list: < 500ms
  - LP search: < 300ms
  - LP create: < 200ms

### Service
- [ ] `consumeLP()` validates and processes correctly
- [ ] `createOutputLP()` creates production LPs correctly
- [ ] `getAvailableLPs()` returns correct filtered/sorted results
- [ ] All Epic 04 integration methods tested and working

### Frontend
- [ ] LP list page renders DataTable
- [ ] Filters work correctly (warehouse, location, status, QA)
- [ ] Search debounces and filters by LP number
- [ ] Pagination controls work
- [ ] Sorting by columns works
- [ ] Detail panel displays all LP information
- [ ] Status badges display correct colors
- [ ] QA badges display correct colors
- [ ] Expiry indicators show warnings

### Testing
- [ ] Unit tests: >80% coverage on service
- [ ] Integration tests: All endpoints covered
- [ ] RLS tests: Multi-tenancy verified
- [ ] E2E tests: Critical flows passing

### Documentation
- [ ] API endpoints documented
- [ ] Service methods documented with JSDoc
- [ ] Zod schemas have field descriptions

---

## Future Phases (Not in This Story)

### Story 05.2 - LP Genealogy
- `lp_genealogy` table for parent-child tracking
- Split/merge/consume/output relationship recording

### Story 05.3 - LP Reservations
- `lp_reservations` table
- Reserve LP for WO/TO
- Release/consume reservations

### Story 05.4 - FIFO/FEFO Pick Suggestions
- Intelligent pick suggestion service
- Warning on violation
- Override with audit

### Story 05.5 - LP CRUD Desktop (Full)
- Create LP modal
- Edit LP modal
- Delete LP functionality
- Bulk operations

### Story 05.6 - LP Split/Merge
- Split LP workflow
- Merge LP workflow
- Genealogy integration

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Schema changes after Epic 04 starts | HIGH | LOW | Schema reviewed and approved before development |
| Performance with large datasets | MEDIUM | MEDIUM | Indexes designed, pagination implemented |
| RLS policy gaps | HIGH | LOW | Comprehensive RLS tests |
| LP number sequence conflicts | MEDIUM | LOW | Atomic upsert with row lock |
| Missing Epic 04 service method | CRITICAL | MEDIUM | Service interface reviewed with Epic 04 spec |

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-12-16 | Initial story creation with Epic 04 integration focus | OPUS |
