# Story 07.2 - Database Schema & Migrations
# Purpose: Tables, RLS policies, indexes, seed data
# Agent: BACKEND-DEV (database focus)

migrations:
  - path: "supabase/migrations/063_create_sales_orders_tables.sql"
    type: "migration"
    description: "Create sales_orders + sales_order_lines tables with RLS, indexes, sequence"

tables:
  - name: "sales_orders"
    description: "Sales orders with status workflow (draft â†’ confirmed)"
    columns:
      - { name: "id", type: "UUID", constraints: "PRIMARY KEY DEFAULT gen_random_uuid()" }
      - { name: "org_id", type: "UUID", constraints: "NOT NULL REFERENCES organizations(id) ON DELETE CASCADE" }
      - { name: "order_number", type: "TEXT", constraints: "NOT NULL" }
      - { name: "customer_id", type: "UUID", constraints: "NOT NULL REFERENCES customers(id)" }
      - { name: "customer_po", type: "TEXT", constraints: "DEFAULT NULL" }
      - { name: "shipping_address_id", type: "UUID", constraints: "NOT NULL REFERENCES customer_addresses(id)" }
      - { name: "order_date", type: "DATE", constraints: "NOT NULL" }
      - { name: "promised_ship_date", type: "DATE", constraints: "DEFAULT NULL" }
      - { name: "required_delivery_date", type: "DATE", constraints: "DEFAULT NULL" }
      - { name: "status", type: "TEXT", constraints: "NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'confirmed'))" }
      - { name: "total_amount", type: "DECIMAL(15,2)", constraints: "GENERATED ALWAYS AS (COALESCE(SUM(sales_order_lines.line_total), 0)) STORED" }
      - { name: "notes", type: "TEXT", constraints: "DEFAULT NULL" }
      - { name: "allergen_validated", type: "BOOLEAN", constraints: "DEFAULT false" }
      - { name: "created_at", type: "TIMESTAMPTZ", constraints: "DEFAULT NOW()" }
      - { name: "created_by", type: "UUID", constraints: "REFERENCES users(id)" }
      - { name: "updated_at", type: "TIMESTAMPTZ", constraints: "DEFAULT NOW()" }
      - { name: "confirmed_at", type: "TIMESTAMPTZ", constraints: "DEFAULT NULL" }
      - { name: "shipped_at", type: "TIMESTAMPTZ", constraints: "DEFAULT NULL" }
    rls: true
    rls_pattern: "org_id = (SELECT org_id FROM users WHERE id = auth.uid())"
    unique_constraints:
      - "UNIQUE(org_id, order_number)"
    indexes:
      - "idx_sales_orders_org_status ON sales_orders(org_id, status)"
      - "idx_sales_orders_customer ON sales_orders(customer_id)"
      - "idx_sales_orders_promised_date ON sales_orders(promised_ship_date)"
      - "idx_sales_orders_order_date ON sales_orders(order_date)"

  - name: "sales_order_lines"
    description: "Order line items with quantity tracking across fulfillment stages"
    columns:
      - { name: "id", type: "UUID", constraints: "PRIMARY KEY DEFAULT gen_random_uuid()" }
      - { name: "org_id", type: "UUID", constraints: "NOT NULL REFERENCES organizations(id) ON DELETE CASCADE" }
      - { name: "sales_order_id", type: "UUID", constraints: "NOT NULL REFERENCES sales_orders(id) ON DELETE CASCADE" }
      - { name: "line_number", type: "INTEGER", constraints: "NOT NULL" }
      - { name: "product_id", type: "UUID", constraints: "NOT NULL REFERENCES products(id)" }
      - { name: "quantity_ordered", type: "DECIMAL(15,4)", constraints: "NOT NULL CHECK (quantity_ordered > 0)" }
      - { name: "quantity_allocated", type: "DECIMAL(15,4)", constraints: "DEFAULT 0" }
      - { name: "quantity_picked", type: "DECIMAL(15,4)", constraints: "DEFAULT 0" }
      - { name: "quantity_packed", type: "DECIMAL(15,4)", constraints: "DEFAULT 0" }
      - { name: "quantity_shipped", type: "DECIMAL(15,4)", constraints: "DEFAULT 0" }
      - { name: "unit_price", type: "DECIMAL(15,4)", constraints: "NOT NULL CHECK (unit_price >= 0)" }
      - { name: "line_total", type: "DECIMAL(15,2)", constraints: "GENERATED ALWAYS AS (quantity_ordered * unit_price) STORED" }
      - { name: "requested_lot", type: "TEXT", constraints: "DEFAULT NULL" }
      - { name: "notes", type: "TEXT", constraints: "DEFAULT NULL" }
      - { name: "created_at", type: "TIMESTAMPTZ", constraints: "DEFAULT NOW()" }
    rls: true
    rls_pattern: "org_id = (SELECT org_id FROM users WHERE id = auth.uid())"
    unique_constraints:
      - "UNIQUE(sales_order_id, line_number)"
    indexes:
      - "idx_so_lines_order ON sales_order_lines(sales_order_id)"
      - "idx_so_lines_product ON sales_order_lines(product_id)"

# Sequence for order number generation
sequence:
  name: "sales_order_sequence"
  column: "organizations.next_so_sequence"
  logic: |
    ALTER TABLE organizations ADD COLUMN IF NOT EXISTS next_so_sequence INTEGER DEFAULT 1;

    -- Get next SO number per org + year
    CREATE OR REPLACE FUNCTION get_next_sales_order_number(p_org_id UUID, p_order_date DATE)
    RETURNS TEXT AS $$
    DECLARE
      v_year TEXT;
      v_sequence INTEGER;
    BEGIN
      v_year := TO_CHAR(p_order_date, 'YYYY');

      -- Increment org sequence
      UPDATE organizations
      SET next_so_sequence = next_so_sequence + 1
      WHERE id = p_org_id
      RETURNING next_so_sequence INTO v_sequence;

      -- Return formatted SO number
      RETURN 'SO-' || v_year || '-' || LPAD(v_sequence::TEXT, 5, '0');
    END;
    $$ LANGUAGE plpgsql;

# RLS Policies (ADR-013)
rls_policies:
  pattern: "Users Table Lookup"
  pattern_sql: "(SELECT org_id FROM users WHERE id = auth.uid())"

  policies:
    - table: "sales_orders"
      name: "sales_orders_select"
      operation: "SELECT"
      using: "org_id = (SELECT org_id FROM users WHERE id = auth.uid())"

    - table: "sales_orders"
      name: "sales_orders_insert"
      operation: "INSERT"
      with_check: "org_id = (SELECT org_id FROM users WHERE id = auth.uid())"

    - table: "sales_orders"
      name: "sales_orders_update"
      operation: "UPDATE"
      using: "org_id = (SELECT org_id FROM users WHERE id = auth.uid())"

    - table: "sales_orders"
      name: "sales_orders_delete"
      operation: "DELETE"
      using: "org_id = (SELECT org_id FROM users WHERE id = auth.uid()) AND status = 'draft'"

    - table: "sales_order_lines"
      name: "sales_order_lines_select"
      operation: "SELECT"
      using: "org_id = (SELECT org_id FROM users WHERE id = auth.uid())"

    - table: "sales_order_lines"
      name: "sales_order_lines_insert"
      operation: "INSERT"
      with_check: "org_id = (SELECT org_id FROM users WHERE id = auth.uid())"

    - table: "sales_order_lines"
      name: "sales_order_lines_update"
      operation: "UPDATE"
      using: |
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND sales_order_id IN (
          SELECT id FROM sales_orders WHERE status = 'draft'
        )

    - table: "sales_order_lines"
      name: "sales_order_lines_delete"
      operation: "DELETE"
      using: |
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND sales_order_id IN (
          SELECT id FROM sales_orders WHERE status = 'draft'
        )

# Triggers
triggers:
  - name: "tr_sales_orders_auto_order_number"
    table: "sales_orders"
    operation: "BEFORE INSERT"
    condition: "WHEN NEW.order_number IS NULL"
    function: "get_next_sales_order_number"
    logic: |
      NEW.order_number := get_next_sales_order_number(NEW.org_id, NEW.order_date);
      RETURN NEW;

  - name: "tr_sales_order_lines_auto_line_number"
    table: "sales_order_lines"
    operation: "BEFORE INSERT"
    condition: "WHEN NEW.line_number IS NULL"
    function: "get_next_line_number"
    logic: |
      SELECT COALESCE(MAX(line_number), 0) + 1
      INTO NEW.line_number
      FROM sales_order_lines
      WHERE sales_order_id = NEW.sales_order_id;
      RETURN NEW;

  - name: "tr_sales_orders_update_confirmed_at"
    table: "sales_orders"
    operation: "BEFORE UPDATE"
    condition: "WHEN NEW.status = 'confirmed' AND OLD.status != 'confirmed'"
    logic: |
      NEW.confirmed_at := NOW();
      RETURN NEW;

# Data Validation
validations:
  order_date:
    rule: "Must not be in future (today or earlier)"
    check: "order_date <= NOW()::DATE"

  delivery_date:
    rule: "Must be on or after order_date"
    check: "required_delivery_date >= order_date"

  quantity:
    rule: "Must be greater than zero"
    check: "quantity_ordered > 0"

  unit_price:
    rule: "Must be non-negative"
    check: "unit_price >= 0"

  status_edit:
    rule: "Draft orders editable, confirmed orders locked"
    check: "Can UPDATE only if status = 'draft'"

  deletion:
    rule: "Only draft orders can be deleted"
    check: "Can DELETE only if status = 'draft'"

# Seed Data
seed_data:
  description: "No seed data for sales orders (user-created)"
  notes:
    - "Sales orders are created via API, not seeded"
    - "Seed customer data first (Story 07.1)"
    - "Seed products first (Story 02.1)"
