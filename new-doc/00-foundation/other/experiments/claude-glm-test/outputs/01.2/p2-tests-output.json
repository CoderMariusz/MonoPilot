[GLM WRAPPER] Task: write-tests | Story: 01.2 | Model: glm-4-plus
[GLM WRAPPER] Context files: 2
[DEBUG] Calling glm-4-plus with 3951 chars prompt
[DEBUG] Response status: 200
{
  "success": true,
  "data": {
    "raw_response": "```json\n{\n  \"files\": [\n    {\n      \"path\": \"apps/frontend/__tests__/01-settings/01.2.test.ts\",\n      \"content\": \"import { describe, it, expect, beforeEach, vi } from 'vitest';\\nimport { render, screen, fireEvent, waitFor } from '@testing-library/vue';\\nimport { createRouter, createWebHistory } from 'vue-router';\\nimport { createPinia, setActivePinia } from 'pinia';\\nimport UserRoles from '@/views/settings/UserRoles.vue';\\nimport userRolesModule from '@/store/modules/userRoles';\\n\\n// Mock API responses\\nconst mockRoles = [\\n  {\\n    id: '1',\\n    name: 'Owner',\\n    description: 'Super Admin (all permissions)',\\n    permissions: ['C', 'R', 'U', 'D'],\\n    createdAt: '2026-01-01T00:00:00Z',\\n    updatedAt: '2026-01-01T00:00:00Z',\\n  },\\n  {\\n    id: '2',\\n    name: 'Administrator',\\n    description: 'System config, user mgmt',\\n    permissions: ['C', 'R', 'U'],\\n    createdAt: '2026-01-01T00:00:00Z',\\n    updatedAt: '2026-01-01T00:00:00Z',\\n  },\\n  {\\n    id: '3',\\n    name: 'Production Manager',\\n    description: 'Production planning & oversight',\\n    permissions: ['C', 'R', 'U'],\\n    createdAt: '2026-01-01T00:00:00Z',\\n    updatedAt: '2026-01-01T00:00:00Z',\\n  },\\n  {\\n    id: '4',\\n    name: 'Quality Manager',\\n    description: 'Quality control & standards',\\n    permissions: ['C', 'R', 'U'],\\n    createdAt: '2026-01-01T00:00:00Z',\\n    updatedAt: '2026-01-01T00:00:00Z',\\n  },\\n  {\\n    id: '5',\\n    name: 'Warehouse Manager',\\n    description: 'Inventory & storage',\\n    permissions: ['C', 'R', 'U'],\\n    createdAt: '2026-01-01T00:00:00Z',\\n    updatedAt: '2026-01-01T00:00:00Z',\\n  },\\n  {\\n    id: '6',\\n    name: 'Production Operator',\\n    description: 'Execute production tasks',\\n    permissions: ['R', 'U'],\\n    createdAt: '2026-01-01T00:00:00Z',\\n    updatedAt: '2026-01-01T00:00:00Z',\\n  },\\n  {\\n    id: '7',\\n    name: 'Quality Inspector',\\n    description: 'Quality checks',\\n    permissions: ['R', 'U'],\\n    createdAt: '2026-01-01T00:00:00Z',\\n    updatedAt: '2026-01-01T00:00:00Z',\\n  },\\n  {\\n    id: '8',\\n    name: 'Warehouse Operator',\\n    description: 'Picking, packing, receiving',\\n    permissions: ['R', 'U'],\\n    createdAt: '2026-01-01T00:00:00Z',\\n    updatedAt: '2026-01-01T00:00:00Z',\\n  },\\n  {\\n    id: '9',\\n    name: 'Planner',\\n    description: 'Production planning',\\n    permissions: ['C', 'R'],\\n    createdAt: '2026-01-01T00:00:00Z',\\n    updatedAt: '2026-01-01T00:00:00Z',\\n  },\\n  {\\n    id: '10',\\n    name: 'Viewer',\\n    description: 'Read-only access',\\n    permissions: ['R'],\\n    createdAt: '2026-01-01T00:00:00Z',\\n    updatedAt: '2026-01-01T00:00:00Z',\\n  },\\n];\\n\\nconst mockUsers = [\\n  {\\n    id: '1',\\n    name: 'John Doe',\\n    email: 'john@example.com',\\n    roleId: '1',\\n    status: 'active',\\n    createdAt: '2026-01-01T00:00:00Z',\\n    updatedAt: '2026-01-01T00:00:00Z',\\n  },\\n  {\\n    id: '2',\\n    name: 'Jane Smith',\\n    email: 'jane@example.com',\\n    roleId: '2',\\n    status: 'active',\\n    createdAt: '2026-01-01T00:00:00Z',\\n    updatedAt: '2026-01-01T00:00:00Z',\\n  },\\n];\\n\\nconst mockApiResponse = {\\n  roles: mockRoles,\\n  users: mockUsers,\\n  total: 2,\\n};\\n\\n// Mock API module\\nvi.mock('@/api/settings', () => ({\\n  getRoles: vi.fn(),\\n  getUsers: vi.fn(),\\n  createUser: vi.fn(),\\n  updateUser: vi.fn(),\\n  deleteUser: vi.fn(),\\n  getRolePermissions: vi.fn(),\\n  updateRolePermissions: vi.fn(),\\n}));\\n\\ndescribe('UserRoles - Unit Tests', () => {\\n  beforeEach(() => {\\n    setActivePinia(createPinia());\\n    vi.clearAllMocks();\\n  });\\n\\n  it('should render loading state initially', () => {\\n    const store = userRolesModule();\\n    store.setLoading(true);\\n    \\n    const { getByTestId } = render(UserRoles);\\n    expect(getByTestId('loading-skeleton')).toBeInTheDocument();\\n  });\\n\\n  it('should render empty state when no users exist', async () => {\\n    const { getApi } = await import('@/api/settings');\\n    getApi.mockResolvedValue({\\n      roles: mockRoles,\\n      users: [],\\n      total: 0,\\n    });\\n\\n    const { getByText, getByTestId } = render(UserRoles);\\n    \\n    await waitFor(() => {\\n      expect(getByTestId('empty-state')).toBeInTheDocument();\\n      expect(getByText('No users found')).toBeInTheDocument();\\n      expect(getByText('Create your first user')).toBeInTheDocument();\\n    });\\n  });\\n\\n  it('should display user list with role badges', async () => {\\n    const { getApi } = await import('@/api/settings');\\n    getApi.mockResolvedValue(mockApiResponse);\\n\\n    const { getByText, getAllByTestId } = render(UserRoles);\\n    \\n    await waitFor(() => {\\n      expect(getByText('John Doe')).toBeInTheDocument();\\n      expect(getByText('john@example.com')).toBeInTheDocument();\\n      expect(getByText('Jane Smith')).toBeInTheDocument();\\n      expect(getByText('jane@example.com')).toBeInTheDocument();\\n    });\\n\\n    const roleBadges = getAllByTestId('role-badge');\\n    expect(roleBadges).toHaveLength(2);\\n    expect(roleBadges[0]).toHaveTextContent('Owner');\\n    expect(roleBadges[1]).toHaveTextContent('Administrator');\\n  });\\n\\n  it('should open create user modal when create button is clicked', async () => {\\n    const { getApi } = await import('@/api/settings');\\n    getApi.mockResolvedValue(mockApiResponse);\\n\\n    const { getByText, getByTestId, queryByTestId } = render(UserRoles);\\n    \\n    await waitFor(() => {\\n      expect(getByText('Create User')).toBeInTheDocument();\\n    });\\n\\n    fireEvent.click(getByText('Create User'));\\n    \\n    await waitFor(() => {\\n      expect(getByTestId('user-modal')).toBeInTheDocument();\\n      expect(getByTestId('modal-title')).toHaveTextContent('Create New User');\\n    });\\n  });\\n\\n  it('should validate form inputs in create user modal', async () => {\\n    const { getApi } = await import('@/api/settings');\\n    getApi.mockResolvedValue(mockApiResponse);\\n\\n    const { getByText, getByTestId, queryByTestId } = render(UserRoles);\\n    \\n    // Open modal\\n    fireEvent.click(getByText('Create User'));\\n    \\n    // Try to submit without filling required fields\\n    const submitButton = getByTestId('submit-button');\\n    fireEvent.click(submitButton);\\n    \\n    await waitFor(() => {\\n      expect(getByTestId('error-name')).toBeInTheDocument();\\n      expect(getByTestId('error-email')).toBeInTheDocument();\\n      expect(getByTestId('error-role')).toBeInTheDocument();\\n    });\\n  });\\n\\n  it('should display permission matrix when view permissions is clicked', async () => {\\n    const { getApi } = await import('@/api/settings');\\n    getApi.mockResolvedValue(mockApiResponse);\\n\\n    const { getByText, getByTestId } = render(UserRoles);\\n    \\n    // Wait for users to load\\n    await waitFor(() => {\\n      expect(getByText('John Doe')).toBeInTheDocument();\\n    });\\n\\n    // Click view permissions for Owner role\\n    const viewPermissionsButton = getByText('View Permissions');\\n    fireEvent.click(viewPermissionsButton);\\n    \\n    await waitFor(() => {\\n      expect(getByTestId('permission-matrix-modal')).toBeInTheDocument();\\n      expect(getByTestId('modal-title')).toHaveTextContent('Role Permissions - Owner');\\n    });\\n  });\\n\\n  it('should handle error states gracefully', async () => {\\n    const { getApi } = await import('@/api/settings');\\n    getApi.mockRejectedValue(new Error('API Error'));\\n\\n    const { getByText, getByTestId } = render(UserRoles);\\n    \\n    await waitFor(() => {\\n      expect(getByTestId('error-state')).toBeInTheDocument();\\n      expect(getByText('Failed to load users')).toBeInTheDocument();\\n      expect(getByText('Retry')).toBeInTheDocument();\\n    });\\n  });\\n});\\n\"\n    },\n    {\n      \"path\": \"apps/backend/src/tests/api/settings/user-roles.test.ts\",\n      \"content\": \"import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\\nimport { FastifyInstance } from 'fastify';\\nimport { createServer } from '@/server';\\nimport { prisma } from '@/lib/prisma';\\nimport { Role, Permission } from '@prisma/client';\\n\\n// Mock Prisma client\\nvi.mock('@/lib/prisma', () => ({\\n  prisma: {\\n    role: {\\n      findMany: vi.fn(),\\n      findUnique: vi.fn(),\\n      create: vi.fn(),\\n      update: vi.fn(),\\n      delete: vi.fn(),\\n      findFirst: vi.fn(),\\n    },\\n    user: {\\n      findMany: vi.fn(),\\n      findUnique: vi.fn(),\\n      create: vi.fn(),\\n      update: vi.fn(),\\n      delete: vi.fn(),\\n    },\\n    rolePermission: {\\n      findMany: vi.fn(),\\n      create: vi.fn(),\\n      deleteMany: vi.fn(),\\n    },\\n    $transaction: vi.fn(),\\n  },\\n}));\\n\\n// Test data\\nconst mockRoles = [\\n  {\\n    id: '1',\\n    name: 'Owner',\\n    description: 'Super Admin (all permissions)',\\n    permissions: ['C', 'R', 'U', 'D'],\\n    createdAt: new Date('2026-01-01T00:00:00Z'),\\n    updatedAt: new Date('2026-01-01T00:00:00Z'),\\n  },\\n  {\\n    id: '2',\\n    name: 'Administrator',\\n    description: 'System config, user mgmt',\\n    permissions: ['C', 'R', 'U'],\\n    createdAt: new Date('2026-01-01T00:00:00Z'),\\n    updatedAt: new Date('2026-01-01T00:00:00Z'),\\n  },\\n];\\n\\nconst mockUsers = [\\n  {\\n    id: '1',\\n    name: 'John Doe',\\n    email: 'john@example.com',\\n    roleId: '1',\\n    status: 'ACTIVE',\\n    createdAt: new Date('2026-01-01T00:00:00Z'),\\n    updatedAt: new Date('2026-01-01T00:00:00Z'),\\n  },\\n  {\\n    id: '2',\\n    name: 'Jane Smith',\\n    email: 'jane@example.com',\\n    roleId: '2',\\n    status: 'ACTIVE',\\n    createdAt: new Date('2026-01-01T00:00:00Z'),\\n    updatedAt: new Date('2026-01-01T00:00:00Z'),\\n  },\\n];\\n\\ndescribe('User Roles API Tests', () => {\\n  let app: FastifyInstance;\\n\\n  beforeEach(async () => {\\n    app = await createServer();\\n    vi.clearAllMocks();\\n  });\\n\\n  afterEach(async () => {\\n    await app.close();\\n  });\\n\\n  describe('GET /api/v1/settings/roles', () => {\\n    it('should return all roles with permissions', async () => {\\n      const { prisma } = await import('@/lib/prisma');\\n      prisma.role.findMany.mockResolvedValue(mockRoles as any);\\n      prisma.rolePermission.findMany.mockResolvedValue([\\n        { roleId: '1', permission: 'C' },\\n        { roleId: '1', permission: 'R' },\\n        { roleId: '1', permission: 'U' },\\n        { roleId: '1', permission: 'D' },\\n        { roleId: '2', permission: 'C' },\\n        { roleId: '2', permission: 'R' },\\n        { roleId: '2', permission: 'U' },\\n      ] as any);\\n\\n      const response = await app.inject({\\n        method: 'GET',\\n        url: '/api/v1/settings/roles',\\n      });\\n\\n      expect(response.statusCode).toBe(200);\\n      expect(JSON.parse(response.payload)).toEqual({\\n        success: true,\\n        data: mockRoles,\\n      });\\n    });\\n\\n    it('should handle database errors', async () => {\\n      const { prisma } = await import('@/lib/prisma');\\n      prisma.role.findMany.mockRejectedValue(new Error('Database error'));\\n\\n      const response = await app.inject({\\n        method: 'GET',\\n        url: '/api/v1/settings/roles',\\n      });\\n\\n      expect(response.statusCode).toBe(500);\\n      expect(JSON.parse(response.payload)).toEqual({\\n        success: false,\\n        error: 'Internal server error',\\n      });\\n    });\\n  });\\n\\n  describe('GET /api/v1/settings/users', () => {\\n    it('should return users with role information', async () => {\\n      const { prisma } = await import('@/lib/prisma');\\n      prisma.user.findMany.mockResolvedValue(mockUsers as any);\\n      prisma.role.findMany.mockResolvedValue(mockRoles as any);\\n\\n      const response = await app.inject({\\n        method: 'GET',\\n        url: '/api/v1/settings/users',\\n      });\\n\\n      expect(response.statusCode).toBe(200);\\n      const parsed = JSON.parse(response.payload);\\n      expect(parsed.success).toBe(true);\\n      expect(parsed.data.users).toHaveLength(2);\\n      expect(parsed.data.roles).toHaveLength(2);\\n    });\\n\\n    it('should handle pagination parameters', async () => {\\n      const { prisma } = await import('@/lib/prisma');\\n      prisma.user.findMany.mockResolvedValue(mockUsers.slice(0, 1) as any);\\n      prisma.user.count.mockResolvedValue(2);\\n      prisma.role.findMany.mockResolvedValue(mockRoles as any);\\n\\n      const response = await app.inject({\\n        method: 'GET',\\n        url: '/api/v1/settings/users?page=1&limit=1',\\n      });\\n\\n      expect(response.statusCode).toBe(200);\\n      const parsed = JSON.parse(response.payload);\\n      expect(parsed.data.users).toHaveLength(1);\\n      expect(parsed.pagination.total).toBe(2);\\n      expect(parsed.pagination.page).toBe(1);\\n      expect(parsed.pagination.limit).toBe(1);\\n    });\\n  });\\n\\n  describe('POST /api/v1/settings/users', () => {\\n    it('should create a new user with role assignment', async () => {\\n      const { prisma } = await import('@/lib/prisma');\\n      const newUser = {\\n        id: '3',\\n        name: 'New User',\\n        email: 'new@example.com',\\n        roleId: '2',\\n        status: 'ACTIVE',\\n        createdAt: new Date(),\\n        updatedAt: new Date(),\\n      };\\n\\n      prisma.user.create.mockResolvedValue(newUser as any);\\n      prisma.role.findUnique.mockResolvedValue({\\n        id: '2',\\n        name: 'Administrator',\\n        description: 'System config, user mgmt',\\n      } as any);\\n\\n      const response = await app.inject({\\n        method: 'POST',\\n        url: '/api/v1/settings/users',\\n        payload: {\\n          name: 'New User',\\n          email: 'new@example.com',\\n          roleId: '2',\\n        },\\n      });\\n\\n      expect(response.statusCode).toBe(201);\\n      expect(JSON.parse(response.payload)).toEqual({\\n        success: true,\\n        data: newUser,\\n      });\\n    });\\n\\n    it('should validate required fields', async () => {\\n      const response = await app.inject({\\n        method: 'POST',\\n        url: '/api/v1/settings/users',\\n        payload: {\\n          name: '',\\n          email: 'invalid-email',\\n        },\\n      });\\n\\n      expect(response.statusCode).toBe(400);\\n      const parsed = JSON.parse(response.payload);\\n      expect(parsed.success).toBe(false);\\n      expect(parsed.errors).toHaveLength(2);\\n    });\\n\\n    it('should check for duplicate email', async () => {\\n      const { prisma } = await import('@/lib/prisma');\\n      prisma.user.findFirst.mockResolvedValue({\\n        id: '1',\\n        email: 'existing@example.com',\\n      } as any);\\n\\n      const response = await app.inject({\\n        method: 'POST',\\n        url: '/api/v1/settings/users',\\n        payload: {\\n          name: 'Test User',\\n          email: 'existing@example.com',\\n          roleId: '1',\\n        },\\n      });\\n\\n      expect(response.statusCode).toBe(409);\\n      expect(JSON.parse(response.payload).success).toBe(false);\\n    });\\n  });\\n\\n  describe('PUT /api/v1/settings/users/:id', () => {\\n    it('should update user information', async () => {\\n      const { prisma } = await import('@/lib/prisma');\\n      const updatedUser = {\\n        ...mockUsers[0],\\n        name: 'Updated Name',\\n        roleId: '2',\\n      };\\n\\n      prisma.user.update.mockResolvedValue(updatedUser as any);\\n      prisma.role.findUnique.mockResolvedValue({\\n        id: '2',\\n        name: 'Administrator',\\n      } as any);\\n\\n      const response = await app.inject({\\n        method: 'PUT',\\n        url: '/api/v1/settings/users/1',\\n        payload: {\\n          name: 'Updated Name',\\n          roleId: '2',\\n        },\\n      });\\n\\n      expect(response.statusCode).toBe(200);\\n      expect(JSON.parse(response.payload).success).toBe(true);\\n    });\\n\\n    it('should handle non-existent user', async () => {\\n      const { prisma } = await import('@/lib/prisma');\\n      prisma.user.update.mockRejectedValue({\\n        code: 'P2025',\\n        message: 'Record to update not found',\\n      });\\n\\n      const response = await app.inject({\\n        method: 'PUT',\\n        url: '/api/v1/settings/users/999',\\n        payload: {\\n          name: 'Updated Name',\\n        },\\n      });\\n\\n      expect(response.statusCode).toBe(404);\\n      expect(JSON.parse(response.payload).success).toBe(false);\\n    });\\n  });\\n\\n  describe('DELETE /api/v1/settings/users/:id', () => {\\n    it('should delete a user', async () => {\\n      const { prisma } = await import('@/lib/prisma');\\n      prisma.user.delete.mockResolvedValue(mockUsers[0] as any);\\n\\n      const response = await app.inject({\\n        method: 'DELETE',\\n        url: '/api/v1/settings/users/1',\\n      });\\n\\n      expect(response.statusCode).toBe(200);\\n      expect(JSON.parse(response.payload).success).toBe(true);\\n    });\\n\\n    it('should prevent deletion of last admin', async () => {\\n      const { prisma } = await import('@/lib/prisma');\\n      prisma.user.count.mockResolvedValue(1);\\n      prisma.user.findUnique.mockResolvedValue({\\n        ...mockUsers[0],\\n        roleId: '1', // Owner role\\n      } as any);\\n\\n      const response = await app.inject({\\n        method: 'DELETE',\\n        url: '/api/v1/settings/users/1',\\n      });\\n\\n      expect(response.statusCode).toBe(400);\\n      expect(JSON.parse(response.payload).success).toBe(false);\\n    });\\n  });\\n\\n  describe('GET /api/v1/settings/roles/:id/permissions', () => {\\n    it('should return role permissions', async () => {\\n      const { prisma } = await import('@/lib/prisma');\\n      prisma.role.findUnique.mockResolvedValue({\\n        id: '1',\\n        name: 'Owner',\\n        description: 'Super Admin',\\n      } as any);\\n      prisma.rolePermission.findMany.mockResolvedValue([\\n        { roleId: '1', permission: 'C' },\\n        { roleId: '1', permission: 'R' },\\n        { roleId: '1', permission: 'U' },\\n        { roleId: '1', permission: 'D' },\\n      ] as any);\\n\\n      const response = await app.inject({\\n        method: 'GET',\\n        url: '/api/v1/settings/roles/1/permissions',\\n      });\\n\\n      expect(response.statusCode).toBe(200);\\n      const parsed = JSON.parse(response.payload);\\n      expect(parsed.success).toBe(true);\\n      expect(parsed.data.permissions).toEqual(['C', 'R', 'U', 'D']);\\n    });\\n  });\\n\\n  describe('PUT /api/v1/settings/roles/:id/permissions', () => {\\n    it('should update role permissions', async () => {\\n      const { prisma } = await import('@/lib/prisma');\\n      const { $transaction } = prisma;\\n      $transaction.mockImplementation((callback) => callback(prisma));\\n\\n      prisma.role.findUnique.mockResolvedValue({\\n        id: '2',\\n        name: 'Administrator',\\n      } as any);\\n\\n      const response = await app.inject({\\n        method: 'PUT',\\n        url: '/api/v1/settings/roles/2/permissions',\\n        payload: {\\n          permissions: ['C', 'R', 'U'],\\n        },\\n      });\\n\\n      expect(response.statusCode).toBe(200);\\n      expect(JSON.parse(response.payload).success).toBe(true);\\n      expect(prisma.rolePermission.deleteMany).toHaveBeenCalledWith({\\n        where: { roleId: '2' },\\n      });\\n      expect(prisma.rolePermission.create).toHaveBeenCalledTimes(3);\\n    });\\n\\n    it('should validate permission values', async () => {\\n      const response = await app.inject({\\n        method: 'PUT',\\n        url: '/api/v1/settings/roles/1/permissions',\\n        payload: {\\n          permissions: ['INVALID'],\\n        },\\n      });\\n\\n      expect(response.statusCode).toBe(400);\\n      expect(JSON.parse(response.payload).success).toBe(false);\\n    });\\n  });\\n});\\n\"\n    },\n    {\n      \"path\": \"apps/e2e/tests/01-settings/user-roles.spec.ts\",\n      \"content\": \"import { test, expect } from '@playwright/test';\\nimport { login } from '../utils/auth';\\n\\nconst BASE_URL = process.env.PLAYWRIGHT_BASE_URL || 'http://localhost:3000';\\n\\n// Test data\\nconst testUsers = [\\n  {\\n    name: 'Test User One',\\n    email: 'test1@example.com',\\n    role: 'Administrator',\\n  },\\n  {\\n    name: 'Test User Two',\\n    email: 'test2@example.com',\\n    role: 'Production Manager',\\n  },\\n];\\n\\nconst testRoles = [\\n  'Owner',\\n  'Administrator',\\n  'Production Manager',\\n  'Quality Manager',\\n  'Warehouse Manager',\\n  'Production Operator',\\n  'Quality Inspector',\\n  'Warehouse Operator',\\n  'Planner',\\n  'Viewer',\\n];\\n\\ntest.describe('User Roles E2E Tests', () => {\\n  test.beforeEach(async ({ page }) => {\\n    await login(page, 'admin@example.com', 'password');\\n    await page.goto(`${BASE_URL}/settings/users`);\\n  });\\n\\n  test('should display user list with role badges', async ({ page }) => {\\n    // Check for loading state\\n    await expect(page.locator('[data-testid=\\\"loading-skeleton\\\"]')).toBeVisible();\\n    \\n    // Wait for users to load\\n    await expect(page.locator('[data-testid=\\\"user-list\\\"]')).toBeVisible();\\n    \\n    // Verify table headers\\n    await expect(page.getByText('Name')).toBeVisible();\\n    await expect(page.getByText('Email')).toBeVisible();\\n    await expect(page.getByText('Role')).toBeVisible();\\n    await expect(page.getByText('Status')).toBeVisible();\\n    \\n    // Check if role badges are present\\n    const roleBadges = page.locator('[data-testid=\\\"role-badge\\\"]');\\n    await expect(roleBadges.first()).toBeVisible();\\n    \\n    // Verify at least one role badge has correct text\\n    const firstRoleBadge = roleBadges.first();\\n    const roleText = await firstRoleBadge.textContent();\\n    expect(testRoles).toContain(roleText);\\n  });\\n\\n  test('should create a new user', async ({ page }) => {\\n    // Open create user modal\\n    await page.getByRole('button', { name: 'Create User' }).click();\\n    \\n    // Verify modal opened\\n    await expect(page.locator('[data-testid=\\\"user-modal\\\"]')).toBeVisible();\\n    await expect(page.getByText('Create New User')).toBeVisible();\\n    \\n    // Fill form\\n    await page.fill('[data-testid=\\\"name-input\\\"]', testUsers[0].name);\\n    await page.fill('[data-testid=\\\"email-input\\\"]', testUsers[0].email);\\n    \\n    // Select role from dropdown\\n    await page.click('[data-testid=\\\"role-select\\\"]');\\n    await page.getByText(testUsers[0].role).click();\\n    \\n    // Submit form\\n    await page.getByRole('button', { name: 'Create User' }).click();\\n    \\n    // Wait for success notification\\n    await expect(page.getByText('User created successfully')).toBeVisible();\\n    \\n    // Verify user appears in list\\n    await expect(page.getByText(testUsers[0].name)).toBeVisible();\\n    await expect(page.getByText(testUsers[0].email)).toBeVisible();\\n    \\n    // Verify role badge\\n    const roleBadge = page.locator('[data-testid=\\\"role-badge\\\"]').first();\\n    await expect(roleBadge).toHaveText(testUsers[0].role);\\n  });\\n\\n  test('should validate form inputs', async ({ page }) => {\\n    // Open create user modal\\n    await page.getByRole('button', { name: 'Create User' }).click();\\n    \\n    // Try to submit without filling required fields\\n    await page.getByRole('button', { name: 'Create User' }).click();\\n    \\n    // Check for validation errors\\n    await expect(page.locator('[data-testid=\\\"error-name\\\"]')).toBeVisible();\\n    await expect(page.locator('[data-testid=\\\"error-email\\\"]')).toBeVisible();\\n    await expect(page.locator('[data-testid=\\\"error-role\\\"]')).toBeVisible();\\n    \\n    // Test email validation\\n    await page.fill('[data-testid=\\\"email-input\\\"]', 'invalid-email');\\n    await page.getByRole('button', { name: 'Create User' }).click();\\n    await expect(page.locator('[data-testid=\\\"error-email\\\"]')).toHaveText('Please enter a valid email address');\\n    \\n    // Test duplicate email\\n    await page.fill('[data-testid=\\\"email-input\\\"]', 'admin@example.com');\\n    await page.getByRole('button', { name: 'Create User' }).click();\\n    await expect(page.locator('[data-testid=\\\"error-email\\\"]')).toHaveText('Email already exists');\\n  });\\n\\n  test('should edit existing user', async ({ page }) => {\\n    // Find first user in list\\n    const firstUserRow = page.locator('[data-testid=\\\"user-row\\\"]').first();\\n    const userName = await firstUserRow.getByText('Name').textContent();\\n    \\n    // Open edit modal\\n    await firstUserRow.getByRole('button', { name: 'Edit' }).click();\\n    \\n    // Verify modal opened with correct data\\n    await expect(page.locator('[data-testid=\\\"user-modal\\\"]')).toBeVisible();\\n    await expect(page.getByText('Edit User')).toBeVisible();\\n    \\n    // Verify form is pre-filled\\n    const nameInput = page.locator('[data-testid=\\\"name-input\\\"]');\\n    await expect(nameInput).toHaveValue(userName);\\n    \\n    // Update name\\n    const newName = 'Updated User Name';\\n    await nameInput.fill(newName);\\n    \\n    // Submit form\\n    await page.getByRole('button', { name: 'Update User' }).click();\\n    \\n    // Wait for success notification\\n    await expect(page.getByText('User updated successfully')).toBeVisible();\\n    \\n    // Verify user is updated\\n    await expect(page.getByText(newName)).toBeVisible();\\n  });\\n\\n  test('should delete user', async ({ page }) => {\\n    // Get initial user count\\n    const initialUserCount = await page.locator('[data-testid=\\\"user-row\\\"]').count();\\n    \\n    // Delete first user\\n    const firstUserRow = page.locator('[data-testid=\\\"user-row\\\"]').first();\\n    await firstUserRow.getByRole('button', { name: 'Delete' }).click();\\n    \\n    // Confirm deletion\\n    await page.getByRole('button', { name: 'Delete' }).click();\\n    \\n    // Wait for success notification\\n    await expect(page.getByText('User deleted successfully')).toBeVisible();\\n    \\n    // Verify user is removed\\n    await expect(page.locator('[data-testid=\\\"user-row\\\"]')).toHaveCount(initialUserCount - 1);\\n  });\\n\\n  test('should view role permissions', async ({ page }) => {\\n    // Open permissions modal for first user\\n    const firstUserRow = page.locator('[data-testid=\\\"user-row\\\"]').first();\\n    const roleName = await firstUserRow.locator('[data-testid=\\\"role-badge\\\"]').textContent();\\n    \\n    await firstUserRow.getByRole('button', { name: 'View Permissions' }).click();\\n    \\n    // Verify permissions modal opened\\n    await expect(page.locator('[data-testid=\\\"permission-matrix-modal\\\"]')).toBeVisible();\\n    await expect(page.getByText(`Role Permissions - ${roleName}`)).toBeVisible();\\n    \\n    // Verify permission matrix\\n    const permissionMatrix = page.locator('[data-testid=\\\"permission-matrix\\\"]');\\n    await expect(permissionMatrix).toBeVisible();\\n    \\n    // Check for CRUD headers\\n    await expect(permissionMatrix.getByText('Create')).toBeVisible();\\n    await expect(permissionMatrix.getByText('Read')).toBeVisible();\\n    await expect(permissionMatrix.getByText('Update')).toBeVisible();\\n    await expect(permissionMatrix.getByText('Delete')).toBeVisible();\\n    \\n    // Check for module sections\\n    const modules = ['Production', 'Quality', 'Warehouse', 'Settings'];\\n    for (const module of modules) {\\n      await expect(permissionMatrix.getByText(module)).toBeVisible();\\n    }\\n  });\\n\\n  test('should handle error states', async ({ page }) => {\\n    // Mock API error\\n    await page.route('**/api/v1/settings/users', route => {\\n      route.abort('failed');\\n    });\\n    \\n    // Reload page to trigger error\\n    await page.reload();\\n    \\n    // Check for error state\\n    await expect(page.locator('[data-testid=\\\"error-state\\\"]')).toBeVisible();\\n    await expect(page.getByText('Failed to load users')).toBeVisible();\\n    \\n    // Test retry functionality\\n    await page.getByRole('button', { name: 'Retry' }).click();\\n    \\n    // Should show loading state\\n    await expect(page.locator('[data-testid=\\\"loading-skeleton\\\"]')).toBeVisible();\\n  });\\n\\n  test('should display empty state', async ({ page }) => {\\n    // Mock empty response\\n    await page.route('**/api/v1/settings/users', route => {\\n      route.fulfill({\\n        status: 200,\\n        body: JSON.stringify({\\n          success: true,\\n          data: {\\n            users: [],\\n            roles: [],\\n            total: 0,\\n          },\\n        }),\\n      });\\n    });\\n    \\n    // Reload page\\n    await page.reload();\\n    \\"
  },
  "tokens": 9083,
  "model": "glm-4-plus",
  "warning": "GLM response wasn't valid JSON: Unterminated string starting at: line 13 column 18 (char 19464)"
}
