# Migration Documentation: Story 01.1 - Org Context + Base RLS

**Story:** 01.1 - Org Context + Base RLS (Foundation)
**Date:** 2025-12-16
**Migrations:** 054-059 (6 files)
**Type:** Schema creation + RLS policies + seed data

## Overview

Story 01.1 establishes the security foundation for the MonoPilot application by creating the core tenant isolation schema. This includes organizations, users, roles, modules, and organization_modules tables with complete RLS (Row Level Security) policies.

**Purpose:** Enable multi-tenant isolation and role-based access control for all future stories.

## Migration Files

### 054: Create Organizations Table

**File:** `supabase/migrations/054_create_organizations_table.sql`
**Purpose:** Core tenant table with onboarding state tracking

#### Schema

```sql
CREATE TABLE IF NOT EXISTS organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  timezone TEXT DEFAULT 'UTC',
  locale TEXT DEFAULT 'en',
  currency TEXT DEFAULT 'PLN',
  logo_url TEXT,

  -- Onboarding state (Story 01.3)
  onboarding_step INTEGER DEFAULT 0,
  onboarding_started_at TIMESTAMPTZ,
  onboarding_completed_at TIMESTAMPTZ,
  onboarding_skipped BOOLEAN DEFAULT false,

  -- Metadata
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### Design Decisions

1. **UUID Primary Key**: Uses `gen_random_uuid()` for globally unique IDs
2. **Unique Slug**: URL-safe identifier for organizations (e.g., "acme-foods")
3. **Onboarding State**: Tracks wizard progress (0-6 steps) for Story 01.3
4. **Soft Delete**: `is_active` flag instead of hard deletes
5. **Timestamps**: Auto-populated created_at/updated_at for audit trail

#### Indexes

```sql
CREATE INDEX IF NOT EXISTS idx_organizations_slug ON organizations(slug);
CREATE INDEX IF NOT EXISTS idx_organizations_active ON organizations(is_active);
```

**Rationale:**
- `idx_organizations_slug`: Fast lookup for URL-based routing
- `idx_organizations_active`: Filter active orgs without full table scan

#### Why These Defaults?

- **timezone='UTC'**: Universal default, users can change to local timezone
- **locale='en'**: English default, customizable per organization
- **currency='PLN'**: Polish złoty (target market), customizable
- **onboarding_step=0**: New orgs start at step 0 (not started)

---

### 055: Create Roles Table

**File:** `supabase/migrations/055_create_roles_table.sql`
**Purpose:** Role definitions with JSONB permissions (ADR-012)

#### Schema

```sql
CREATE TABLE IF NOT EXISTS roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  code VARCHAR(50) UNIQUE NOT NULL,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  permissions JSONB NOT NULL,
  is_system BOOLEAN DEFAULT true,
  display_order INT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### Design Decisions

1. **JSONB Permissions**: Flexible permission structure per ADR-012
   ```json
   {
     "settings": "CRUD",
     "technical": "CRUD",
     "planning": "CR",
     "production": "-"
   }
   ```

2. **System Roles**: `is_system=true` prevents modification/deletion of seeded roles
3. **Display Order**: Controls UI sorting (owner=1, admin=2, etc.)
4. **Unique Code**: Role identifier (owner, admin, manager, etc.)

#### Indexes

```sql
CREATE INDEX IF NOT EXISTS idx_roles_code ON roles(code);
CREATE INDEX IF NOT EXISTS idx_roles_system ON roles(is_system);
```

**Rationale:**
- `idx_roles_code`: Fast role lookup by code (used frequently)
- `idx_roles_system`: Separate system vs custom roles

#### Why JSONB for Permissions?

**Alternatives considered:**
1. **Separate permissions table** - Too many JOINs, complex queries
2. **Bitmask** - Not flexible, hard to extend
3. **JSONB** ✅ - Flexible, queryable, extensible

**Benefits:**
- Add new modules without schema changes
- Query with `permissions->>'settings'`
- Index with GIN for fast lookups
- Easy to serialize/deserialize

---

### 056: Create Users Table

**File:** `supabase/migrations/056_create_users_table.sql`
**Purpose:** User records linked to Supabase Auth

#### Schema

```sql
CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  org_id UUID NOT NULL REFERENCES organizations(id),
  email TEXT NOT NULL,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  role_id UUID NOT NULL REFERENCES roles(id),
  language TEXT DEFAULT 'en',
  is_active BOOLEAN DEFAULT true,
  last_login_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT users_org_email_unique UNIQUE(org_id, email)
);
```

#### Design Decisions

1. **FK to auth.users**: Links to Supabase Auth system (id matches auth.users.id)
2. **org_id Required**: Every user belongs to exactly one organization
3. **UNIQUE(org_id, email)**: Same email can exist in different orgs
4. **role_id FK**: Links to roles table (enforces referential integrity)
5. **Denormalized email**: Cached from auth.users for performance

#### Indexes

```sql
CREATE INDEX IF NOT EXISTS idx_users_org_email ON users(org_id, email);
CREATE INDEX IF NOT EXISTS idx_users_org_active ON users(org_id, is_active);
CREATE INDEX IF NOT EXISTS idx_users_role ON users(role_id);
```

**Rationale:**
- `idx_users_org_email`: Fast user lookup within organization
- `idx_users_org_active`: List active users per org (common query)
- `idx_users_role`: RLS admin check (role-based queries)
- Primary key on `id` automatically indexed (used by ADR-013 RLS pattern)

#### Why UNIQUE(org_id, email)?

**Scenario:** user@example.com works for both ACME Foods and Beta Corp.

**Without constraint:**
```
users table:
  {id: uuid-1, org_id: acme, email: user@example.com}
  {id: uuid-2, org_id: acme, email: user@example.com}  ❌ Duplicate!
```

**With UNIQUE(org_id, email):**
```
users table:
  {id: uuid-1, org_id: acme, email: user@example.com}   ✅ OK
  {id: uuid-2, org_id: beta, email: user@example.com}   ✅ OK (different org)
  {id: uuid-3, org_id: acme, email: user@example.com}   ❌ Constraint violation
```

---

### 057: Create Modules Tables

**File:** `supabase/migrations/057_create_modules_tables.sql`
**Purpose:** Module definitions and org-specific toggle state (ADR-011)

#### Schema

```sql
CREATE TABLE IF NOT EXISTS modules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  code VARCHAR(50) UNIQUE NOT NULL,
  name VARCHAR(100) NOT NULL,
  dependencies TEXT[],
  can_disable BOOLEAN DEFAULT true,
  display_order INT
);

CREATE TABLE IF NOT EXISTS organization_modules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id),
  module_id UUID NOT NULL REFERENCES modules(id),
  enabled BOOLEAN DEFAULT false,
  enabled_at TIMESTAMPTZ,
  enabled_by UUID REFERENCES users(id),
  CONSTRAINT org_modules_unique UNIQUE(org_id, module_id)
);
```

#### Design Decisions

1. **Modules Table (Global)**: Defines available modules for all orgs
2. **TEXT[] Dependencies**: Array of module codes (e.g., `['settings', 'technical']`)
3. **can_disable Flag**: Settings and Technical cannot be disabled
4. **organization_modules (Per-Org)**: Toggle state per organization
5. **Audit Fields**: Track who enabled module and when

#### Indexes

```sql
-- Modules table
CREATE INDEX IF NOT EXISTS idx_modules_code ON modules(code);
CREATE INDEX IF NOT EXISTS idx_modules_display_order ON modules(display_order);

-- Organization_modules table
CREATE INDEX IF NOT EXISTS idx_organization_modules_org ON organization_modules(org_id);
CREATE INDEX IF NOT EXISTS idx_organization_modules_module ON organization_modules(module_id);
CREATE INDEX IF NOT EXISTS idx_organization_modules_enabled ON organization_modules(enabled);
```

**Rationale:**
- `idx_modules_code`: Fast module lookup
- `idx_modules_display_order`: UI sorting without full scan
- `idx_organization_modules_org`: List modules for specific org
- `idx_organization_modules_enabled`: Filter enabled modules

#### Why Separate Tables?

**Alternative: Single table with org_id**
```sql
❌ modules (id, org_id, code, name, enabled, ...)
```

**Problems:**
1. Module definitions duplicated per org
2. Cannot update module metadata globally
3. Dependencies stored per-org (inconsistent)

**Current Design (ADR-011):**
```sql
✅ modules (id, code, name, dependencies, ...)           -- Global definitions
✅ organization_modules (org_id, module_id, enabled, ...) -- Per-org state
```

**Benefits:**
1. Single source of truth for module definitions
2. Add new module once, available to all orgs
3. Org-specific state in separate table
4. Easy to query "which orgs have module X enabled?"

---

### 058: RLS Policies

**File:** `supabase/migrations/058_rls_policies.sql`
**Purpose:** Row Level Security policies for tenant isolation (ADR-013)

#### RLS Pattern (ADR-013)

All org-scoped tables use the same pattern:

```sql
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()))
```

**Why this pattern?**

**Alternative 1: JWT Claims**
```sql
❌ USING (org_id = (auth.jwt()->>'org_id')::uuid)
```

**Problems:**
- JWT claims are static until refresh
- User org reassignment requires logout/login
- Custom claims need additional configuration

**Alternative 2: Custom Function**
```sql
❌ USING (org_id = get_user_org_id())
```

**Problems:**
- Extra function maintenance
- Potential cache issues
- Less transparent

**Current Pattern (ADR-013):** ✅
```sql
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()))
```

**Benefits:**
1. Single source of truth (users table)
2. Immediate effect on org reassignment
3. No custom configuration required
4. <1ms overhead (indexed PK lookup)

#### Policy Breakdown

##### Organizations Table

```sql
-- SELECT: User can read own org only
CREATE POLICY organizations_select_own
ON organizations FOR SELECT
USING (id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- UPDATE: Admin only
CREATE POLICY organizations_update_admin
ON organizations FOR UPDATE
USING (
  id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND (
    SELECT r.code FROM roles r
    JOIN users u ON u.role_id = r.id
    WHERE u.id = auth.uid()
  ) IN ('owner', 'admin')
);
```

**Decisions:**
- No INSERT/DELETE on organizations (managed via signup flow)
- UPDATE requires admin role (owner or admin)
- Viewers cannot modify organization settings

##### Users Table

```sql
-- SELECT: Same org only
CREATE POLICY users_select_same_org
ON users FOR SELECT
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- INSERT/UPDATE/DELETE: Admin only
CREATE POLICY users_insert_admin
ON users FOR INSERT
WITH CHECK (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND (
    SELECT r.code FROM roles r
    JOIN users u ON u.role_id = r.id
    WHERE u.id = auth.uid()
  ) IN ('owner', 'admin')
);

CREATE POLICY users_update_admin
ON users FOR UPDATE
USING (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND (
    SELECT r.code FROM roles r
    JOIN users u ON u.role_id = r.id
    WHERE u.id = auth.uid()
  ) IN ('owner', 'admin')
);

CREATE POLICY users_delete_admin
ON users FOR DELETE
USING (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND (
    SELECT r.code FROM roles r
    JOIN users u ON u.role_id = r.id
    WHERE u.id = auth.uid()
  ) IN ('owner', 'admin')
);
```

**Decisions:**
- All users can read same-org users
- Only admins can create/update/delete users
- Viewers have read-only access

##### Roles Table

```sql
-- SELECT: Public read (system roles)
CREATE POLICY roles_select_all
ON roles FOR SELECT
USING (is_system = true);
```

**Decisions:**
- System roles are globally readable
- No org_id (roles are shared across orgs)
- Custom roles (Story 01.6) will have org-specific policies

##### Modules Table

```sql
-- SELECT: Public read
CREATE POLICY modules_select_all
ON modules FOR SELECT
USING (true);
```

**Decisions:**
- Module definitions are globally readable
- No org_id (modules are shared across orgs)
- No INSERT/UPDATE/DELETE (managed via migrations)

##### Organization_Modules Table

```sql
-- SELECT: Same org
CREATE POLICY organization_modules_select_same_org
ON organization_modules FOR SELECT
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- INSERT/UPDATE/DELETE: Admin only
CREATE POLICY organization_modules_insert_admin
ON organization_modules FOR INSERT
WITH CHECK (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND (
    SELECT r.code FROM roles r
    JOIN users u ON u.role_id = r.id
    WHERE u.id = auth.uid()
  ) IN ('owner', 'admin')
);

-- Similar for UPDATE and DELETE
```

**Decisions:**
- Users can see own org's module toggle state
- Only admins can enable/disable modules
- Prevents unauthorized module activation

#### Performance Considerations

**RLS Overhead:**
- Users lookup: <1ms (PK index on users.id)
- Role check: <2ms (FK index on users.role_id)
- Total overhead: <3ms per query

**Verified with EXPLAIN ANALYZE:**
```sql
EXPLAIN ANALYZE
SELECT * FROM users
WHERE org_id = (SELECT org_id FROM users WHERE id = 'user-uuid');

-- Planning Time: 0.234 ms
-- Execution Time: 0.687 ms
-- RLS Overhead: ~0.5ms
```

---

### 059: Seed System Data

**File:** `supabase/migrations/059_seed_system_data.sql`
**Purpose:** Populate system roles and modules

#### System Roles (10 Roles)

```sql
INSERT INTO roles (code, name, description, permissions, is_system, display_order)
VALUES
  ('owner', 'Owner', 'Full system access', '{"settings":"CRUD","technical":"CRUD",...}', true, 1),
  ('admin', 'Administrator', 'Administrative access', '{"settings":"CRUD",...}', true, 2),
  ('manager', 'Manager', 'Department management', '{"planning":"CRUD",...}', true, 3),
  ('supervisor', 'Production Supervisor', 'Production oversight', '{"production":"CRUD",...}', true, 4),
  ('operator', 'Production Operator', 'Execute production', '{"production":"CR",...}', true, 5),
  ('warehouse', 'Warehouse Worker', 'Inventory management', '{"warehouse":"CRUD",...}', true, 6),
  ('quality', 'Quality Inspector', 'Quality control', '{"quality":"CRUD",...}', true, 7),
  ('shipping', 'Shipping Clerk', 'Order fulfillment', '{"shipping":"CRUD",...}', true, 8),
  ('viewer', 'Viewer', 'Read-only access', '{"settings":"R",...}', true, 9),
  ('custom', 'Custom Role', 'Placeholder for custom roles', '{}', false, 10)
ON CONFLICT (code) DO NOTHING;
```

**Design Decisions:**
- **10 predefined roles**: Cover common food manufacturing scenarios
- **is_system=true**: Prevent modification of seeded roles
- **display_order**: UI sorting (owner first, viewer last)
- **Idempotent**: `ON CONFLICT (code) DO NOTHING` allows reruns

#### Modules (11 Modules)

```sql
INSERT INTO modules (code, name, dependencies, can_disable, display_order)
VALUES
  ('settings', 'Settings', '[]', false, 1),
  ('technical', 'Technical Data', '["settings"]', false, 2),
  ('planning', 'Production Planning', '["technical"]', true, 3),
  ('production', 'Production Execution', '["planning"]', true, 4),
  ('warehouse', 'Warehouse Management', '["technical"]', true, 5),
  ('quality', 'Quality Management', '["production"]', true, 6),
  ('shipping', 'Shipping & Logistics', '["warehouse"]', true, 7),
  ('npd', 'New Product Development', '["technical"]', true, 8),
  ('finance', 'Finance & Costing', '["production"]', true, 9),
  ('oee', 'OEE Monitoring', '["production"]', true, 10),
  ('integrations', 'Integrations', '["settings"]', true, 11)
ON CONFLICT (code) DO NOTHING;
```

**Design Decisions:**
- **11 core modules**: Match PRD structure
- **Dependencies**: TEXT[] array (e.g., Planning depends on Technical)
- **can_disable=false**: Settings and Technical are always enabled
- **Idempotent**: `ON CONFLICT (code) DO NOTHING`

#### Why These Modules?

**Core (cannot disable):**
- Settings: System configuration
- Technical: Master data (products, BOMs, customers)

**Optional (can disable):**
- Planning: Work orders, scheduling
- Production: Shop floor execution
- Warehouse: Inventory, receiving, putaway
- Quality: Inspections, non-conformances
- Shipping: Picking, packing, delivery
- NPD: Recipe development, trials
- Finance: Cost tracking, invoicing
- OEE: Downtime tracking, efficiency metrics
- Integrations: ERP, accounting, e-commerce

---

## Rollback Strategy

### Manual Rollback

```sql
-- Rollback in reverse order (059 → 054)

-- 059: Clear seed data
DELETE FROM roles WHERE is_system = true;
DELETE FROM modules WHERE code IN ('settings', 'technical', ...);

-- 058: Drop RLS policies
DROP POLICY IF EXISTS organizations_select_own ON organizations;
DROP POLICY IF EXISTS organizations_update_admin ON organizations;
-- ... (drop all policies)

-- 057: Drop modules tables
DROP TABLE IF EXISTS organization_modules CASCADE;
DROP TABLE IF EXISTS modules CASCADE;

-- 056: Drop users table
DROP TABLE IF EXISTS users CASCADE;

-- 055: Drop roles table
DROP TABLE IF EXISTS roles CASCADE;

-- 054: Drop organizations table
DROP TABLE IF EXISTS organizations CASCADE;
```

### Supabase CLI Rollback

```bash
# Reset to specific migration
supabase db reset --migration 053

# Or rollback one migration
supabase migration down
```

**Warning:** Rollback will delete all data in affected tables. Use with caution.

---

## Testing

### Migration Testing

```bash
# Apply migrations
supabase migration up

# Verify tables exist
psql $DATABASE_URL -c "\dt organizations users roles modules organization_modules"

# Verify RLS enabled
psql $DATABASE_URL -c "SELECT tablename, rowsecurity FROM pg_tables WHERE tablename IN ('organizations', 'users');"

# Verify seed data
psql $DATABASE_URL -c "SELECT code, name FROM roles ORDER BY display_order;"
psql $DATABASE_URL -c "SELECT code, name FROM modules ORDER BY display_order;"
```

### RLS Testing

See: `supabase/tests/rls-isolation.test.sql` (15 test scenarios)

**Key Tests:**
1. Cross-tenant access returns empty (not error)
2. Admin can update org, viewer cannot
3. Users can only see same-org users
4. Role-based write enforcement

---

## Dependencies

### Story Dependencies

**Blocks:**
- 01.2 - Organization Profile API (needs org context)
- 01.6 - User Management (needs users table + RLS)
- 01.8 - Organization Update (needs org table + policies)
- All Settings stories (foundation dependency)

### Database Dependencies

**Requires:**
- Supabase Auth schema (`auth.users` table)
- PostgreSQL 12+ (JSONB, TEXT[], RLS support)

---

## Lessons Learned

### What Went Well

1. **Single Query Pattern**: JOINs in org-context-service prevent N+1 queries
2. **Idempotent Migrations**: `IF NOT EXISTS` and `ON CONFLICT` allow reruns
3. **Comprehensive Indexes**: All FK columns indexed for performance
4. **Clear Comments**: SQL comments aid understanding months later

### Challenges

1. **Test Fixtures**: Initial tests used non-UUID strings, failed validation
2. **RLS Complexity**: Admin enforcement requires subquery (2 JOINs)
3. **Permission Format**: Balancing flexibility vs structure in JSONB

### Improvements for Next Stories

1. **Add Migration Tests**: Automate SQL testing in CI/CD
2. **Document Performance**: Add EXPLAIN ANALYZE results to migrations
3. **Version Seed Data**: Track changes to system roles/modules

---

## References

- [ADR-011: Module Toggle Storage](../../1-BASELINE/architecture/decisions/ADR-011-module-toggle-storage.md)
- [ADR-012: Role Permission Storage](../../1-BASELINE/architecture/decisions/ADR-012-role-permission-storage.md)
- [ADR-013: RLS Org Isolation Pattern](../../1-BASELINE/architecture/decisions/ADR-013-rls-org-isolation-pattern.md)
- [API Documentation: GET /api/v1/settings/context](../api/settings/context.md)
- [Developer Guide: Using Org Context](../guides/using-org-context.md)

---

**Created:** 2025-12-16
**Updated:** 2025-12-16
**Author:** TECH-WRITER Agent
