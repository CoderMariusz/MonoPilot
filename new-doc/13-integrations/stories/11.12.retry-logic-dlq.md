# 11.12 - Retry Logic & Dead Letter Queue

**Priority**: P1 (Phase 2)
**Story Points**: M (Medium)
**Type**: backend + frontend
**Phase**: 2
**Model**: OPUS

**State:** ready
**Estimate:** M (3-4 days)
**Primary PRD:** `docs/1-BASELINE/product/modules/integrations.md` (FR-INT-020, FR-INT-021, Section 4.2)
**Architecture:** Exponential backoff retry, DLQ for permanent failures, manual retry UI

---

## Goal

Implement robust error handling for failed integration events (webhooks, EDI, Comarch sync) with automatic retry logic (exponential backoff, max 3 attempts) and Dead Letter Queue (DLQ) for permanent failures. Administrators can view failed events, manually retry, or mark as resolved.

---

## MVP Scope

**MVP Includes**:
- `integration_retry_queue` table (pending retries)
- Automatic retry logic (exponential backoff: 5s, 30s, 5min)
- Max retry attempts = 3 (configurable)
- Dead Letter Queue (DLQ) for failed events
- Retry queue UI at `/integrations/logs/retry-queue`
- DLQ UI at `/integrations/logs/dead-letter-queue`
- Manual retry action
- Bulk retry action (select multiple)
- Skip action (move to DLQ without retry)
- GET /api/integrations/retry-queue (list)
- POST /api/integrations/retry-queue/:id/retry (manual retry)
- POST /api/integrations/retry-queue/bulk-retry (retry multiple)
- POST /api/integrations/retry-queue/:id/skip (move to DLQ)

**Deferred to Phase 3**:
- Custom retry policies per integration type
- Webhook endpoint health checks (auto-disable failing endpoints)
- Retry success rate analytics
- Alerting on DLQ threshold (e.g., >50 items)

---

## User Story

As a **MonoPilot Administrator**, I want to **automatically retry failed integration events** so that **temporary network errors or external system downtime don't cause data loss**.

As a **MonoPilot Administrator**, I want to **view and manually retry permanently failed events** so that **I can investigate root causes and recover from errors**.

---

## Scope

**In scope (this story)**
- Retry queue table and logic
- Exponential backoff (5s, 30s, 5min)
- DLQ for max_retries exceeded
- Retry queue UI (list, manual retry, skip)
- DLQ UI (list, manual fix & retry, delete)
- Bulk actions (retry all, skip all)
- Integration logs linkage
- Notification on DLQ addition (optional)

**Out of scope (this story)**
- Custom retry policies (Phase 3)
- Endpoint health monitoring (Phase 3)
- Alerting (Phase 3)
- Retry analytics (Phase 3)

---

## Dependencies

### Cross-Epic Dependencies

| Dependency | Story/Epic | Type | What It Provides | Status |
|------------|------------|------|------------------|--------|
| 01.1 | Org Context + RLS | HARD | organizations table | Ready |

### Within Epic Dependencies

| Dependency | Story | Type | What It Provides |
|------------|-------|------|------------------|
| 11.3 | Integration Logs | HARD | integration_logs table | Ready |
| 11.4 | Webhooks | HARD | Webhook delivery failures | Ready |
| 11.8 | EDI ORDERS | SOFT | EDI processing failures | Ready |

### Provides To (Downstream)

| Story | What This Provides |
|-------|-------------------|
| Phase 3 | Retry patterns for other integrations |

---

## Database Migration

### Migration: Create integration_retry_queue table

```sql
-- Migration: YYYYMMDDHHMMSS_create_integration_retry_queue.sql

CREATE TABLE integration_retry_queue (
    -- Identity
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id              UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

    -- Linked Log Entry
    log_id              UUID NOT NULL REFERENCES integration_logs(id) ON DELETE CASCADE,

    -- Retry Configuration
    retry_count         INTEGER NOT NULL DEFAULT 0,
    max_retries         INTEGER NOT NULL DEFAULT 3,
    retry_policy        TEXT NOT NULL DEFAULT 'exponential'
                        CHECK (retry_policy IN ('immediate', 'exponential', 'manual')),

    -- Scheduling
    next_retry_at       TIMESTAMPTZ,
    last_retry_at       TIMESTAMPTZ,

    -- Status
    status              TEXT NOT NULL DEFAULT 'pending'
                        CHECK (status IN ('pending', 'in_progress', 'succeeded', 'failed')),
    in_dlq              BOOLEAN NOT NULL DEFAULT false,

    -- Error Details
    error_message       TEXT,
    error_stack         TEXT,

    -- Audit
    created_at          TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at          TIMESTAMPTZ NOT NULL DEFAULT now(),

    -- Constraints
    CONSTRAINT check_dlq_status CHECK (
        (in_dlq = true AND status = 'failed') OR
        (in_dlq = false)
    )
);

-- Indexes
CREATE INDEX idx_retry_queue_org ON integration_retry_queue(org_id);
CREATE INDEX idx_retry_queue_status ON integration_retry_queue(org_id, status) WHERE in_dlq = false;
CREATE INDEX idx_retry_queue_dlq ON integration_retry_queue(org_id) WHERE in_dlq = true;
CREATE INDEX idx_retry_queue_next_retry ON integration_retry_queue(next_retry_at) WHERE status = 'pending';
CREATE INDEX idx_retry_queue_log ON integration_retry_queue(log_id);

-- RLS Policies
ALTER TABLE integration_retry_queue ENABLE ROW LEVEL SECURITY;

CREATE POLICY "retry_queue_select" ON integration_retry_queue
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "retry_queue_update" ON integration_retry_queue
    FOR UPDATE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND EXISTS (
            SELECT 1 FROM users
            WHERE id = auth.uid()
            AND role IN ('ADMIN', 'IT_MANAGER')
        )
    );

-- Updated_at trigger
CREATE TRIGGER update_retry_queue_updated_at
    BEFORE UPDATE ON integration_retry_queue
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================================================
-- Function: Calculate Next Retry Time (Exponential Backoff)
-- =============================================================================

CREATE OR REPLACE FUNCTION calculate_next_retry(
    p_retry_count INTEGER,
    p_retry_policy TEXT
) RETURNS TIMESTAMPTZ AS $$
DECLARE
    v_delay_seconds INTEGER;
BEGIN
    CASE p_retry_policy
        WHEN 'immediate' THEN
            v_delay_seconds := 5; -- Always 5 seconds
        WHEN 'exponential' THEN
            -- Exponential backoff: 5s, 30s, 5min
            CASE p_retry_count
                WHEN 0 THEN v_delay_seconds := 5;
                WHEN 1 THEN v_delay_seconds := 30;
                WHEN 2 THEN v_delay_seconds := 300; -- 5 minutes
                ELSE v_delay_seconds := 300;
            END CASE;
        WHEN 'manual' THEN
            v_delay_seconds := NULL; -- No auto-retry
        ELSE
            v_delay_seconds := 5;
    END CASE;

    IF v_delay_seconds IS NULL THEN
        RETURN NULL;
    ELSE
        RETURN NOW() + (v_delay_seconds || ' seconds')::INTERVAL;
    END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

---

## Acceptance Criteria (Given/When/Then)

### AC-1: Auto-Retry on Webhook Failure

```gherkin
Scenario: Webhook delivery fails (network error)
  Given webhook delivery to https://example.com/webhook
  And request returns 503 Service Unavailable
  When webhook fails
  Then integration_logs entry created with status = 'error'
  And integration_retry_queue record created:
    | Field | Value |
    | retry_count | 0 |
    | max_retries | 3 |
    | retry_policy | exponential |
    | next_retry_at | now + 5 seconds |
    | status | pending |
  And after 5 seconds: system auto-retries webhook

Scenario: Retry succeeds on attempt 2
  Given retry_queue entry with retry_count = 1
  When retry executes and webhook returns 200 OK
  Then status = 'succeeded'
  And entry removed from retry queue
  And integration_logs updated: status = 'success'

Scenario: Retry fails again
  Given retry_queue entry with retry_count = 1
  When retry executes and webhook returns 503 again
  Then retry_count = 2
  And next_retry_at = now + 5 minutes (exponential backoff)
  And status remains 'pending'
```

### AC-2: Move to DLQ After Max Retries

```gherkin
Scenario: Max retries exceeded
  Given retry_queue entry with retry_count = 3
  And max_retries = 3
  When retry executes and fails again
  Then status = 'failed'
  And in_dlq = true
  And next_retry_at = null
  And error_message updated
  And notification sent to admin (optional)

Scenario: DLQ entry created
  Given entry moved to DLQ
  When viewing DLQ
  Then entry visible in Dead Letter Queue table
  And shows original error, retry history
  And actions: [Manual Retry], [Delete], [Mark Resolved]
```

### AC-3: Retry Queue UI

```gherkin
Scenario: View retry queue
  Given admin navigates to /integrations/logs/retry-queue
  Then DataTable displays retry_queue entries (where in_dlq = false):
    | Column | Description |
    | Event Type | From integration_logs |
    | External System | From integration_logs |
    | Error | Error message |
    | Retry Count | X / 3 |
    | Next Retry At | Timestamp |
    | Actions | [Retry Now], [Skip], [View Log] |
  And filter by status, event type
  And sort by next_retry_at ASC (default)

Scenario: Filter by status
  Given retry queue has pending and in_progress entries
  When filtering by status = 'pending'
  Then only pending entries displayed
```

### AC-4: Manual Retry Action

```gherkin
Scenario: Admin manually retries failed event
  Given retry_queue entry with status = 'pending'
  When clicking [Retry Now]
  Then status changes to 'in_progress'
  And backend immediately retries integration
  And if succeeds: status = 'succeeded', removed from queue
  And if fails: retry_count incremented, next_retry_at recalculated

Scenario: Manual retry success
  Given webhook previously failed
  And admin fixes webhook endpoint
  When clicking [Retry Now]
  And webhook returns 200 OK
  Then status = 'succeeded'
  And success toast: "Retry successful. Event removed from queue."
```

### AC-5: Skip Action (Move to DLQ)

```gherkin
Scenario: Admin skips retry and moves to DLQ
  Given retry_queue entry with retry_count = 1
  When clicking [Skip]
  Then confirmation modal: "Skip retry and move to Dead Letter Queue?"
  And if confirmed: status = 'failed', in_dlq = true
  And next_retry_at = null
  And entry removed from retry queue, visible in DLQ
```

### AC-6: Bulk Retry Action

```gherkin
Scenario: Admin retries multiple events
  Given retry queue has 10 entries
  And admin selects 5 entries
  When clicking [Retry All Selected]
  Then all 5 entries status = 'in_progress'
  And backend retries all 5 in parallel
  And progress shown (3/5 succeeded, 2/5 failed)
  And success toast: "Bulk retry complete. 3 succeeded, 2 failed."
```

### AC-7: Dead Letter Queue UI

```gherkin
Scenario: View DLQ
  Given admin navigates to /integrations/logs/dead-letter-queue
  Then DataTable displays retry_queue entries (where in_dlq = true):
    | Column | Description |
    | Event Type | Integration type |
    | External System | System name |
    | Error | Error message |
    | Retry Count | 3 / 3 (max) |
    | Created At | When first failed |
    | Actions | [Manual Retry], [Delete], [Mark Resolved] |
  And filter by event type, date range
  And sort by created_at DESC (default)

Scenario: Empty DLQ
  Given no entries in DLQ
  Then empty state: "No failed events. All integrations healthy."
```

### AC-8: Manual Fix & Retry from DLQ

```gherkin
Scenario: Admin fixes issue and retries DLQ entry
  Given DLQ entry for failed webhook (endpoint was down)
  And admin confirms webhook endpoint is now healthy
  When clicking [Manual Retry]
  Then retry_queue entry reset:
    | Field | Value |
    | retry_count | 0 |
    | max_retries | 3 |
    | in_dlq | false |
    | status | pending |
    | next_retry_at | now + 5 seconds |
  And backend retries webhook
  And if succeeds: entry removed from queue
  And if fails: re-enters retry queue (not DLQ immediately)
```

### AC-9: Delete DLQ Entry

```gherkin
Scenario: Admin deletes unrecoverable DLQ entry
  Given DLQ entry for webhook that will never succeed (endpoint removed)
  When clicking [Delete]
  Then confirmation modal: "Permanently delete this entry?"
  And if confirmed: retry_queue entry deleted
  And integration_logs entry remains (for audit)
  And success toast: "Entry deleted from DLQ."
```

### AC-10: Exponential Backoff Calculation

```gherkin
Scenario: Retry delays increase exponentially
  Given retry_queue entry with retry_policy = 'exponential'
  And retry_count progression: 0 -> 1 -> 2
  Then next_retry_at calculated as:
    | Retry Count | Delay |
    | 0 | now + 5 seconds |
    | 1 | now + 30 seconds |
    | 2 | now + 5 minutes |
  And each retry scheduled accordingly

Scenario: Immediate retry policy
  Given retry_policy = 'immediate'
  Then all retries have 5 second delay
  And no exponential backoff

Scenario: Manual retry policy
  Given retry_policy = 'manual'
  Then next_retry_at = null
  And no auto-retry (admin must manually retry)
```

### AC-11: Integration Logs Linkage

```gherkin
Scenario: View linked integration log from retry queue
  Given retry_queue entry for webhook failure
  When clicking [View Log]
  Then navigates to integration_logs detail page
  And shows request/response, error stack, timestamp
```

### AC-12: Retry Success Updates Log

```gherkin
Scenario: Successful retry updates original log
  Given integration_logs entry with status = 'error'
  And linked retry_queue entry
  When retry succeeds
  Then integration_logs.status updated to 'success'
  And integration_logs.response_body updated with retry response
  And note added: "Succeeded on retry attempt 2"
```

---

## Implementation Notes

### Retry Logic Flow

```
┌──────────────────┐
│ Integration      │
│ Event Fails      │
└────────┬─────────┘
         │
         v
┌─────────────────────────┐
│ Create Retry Queue      │
│ Entry (retry_count=0)   │
└────────┬────────────────┘
         │
         v
┌─────────────────────────┐
│ Calculate next_retry_at │
│ (5 seconds)             │
└────────┬────────────────┘
         │
         │ Wait 5 seconds...
         │
         v
┌─────────────────────────┐
│ Auto-Retry (Attempt 1)  │
└────────┬────────────────┘
         │
    ┌────┴────┐
    │         │
    v         v
Success   Failure
    │         │
    v         v
Remove    Increment retry_count
From      Calculate next_retry_at
Queue     (30 seconds)
    │         │
    │         │ Wait 30 seconds...
    │         │
    │         v
    │     Auto-Retry (Attempt 2)
    │         │
    │    ┌────┴────┐
    │    │         │
    │    v         v
    │ Success   Failure
    │    │         │
    │    v         v
    │ Remove    Increment retry_count
    │ From      Calculate next_retry_at
    │ Queue     (5 minutes)
    │    │         │
    │    │         │ Wait 5 minutes...
    │    │         │
    │    │         v
    │    │     Auto-Retry (Attempt 3)
    │    │         │
    │    │    ┌────┴────┐
    │    │    │         │
    │    │    v         v
    │    │ Success   Failure
    │    │    │         │
    │    │    v         v
    │    │ Remove    Move to DLQ
    │    │ From      (in_dlq=true)
    │    │ Queue
    │    │
    └────┴──> Done
```

### Service Layer

```typescript
// lib/services/retry-service.ts

export class RetryService {
  /**
   * Add failed event to retry queue
   */
  static async addToRetryQueue(
    logId: string,
    retryPolicy: 'immediate' | 'exponential' | 'manual',
    maxRetries: number = 3
  ): Promise<void>;

  /**
   * Process retry queue (scheduled job)
   */
  static async processRetryQueue(): Promise<void>;

  /**
   * Manual retry
   */
  static async manualRetry(retryId: string, userId: string): Promise<void>;

  /**
   * Bulk retry
   */
  static async bulkRetry(retryIds: string[], userId: string): Promise<{
    succeeded: number;
    failed: number;
  }>;

  /**
   * Skip retry and move to DLQ
   */
  static async skipToDLQ(retryId: string, userId: string): Promise<void>;

  /**
   * Delete DLQ entry
   */
  static async deleteDLQEntry(retryId: string, userId: string): Promise<void>;

  /**
   * Get retry queue (not in DLQ)
   */
  static async getRetryQueue(orgId: string): Promise<RetryQueueEntry[]>;

  /**
   * Get DLQ entries
   */
  static async getDLQ(orgId: string): Promise<RetryQueueEntry[]>;
}
```

---

## Key Business Rules

1. **Max Retries**: Default 3 attempts (configurable per integration type)
2. **Exponential Backoff**: 5s -> 30s -> 5min (prevents overwhelming external systems)
3. **DLQ Threshold**: If DLQ > 50 items, send alert to admin (Phase 3)
4. **Manual Retry Resets Count**: Manual retry from DLQ resets retry_count to 0
5. **Retry Policy**: 'exponential' default, 'manual' for critical integrations
6. **Audit Trail**: All retry attempts logged to integration_logs
7. **Scheduled Job**: Background job checks next_retry_at every minute

---

## Deliverables

### Database
- [ ] Migration: `integration_retry_queue` table
- [ ] Function: `calculate_next_retry()`
- [ ] RLS policies
- [ ] Indexes

### API Routes
- [ ] `GET /api/integrations/retry-queue`
- [ ] `POST /api/integrations/retry-queue/:id/retry`
- [ ] `POST /api/integrations/retry-queue/bulk-retry`
- [ ] `POST /api/integrations/retry-queue/:id/skip`
- [ ] `GET /api/integrations/dead-letter-queue`
- [ ] `DELETE /api/integrations/dead-letter-queue/:id`

### Service Layer
- [ ] `RetryService.addToRetryQueue()`
- [ ] `RetryService.processRetryQueue()`
- [ ] `RetryService.manualRetry()`
- [ ] `RetryService.bulkRetry()`
- [ ] `RetryService.skipToDLQ()`

### Frontend
- [ ] Retry queue page
- [ ] DLQ page
- [ ] Manual retry action
- [ ] Bulk retry action
- [ ] Skip action
- [ ] Delete action

### Background Jobs
- [ ] Scheduled job (every 1 minute) to process retry queue

### Tests
- [ ] Unit tests: Retry logic, backoff calculation (>80% coverage)
- [ ] Integration tests: All endpoints
- [ ] E2E: Fail -> Retry -> Succeed / Fail -> DLQ

---

## Definition of Done

### Database
- [ ] Tables created with RLS
- [ ] Function created
- [ ] Indexes created

### API
- [ ] All endpoints functional
- [ ] Retry logic works
- [ ] DLQ management works

### Service
- [ ] Auto-retry with backoff
- [ ] Manual retry
- [ ] Bulk retry
- [ ] DLQ operations

### Frontend
- [ ] Retry queue displays
- [ ] DLQ displays
- [ ] Actions functional

### Testing
- [ ] Unit tests: >80% coverage
- [ ] Integration tests: All endpoints
- [ ] E2E: Full flow passing

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Retry storm (too many retries) | MEDIUM | LOW | Exponential backoff, max retries limit |
| DLQ grows unbounded | LOW | MEDIUM | Alerts on threshold (Phase 3) |
| Scheduled job failure | MEDIUM | LOW | Monitor job health, alerting |

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2026-01-15 | Initial Phase 2 story creation | ARCHITECT |

---

**Document Status**: Ready for Implementation
**Created**: 2026-01-15
**Lines**: ~550
**Complexity**: M (Medium)
**Phase**: 2
