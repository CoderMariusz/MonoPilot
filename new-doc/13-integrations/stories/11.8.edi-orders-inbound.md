# 11.8 - EDI ORDERS Inbound

**Priority**: P1 (Phase 2)
**Story Points**: L (Large)
**Type**: backend
**Phase**: 2
**Model**: OPUS

**State:** ready
**Estimate:** L (4-5 days)
**Primary PRD:** `docs/1-BASELINE/product/modules/integrations.md` (FR-INT-015, Section 4.2)
**Architecture:** EDIFACT parser, validation engine, sales order auto-creation

---

## Goal

Implement inbound EDI processing for customer purchase orders (EDIFACT ORDERS message). System receives EDI messages from VAN provider, parses EDIFACT format, validates data against MonoPilot entities (customer, products), and auto-creates sales orders (or work orders) with full audit trail and error handling.

---

## Food Safety Compliance

This story supports **traceability and automation**:

- [x] **Order Lineage** - EDI message stored raw, linked to created sales order
- [x] **Audit Trail** - All EDI processing logged (parse, validate, create order)
- [x] **Error Tracking** - Failed orders flagged for manual review

**Regulatory Context:**
- EDI messages may contain allergen requirements (customer-specific)
- Temperature requirements for perishables documented in ORDERS
- All EDI transactions retained for compliance audits

---

## MVP Scope

**MVP Includes**:
- `edi_config` table (VAN provider settings)
- `edi_messages` table (raw EDI storage)
- EDIFACT ORDERS parser (UN/EDIFACT D.96A standard)
- Validation engine (customer exists, product exists, qty > 0)
- Auto-create sales order (or work order if direct-to-production)
- Error handling (validation fails -> "pending review" status)
- EDI inbox UI at `/integrations/edi/inbox`
- Manual process/retry for failed messages
- Integration logs for all EDI events

**Deferred to Phase 3**:
- ORDRSP (Order Response) - acknowledge receipt
- RECADV (Receiving Advice) - inbound
- Additional message types (DESADV, INVOIC covered in 11.9, 11.10)
- VAN provider API integration (MVP: manual file upload)
- Real-time EDI polling (MVP: scheduled job every 15 minutes)

---

## User Story

As a **Large Customer** (e.g., retail chain), I want to **send purchase orders via EDI (EDIFACT ORDERS)** so that **orders are automatically created in MonoPilot without manual data entry, reducing errors and processing time**.

As a **MonoPilot Administrator**, I want to **receive and process EDI ORDERS messages** so that **I can fulfill customer orders faster and meet EDI compliance requirements for major retailers**.

---

## Scope

**In scope (this story)**
- EDI configuration (VAN provider, mailbox, test mode)
- EDIFACT ORDERS message parsing (D.96A standard)
- Validation rules (customer, products, dates, quantities)
- Auto-create sales order (if Epic 03 complete) OR work order (if direct)
- Error handling (parse errors, validation errors)
- Manual file upload (EDI message as .txt or .edi)
- EDI inbox UI (list messages, process, view raw)
- GET /api/integrations/edi/config
- PUT /api/integrations/edi/config
- POST /api/integrations/edi/upload (manual upload)
- POST /api/integrations/edi/process/:id (process message)
- GET /api/integrations/edi/inbox (list messages)
- Integration logs for all EDI events

**Out of scope (this story)**
- ORDRSP (Order Response) - Phase 3
- RECADV (Receiving Advice) - Phase 3
- INVOIC (Invoice) - Story 11.9
- DESADV (ASN) - Story 11.10
- Real-time VAN polling - Phase 3
- Multi-message batch processing - Phase 3

---

## Dependencies

### Cross-Epic Dependencies

| Dependency | Story/Epic | Type | What It Provides | Status |
|------------|------------|------|------------------|--------|
| 01.1 | Org Context + RLS | HARD | organizations table | Ready |
| 02.1 | Products CRUD | HARD | products table for product validation | Ready |
| 03.8 | Sales Orders (future) | SOFT | sales_orders table | Planned |
| 04.1 | Work Orders | HARD | work_orders table (fallback if no sales orders) | Ready |

### Within Epic Dependencies

| Dependency | Story | Type | What It Provides |
|------------|-------|------|------------------|
| 11.1 | Integrations Dashboard | HARD | EDI health status display |
| 11.3 | Integration Logs | HARD | EDI event logging |

### Provides To (Downstream)

| Story | What This Provides |
|-------|-------------------|
| 11.9 | EDIFACT parsing patterns for INVOIC |
| 11.10 | EDIFACT parsing patterns for DESADV |
| Phase 3 | EDI inbox/processing UI patterns |

---

## Database Migration

### Migration: Create edi_config and edi_messages tables

```sql
-- Migration: YYYYMMDDHHMMSS_create_edi_tables.sql

CREATE TABLE edi_config (
    -- Identity
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id              UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

    -- Configuration
    enabled             BOOLEAN NOT NULL DEFAULT false,
    edi_mailbox         TEXT, -- e.g., "MONOPILOT@EANCOM"
    van_provider        TEXT, -- e.g., "Seeburger", "TrueCommerce"
    message_types       JSONB NOT NULL DEFAULT '["ORDERS"]'::jsonb,
    test_mode           BOOLEAN NOT NULL DEFAULT true,

    -- Audit
    created_at          TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at          TIMESTAMPTZ NOT NULL DEFAULT now(),

    -- Constraints
    CONSTRAINT uq_edi_config_org UNIQUE (org_id)
);

CREATE TABLE edi_messages (
    -- Identity
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id              UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

    -- Message Metadata
    direction           TEXT NOT NULL CHECK (direction IN ('inbound', 'outbound')),
    message_type        TEXT NOT NULL, -- ORDERS, INVOIC, DESADV, etc.
    message_content     TEXT NOT NULL, -- Raw EDIFACT message
    file_name           TEXT,

    -- Processing
    status              TEXT NOT NULL DEFAULT 'pending'
                        CHECK (status IN ('pending', 'processing', 'processed', 'error', 'pending_review')),
    partner_id          TEXT, -- Trading partner ID (e.g., GLN)
    reference_id        TEXT, -- PO/Order number extracted from message

    -- Result
    created_entity_type TEXT, -- 'sales_order', 'work_order'
    created_entity_id   UUID,
    error_message       TEXT,
    validation_errors   JSONB,

    -- Timing
    processed_at        TIMESTAMPTZ,
    created_at          TIMESTAMPTZ NOT NULL DEFAULT now(),

    -- Constraints
    CONSTRAINT check_processed_entity CHECK (
        (status = 'processed' AND created_entity_id IS NOT NULL) OR
        (status != 'processed')
    )
);

-- Indexes
CREATE INDEX idx_edi_config_org ON edi_config(org_id);

CREATE INDEX idx_edi_messages_org ON edi_messages(org_id);
CREATE INDEX idx_edi_messages_status ON edi_messages(org_id, status);
CREATE INDEX idx_edi_messages_type ON edi_messages(org_id, message_type);
CREATE INDEX idx_edi_messages_direction ON edi_messages(org_id, direction);
CREATE INDEX idx_edi_messages_created ON edi_messages(org_id, created_at DESC);
CREATE INDEX idx_edi_messages_reference ON edi_messages(org_id, reference_id);

-- RLS Policies
ALTER TABLE edi_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE edi_messages ENABLE ROW LEVEL SECURITY;

CREATE POLICY "edi_config_select" ON edi_config
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "edi_config_manage" ON edi_config
    FOR ALL USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND EXISTS (
            SELECT 1 FROM users
            WHERE id = auth.uid()
            AND role IN ('ADMIN', 'IT_MANAGER')
        )
    );

CREATE POLICY "edi_messages_select" ON edi_messages
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "edi_messages_insert" ON edi_messages
    FOR INSERT WITH CHECK (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "edi_messages_update" ON edi_messages
    FOR UPDATE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND EXISTS (
            SELECT 1 FROM users
            WHERE id = auth.uid()
            AND role IN ('ADMIN', 'IT_MANAGER')
        )
    );

-- Updated_at trigger
CREATE TRIGGER update_edi_config_updated_at
    BEFORE UPDATE ON edi_config
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

---

## Acceptance Criteria (Given/When/Then)

### AC-1: EDI Configuration

```gherkin
Scenario: Admin configures EDI settings
  Given MonoPilot admin navigates to /integrations/edi
  When entering:
    | Field | Value |
    | Enabled | true |
    | EDI Mailbox | MONOPILOT@EANCOM |
    | VAN Provider | Seeburger |
    | Message Types | ORDERS, INVOIC, DESADV |
    | Test Mode | true |
  And clicking [Save]
  Then edi_config record created/updated
  And success toast "EDI configuration saved"

Scenario: Test connection (Phase 3)
  Given EDI config exists
  When clicking [Test Connection]
  Then system validates VAN mailbox access
  And shows success/error message
```

### AC-2: Manual EDI Message Upload

```gherkin
Scenario: Admin uploads ORDERS message
  Given admin navigates to /integrations/edi/inbox
  And clicks [Upload Message]
  When selecting file: ORDERS_2025001.edi
  And file contains valid EDIFACT syntax
  And clicking [Upload]
  Then edi_messages record created
  And status = 'pending'
  And message_content = raw file content
  And message_type = 'ORDERS' (detected from UNH segment)
  And success toast "Message uploaded. Ready to process."

Scenario: Invalid file format
  Given admin uploads non-EDIFACT file
  Then error: "Invalid EDIFACT format. Expected UNA/UNB header."
  And file rejected
```

### AC-3: Parse EDIFACT ORDERS Message

```gherkin
Scenario: Parse valid ORDERS message
  Given edi_message with message_type = 'ORDERS'
  And message contains:
    | Segment | Value |
    | BGM.C002.1001 | 220 (purchase order) |
    | BGM.C002.1004 | PO-2025-001 (order number) |
    | DTM.2005 | 20250115 (order date) |
    | NAD+BY | 5412345000013 (buyer GLN) |
    | LIN.1082 | 1 (line 1) |
    | PIA.C212.7140 | PROD-001 (product code) |
    | QTY.6060 | 1000 (quantity) |
  When processing message
  Then system parses:
    | Field | Value |
    | order_number | PO-2025-001 |
    | order_date | 2025-01-15 |
    | customer_gln | 5412345000013 |
    | line_items[0].product_code | PROD-001 |
    | line_items[0].qty | 1000 |

Scenario: Parse error (malformed EDIFACT)
  Given edi_message with syntax error (e.g., missing mandatory segment)
  When processing message
  Then status = 'error'
  And error_message = "Parse error: Missing mandatory UNH segment"
  And validation_errors = {parse_errors: [...]}
  And integration_logs entry created
```

### AC-4: Validate Parsed Data

```gherkin
Scenario: Validation - customer exists
  Given parsed ORDERS message with customer_gln = 5412345000013
  And customer with gln = 5412345000013 exists in customers table
  When validating message
  Then validation passes
  And customer_id mapped

Scenario: Validation - customer not found
  Given parsed ORDERS with customer_gln = 9999999999999
  And no customer with this GLN
  When validating
  Then validation fails
  And validation_errors = {customer: "Customer GLN 9999999999999 not found"}
  And status = 'pending_review'

Scenario: Validation - product exists
  Given line item with product_code = PROD-001
  And product with code = PROD-001 exists
  Then validation passes

Scenario: Validation - product not found
  Given line item with product_code = INVALID-999
  And product does not exist
  Then validation fails
  And validation_errors = {line_items[0].product: "Product INVALID-999 not found"}

Scenario: Validation - quantity > 0
  Given line item with qty = 0
  Then validation fails
  And validation_errors = {line_items[0].qty: "Quantity must be > 0"}

Scenario: Validation - valid delivery date
  Given delivery date = 2025-01-01 (past)
  Then validation warning (not error)
  And validation_errors = {delivery_date: "Delivery date in the past"}
```

### AC-5: Auto-Create Sales Order (if sales_orders exists)

```gherkin
Scenario: Create sales order from valid ORDERS
  Given parsed and validated ORDERS message
  And sales_orders table exists (Epic 03 complete)
  When processing message
  Then sales order created:
    | Field | Value |
    | order_number | SO-2025-001 (auto-generated) |
    | customer_id | (mapped from GLN) |
    | external_reference | PO-2025-001 (from EDI) |
    | status | pending |
    | line_items | (mapped from ORDERS LIN segments) |
  And edi_message.created_entity_type = 'sales_order'
  And edi_message.created_entity_id = sales_order.id
  And edi_message.status = 'processed'
  And integration_logs entry created (success)

Scenario: Create work order (if no sales_orders)
  Given sales_orders table does not exist
  And ORDERS contains single product line
  When processing message
  Then work order created instead:
    | Field | Value |
    | wo_number | WO-2025-001 |
    | product_id | (mapped from product_code) |
    | qty_planned | (from ORDERS qty) |
    | external_reference | PO-2025-001 |
  And edi_message.created_entity_type = 'work_order'
  And edi_message.status = 'processed'
```

### AC-6: Error Handling - Pending Review

```gherkin
Scenario: Validation errors create pending review order
  Given ORDERS message with validation errors (e.g., product not found)
  When processing message
  Then edi_message.status = 'pending_review'
  And error_message = "Validation failed: 2 errors"
  And validation_errors = {customer: "...", line_items[0].product: "..."}
  And NO sales order created
  And integration_logs entry created (error)
  And admin notification sent

Scenario: Manual review and retry
  Given edi_message with status = 'pending_review'
  And admin corrects issue (e.g., adds missing product)
  When clicking [Retry Processing]
  Then system re-validates and re-processes
  And if valid: creates sales order
  And status = 'processed'
```

### AC-7: EDI Inbox UI

```gherkin
Scenario: View EDI inbox
  Given admin navigates to /integrations/edi/inbox
  Then DataTable displays edi_messages:
    | Column | Description |
    | Message Type | ORDERS, INVOIC, etc. |
    | Direction | Inbound/Outbound |
    | Reference | PO number (if parsed) |
    | Partner | Customer name (if mapped) |
    | Status | Badge (pending/processed/error/pending_review) |
    | Created At | Timestamp |
    | Actions | Process, View Raw, Retry |
  And pagination (20 per page)
  And filter by status, type, date range

Scenario: View raw EDIFACT message
  Given edi_message with id = MSG-001
  When clicking [View Raw]
  Then modal shows message_content as plain text
  And syntax highlighting (optional)
  And [Copy to Clipboard] button
```

### AC-8: Process Message Action

```gherkin
Scenario: Admin manually processes pending message
  Given edi_message with status = 'pending'
  When clicking [Process]
  Then status changes to 'processing'
  And backend parses, validates, creates order
  And status updates to 'processed' or 'error'
  And table refreshes

Scenario: Already processed message
  Given edi_message with status = 'processed'
  Then [Process] button disabled
  And tooltip: "Message already processed"
```

### AC-9: Integration Logs

```gherkin
Scenario: Log all EDI events
  Given any EDI message processing
  When parse/validate/create order
  Then integration_logs entries created:
    | Event Type | Status | Details |
    | edi.message.received | success | Message uploaded |
    | edi.message.parsed | success | Parsed 5 line items |
    | edi.message.validated | error | 2 validation errors |
    | edi.order.created | success | Sales order SO-2025-001 |
  And all entries linked to edi_message.id
```

### AC-10: RLS Policy Enforcement

```gherkin
Scenario: Org isolation on edi_messages
  Given User A from Org A and User B from Org B
  And EDI messages exist in both orgs
  When User A requests GET /api/integrations/edi/inbox
  Then only Org A messages returned

Scenario: Cannot view message from different org
  Given edi_message belongs to Org B
  When User A (Org A) requests GET /api/integrations/edi/messages/:id
  Then 404 Not Found returned
```

---

## Implementation Notes

### EDIFACT ORDERS Parsing

**Standard**: UN/EDIFACT D.96A (most common in Europe)

**Segment Mapping**:

```
UNB - Interchange Header (sender, receiver, date/time)
UNH - Message Header (message type = ORDERS)
BGM - Beginning of Message (order number, order type)
DTM - Date/Time (order date, delivery date)
NAD - Name and Address (buyer, supplier, delivery address)
LIN - Line Item (sequence number)
PIA - Product Identification (product code, GTIN)
IMD - Item Description (product name)
QTY - Quantity (ordered quantity)
DTM - Delivery Date (requested delivery)
UNT - Message Trailer
UNZ - Interchange Trailer
```

**Example EDIFACT ORDERS**:

```
UNA:+.? '
UNB+UNOC:3+5412345000013:14+MONOPILOT:14+250115:1430+1++ORDERS'
UNH+1+ORDERS:D:96A:UN'
BGM+220+PO-2025-001+9'
DTM+137:20250115:102'
NAD+BY+5412345000013::9'
LIN+1++PROD-001:SA'
QTY+21:1000'
DTM+2:20250120:102'
UNT+8+1'
UNZ+1+1'
```

### Validation Rules

```typescript
interface EDIValidationRules {
  customer: {
    required: true;
    lookup: 'gln' | 'tax_id' | 'code';
    create_if_missing: false; // Phase 3
  };
  products: {
    required: true;
    lookup: 'code' | 'gtin' | 'ean';
    create_if_missing: false; // Phase 3
  };
  quantities: {
    min: 1;
    allow_decimals: true;
  };
  delivery_date: {
    allow_past: false;
    max_future_days: 365;
  };
}
```

### Service Layer

```typescript
// lib/services/edi-service.ts

export class EDIService {
  /**
   * Parse EDIFACT ORDERS message
   */
  static async parseORDERS(messageContent: string): Promise<ParsedORDERS>;

  /**
   * Validate parsed ORDERS against MonoPilot data
   */
  static async validateORDERS(parsed: ParsedORDERS, orgId: string): Promise<ValidationResult>;

  /**
   * Create sales order (or work order) from validated ORDERS
   */
  static async createOrderFromEDI(
    parsed: ParsedORDERS,
    validation: ValidationResult,
    messageId: string,
    orgId: string
  ): Promise<{ entityType: string; entityId: string }>;

  /**
   * Process EDI message end-to-end
   */
  static async processMessage(messageId: string): Promise<void>;

  /**
   * Upload raw EDI file
   */
  static async uploadMessage(
    file: File,
    orgId: string,
    userId: string
  ): Promise<EDIMessage>;
}
```

---

## Key Business Rules

1. **EDIFACT Standard**: UN/EDIFACT D.96A (most widely used in Europe)
2. **Customer Lookup**: Match by GLN first, fallback to tax_id or customer code
3. **Product Lookup**: Match by product_code (exact match, case-insensitive)
4. **Validation Errors**: Create "pending_review" status, admin must fix and retry
5. **Sales Order vs Work Order**: Create sales_order if Epic 03 complete, else work_order
6. **Audit Trail**: Raw EDI message stored permanently, linked to created order
7. **Manual Processing**: MVP requires manual upload + process (auto-polling in Phase 3)
8. **Error Notification**: Email admin on validation errors or parse failures

---

## Deliverables

### Database
- [ ] Migration: `edi_config` table
- [ ] Migration: `edi_messages` table
- [ ] RLS policies for edi_config, edi_messages
- [ ] Indexes for performance

### API Routes
- [ ] `GET /api/integrations/edi/config` - Get EDI config
- [ ] `PUT /api/integrations/edi/config` - Update EDI config
- [ ] `POST /api/integrations/edi/upload` - Upload EDI message file
- [ ] `GET /api/integrations/edi/inbox` - List EDI messages
- [ ] `POST /api/integrations/edi/process/:id` - Process message
- [ ] `GET /api/integrations/edi/messages/:id` - Get message detail

### Service Layer
- [ ] `EDIService.parseORDERS()` - EDIFACT parser
- [ ] `EDIService.validateORDERS()` - Validation engine
- [ ] `EDIService.createOrderFromEDI()` - Order creation
- [ ] `EDIService.processMessage()` - End-to-end processing
- [ ] `EDIService.uploadMessage()` - File upload handler

### Frontend
- [ ] EDI config page (`/integrations/edi`)
- [ ] EDI inbox page (`/integrations/edi/inbox`)
- [ ] Upload message modal
- [ ] View raw message modal
- [ ] Process/retry actions
- [ ] Status badges

### Tests
- [ ] Unit tests: EDI parsing, validation (>80% coverage)
- [ ] Integration tests: All API endpoints
- [ ] RLS tests: Org isolation
- [ ] E2E: Upload -> Parse -> Validate -> Create order

---

## Definition of Done

### Database
- [ ] Tables created with RLS
- [ ] Indexes created
- [ ] RLS policies enforce org isolation

### API
- [ ] All endpoints functional
- [ ] EDIFACT parsing works for valid messages
- [ ] Validation engine catches errors
- [ ] Order creation works

### Service
- [ ] EDIFACT ORDERS parser complete
- [ ] Validation rules enforced
- [ ] Sales order/work order creation
- [ ] Error handling with pending_review

### Frontend
- [ ] EDI inbox displays messages
- [ ] Upload works
- [ ] Process/retry actions functional
- [ ] Raw message viewer

### Testing
- [ ] Unit tests: >80% coverage
- [ ] Integration tests: All endpoints
- [ ] E2E: Full flow passing

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| EDIFACT parsing complexity | HIGH | MEDIUM | Use proven library (edifact-parser npm), comprehensive tests |
| Customer/product mapping failures | MEDIUM | HIGH | Pending review status, manual admin fix |
| Invalid EDIFACT syntax | MEDIUM | MEDIUM | Parse error handling, log raw message |
| Performance (large messages) | LOW | LOW | Stream parsing for >10k lines |

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2026-01-15 | Initial Phase 2 story creation | ARCHITECT |

---

**Document Status**: Ready for Implementation
**Created**: 2026-01-15
**Lines**: ~600
**Complexity**: L (Large)
**Phase**: 2
