# 06.12 - Batch Release Approval

**Priority**: P0 (MVP - Regulatory Critical)
**Story Points**: M (Medium - 2-3 days)
**Type:** fullstack
**Phase**: 2B (In-Process & Final - Advanced)
**Model**: OPUS

**State:** ready
**Estimate:** M (2-3 days)
**Primary PRD:** `docs/1-BASELINE/product/modules/quality.md` (FR-QA-010)
**Architecture:** `docs/1-BASELINE/architecture/modules/quality.md` (batch_releases table, E-Signature)

---

## Goal

Implement the formal batch release approval workflow with QA Manager sign-off, e-signature support, and release conditions validation. This story extends 06.11 (Final Inspection + Batch Release) by adding:

1. **QA Manager Exclusive Approval** - Only QA_MANAGER or QUALITY_DIRECTOR can approve releases
2. **E-Signature Support** - FDA 21 CFR Part 11 compliant electronic signatures
3. **Release Conditions Validation** - All inspections passed, CCPs within limits, no open NCRs
4. **Approval Queue Management** - Pending releases queue for QA Managers
5. **Release Certificate Generation** - Printable batch release document

**CRITICAL IMPORTANCE:**
- **FDA 21 CFR Part 11 Compliance** - E-signatures with meaning, intent, and timestamp
- **FSMA Compliance** - Documented batch release by authorized personnel
- **Audit Trail** - Complete history of all approval/rejection decisions
- **Food Safety Gate** - Last approval before products can be shipped

---

## Food Safety Compliance

This story is **CRITICAL for food safety regulatory compliance**:

- [x] **FDA 21 CFR Part 11** - E-signature with unique user ID, timestamp, meaning statement
- [x] **FSMA Compliance** - Batch release by authorized personnel only
- [x] **HACCP Verification** - Confirms all CCPs were monitored and within limits
- [x] **Audit Trail Required** - Approver ID, decision, timestamp, signature meaning
- [x] **Immutable Records** - Approved releases cannot be modified

**Regulatory Context:**
- Batch release is a LEGALLY BINDING decision
- E-signatures must be linked to unique user identification
- Signature meaning must be captured ("I approve release of this batch")
- All records retained for minimum 2 years (food) / 7 years (medical foods)
- Release decision must be traceable to single responsible person

---

## MVP Scope

This story focuses on the **approval workflow** aspect of batch release, building on the inspection completion in 06.11.

**MVP Includes**:
- `batch_releases` table (extends 06.11 batch_release_records)
- E-signature fields (meaning, timestamp, user_id, intent)
- Release approval status workflow (pending_release -> approved/rejected)
- Pre-release conditions validation API
- Approval queue page for QA Managers
- Release approval modal with e-signature
- Rejection workflow with reason capture
- Release certificate printable document
- Permission enforcement (QA_MANAGER, QUALITY_DIRECTOR only)
- Audit trail for all approval/rejection actions

**Deferred to Phase 3+**:
- Biometric e-signature (fingerprint, face recognition)
- Third-party e-signature integration (DocuSign, Adobe Sign)
- Multi-level approval workflow (QA Manager + Quality Director)
- Batch release analytics dashboard

---

## User Story

As a **QA Manager**, I want to **review pending batch releases and approve them with my electronic signature** so that **only batches I've personally verified are released for shipping, maintaining FDA compliance**.

As a **Quality Director**, I want to **override or escalate batch release decisions** so that **critical quality issues are properly addressed before products reach customers**.

As an **Auditor**, I want to **view the complete approval history with e-signatures** so that **I can verify regulatory compliance during inspections**.

---

## Scope

**In scope (this story)**
- E-signature fields in batch_releases table:
  - `signature_user_id` - User who signed
  - `signature_meaning` - "I approve/reject release of this batch"
  - `signature_timestamp` - When signature captured
  - `signature_method` - 'password' | 'pin' | 'email_confirm' (MVP)
  - `signature_intent` - 'approve' | 'reject'
- Release conditions validation:
  - All final inspections passed
  - All CCPs within limits (no unresolved deviations)
  - All operation checkpoints passed
  - No open NCRs linked to batch
  - No active quality holds
- POST /api/quality/releases/:id/approve (with e-signature)
- POST /api/quality/releases/:id/reject (with e-signature)
- GET /api/quality/releases/pending (QA Manager queue)
- GET /api/quality/releases/:id/conditions (validation status)
- GET /api/quality/releases/:id/certificate (PDF generation)
- Approval queue page with pending releases
- Release approval modal with e-signature capture
- Release certificate printable document
- Rejection modal with reason and e-signature
- Audit trail for all decisions

**Out of scope (this story)**
- Final inspection execution (story 06.11)
- CoA generation (story 06.27-06.29)
- Multi-level approval workflow
- Biometric e-signature
- Third-party e-signature integration

---

## Dependencies

### Cross-Epic Dependencies

| Dependency | Story/Epic | Type | What It Provides | Status |
|------------|------------|------|------------------|--------|
| 01.1 | Org Context + RLS | HARD | organizations, users, roles tables | Ready |
| 01.1 | User Roles | HARD | QA_MANAGER, QUALITY_DIRECTOR role definitions | Ready |
| 05.1 | LP Table + CRUD | HARD | license_plates table for release_status updates | Ready |
| 05.7 | LP QA Status | HARD | LP.release_status field | Required |

### Within Epic Dependencies

| Dependency | Story | Type | What It Provides |
|------------|-------|------|------------------|
| 06.0 | Quality Settings | HARD | quality_settings.require_batch_release |
| 06.11 | Final Inspection | HARD | batch_release_records table, final inspection completion |
| 06.6 | Test Results | HARD | Test results for conditions validation |
| 06.10 | In-Process Inspection | SOFT | In-process inspection results for conditions |
| 06.9 | NCR Creation | SOFT | NCR records for blocking validation |

### Provides To (Downstream)

| Story/Epic | What This Provides |
|------------|-------------------|
| 06.27-06.29 | CoA Generation - Release approval triggers CoA |
| 07.* | Shipping Module - LP.release_status='released' gates shipping |
| Epic 09 | Finance Module - Released batches for invoicing |

---

## Database Schema

### Migration: Extend batch_release_records with E-Signature fields

```sql
-- Migration: YYYYMMDDHHMMSS_add_esignature_fields_to_batch_releases.sql

-- Add e-signature fields to batch_release_records
ALTER TABLE batch_release_records
ADD COLUMN IF NOT EXISTS signature_user_id UUID REFERENCES users(id),
ADD COLUMN IF NOT EXISTS signature_meaning TEXT,
ADD COLUMN IF NOT EXISTS signature_timestamp TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS signature_method TEXT CHECK (signature_method IN ('password', 'pin', 'email_confirm')),
ADD COLUMN IF NOT EXISTS signature_intent TEXT CHECK (signature_intent IN ('approve', 'reject')),
ADD COLUMN IF NOT EXISTS signature_ip_address TEXT,
ADD COLUMN IF NOT EXISTS signature_user_agent TEXT;

-- Add rejection fields
ALTER TABLE batch_release_records
ADD COLUMN IF NOT EXISTS rejection_reason TEXT,
ADD COLUMN IF NOT EXISTS rejected_by UUID REFERENCES users(id),
ADD COLUMN IF NOT EXISTS rejected_at TIMESTAMPTZ;

-- Update release_decision check to include pending_release
ALTER TABLE batch_release_records
DROP CONSTRAINT IF EXISTS batch_release_records_release_decision_check;

ALTER TABLE batch_release_records
ADD CONSTRAINT batch_release_records_release_decision_check
CHECK (release_decision IN ('pending', 'pending_release', 'approved', 'rejected', 'conditional'));

-- Index for approval queue
CREATE INDEX IF NOT EXISTS idx_batch_release_pending_approval
    ON batch_release_records(org_id, release_decision)
    WHERE release_decision = 'pending_release';

-- Index for signature audit
CREATE INDEX IF NOT EXISTS idx_batch_release_signature_user
    ON batch_release_records(signature_user_id)
    WHERE signature_user_id IS NOT NULL;
```

### New Table: release_conditions_log

```sql
-- Migration: YYYYMMDDHHMMSS_create_release_conditions_log.sql

CREATE TABLE release_conditions_log (
    -- Identity
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id                  UUID NOT NULL REFERENCES organizations(id),
    release_id              UUID NOT NULL REFERENCES batch_release_records(id) ON DELETE CASCADE,

    -- Condition Check
    check_type              TEXT NOT NULL
                            CHECK (check_type IN (
                                'final_inspection',
                                'ccp_records',
                                'in_process_inspections',
                                'operation_checkpoints',
                                'quality_holds',
                                'ncr_review',
                                'specification_compliance'
                            )),
    check_result            TEXT NOT NULL CHECK (check_result IN ('pass', 'fail', 'warning', 'not_applicable')),
    check_details           JSONB,

    -- References
    reference_type          TEXT,
    reference_id            UUID,

    -- Audit
    checked_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    checked_by              UUID REFERENCES users(id),

    -- Constraint
    UNIQUE(release_id, check_type)
);

-- Index for release lookup
CREATE INDEX idx_release_conditions_release ON release_conditions_log(release_id);

-- RLS
ALTER TABLE release_conditions_log ENABLE ROW LEVEL SECURITY;

CREATE POLICY "release_conditions_select" ON release_conditions_log
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "release_conditions_insert" ON release_conditions_log
    FOR INSERT WITH CHECK (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );
```

### Function: Validate Release Conditions

```sql
-- Function to validate all release conditions
CREATE OR REPLACE FUNCTION validate_release_conditions(p_release_id UUID)
RETURNS TABLE (
    check_type TEXT,
    check_result TEXT,
    check_details JSONB
) AS $$
DECLARE
    v_release RECORD;
    v_wo_id UUID;
    v_batch_number TEXT;
    v_org_id UUID;
BEGIN
    -- Get release record
    SELECT * INTO v_release FROM batch_release_records WHERE id = p_release_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Release record not found';
    END IF;

    v_wo_id := v_release.wo_id;
    v_batch_number := v_release.batch_number;
    v_org_id := v_release.org_id;

    -- Check 1: Final Inspection
    RETURN QUERY
    SELECT
        'final_inspection'::TEXT,
        CASE
            WHEN EXISTS (
                SELECT 1 FROM quality_inspections
                WHERE org_id = v_org_id
                AND inspection_type = 'final'
                AND (wo_id = v_wo_id OR batch_number = v_batch_number)
                AND result = 'pass'
            ) THEN 'pass'::TEXT
            WHEN EXISTS (
                SELECT 1 FROM quality_inspections
                WHERE org_id = v_org_id
                AND inspection_type = 'final'
                AND (wo_id = v_wo_id OR batch_number = v_batch_number)
                AND result = 'conditional'
            ) THEN 'warning'::TEXT
            ELSE 'fail'::TEXT
        END,
        (SELECT jsonb_build_object(
            'inspection_id', id,
            'inspection_number', inspection_number,
            'result', result
        ) FROM quality_inspections
        WHERE org_id = v_org_id
        AND inspection_type = 'final'
        AND (wo_id = v_wo_id OR batch_number = v_batch_number)
        ORDER BY created_at DESC LIMIT 1)::JSONB;

    -- Check 2: CCP Records (placeholder - depends on HACCP stories)
    RETURN QUERY
    SELECT
        'ccp_records'::TEXT,
        CASE
            WHEN NOT EXISTS (
                SELECT 1 FROM haccp_monitoring_records
                WHERE org_id = v_org_id AND wo_id = v_wo_id
            ) THEN 'not_applicable'::TEXT
            WHEN NOT EXISTS (
                SELECT 1 FROM haccp_monitoring_records
                WHERE org_id = v_org_id AND wo_id = v_wo_id AND within_limits = false
            ) THEN 'pass'::TEXT
            ELSE 'fail'::TEXT
        END,
        jsonb_build_object('checked', true)::JSONB;

    -- Check 3: In-Process Inspections
    RETURN QUERY
    SELECT
        'in_process_inspections'::TEXT,
        CASE
            WHEN NOT EXISTS (
                SELECT 1 FROM quality_inspections
                WHERE org_id = v_org_id
                AND inspection_type = 'in_process'
                AND (wo_id = v_wo_id OR batch_number = v_batch_number)
                AND result = 'fail'
            ) THEN 'pass'::TEXT
            ELSE 'fail'::TEXT
        END,
        (SELECT jsonb_agg(jsonb_build_object(
            'inspection_id', id,
            'inspection_number', inspection_number,
            'result', result
        )) FROM quality_inspections
        WHERE org_id = v_org_id
        AND inspection_type = 'in_process'
        AND (wo_id = v_wo_id OR batch_number = v_batch_number))::JSONB;

    -- Check 4: Operation Checkpoints (placeholder)
    RETURN QUERY
    SELECT
        'operation_checkpoints'::TEXT,
        'not_applicable'::TEXT,
        jsonb_build_object('message', 'Checkpoints validation pending implementation')::JSONB;

    -- Check 5: Quality Holds
    RETURN QUERY
    SELECT
        'quality_holds'::TEXT,
        CASE
            WHEN NOT EXISTS (
                SELECT 1 FROM quality_holds qh
                JOIN quality_hold_items qhi ON qhi.hold_id = qh.id
                WHERE qh.org_id = v_org_id
                AND qh.status = 'active'
                AND qhi.reference_type = 'batch'
                AND qhi.reference_id::TEXT = v_batch_number
            ) THEN 'pass'::TEXT
            ELSE 'fail'::TEXT
        END,
        jsonb_build_object('checked', true)::JSONB;

    -- Check 6: NCR Review
    RETURN QUERY
    SELECT
        'ncr_review'::TEXT,
        CASE
            WHEN NOT EXISTS (
                SELECT 1 FROM ncr_reports
                WHERE org_id = v_org_id
                AND reference_type = 'batch'
                AND reference_id::TEXT = v_batch_number
                AND status NOT IN ('closed', 'cancelled')
            ) THEN 'pass'::TEXT
            ELSE 'fail'::TEXT
        END,
        (SELECT jsonb_agg(jsonb_build_object(
            'ncr_id', id,
            'ncr_number', ncr_number,
            'status', status
        )) FROM ncr_reports
        WHERE org_id = v_org_id
        AND reference_type = 'batch'
        AND reference_id::TEXT = v_batch_number
        AND status NOT IN ('closed', 'cancelled'))::JSONB;

    -- Check 7: Specification Compliance
    RETURN QUERY
    SELECT
        'specification_compliance'::TEXT,
        CASE
            WHEN NOT EXISTS (
                SELECT 1 FROM quality_test_results qtr
                JOIN quality_inspections qi ON qi.id = qtr.inspection_id
                WHERE qi.org_id = v_org_id
                AND (qi.wo_id = v_wo_id OR qi.batch_number = v_batch_number)
                AND qtr.result_status = 'fail'
            ) THEN 'pass'::TEXT
            ELSE 'fail'::TEXT
        END,
        jsonb_build_object('checked', true)::JSONB;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

---

## Acceptance Criteria (Given/When/Then)

### AC-1: E-Signature Capture on Approval

```gherkin
Scenario: Approve release with e-signature (password method)
  Given batch BATCH-001 with release_decision = 'pending_release'
  And user has QA_MANAGER role
  When user clicks [Approve Release]
  Then e-signature modal displays:
    | Field | Description |
    | Signature Meaning | "I approve release of batch BATCH-001 for shipping" |
    | Signature Method | Password (default) / PIN / Email Confirm |
    | Password Input | User re-enters password to confirm |
  And user enters password correctly
  And clicks [Sign and Approve]
  Then release record updated:
    | Field | Value |
    | release_decision | approved |
    | signature_user_id | current user |
    | signature_meaning | "I approve release of batch BATCH-001 for shipping" |
    | signature_timestamp | now |
    | signature_method | password |
    | signature_intent | approve |
  And all output LPs updated: release_status = 'released'
  And success toast "Batch BATCH-001 approved for release"

Scenario: E-signature validation fails on wrong password
  Given user on approval modal
  When user enters incorrect password
  And clicks [Sign and Approve]
  Then error: "Invalid password. Please try again."
  And attempt logged in audit trail
  And release NOT approved
```

### AC-2: E-Signature Capture on Rejection

```gherkin
Scenario: Reject release with e-signature
  Given batch BATCH-001 with release_decision = 'pending_release'
  And user has QA_MANAGER role
  When user clicks [Reject Release]
  Then rejection modal displays:
    | Field | Description |
    | Rejection Reason | Required text field (min 20 chars) |
    | Signature Meaning | "I reject release of batch BATCH-001" |
    | Password Input | User re-enters password |
  And user enters rejection reason: "Critical defect found in final inspection"
  And enters password
  And clicks [Sign and Reject]
  Then release record updated:
    | Field | Value |
    | release_decision | rejected |
    | rejection_reason | "Critical defect found..." |
    | rejected_by | current user |
    | rejected_at | now |
    | signature_intent | reject |
  And all output LPs updated: release_status = 'rejected'
  And prompt: "Create NCR for rejected batch?"
```

### AC-3: Release Conditions Validation

```gherkin
Scenario: All release conditions pass
  Given batch BATCH-001 ready for release
  And final inspection result = 'pass'
  And all CCPs within limits
  And no open NCRs
  And no active quality holds
  When calling GET /api/quality/releases/:id/conditions
  Then response:
    {
      "all_conditions_met": true,
      "can_approve": true,
      "conditions": [
        { "type": "final_inspection", "result": "pass", "blocking": false },
        { "type": "ccp_records", "result": "pass", "blocking": false },
        { "type": "in_process_inspections", "result": "pass", "blocking": false },
        { "type": "operation_checkpoints", "result": "not_applicable", "blocking": false },
        { "type": "quality_holds", "result": "pass", "blocking": false },
        { "type": "ncr_review", "result": "pass", "blocking": false },
        { "type": "specification_compliance", "result": "pass", "blocking": false }
      ],
      "blockers": [],
      "warnings": []
    }

Scenario: Release blocked by failed condition
  Given batch BATCH-001 with open NCR
  When calling GET /api/quality/releases/:id/conditions
  Then response:
    {
      "all_conditions_met": false,
      "can_approve": false,
      "blockers": ["Open NCR NCR-2025-00123 linked to batch"]
    }
  And [Approve Release] button disabled
  And blocker message displayed
```

### AC-4: Approval Queue for QA Managers

```gherkin
Scenario: QA Manager views pending approvals
  Given user has QA_MANAGER role
  And 5 batches pending release approval
  When navigating to Quality > Release Approvals
  Then queue displays batches awaiting approval:
    | Column | Description |
    | Release # | REL-2025-00001 |
    | Batch # | BATCH-001 |
    | Product | Product name |
    | Quantity | Total qty |
    | Submitted By | Inspector name |
    | Submitted At | Date/time |
    | Conditions | Pass/Fail count |
    | Priority | High/Normal |
    | Actions | View, Approve, Reject |
  And sorted by submitted_at (oldest first)
  And count badge shows "5 Pending"

Scenario: Filter approval queue
  Given multiple pending releases
  When filtering by product or priority
  Then queue updates to show matching releases
  And URL updates with filter state
```

### AC-5: Permission Enforcement

```gherkin
Scenario: QA Inspector cannot approve
  Given user has QA_INSPECTOR role (not QA_MANAGER)
  When viewing release detail page
  Then [Approve Release] button not shown
  And [Submit for Approval] button shown
  And message: "QA Manager approval required"

Scenario: QA Manager can approve
  Given user has QA_MANAGER role
  When viewing release detail page
  Then [Approve Release] and [Reject Release] buttons shown
  And can proceed with approval workflow

Scenario: Quality Director can approve and override
  Given user has QUALITY_DIRECTOR role
  When viewing any release
  Then can approve, reject, or override previous decisions
```

### AC-6: Release Certificate Generation

```gherkin
Scenario: Generate release certificate PDF
  Given batch BATCH-001 with release_decision = 'approved'
  When user clicks [Print Release Certificate]
  Then PDF generated containing:
    | Section | Content |
    | Header | Company logo, "Batch Release Certificate" |
    | Batch Info | Batch #, Product, Quantity, Production Date |
    | Inspection Summary | Final inspection result, test summary |
    | Conditions | All 7 conditions with pass/fail status |
    | Approval | Approver name, signature meaning, timestamp |
    | Footer | Document ID, generation timestamp, "For internal use" |
  And PDF opens in new tab or downloads
  And document ID logged in audit trail

Scenario: Certificate not available for pending release
  Given batch BATCH-001 with release_decision = 'pending_release'
  When user clicks [Print Release Certificate]
  Then message: "Certificate available after approval"
```

### AC-7: Audit Trail for All Decisions

```gherkin
Scenario: Approval logged in audit trail
  Given batch release approved
  When approval completes
  Then quality_audit_log entry created:
    | Field | Value |
    | entity_type | batch_release |
    | entity_id | release.id |
    | action | approve |
    | user_id | approver.id |
    | timestamp | now |
    | new_value | { decision: 'approved', signature_meaning: '...', conditions: [...] } |

Scenario: View approval history
  Given release with approval history
  When user clicks [View History]
  Then timeline displays all actions:
    - Submitted by Inspector A at T1
    - Conditions validated at T2
    - Approved by QA Manager at T3 (with e-signature)
  And each entry shows user, action, timestamp
```

### AC-8: Conditional Release Approval

```gherkin
Scenario: Approve conditional release
  Given batch BATCH-001 with final inspection result = 'conditional'
  And condition reason: "Minor color variation"
  When QA Manager approves with conditional decision
  Then must enter:
    | Field | Required |
    | Conditional Reason | Yes |
    | Usage Restrictions | Yes |
    | Expiry Date | Optional |
  And e-signature required
  Then release_decision = 'conditional'
  And LPs released with restrictions noted
  And warning displays in shipping module
```

---

## Implementation Notes

### API Endpoints

```typescript
// =============================================================================
// Release Approval Endpoints
// =============================================================================

// POST /api/quality/releases/:id/approve
// Approve release with e-signature
interface ApproveReleaseRequest {
  signature_method: 'password' | 'pin' | 'email_confirm';
  signature_credential: string; // Password, PIN, or confirmation code
  signature_meaning?: string; // Override default meaning
  approval_notes?: string;

  // For conditional approval
  is_conditional?: boolean;
  conditional_reason?: string;
  conditional_restrictions?: string;
  conditional_expires_at?: string;
}

interface ApproveReleaseResponse {
  release: BatchReleaseRecord;
  signature_captured: boolean;
  lps_updated: number;
  certificate_available: boolean;
}

// POST /api/quality/releases/:id/reject
// Reject release with e-signature
interface RejectReleaseRequest {
  signature_method: 'password' | 'pin' | 'email_confirm';
  signature_credential: string;
  rejection_reason: string; // Required, min 20 chars
  create_ncr?: boolean;
}

interface RejectReleaseResponse {
  release: BatchReleaseRecord;
  signature_captured: boolean;
  lps_updated: number;
  ncr_id?: string; // If NCR created
}

// GET /api/quality/releases/pending
// List releases pending approval (QA Manager queue)
interface PendingReleasesParams {
  product_id?: string;
  priority?: 'high' | 'normal' | 'urgent';
  submitted_from?: string;
  submitted_to?: string;
  page?: number;
  limit?: number;
}

interface PendingReleasesResponse {
  releases: BatchReleaseRecord[];
  summary: {
    total_pending: number;
    high_priority: number;
    oldest_waiting_hours: number;
  };
  pagination: Pagination;
}

// GET /api/quality/releases/:id/conditions
// Get release conditions validation status
interface ReleaseConditionsResponse {
  release_id: string;
  batch_number: string;
  all_conditions_met: boolean;
  can_approve: boolean;
  conditions: Array<{
    type: string;
    result: 'pass' | 'fail' | 'warning' | 'not_applicable';
    details?: any;
    blocking: boolean;
  }>;
  blockers: string[];
  warnings: string[];
  validated_at: string;
}

// GET /api/quality/releases/:id/certificate
// Generate release certificate PDF
interface ReleaseCertificateResponse {
  certificate_url: string;
  document_id: string;
  generated_at: string;
}
```

### Validation Schemas (Zod)

```typescript
import { z } from 'zod';

export const signatureMethodEnum = z.enum(['password', 'pin', 'email_confirm']);

export const approveReleaseSchema = z.object({
  signature_method: signatureMethodEnum,
  signature_credential: z.string().min(1, 'Credential required'),
  signature_meaning: z.string().max(500).optional(),
  approval_notes: z.string().max(2000).optional(),

  // Conditional approval
  is_conditional: z.boolean().default(false),
  conditional_reason: z.string().max(500).optional(),
  conditional_restrictions: z.string().max(1000).optional(),
  conditional_expires_at: z.string().datetime().optional(),
}).refine(
  (data) => {
    if (data.is_conditional) {
      return data.conditional_reason && data.conditional_restrictions;
    }
    return true;
  },
  {
    message: 'Conditional reason and restrictions required for conditional approval',
    path: ['conditional_reason'],
  }
);

export const rejectReleaseSchema = z.object({
  signature_method: signatureMethodEnum,
  signature_credential: z.string().min(1, 'Credential required'),
  rejection_reason: z.string()
    .min(20, 'Rejection reason must be at least 20 characters')
    .max(1000),
  create_ncr: z.boolean().default(false),
});

export const pendingReleasesQuerySchema = z.object({
  product_id: z.string().uuid().optional(),
  priority: z.enum(['high', 'normal', 'urgent']).optional(),
  submitted_from: z.string().optional(),
  submitted_to: z.string().optional(),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
});
```

### Service Layer

```typescript
// lib/services/release-approval-service.ts

export class ReleaseApprovalService {
  // ==========================================================================
  // E-Signature Validation
  // ==========================================================================

  /**
   * Validate user credentials for e-signature
   */
  static async validateSignatureCredential(
    userId: string,
    method: 'password' | 'pin' | 'email_confirm',
    credential: string
  ): Promise<{ valid: boolean; error?: string }>;

  // ==========================================================================
  // Approval Workflow
  // ==========================================================================

  /**
   * Approve release with e-signature
   */
  static async approveRelease(
    releaseId: string,
    input: ApproveReleaseInput,
    userId: string,
    ipAddress: string,
    userAgent: string
  ): Promise<ApproveReleaseResult>;

  /**
   * Reject release with e-signature
   */
  static async rejectRelease(
    releaseId: string,
    input: RejectReleaseInput,
    userId: string,
    ipAddress: string,
    userAgent: string
  ): Promise<RejectReleaseResult>;

  // ==========================================================================
  // Conditions Validation
  // ==========================================================================

  /**
   * Validate all release conditions
   */
  static async validateConditions(releaseId: string): Promise<ConditionsResult>;

  /**
   * Log conditions validation result
   */
  static async logConditionsValidation(
    releaseId: string,
    conditions: ConditionCheck[]
  ): Promise<void>;

  // ==========================================================================
  // Approval Queue
  // ==========================================================================

  /**
   * Get pending releases for approval
   */
  static async getPendingReleases(
    params: PendingReleasesParams
  ): Promise<PaginatedResult<BatchReleaseRecord>>;

  /**
   * Get approval queue summary
   */
  static async getApprovalQueueSummary(): Promise<ApprovalQueueSummary>;

  // ==========================================================================
  // Certificate Generation
  // ==========================================================================

  /**
   * Generate release certificate PDF
   */
  static async generateCertificate(releaseId: string): Promise<{
    url: string;
    documentId: string;
  }>;

  // ==========================================================================
  // Audit Trail
  // ==========================================================================

  /**
   * Log approval decision
   */
  static async logApprovalDecision(
    releaseId: string,
    decision: 'approve' | 'reject',
    userId: string,
    details: any
  ): Promise<void>;

  /**
   * Get approval history
   */
  static async getApprovalHistory(releaseId: string): Promise<AuditLogEntry[]>;
}
```

### Frontend Components

```
apps/frontend/app/(authenticated)/quality/
  release-approvals/
    page.tsx                           -- Pending approvals queue
    [id]/
      page.tsx                         -- Release approval detail

components/quality/release-approval/
  PendingApprovalsDataTable.tsx        -- DataTable for approval queue
  PendingApprovalsFilters.tsx          -- Filter panel
  ApprovalQueueSummary.tsx             -- Summary stats card
  ReleaseConditionsPanel.tsx           -- Conditions validation display
  ConditionCheckRow.tsx                -- Individual condition with status
  ESignatureModal.tsx                  -- E-signature capture modal
  ESignatureMethodSelector.tsx         -- Password/PIN/Email selector
  ApprovalConfirmationModal.tsx        -- Final confirmation before sign
  RejectionModal.tsx                   -- Rejection with reason and signature
  ConditionalApprovalForm.tsx          -- Conditional details input
  ReleaseCertificatePreview.tsx        -- Certificate preview component
  ReleaseCertificateButton.tsx         -- Print/download certificate
  ApprovalHistoryTimeline.tsx          -- Audit trail timeline
  ApprovalDecisionBadge.tsx            -- Decision status badge
```

### UI Component Details

**ESignatureModal.tsx**
- Modal with signature meaning prominently displayed
- Signature method selector (Password default, PIN, Email)
- Password/PIN input field with show/hide toggle
- "I understand" checkbox (required)
- Sign and Approve / Sign and Reject button
- Loading state during validation
- Error display for invalid credentials
- Attempt counter (lock after 3 failed attempts)

**ReleaseConditionsPanel.tsx**
- 7 condition rows with pass/fail/warning/N/A icons
- Expandable details for each condition
- Links to source records (inspection, NCR, etc.)
- Overall status banner (All Pass / Blockers / Warnings)
- Refresh button to re-validate
- Timestamp of last validation

**ApprovalHistoryTimeline.tsx**
- Vertical timeline of all actions
- Each entry: User avatar, action, timestamp
- Expandable details per entry
- E-signature indicator for approval/rejection
- Color-coded by action type

---

## Key Business Rules

1. **QA Manager Exclusive**: Only QA_MANAGER or QUALITY_DIRECTOR can approve/reject
2. **E-Signature Required**: All approval/rejection decisions require valid e-signature
3. **Signature Meaning Captured**: "I approve/reject release of batch X" statement stored
4. **Conditions Must Pass**: Cannot approve if any blocking condition fails
5. **Rejection Reason Required**: Minimum 20 characters explanation for rejection
6. **Immutable After Decision**: Approved/rejected records cannot be modified
7. **Audit Trail Complete**: All actions logged with user, timestamp, IP, user agent
8. **Certificate After Approval**: Release certificate only available after approval
9. **LP Status Update Automatic**: Approval triggers LP.release_status update
10. **NCR Prompt on Rejection**: Offer to create NCR when rejecting

---

## Deliverables

### Database
- [ ] Migration: E-signature fields in batch_release_records
- [ ] Migration: release_conditions_log table
- [ ] Function: validate_release_conditions()
- [ ] Indexes for approval queue queries
- [ ] RLS policies for new tables

### API Routes
- [ ] `POST /api/quality/releases/:id/approve` - Approve with e-signature
- [ ] `POST /api/quality/releases/:id/reject` - Reject with e-signature
- [ ] `GET /api/quality/releases/pending` - Pending approval queue
- [ ] `GET /api/quality/releases/:id/conditions` - Conditions validation
- [ ] `GET /api/quality/releases/:id/certificate` - Certificate PDF

### Service Layer
- [ ] `ReleaseApprovalService.validateSignatureCredential()`
- [ ] `ReleaseApprovalService.approveRelease()`
- [ ] `ReleaseApprovalService.rejectRelease()`
- [ ] `ReleaseApprovalService.validateConditions()`
- [ ] `ReleaseApprovalService.getPendingReleases()`
- [ ] `ReleaseApprovalService.generateCertificate()`

### Validation
- [ ] `approveReleaseSchema`
- [ ] `rejectReleaseSchema`
- [ ] `pendingReleasesQuerySchema`

### Frontend
- [ ] Pending approvals queue page
- [ ] Release approval detail page
- [ ] E-signature modal
- [ ] Conditions validation panel
- [ ] Rejection modal
- [ ] Certificate preview/download
- [ ] Approval history timeline

### Tests
- [ ] Unit tests: ReleaseApprovalService (>80% coverage)
- [ ] Integration tests: All API endpoints
- [ ] E-signature validation tests
- [ ] Permission enforcement tests
- [ ] E2E: Complete approval workflow

---

## Test Strategy

### Unit Tests

```typescript
describe('ReleaseApprovalService', () => {
  describe('validateSignatureCredential', () => {
    it('validates correct password', async () => {});
    it('rejects incorrect password', async () => {});
    it('locks account after 3 failed attempts', async () => {});
    it('supports PIN validation', async () => {});
  });

  describe('approveRelease', () => {
    it('approves with valid e-signature', async () => {});
    it('captures signature metadata (IP, user agent)', async () => {});
    it('updates LP release_status', async () => {});
    it('creates audit log entry', async () => {});
    it('blocks if conditions not met', async () => {});
    it('requires QA_MANAGER role', async () => {});
  });

  describe('rejectRelease', () => {
    it('rejects with valid e-signature', async () => {});
    it('requires rejection reason min 20 chars', async () => {});
    it('creates NCR if requested', async () => {});
    it('updates LP release_status to rejected', async () => {});
  });

  describe('validateConditions', () => {
    it('returns all pass when conditions met', async () => {});
    it('returns blockers for failed conditions', async () => {});
    it('handles conditional inspection as warning', async () => {});
    it('checks all 7 condition types', async () => {});
  });
});
```

### E2E Tests

```typescript
describe('Release Approval Workflow', () => {
  it('QA Manager approves release with e-signature', async () => {
    // 1. Navigate to pending approvals
    // 2. Select batch for approval
    // 3. Verify conditions all pass
    // 4. Click Approve
    // 5. Enter password in e-signature modal
    // 6. Confirm signature meaning
    // 7. Submit
    // 8. Verify LP status updated
    // 9. Verify certificate available
  });

  it('Rejection with NCR creation', async () => {
    // 1. Navigate to release detail
    // 2. Click Reject
    // 3. Enter rejection reason
    // 4. Check "Create NCR"
    // 5. Enter password
    // 6. Submit
    // 7. Verify NCR created
    // 8. Verify LP status = rejected
  });
});
```

---

## Definition of Done

### Database
- [ ] E-signature fields added to batch_release_records
- [ ] release_conditions_log table created
- [ ] validate_release_conditions function works
- [ ] All indexes created
- [ ] RLS policies enforce org isolation

### API
- [ ] All endpoints return correct HTTP status codes
- [ ] E-signature validation works correctly
- [ ] Permission enforcement returns 403 for non-managers
- [ ] Certificate PDF generates correctly

### Service
- [ ] E-signature validation with password/PIN
- [ ] Conditions validation checks all 7 criteria
- [ ] LP status updated on approval/rejection
- [ ] Audit trail captures all required fields

### Frontend
- [ ] Pending approvals queue displays correctly
- [ ] E-signature modal captures signature properly
- [ ] Conditions panel shows all checks
- [ ] Certificate preview/download works

### Compliance
- [ ] FDA 21 CFR Part 11 requirements met
- [ ] Signature meaning captured and stored
- [ ] Audit trail immutable
- [ ] Failed signature attempts logged

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| **E-signature security** | HIGH | LOW | Password hash validation, rate limiting |
| **Conditions validation performance** | MEDIUM | MEDIUM | Optimize queries, cache results |
| **Permission bypass** | HIGH | LOW | RLS + service layer + UI checks |
| **Audit trail gaps** | HIGH | LOW | Trigger-based logging, validation |
| **Certificate generation performance** | MEDIUM | LOW | Async generation, caching |

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-01-15 | Initial story creation | ARCHITECT-AGENT |

---

**Document Status**: Ready for Implementation
**Created**: 2025-01-15
**Lines**: ~950
**Complexity**: M (Medium)
**Phase**: 2B (In-Process & Final - Advanced)
**FR**: FR-QA-010
