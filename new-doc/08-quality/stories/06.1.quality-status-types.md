# 06.1 - Quality Status Types

**Priority**: P0 (MVP)
**Story Points**: S (Simple)
**Type**: backend + frontend

**State:** ready
**Estimate:** S (simple story)
**Primary PRD:** `docs/1-BASELINE/product/modules/quality.md` (FR-QA-001)
**Architecture:** `docs/1-BASELINE/architecture/modules/quality.md`

## Goal
Implement quality status type management system with 7 standardized QA statuses (PENDING, PASSED, FAILED, HOLD, RELEASED, QUARANTINED, COND_APPROVED) including status transition validation, License Plate integration, and database enum type creation.

## MVP Scope

This story implements Phase 1A functionality only. Features listed in "Future Phases" are deferred to Phase 1B+ and should be handled per Epic 06.0 "Definition of Done" guidance.

**MVP Includes**:
- 7 QA status types as PostgreSQL enum
- Status transition validation service
- LP QA status enum integration
- Basic status management API endpoints
- Status display in UI components
- Status filtering in quality dashboards

**Deferred to Phase 1B+**: See "Future Phases" section below.

## Scope

**In scope**
- Database enum type `quality_status_type` with 7 statuses
- Status transition validation service with business rules
- Integration with `license_plates.qa_status` column
- GET /api/quality/status/types (list available statuses)
- GET /api/quality/status/transitions (get valid transitions for current status)
- POST /api/quality/status/validate-transition (validate if transition is allowed)
- Status badge component with color coding
- Status transition history tracking in audit log
- Status filtering in quality inspection queues
- Business rule validation (e.g., PENDING → PASSED requires inspection)

**Out of scope** (Phase 1B+)
- Custom status types per organization
- Status workflow automation triggers
- Status-based notifications/alerts
- Status transition reason templates
- Bulk status updates
- Status change approval workflows

## Future Phases (Not in MVP)

### Phase 1B
- **Custom status types** - Organization-specific QA statuses beyond the 7 standard types
- **Status workflow automation** - Trigger actions on status transitions (e.g., email on HOLD)
- **Status transition reason templates** - Predefined reasons for common transitions
- **Status-based alerts** - Real-time notifications on critical status changes

### Phase 2
- **Bulk status updates** - Update QA status for multiple LPs at once
- **Status change approvals** - Require manager approval for certain transitions
- **Status SLA tracking** - Monitor time spent in each status
- **Status analytics dashboard** - Trends, aging, bottleneck analysis
- **Custom transition rules** - Organization-specific validation rules

### Phase 3
- **Status-based routing** - Automatic routing to queues based on status
- **Status escalation rules** - Auto-escalate items stuck in status too long
- **Status integration with external systems** - Push status updates to ERP/WMS

**Implementation**: Future features should return 501 Not Implemented from API endpoints with clear messaging about availability in later phases.

## Dependencies

### Cross-Epic Dependencies
- **01.1** - Org Context + Base RLS (organizations, users tables, RLS policies)
- **05.1** - License Plates CRUD (license_plates table with qa_status column)
- **05.7** - LP QA Status Management (LP status update workflow)

### Internal Epic Dependencies
- None (first story in Epic 06 Phase 1A)

### Master Data Dependencies
- PostgreSQL enum types supported (standard feature)
- No external reference data required

## Database Migration

### Migration 1: Create quality_status_type Enum

```sql
-- File: supabase/migrations/XXX_create_quality_status_enum.sql

-- Create enum for quality status types
CREATE TYPE quality_status_type AS ENUM (
  'PENDING',         -- Awaiting inspection
  'PASSED',          -- Meets specifications
  'FAILED',          -- Does not meet specs
  'HOLD',            -- Investigation required
  'RELEASED',        -- Approved for use after hold
  'QUARANTINED',     -- Isolated pending review
  'COND_APPROVED'    -- Conditionally approved (limited use)
);

COMMENT ON TYPE quality_status_type IS 'Quality assurance status types for inventory and batches';

-- Create status transitions lookup table
CREATE TABLE quality_status_transitions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  from_status quality_status_type NOT NULL,
  to_status quality_status_type NOT NULL,
  requires_inspection BOOLEAN DEFAULT false,
  requires_approval BOOLEAN DEFAULT false,
  requires_reason BOOLEAN DEFAULT true,
  is_allowed BOOLEAN DEFAULT true,
  description TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),

  CONSTRAINT unique_status_transition UNIQUE(from_status, to_status)
);

COMMENT ON TABLE quality_status_transitions IS 'Valid quality status transitions with business rules';

-- Create index for transition lookups
CREATE INDEX idx_status_transitions_from ON quality_status_transitions(from_status);
CREATE INDEX idx_status_transitions_lookup ON quality_status_transitions(from_status, to_status);

-- Seed valid transitions
INSERT INTO quality_status_transitions (from_status, to_status, requires_inspection, requires_approval, requires_reason, is_allowed, description) VALUES
  -- From PENDING
  ('PENDING', 'PASSED', true, false, true, true, 'Inspection passed, approved for use'),
  ('PENDING', 'FAILED', true, false, true, true, 'Inspection failed, rejected'),
  ('PENDING', 'HOLD', false, false, true, true, 'Investigation required before decision'),
  ('PENDING', 'QUARANTINED', false, true, true, true, 'Immediate quarantine required'),

  -- From PASSED
  ('PASSED', 'HOLD', false, false, true, true, 'Post-approval issue identified'),
  ('PASSED', 'QUARANTINED', false, true, true, true, 'Critical issue found after approval'),
  ('PASSED', 'FAILED', false, true, true, true, 'Revoke approval due to new information'),

  -- From FAILED
  ('FAILED', 'HOLD', false, false, true, true, 'Further investigation needed'),
  ('FAILED', 'QUARANTINED', false, false, true, true, 'Quarantine failed material'),

  -- From HOLD
  ('HOLD', 'PASSED', true, true, true, true, 'Investigation complete, approved'),
  ('HOLD', 'FAILED', true, true, true, true, 'Investigation complete, rejected'),
  ('HOLD', 'RELEASED', true, true, true, true, 'Released for use after investigation'),
  ('HOLD', 'COND_APPROVED', true, true, true, true, 'Approved with conditions'),
  ('HOLD', 'QUARANTINED', false, false, true, true, 'Escalate to quarantine'),

  -- From QUARANTINED
  ('QUARANTINED', 'HOLD', false, true, true, true, 'Downgrade to hold for investigation'),
  ('QUARANTINED', 'RELEASED', true, true, true, true, 'Released after quarantine review'),
  ('QUARANTINED', 'FAILED', true, true, true, true, 'Permanently rejected'),

  -- From COND_APPROVED
  ('COND_APPROVED', 'PASSED', true, true, true, true, 'Conditions met, full approval'),
  ('COND_APPROVED', 'FAILED', true, true, true, true, 'Conditions not met, rejected'),
  ('COND_APPROVED', 'HOLD', false, false, true, true, 'Additional investigation needed'),

  -- From RELEASED
  ('RELEASED', 'HOLD', false, false, true, true, 'New issue identified'),
  ('RELEASED', 'QUARANTINED', false, true, true, true, 'Critical issue after release');

-- Create quality_status_history table for audit trail
CREATE TABLE quality_status_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  entity_type TEXT NOT NULL CHECK (entity_type IN ('lp', 'batch', 'inspection')),
  entity_id UUID NOT NULL,
  from_status quality_status_type,
  to_status quality_status_type NOT NULL,
  reason TEXT,
  changed_by UUID NOT NULL REFERENCES users(id),
  changed_at TIMESTAMPTZ DEFAULT now(),
  requires_reversal BOOLEAN DEFAULT false,

  CONSTRAINT valid_status_change CHECK (from_status IS NULL OR from_status != to_status)
);

COMMENT ON TABLE quality_status_history IS 'Audit trail of all quality status changes';

-- Create indexes for history queries
CREATE INDEX idx_status_history_org ON quality_status_history(org_id);
CREATE INDEX idx_status_history_entity ON quality_status_history(entity_type, entity_id);
CREATE INDEX idx_status_history_date ON quality_status_history(changed_at DESC);

-- RLS policies for quality_status_history
ALTER TABLE quality_status_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Status history org isolation"
ON quality_status_history FOR ALL
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- RLS policies for quality_status_transitions (read-only for all authenticated users)
ALTER TABLE quality_status_transitions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Status transitions read for authenticated"
ON quality_status_transitions FOR SELECT
TO authenticated
USING (true);
```

### Migration 2: Update License Plates Table

```sql
-- File: supabase/migrations/XXX_update_lp_qa_status_enum.sql

-- Update license_plates.qa_status to use enum type (if not already done)
-- This assumes license_plates table exists from Epic 05 story 05.1

-- If qa_status column exists as TEXT, convert it
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'license_plates'
    AND column_name = 'qa_status'
    AND data_type = 'text'
  ) THEN
    -- Add new column with enum type
    ALTER TABLE license_plates ADD COLUMN qa_status_new quality_status_type DEFAULT 'PENDING';

    -- Migrate existing data (map old text values to enum)
    UPDATE license_plates
    SET qa_status_new = CASE
      WHEN UPPER(qa_status) IN ('PENDING', 'PASSED', 'FAILED', 'HOLD', 'RELEASED', 'QUARANTINED', 'COND_APPROVED')
        THEN UPPER(qa_status)::quality_status_type
      ELSE 'PENDING'::quality_status_type
    END;

    -- Drop old column and rename new
    ALTER TABLE license_plates DROP COLUMN qa_status;
    ALTER TABLE license_plates RENAME COLUMN qa_status_new TO qa_status;
  ELSIF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'license_plates'
    AND column_name = 'qa_status'
  ) THEN
    -- Column doesn't exist, add it
    ALTER TABLE license_plates ADD COLUMN qa_status quality_status_type DEFAULT 'PENDING';
  END IF;
END $$;

-- Add constraint to ensure qa_status is never null
ALTER TABLE license_plates ALTER COLUMN qa_status SET NOT NULL;
ALTER TABLE license_plates ALTER COLUMN qa_status SET DEFAULT 'PENDING';

-- Create index for QA status filtering
CREATE INDEX IF NOT EXISTS idx_lp_qa_status ON license_plates(org_id, qa_status);
```

## Acceptance Criteria (Given/When/Then)

### Status Type Definition
- GIVEN quality_status_type enum is created, WHEN database schema is queried, THEN 7 status types (PENDING, PASSED, FAILED, HOLD, RELEASED, QUARANTINED, COND_APPROVED) exist.
- GIVEN status transitions table is seeded, WHEN querying transitions, THEN all valid transitions have business rules defined.
- GIVEN license_plates table is updated, WHEN qa_status column is inspected, THEN it uses quality_status_type enum with default 'PENDING'.

### Status Transition Validation
- GIVEN LP with status PENDING, WHEN user attempts transition to PASSED, THEN validation checks requires_inspection=true and blocks if no inspection exists.
- GIVEN LP with status PASSED, WHEN user attempts transition to HOLD, THEN validation allows transition (requires_reason=true).
- GIVEN LP with status FAILED, WHEN user attempts invalid transition to RELEASED, THEN validation returns error "Invalid status transition: FAILED → RELEASED".
- GIVEN LP with status HOLD, WHEN user attempts transition to RELEASED with approval=true, THEN transition succeeds and history record created.
- GIVEN LP with status QUARANTINED, WHEN user without QA Manager role attempts transition, THEN API returns 403 Forbidden "Requires QA Manager approval".

### Status History Tracking
- GIVEN LP status changes from PENDING to PASSED, WHEN transition completes, THEN quality_status_history record created with from_status, to_status, reason, changed_by, changed_at.
- GIVEN 10 status changes on single LP, WHEN history is queried, THEN all 10 transitions returned in chronological order (changed_at DESC).
- GIVEN status change without reason, WHEN requires_reason=true, THEN validation error "Reason is required for this status transition" displayed.

### API Endpoint Functionality
- GIVEN authenticated user, WHEN GET /api/quality/status/types called, THEN 7 status types returned with display names and descriptions within 200ms.
- GIVEN LP with status HOLD, WHEN GET /api/quality/status/transitions?current=HOLD called, THEN valid transitions (PASSED, FAILED, RELEASED, COND_APPROVED, QUARANTINED) returned with business rules.
- GIVEN valid transition request, WHEN POST /api/quality/status/validate-transition called with {from: 'PENDING', to: 'PASSED', entity_id: 'lp-123'}, THEN validation result returned indicating success/failure with reason.

### Status Badge Display
- GIVEN LP with status PASSED, WHEN status badge renders in UI, THEN green badge with "Passed" text and checkmark icon displays.
- GIVEN LP with status FAILED, WHEN status badge renders, THEN red badge with "Failed" text and X icon displays.
- GIVEN LP with status HOLD, WHEN status badge renders, THEN orange badge with "Hold" text and pause icon displays.
- GIVEN LP with status QUARANTINED, WHEN status badge renders, THEN dark red badge with "Quarantined" text and alert icon displays.

### Permission Enforcement
- GIVEN user with VIEWER role, WHEN attempting to view status types, THEN GET /api/quality/status/types succeeds (read access for all).
- GIVEN user without QA Manager role, WHEN attempting transition requiring approval, THEN API returns 403 "QA Manager approval required".
- GIVEN user with QA Inspector role, WHEN attempting PENDING → PASSED transition with inspection, THEN transition succeeds.

### Phase 1B+ Features Handling
- GIVEN user viewing status management UI, WHEN MVP is active (Phase 1A), THEN "Add Custom Status" button hidden.
- GIVEN user attempting to create custom status via API, WHEN POST /api/quality/status/types called, THEN 501 Not Implemented returned with message "Custom status types available in Phase 1B".

## Implementation Notes

### API Endpoints

```typescript
// GET /api/quality/status/types
// Returns: List of available quality status types
interface StatusTypesResponse {
  types: QualityStatusType[];
}

interface QualityStatusType {
  code: 'PENDING' | 'PASSED' | 'FAILED' | 'HOLD' | 'RELEASED' | 'QUARANTINED' | 'COND_APPROVED';
  name: string;
  description: string;
  color: string;         // Badge color
  icon: string;          // Icon name
  allows_shipment: boolean;
  allows_consumption: boolean;
}

// GET /api/quality/status/transitions
// Query params: ?current=HOLD
// Returns: Valid transitions from current status
interface StatusTransitionsResponse {
  current_status: string;
  valid_transitions: StatusTransition[];
}

interface StatusTransition {
  to_status: string;
  requires_inspection: boolean;
  requires_approval: boolean;
  requires_reason: boolean;
  description: string;
}

// POST /api/quality/status/validate-transition
// Validates if a status transition is allowed
interface ValidateTransitionRequest {
  entity_type: 'lp' | 'batch' | 'inspection';
  entity_id: string;
  from_status: string;
  to_status: string;
  reason?: string;
}

interface ValidateTransitionResponse {
  is_valid: boolean;
  errors?: string[];
  warnings?: string[];
  required_actions?: {
    inspection_required?: boolean;
    approval_required?: boolean;
    reason_required?: boolean;
  };
}

// POST /api/quality/status/change (used by LP QA status update endpoints)
interface ChangeStatusRequest {
  entity_type: 'lp' | 'batch' | 'inspection';
  entity_id: string;
  to_status: string;
  reason: string;
  inspection_id?: string; // For transitions requiring inspection
}

interface ChangeStatusResponse {
  success: boolean;
  new_status: string;
  history_id: string;
  warnings?: string[];
}

// GET /api/quality/status/history/:entityType/:entityId
// Returns: Status change history for entity
interface StatusHistoryResponse {
  entity_type: string;
  entity_id: string;
  history: StatusHistoryEntry[];
}

interface StatusHistoryEntry {
  id: string;
  from_status: string | null;
  to_status: string;
  reason: string;
  changed_by: string;
  changed_by_name: string;
  changed_at: string;
}
```

### Status Type Configuration

```typescript
// lib/constants/quality-status.ts
export const QUALITY_STATUS_CONFIG: Record<string, QualityStatusType> = {
  PENDING: {
    code: 'PENDING',
    name: 'Pending',
    description: 'Awaiting inspection',
    color: 'gray',
    icon: 'Clock',
    allows_shipment: false,
    allows_consumption: false, // Configurable via settings
  },
  PASSED: {
    code: 'PASSED',
    name: 'Passed',
    description: 'Meets specifications',
    color: 'green',
    icon: 'CheckCircle',
    allows_shipment: true,
    allows_consumption: true,
  },
  FAILED: {
    code: 'FAILED',
    name: 'Failed',
    description: 'Does not meet specs',
    color: 'red',
    icon: 'XCircle',
    allows_shipment: false,
    allows_consumption: false,
  },
  HOLD: {
    code: 'HOLD',
    name: 'Hold',
    description: 'Investigation required',
    color: 'orange',
    icon: 'Pause',
    allows_shipment: false,
    allows_consumption: false,
  },
  RELEASED: {
    code: 'RELEASED',
    name: 'Released',
    description: 'Approved for use after hold',
    color: 'blue',
    icon: 'Unlock',
    allows_shipment: true,
    allows_consumption: true,
  },
  QUARANTINED: {
    code: 'QUARANTINED',
    name: 'Quarantined',
    description: 'Isolated pending review',
    color: 'darkRed',
    icon: 'AlertTriangle',
    allows_shipment: false,
    allows_consumption: false,
  },
  COND_APPROVED: {
    code: 'COND_APPROVED',
    name: 'Conditionally Approved',
    description: 'Limited use allowed',
    color: 'yellow',
    icon: 'AlertCircle',
    allows_shipment: false, // Restricted
    allows_consumption: true, // Restricted (business rules apply)
  },
};
```

### Services

```typescript
// lib/services/quality-status-service.ts
export class QualityStatusService {
  /**
   * Get all available quality status types
   */
  static async getStatusTypes(): Promise<QualityStatusType[]> {
    return Object.values(QUALITY_STATUS_CONFIG);
  }

  /**
   * Get valid transitions from current status
   */
  static async getValidTransitions(
    currentStatus: string
  ): Promise<StatusTransition[]> {
    const { data, error } = await supabase
      .from('quality_status_transitions')
      .select('*')
      .eq('from_status', currentStatus)
      .eq('is_allowed', true);

    if (error) throw error;
    return data || [];
  }

  /**
   * Validate if status transition is allowed
   */
  static async validateTransition(
    request: ValidateTransitionRequest
  ): Promise<ValidateTransitionResponse> {
    const { entity_type, entity_id, from_status, to_status, reason } = request;

    // 1. Check if transition rule exists
    const { data: transition, error: transitionError } = await supabase
      .from('quality_status_transitions')
      .select('*')
      .eq('from_status', from_status)
      .eq('to_status', to_status)
      .single();

    if (transitionError || !transition?.is_allowed) {
      return {
        is_valid: false,
        errors: [`Invalid status transition: ${from_status} → ${to_status}`],
      };
    }

    const errors: string[] = [];
    const warnings: string[] = [];
    const required_actions: any = {};

    // 2. Check if reason is provided when required
    if (transition.requires_reason && !reason) {
      errors.push('Reason is required for this status transition');
      required_actions.reason_required = true;
    }

    // 3. Check if inspection exists when required
    if (transition.requires_inspection) {
      const hasInspection = await this.checkInspectionExists(entity_id);
      if (!hasInspection) {
        errors.push('Inspection required before this status transition');
        required_actions.inspection_required = true;
      }
    }

    // 4. Check if approval is required
    if (transition.requires_approval) {
      const hasApproval = await this.checkUserHasApprovalRole();
      if (!hasApproval) {
        errors.push('QA Manager approval required for this transition');
        required_actions.approval_required = true;
      }
    }

    return {
      is_valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined,
      required_actions: Object.keys(required_actions).length > 0 ? required_actions : undefined,
    };
  }

  /**
   * Change status and record in history
   */
  static async changeStatus(
    request: ChangeStatusRequest,
    userId: string
  ): Promise<ChangeStatusResponse> {
    const { entity_type, entity_id, to_status, reason } = request;

    // 1. Get current status
    const currentStatus = await this.getCurrentStatus(entity_type, entity_id);

    // 2. Validate transition
    const validation = await this.validateTransition({
      entity_type,
      entity_id,
      from_status: currentStatus,
      to_status,
      reason,
    });

    if (!validation.is_valid) {
      throw new Error(validation.errors?.join(', '));
    }

    // 3. Update status (different tables based on entity_type)
    if (entity_type === 'lp') {
      await this.updateLPStatus(entity_id, to_status);
    }
    // Add batch, inspection cases when implemented

    // 4. Record in history
    const { data: history, error: historyError } = await supabase
      .from('quality_status_history')
      .insert({
        entity_type,
        entity_id,
        from_status: currentStatus,
        to_status,
        reason,
        changed_by: userId,
      })
      .select()
      .single();

    if (historyError) throw historyError;

    return {
      success: true,
      new_status: to_status,
      history_id: history.id,
      warnings: validation.warnings,
    };
  }

  /**
   * Get status change history for entity
   */
  static async getStatusHistory(
    entityType: string,
    entityId: string
  ): Promise<StatusHistoryEntry[]> {
    const { data, error } = await supabase
      .from('quality_status_history')
      .select(`
        *,
        users:changed_by (
          id,
          full_name
        )
      `)
      .eq('entity_type', entityType)
      .eq('entity_id', entityId)
      .order('changed_at', { ascending: false });

    if (error) throw error;

    return data.map((entry) => ({
      id: entry.id,
      from_status: entry.from_status,
      to_status: entry.to_status,
      reason: entry.reason,
      changed_by: entry.changed_by,
      changed_by_name: entry.users?.full_name || 'Unknown',
      changed_at: entry.changed_at,
    }));
  }

  // Helper methods
  private static async getCurrentStatus(
    entityType: string,
    entityId: string
  ): Promise<string> {
    if (entityType === 'lp') {
      const { data } = await supabase
        .from('license_plates')
        .select('qa_status')
        .eq('id', entityId)
        .single();
      return data?.qa_status || 'PENDING';
    }
    // Add other entity types
    throw new Error(`Unknown entity type: ${entityType}`);
  }

  private static async updateLPStatus(
    lpId: string,
    status: string
  ): Promise<void> {
    const { error } = await supabase
      .from('license_plates')
      .update({ qa_status: status })
      .eq('id', lpId);

    if (error) throw error;
  }

  private static async checkInspectionExists(entityId: string): Promise<boolean> {
    // Placeholder - implement when quality_inspections table exists
    return true;
  }

  private static async checkUserHasApprovalRole(): Promise<boolean> {
    // Check if current user has QA Manager or higher role
    const { data: user } = await supabase
      .from('users')
      .select('role')
      .eq('id', (await supabase.auth.getUser()).data.user?.id)
      .single();

    return ['QA_MANAGER', 'QUALITY_DIRECTOR', 'ADMIN'].includes(user?.role || '');
  }
}
```

### Validation (Zod)

```typescript
// lib/validation/quality-status-validation.ts
import { z } from 'zod';

export const qualityStatusEnum = z.enum([
  'PENDING',
  'PASSED',
  'FAILED',
  'HOLD',
  'RELEASED',
  'QUARANTINED',
  'COND_APPROVED',
]);

export const validateTransitionSchema = z.object({
  entity_type: z.enum(['lp', 'batch', 'inspection']),
  entity_id: z.string().uuid('Invalid entity ID'),
  from_status: qualityStatusEnum,
  to_status: qualityStatusEnum,
  reason: z.string().min(10, 'Reason must be at least 10 characters').max(500).optional(),
}).refine(
  (data) => data.from_status !== data.to_status,
  { message: 'From and to status cannot be the same', path: ['to_status'] }
);

export const changeStatusSchema = z.object({
  entity_type: z.enum(['lp', 'batch', 'inspection']),
  entity_id: z.string().uuid('Invalid entity ID'),
  to_status: qualityStatusEnum,
  reason: z.string().min(10, 'Reason must be at least 10 characters').max(500),
  inspection_id: z.string().uuid().optional(),
});
```

### Frontend Components

```typescript
// components/quality/StatusBadge.tsx
interface StatusBadgeProps {
  status: string;
  size?: 'sm' | 'md' | 'lg';
}

export function StatusBadge({ status, size = 'md' }: StatusBadgeProps) {
  const config = QUALITY_STATUS_CONFIG[status];
  if (!config) return null;

  const Icon = getIconComponent(config.icon);
  const colorClass = getColorClass(config.color);

  return (
    <Badge variant="outline" className={`${colorClass} ${getSizeClass(size)}`}>
      <Icon className="w-4 h-4 mr-1" />
      {config.name}
    </Badge>
  );
}

// components/quality/StatusTransitionModal.tsx
interface StatusTransitionModalProps {
  entityType: 'lp' | 'batch' | 'inspection';
  entityId: string;
  currentStatus: string;
  onSuccess: () => void;
}

export function StatusTransitionModal({
  entityType,
  entityId,
  currentStatus,
  onSuccess,
}: StatusTransitionModalProps) {
  const [toStatus, setToStatus] = useState('');
  const [reason, setReason] = useState('');
  const [validTransitions, setValidTransitions] = useState<StatusTransition[]>([]);

  useEffect(() => {
    loadValidTransitions();
  }, [currentStatus]);

  async function loadValidTransitions() {
    const transitions = await QualityStatusService.getValidTransitions(currentStatus);
    setValidTransitions(transitions);
  }

  async function handleSubmit() {
    // Validate
    const validation = await QualityStatusService.validateTransition({
      entity_type: entityType,
      entity_id: entityId,
      from_status: currentStatus,
      to_status: toStatus,
      reason,
    });

    if (!validation.is_valid) {
      toast.error(validation.errors?.join(', '));
      return;
    }

    // Change status
    await QualityStatusService.changeStatus(
      { entity_type: entityType, entity_id: entityId, to_status: toStatus, reason },
      currentUserId
    );

    toast.success('Status updated successfully');
    onSuccess();
  }

  return (
    <Dialog>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Change Quality Status</DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          <div>
            <Label>Current Status</Label>
            <StatusBadge status={currentStatus} />
          </div>

          <div>
            <Label>New Status</Label>
            <Select value={toStatus} onValueChange={setToStatus}>
              <SelectTrigger>
                <SelectValue placeholder="Select new status" />
              </SelectTrigger>
              <SelectContent>
                {validTransitions.map((t) => (
                  <SelectItem key={t.to_status} value={t.to_status}>
                    <div className="flex items-center">
                      <StatusBadge status={t.to_status} size="sm" />
                      <span className="ml-2 text-sm text-muted-foreground">
                        {t.description}
                      </span>
                    </div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div>
            <Label>Reason *</Label>
            <Textarea
              value={reason}
              onChange={(e) => setReason(e.target.value)}
              placeholder="Explain reason for status change..."
              rows={3}
            />
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={onClose}>Cancel</Button>
          <Button onClick={handleSubmit}>Update Status</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

## Deliverables

- Database migration creating `quality_status_type` enum with 7 statuses
- `quality_status_transitions` table with seeded transition rules
- `quality_status_history` table for audit trail
- Updated `license_plates.qa_status` to use enum type
- `QualityStatusService` with validation and transition logic
- API routes for status types, transitions, validation, and history
- `StatusBadge` component with color coding
- `StatusTransitionModal` component for status changes
- Zod validation schemas for status operations
- RLS policies for status history and transitions tables
- Unit tests for status transition validation (>85% coverage)
- Integration tests for API endpoints

## Test Strategy

### Unit Tests
- Status transition validation logic (all 7 statuses, 20+ transitions)
- Business rule checks (requires_inspection, requires_approval, requires_reason)
- Role-based permission checks for transitions
- Status history recording

### Integration Tests
- GET /api/quality/status/types returns 7 statuses
- GET /api/quality/status/transitions returns valid transitions for each status
- POST /api/quality/status/validate-transition correctly validates all business rules
- POST /api/quality/status/change updates LP status and creates history record
- GET /api/quality/status/history returns chronological history

### E2E Tests
- User navigates to LP detail, changes status from PENDING to PASSED with inspection
- User attempts invalid transition (FAILED → RELEASED), sees error message
- QA Manager approves status change requiring approval
- Status badge displays correct color and icon in LP list

## Definition of Done

- [ ] `quality_status_type` enum created with 7 statuses
- [ ] `quality_status_transitions` table seeded with 20+ valid transitions
- [ ] `quality_status_history` table tracks all status changes
- [ ] `license_plates.qa_status` uses enum type with PENDING default
- [ ] GET /api/quality/status/types returns all statuses within 200ms
- [ ] GET /api/quality/status/transitions filters by current status correctly
- [ ] POST /api/quality/status/validate-transition enforces all business rules
- [ ] Status change creates history record with user, timestamp, reason
- [ ] Transitions requiring inspection are blocked without inspection
- [ ] Transitions requiring approval are blocked for non-QA Manager users
- [ ] StatusBadge component displays correct colors and icons
- [ ] Status transition modal shows only valid transitions
- [ ] RLS policies enforce org isolation on status history
- [ ] Phase 1B+ features (custom statuses) return 501 Not Implemented
- [ ] Unit tests achieve >85% coverage on status service
- [ ] Integration tests cover all API endpoints
- [ ] E2E test covers full status change workflow
- [ ] Documentation updated with status types and transition rules
