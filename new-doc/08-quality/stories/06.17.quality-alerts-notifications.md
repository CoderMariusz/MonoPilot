# 06.17 - Quality Alerts & Notifications

**Story ID:** 06.17
**Epic:** 06 - Quality
**Phase:** 2B
**Complexity:** M (Medium)
**Estimate:** 3-4 days
**Type:** Backend (notification system)
**State:** ready

**Primary PRD:** `docs/1-BASELINE/product/modules/quality.md` (Section 18 - Notifications)
**Architecture:** `docs/1-BASELINE/architecture/modules/quality.md`
**UX Wireframes:**
- `docs/3-ARCHITECTURE/ux/wireframes/QA-017-alert-bell.md`
- `docs/3-ARCHITECTURE/ux/wireframes/QA-017-alert-preferences.md`

---

## Goal

Implement a **real-time quality alert and notification system** that ensures quality-critical events reach the right people at the right time through multiple channels (WebSocket, Email, SMS). This enables immediate response to food safety issues like CCP deviations, failed inspections, and critical NCRs.

---

## Food Safety Compliance

This story is **critical for food safety compliance**:

- [x] **FDA FSMA** - Requires timely corrective action for food safety deviations
- [x] **HACCP Compliance** - CCP deviations must trigger immediate alerts (<30 seconds)
- [x] **ISO 22000** - Documented notification and escalation procedures
- [x] **Audit Trail** - All alert deliveries and acknowledgments logged

**Regulatory Context:**
- CCP deviation alerts are life-critical and require immediate delivery
- Critical NCRs (food safety risk) must escalate within 24 hours
- All alert acknowledgments create audit trail for compliance
- Notification failures must be logged and retried

---

## MVP Scope

This story implements **Phase 2B Quality Alerts** with:

**MVP Includes:**
- `quality_alerts` table (alert storage)
- `quality_alert_recipients` table (many-to-many routing)
- `quality_alert_templates` table (configurable messages)
- `user_alert_preferences` table (per-user channel toggles)
- Alert types by severity (Critical, High, Medium, Low)
- Alert routing by role (QA Manager, Production Lead, etc.)
- Alert acknowledgment tracking
- Alert history with read/unread status
- WebSocket real-time delivery
- Email notifications (via SendGrid/Resend)
- SMS notifications (via Twilio - optional)
- Escalation rules (auto-escalate if not acknowledged)

**Deferred to Phase 3+:**
- Push notifications (mobile app)
- Slack/Teams integration
- Custom escalation chains
- Alert digest (daily/weekly summary)
- Advanced alert analytics

---

## User Story

As a **QA Manager**, I want to **receive immediate alerts when critical quality events occur (CCP deviations, failed inspections, critical NCRs)** so that **I can respond quickly to food safety issues and maintain compliance**.

As a **Production Lead**, I want to **be notified when quality holds affect my production batches** so that **I can adjust production plans and investigate root causes**.

As a **User**, I want to **configure my alert preferences (email, SMS, in-app)** so that **I receive notifications through my preferred channels without being overwhelmed**.

---

## Scope

**In scope (this story)**
- `quality_alerts` table with alert metadata
- `quality_alert_recipients` table (many-to-many)
- `quality_alert_templates` table (message templates)
- `user_alert_preferences` table (channel preferences)
- GET /api/quality/alerts (list user's alerts)
- GET /api/quality/alerts/unread-count (badge count)
- POST /api/quality/alerts/:id/acknowledge
- PUT /api/quality/alerts/:id/read
- GET /api/quality/alerts/preferences
- PUT /api/quality/alerts/preferences
- POST /api/quality/alerts/send (admin trigger)
- POST /api/quality/alerts/test (test notification)
- WebSocket alert delivery (real-time)
- Email notification integration
- SMS notification integration (Twilio)
- Alert bell icon with unread count badge
- Alert dropdown (recent 10 alerts)
- Alert preferences page
- Escalation rules engine
- Audit trail for all alert actions

**Out of scope (this story)**
- Push notifications (mobile)
- Slack/Teams webhooks
- Alert digest emails
- Complex escalation chains
- Alert analytics dashboard

---

## Alert Types & Severity

| Severity | Alert Type | Description | Delivery Channels | Response Time |
|----------|------------|-------------|-------------------|---------------|
| **Critical** | CCP Deviation | Critical control point outside limits | WebSocket + Email + SMS | Immediate (<30s) |
| **Critical** | Critical NCR | Food safety risk or regulatory violation | WebSocket + Email + SMS | Immediate (<30s) |
| **Critical** | Failed Inspection | Inspection result = fail (critical parameter) | WebSocket + Email + SMS | Immediate (<30s) |
| **High** | Inspection Due | Scheduled inspection approaching | WebSocket + Email | 5 minutes |
| **High** | Hold Aging >48h | Quality hold not resolved within 48 hours | WebSocket + Email | Hourly check |
| **High** | NCR Overdue | NCR not progressed within SLA | WebSocket + Email | Hourly check |
| **Medium** | Batch Pending Release | Batch completed, awaiting QA release | WebSocket + Email | 15 minutes |
| **Medium** | CAPA Effectiveness Due | CAPA effectiveness check due date | WebSocket + Email | Daily |
| **Low** | Supplier Audit Due | Scheduled supplier audit approaching | WebSocket + Email | Daily |

---

## Dependencies

### Cross-Epic Dependencies

| Dependency | Story/Epic | Type | What It Provides | Status |
|------------|------------|------|------------------|--------|
| 01.1 | Org Context + RLS | HARD | organizations, users, roles | Ready |
| 01.15 | Session Management | SOFT | User session for WebSocket | Ready |

### Within Epic Dependencies

| Dependency | Story | Type | What It Provides |
|------------|-------|------|------------------|
| 06.1 | Quality Status Types | HARD | Quality events to trigger alerts |
| 06.2 | Quality Holds CRUD | HARD | Hold events for alerts |
| 06.5 | Incoming Inspection | HARD | Inspection events for alerts |
| 06.9 | Basic NCR Creation | HARD | NCR events for alerts |
| 06.13 | NCR Workflow | SOFT | Workflow transitions for alerts |

### Provides To (Downstream)

| Story | What This Provides |
|-------|-------------------|
| 06.25-06.26 | CCP Deviation Alerts - extends alert system |
| 06.31 | CAPA Creation - CAPA due alerts |
| 06.37 | Quality Dashboard - alert metrics |

---

## Database Migration

### Migration: Create quality alert tables

```sql
-- Migration: YYYYMMDDHHMMSS_create_quality_alerts.sql

-- =============================================================================
-- Quality Alert Types Enum
-- =============================================================================

CREATE TYPE quality_alert_severity AS ENUM ('critical', 'high', 'medium', 'low');
CREATE TYPE quality_alert_status AS ENUM ('pending', 'delivered', 'read', 'acknowledged', 'expired');
CREATE TYPE quality_alert_channel AS ENUM ('websocket', 'email', 'sms', 'push');

-- =============================================================================
-- Quality Alert Templates Table
-- =============================================================================
-- Configurable message templates for different alert types

CREATE TABLE quality_alert_templates (
    -- Identity
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id                  UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

    -- Template identification
    template_code           TEXT NOT NULL,  -- 'ccp_deviation', 'ncr_critical', 'inspection_failed', etc.
    name                    TEXT NOT NULL,
    description             TEXT,

    -- Template content
    severity                quality_alert_severity NOT NULL,
    subject_template        TEXT NOT NULL,  -- "CRITICAL: CCP Deviation at {{ccp_name}}"
    body_template           TEXT NOT NULL,  -- "CCP {{ccp_name}} recorded value {{value}} (limit: {{limit_min}}-{{limit_max}})"
    sms_template            TEXT,           -- Short SMS version: "CCP {{ccp_name}} DEVIATION: {{value}}"

    -- Routing
    default_recipients      JSONB,          -- ["QA_MANAGER", "PRODUCTION_LEAD"]
    escalation_roles        JSONB,          -- ["QUALITY_DIRECTOR"] after timeout
    escalation_timeout_min  INTEGER DEFAULT 60, -- Minutes before escalation

    -- Channels
    channels_enabled        JSONB NOT NULL DEFAULT '["websocket", "email"]',

    -- Auto-trigger rules
    auto_trigger_enabled    BOOLEAN NOT NULL DEFAULT true,
    trigger_conditions      JSONB,          -- Conditions for auto-trigger

    -- Audit
    is_active               BOOLEAN NOT NULL DEFAULT true,
    created_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by              UUID REFERENCES users(id),
    updated_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by              UUID REFERENCES users(id),

    -- Constraints
    CONSTRAINT uq_alert_template_code UNIQUE (org_id, template_code)
);

COMMENT ON TABLE quality_alert_templates IS 'Configurable alert message templates';
COMMENT ON COLUMN quality_alert_templates.subject_template IS 'Mustache-style template for subject';
COMMENT ON COLUMN quality_alert_templates.body_template IS 'Mustache-style template for body';

-- =============================================================================
-- Quality Alerts Table (Main Alert Records)
-- =============================================================================

CREATE TABLE quality_alerts (
    -- Identity
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id                  UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    alert_number            TEXT NOT NULL,  -- QA-YYYY-NNNNN

    -- Alert type and content
    template_id             UUID REFERENCES quality_alert_templates(id),
    alert_type              TEXT NOT NULL,  -- 'ccp_deviation', 'ncr_critical', etc.
    severity                quality_alert_severity NOT NULL,

    -- Message content (rendered from template)
    subject                 TEXT NOT NULL,
    body                    TEXT NOT NULL,
    sms_body                TEXT,

    -- Source reference (polymorphic)
    source_type             TEXT,           -- 'ncr', 'inspection', 'hold', 'ccp_monitoring', 'capa', etc.
    source_id               UUID,
    source_reference        TEXT,           -- Human-readable: "NCR-2025-00123"

    -- Delivery tracking
    status                  quality_alert_status NOT NULL DEFAULT 'pending',
    channels_sent           JSONB DEFAULT '[]',  -- ["websocket", "email"]

    -- Timing
    created_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    expires_at              TIMESTAMPTZ,    -- Alert expiration
    delivered_at            TIMESTAMPTZ,
    first_read_at           TIMESTAMPTZ,
    acknowledged_at         TIMESTAMPTZ,
    acknowledged_by         UUID REFERENCES users(id),

    -- Escalation
    escalation_level        INTEGER DEFAULT 0,
    escalated_at            TIMESTAMPTZ,
    next_escalation_at      TIMESTAMPTZ,

    -- Metadata
    metadata                JSONB,          -- Additional context data

    -- Constraints
    CONSTRAINT uq_alert_number UNIQUE (org_id, alert_number)
);

-- Indexes for performance
CREATE INDEX idx_qa_alerts_org_status ON quality_alerts(org_id, status);
CREATE INDEX idx_qa_alerts_org_severity ON quality_alerts(org_id, severity);
CREATE INDEX idx_qa_alerts_created ON quality_alerts(org_id, created_at DESC);
CREATE INDEX idx_qa_alerts_source ON quality_alerts(source_type, source_id);
CREATE INDEX idx_qa_alerts_pending_escalation ON quality_alerts(next_escalation_at)
    WHERE status = 'pending' AND next_escalation_at IS NOT NULL;

COMMENT ON TABLE quality_alerts IS 'Quality alert records with delivery tracking';

-- =============================================================================
-- Quality Alert Recipients Table (Many-to-Many)
-- =============================================================================

CREATE TABLE quality_alert_recipients (
    -- Identity
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    alert_id                UUID NOT NULL REFERENCES quality_alerts(id) ON DELETE CASCADE,
    user_id                 UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Delivery status per user
    status                  quality_alert_status NOT NULL DEFAULT 'pending',

    -- Channel delivery tracking
    websocket_sent_at       TIMESTAMPTZ,
    websocket_delivered_at  TIMESTAMPTZ,
    email_sent_at           TIMESTAMPTZ,
    email_delivered_at      TIMESTAMPTZ,
    email_opened_at         TIMESTAMPTZ,
    sms_sent_at             TIMESTAMPTZ,
    sms_delivered_at        TIMESTAMPTZ,

    -- Read/Acknowledgment per user
    read_at                 TIMESTAMPTZ,
    acknowledged_at         TIMESTAMPTZ,
    acknowledgment_notes    TEXT,

    -- Escalation tracking
    escalation_level        INTEGER DEFAULT 0, -- 0 = original, 1 = first escalation, etc.

    -- Audit
    created_at              TIMESTAMPTZ NOT NULL DEFAULT now(),

    -- Constraints
    CONSTRAINT uq_alert_recipient UNIQUE (alert_id, user_id)
);

-- Indexes
CREATE INDEX idx_qa_alert_recipients_user ON quality_alert_recipients(user_id, status);
CREATE INDEX idx_qa_alert_recipients_alert ON quality_alert_recipients(alert_id);
CREATE INDEX idx_qa_alert_recipients_unread ON quality_alert_recipients(user_id, read_at)
    WHERE read_at IS NULL;

COMMENT ON TABLE quality_alert_recipients IS 'Alert recipients with per-user delivery status';

-- =============================================================================
-- User Alert Preferences Table
-- =============================================================================

CREATE TABLE user_alert_preferences (
    -- Identity
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id                 UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    org_id                  UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

    -- Global preferences
    alerts_enabled          BOOLEAN NOT NULL DEFAULT true,
    quiet_hours_enabled     BOOLEAN NOT NULL DEFAULT false,
    quiet_hours_start       TIME,           -- 22:00
    quiet_hours_end         TIME,           -- 07:00
    quiet_hours_timezone    TEXT DEFAULT 'UTC',

    -- Channel preferences (global defaults)
    websocket_enabled       BOOLEAN NOT NULL DEFAULT true,
    email_enabled           BOOLEAN NOT NULL DEFAULT true,
    sms_enabled             BOOLEAN NOT NULL DEFAULT false,
    push_enabled            BOOLEAN NOT NULL DEFAULT false,

    -- Per-severity overrides (JSONB)
    -- {"critical": {"websocket": true, "email": true, "sms": true}, "high": {...}}
    severity_preferences    JSONB,

    -- Per-alert-type overrides (JSONB)
    -- {"ccp_deviation": {"email": false}, "ncr_critical": {...}}
    alert_type_preferences  JSONB,

    -- Contact info
    email_address           TEXT,           -- Override user email (optional)
    sms_phone_number        TEXT,           -- E.164 format: +1234567890

    -- Audit
    created_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at              TIMESTAMPTZ NOT NULL DEFAULT now(),

    -- Constraints
    CONSTRAINT uq_user_alert_preferences UNIQUE (user_id, org_id)
);

CREATE INDEX idx_user_alert_prefs_user ON user_alert_preferences(user_id);
CREATE INDEX idx_user_alert_prefs_org ON user_alert_preferences(org_id);

COMMENT ON TABLE user_alert_preferences IS 'Per-user alert delivery preferences';

-- =============================================================================
-- Alert Delivery Log Table (Audit Trail)
-- =============================================================================

CREATE TABLE quality_alert_delivery_log (
    -- Identity
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    alert_id                UUID NOT NULL REFERENCES quality_alerts(id) ON DELETE CASCADE,
    recipient_id            UUID REFERENCES quality_alert_recipients(id) ON DELETE SET NULL,
    user_id                 UUID REFERENCES users(id),

    -- Delivery details
    channel                 quality_alert_channel NOT NULL,
    status                  TEXT NOT NULL,  -- 'sent', 'delivered', 'failed', 'bounced', 'opened'

    -- Provider response
    provider                TEXT,           -- 'sendgrid', 'twilio', 'internal'
    provider_message_id     TEXT,
    provider_response       JSONB,

    -- Error handling
    error_message           TEXT,
    retry_count             INTEGER DEFAULT 0,
    next_retry_at           TIMESTAMPTZ,

    -- Timestamps
    created_at              TIMESTAMPTZ NOT NULL DEFAULT now(),

    -- No updates - append-only audit log
    CONSTRAINT check_status CHECK (status IN ('pending', 'sent', 'delivered', 'failed', 'bounced', 'opened'))
);

CREATE INDEX idx_qa_delivery_log_alert ON quality_alert_delivery_log(alert_id);
CREATE INDEX idx_qa_delivery_log_user ON quality_alert_delivery_log(user_id);
CREATE INDEX idx_qa_delivery_log_retry ON quality_alert_delivery_log(next_retry_at)
    WHERE status = 'failed' AND next_retry_at IS NOT NULL;

COMMENT ON TABLE quality_alert_delivery_log IS 'Immutable audit trail for alert deliveries';

-- =============================================================================
-- Alert Number Sequence
-- =============================================================================

CREATE TABLE quality_alert_sequences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    year INTEGER NOT NULL,
    current_value BIGINT NOT NULL DEFAULT 0,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    UNIQUE(org_id, year)
);

-- Function to generate alert number (QA-YYYY-NNNNN)
CREATE OR REPLACE FUNCTION generate_alert_number(p_org_id UUID)
RETURNS TEXT AS $$
DECLARE
    v_year INTEGER;
    v_next_val BIGINT;
    v_alert_number TEXT;
BEGIN
    v_year := EXTRACT(YEAR FROM CURRENT_DATE);

    INSERT INTO quality_alert_sequences (org_id, year, current_value)
    VALUES (p_org_id, v_year, 1)
    ON CONFLICT (org_id, year)
    DO UPDATE SET
        current_value = quality_alert_sequences.current_value + 1,
        updated_at = NOW()
    RETURNING current_value INTO v_next_val;

    v_alert_number := 'QA-' || v_year::TEXT || '-' || LPAD(v_next_val::TEXT, 5, '0');

    RETURN v_alert_number;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- RLS Policies
-- =============================================================================

ALTER TABLE quality_alert_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE quality_alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE quality_alert_recipients ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_alert_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE quality_alert_delivery_log ENABLE ROW LEVEL SECURITY;

-- Templates: Org members can read, admins can write
CREATE POLICY "alert_templates_select" ON quality_alert_templates
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "alert_templates_insert" ON quality_alert_templates
    FOR INSERT WITH CHECK (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND EXISTS (
            SELECT 1 FROM users u
            JOIN roles r ON u.role_id = r.id
            WHERE u.id = auth.uid() AND r.code IN ('SUPER_ADMIN', 'ADMIN', 'QA_MANAGER')
        )
    );

CREATE POLICY "alert_templates_update" ON quality_alert_templates
    FOR UPDATE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND EXISTS (
            SELECT 1 FROM users u
            JOIN roles r ON u.role_id = r.id
            WHERE u.id = auth.uid() AND r.code IN ('SUPER_ADMIN', 'ADMIN', 'QA_MANAGER')
        )
    );

-- Alerts: Org members can read, system can write
CREATE POLICY "alerts_select" ON quality_alerts
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "alerts_insert" ON quality_alerts
    FOR INSERT WITH CHECK (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

-- Recipients: Users can see their own alerts
CREATE POLICY "alert_recipients_select" ON quality_alert_recipients
    FOR SELECT USING (
        user_id = auth.uid()
        OR EXISTS (
            SELECT 1 FROM quality_alerts a
            WHERE a.id = alert_id
            AND a.org_id = (SELECT org_id FROM users WHERE id = auth.uid())
            AND EXISTS (
                SELECT 1 FROM users u
                JOIN roles r ON u.role_id = r.id
                WHERE u.id = auth.uid() AND r.code IN ('SUPER_ADMIN', 'ADMIN', 'QA_MANAGER')
            )
        )
    );

-- User preferences: Users can manage their own
CREATE POLICY "user_prefs_select" ON user_alert_preferences
    FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "user_prefs_insert" ON user_alert_preferences
    FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY "user_prefs_update" ON user_alert_preferences
    FOR UPDATE USING (user_id = auth.uid());

-- Delivery log: Admins and QA Managers can view
CREATE POLICY "delivery_log_select" ON quality_alert_delivery_log
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM quality_alerts a
            WHERE a.id = alert_id
            AND a.org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        )
    );

-- =============================================================================
-- Triggers
-- =============================================================================

CREATE TRIGGER update_alert_templates_updated_at
    BEFORE UPDATE ON quality_alert_templates
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_alert_prefs_updated_at
    BEFORE UPDATE ON user_alert_preferences
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =============================================================================
-- Seed Default Templates
-- =============================================================================

-- Note: Seed data should be inserted per-org during org creation
-- Example templates provided in seed-data.sql
```

---

## Acceptance Criteria (Given/When/Then)

### AC-1: Alert Table Structure

```gherkin
Scenario: Alert tables created with all required columns
  Given database migration runs
  When schema is inspected
  Then quality_alerts table has all columns from schema
  And quality_alert_recipients has per-user tracking
  And quality_alert_templates has configurable messages
  And user_alert_preferences has channel toggles
  And RLS policies enforce org isolation
  And alert number generation works (QA-YYYY-NNNNN)
```

### AC-2: Alert Creation - CCP Deviation

```gherkin
Scenario: Critical CCP deviation triggers alert
  Given CCP monitoring records value outside limits
  And template 'ccp_deviation' is configured
  When deviation is detected (story 06.25-06.26 integration)
  Then alert created with:
    | Field | Value |
    | severity | critical |
    | alert_type | ccp_deviation |
    | status | pending |
    | channels_sent | [] |
  And alert_number auto-generated: 'QA-2025-00001'
  And recipients determined by template.default_recipients
  And quality_alert_recipients records created for each recipient
  And WebSocket message sent to online recipients
  And email queued for all recipients with email_enabled=true
  And SMS queued for all recipients with sms_enabled=true (critical only)
```

### AC-3: Alert Creation - Critical NCR

```gherkin
Scenario: Critical NCR creates alert
  Given NCR created with severity = 'critical'
  And template 'ncr_critical' exists
  When NCR saved
  Then alert auto-created with:
    | Field | Value |
    | severity | critical |
    | alert_type | ncr_critical |
    | source_type | ncr |
    | source_id | <ncr uuid> |
    | source_reference | NCR-2025-00123 |
  And QA_MANAGER and QUALITY_DIRECTOR roles notified
  And delivery within 30 seconds (SLA)
```

### AC-4: Alert Creation - Failed Inspection

```gherkin
Scenario: Failed inspection triggers alert
  Given inspection completed with result = 'fail'
  And at least one critical parameter failed
  When inspection saved
  Then alert created with severity = 'critical'
  And alert_type = 'inspection_failed'
  And subject = "FAILED: Inspection INS-INC-2025-00456"
  And QA_MANAGER notified
```

### AC-5: Alert Routing by Role

```gherkin
Scenario: Alerts routed to configured roles
  Given template with default_recipients = ["QA_MANAGER", "PRODUCTION_LEAD"]
  And org has 2 QA Managers and 1 Production Lead
  When alert triggered
  Then 3 quality_alert_recipients records created
  And each recipient receives via their enabled channels

Scenario: Respect user preferences
  Given QA Manager A has email_enabled = true, sms_enabled = false
  And QA Manager B has email_enabled = false, sms_enabled = true
  When critical alert triggered
  Then Manager A receives email only
  And Manager B receives SMS only
  And both receive WebSocket (always enabled for critical)
```

### AC-6: Alert Delivery - WebSocket

```gherkin
Scenario: Real-time WebSocket delivery
  Given user is connected via WebSocket
  When alert created with user as recipient
  Then WebSocket message sent within 1 second
  And message contains: { alertId, type, severity, subject, sourceReference }
  And recipient.websocket_delivered_at updated

Scenario: Offline user
  Given user is not connected via WebSocket
  When alert created with user as recipient
  Then websocket_sent_at remains NULL
  And alert visible when user opens app
```

### AC-7: Alert Delivery - Email

```gherkin
Scenario: Email notification sent
  Given user has email_enabled = true
  And user has valid email address
  When alert created with severity >= medium
  Then email queued to SendGrid/Resend
  And recipient.email_sent_at updated
  And delivery log entry created with provider_message_id
  And email contains: subject, body, link to alert, unsubscribe link

Scenario: Email delivery failure
  Given email bounces or fails
  When webhook received from email provider
  Then delivery_log.status = 'failed'
  And retry scheduled (max 3 attempts)
  And alert.channels_sent not updated until success
```

### AC-8: Alert Delivery - SMS

```gherkin
Scenario: SMS notification sent for critical alerts
  Given user has sms_enabled = true
  And user has valid phone number (E.164 format)
  And alert severity = 'critical'
  When alert created
  Then SMS queued to Twilio
  And SMS body uses sms_template (short version)
  And recipient.sms_sent_at updated
  And delivery log entry created

Scenario: SMS not sent for non-critical
  Given user has sms_enabled = true
  And alert severity = 'medium'
  When alert created
  Then SMS NOT sent (email + websocket only)
```

### AC-9: Alert Acknowledgment

```gherkin
Scenario: Acknowledge alert
  Given user is recipient of alert
  And alert status = 'delivered' or 'read'
  When user clicks [Acknowledge] and provides optional notes
  Then recipient.acknowledged_at = now
  And recipient.acknowledgment_notes = notes
  And recipient.status = 'acknowledged'
  And audit log entry created

Scenario: First acknowledgment updates alert
  Given alert has 3 recipients
  And 0 have acknowledged
  When first recipient acknowledges
  Then alert.acknowledged_at = now
  And alert.acknowledged_by = user
  And alert.status = 'acknowledged'
  And escalation stopped (next_escalation_at = NULL)
```

### AC-10: Alert Read/Unread Status

```gherkin
Scenario: Mark alert as read
  Given user is recipient of alert
  And alert.read_at = NULL (unread)
  When user views alert (opens dropdown or detail)
  Then recipient.read_at = now
  And if first read: alert.first_read_at = now
  And unread count decremented

Scenario: Unread count badge
  Given user has 5 unread alerts
  When viewing any page
  Then alert bell icon shows badge with "5"
  And badge is red for critical unread alerts
```

### AC-11: Alert List API

```gherkin
Scenario: Get user's alerts
  Given user is recipient of 25 alerts
  When GET /api/quality/alerts
  Then response contains paginated list (20 per page)
  And each alert includes: id, alert_number, type, severity, subject, source_reference, status, read_at
  And sorted by created_at DESC (newest first)

Scenario: Filter alerts
  Given user has alerts of various severities
  When GET /api/quality/alerts?severity=critical&status=pending
  Then only matching alerts returned

Scenario: Get unread count
  Given user has 3 unread alerts (1 critical, 2 medium)
  When GET /api/quality/alerts/unread-count
  Then response: { total: 3, critical: 1, high: 0, medium: 2, low: 0 }
```

### AC-12: Alert Preferences API

```gherkin
Scenario: Get user preferences
  Given user has configured preferences
  When GET /api/quality/alerts/preferences
  Then response includes all preference fields
  And default values for unconfigured options

Scenario: Update preferences
  Given user updates preferences:
    | Field | Value |
    | email_enabled | true |
    | sms_enabled | true |
    | sms_phone_number | +1234567890 |
    | quiet_hours_enabled | true |
    | quiet_hours_start | 22:00 |
    | quiet_hours_end | 07:00 |
  When PUT /api/quality/alerts/preferences
  Then preferences saved
  And success toast "Alert preferences updated"

Scenario: Validate phone number
  Given user enters invalid phone number "abc123"
  When saving preferences
  Then error: "Invalid phone number. Use E.164 format (+1234567890)"
```

### AC-13: Escalation Rules

```gherkin
Scenario: Escalation after timeout
  Given critical alert not acknowledged
  And template.escalation_timeout_min = 60
  And template.escalation_roles = ["QUALITY_DIRECTOR"]
  When 60 minutes pass without acknowledgment
  Then escalation job triggers
  And alert.escalation_level = 1
  And alert.escalated_at = now
  And new recipients added from escalation_roles
  And escalation notification sent to new recipients
  And next_escalation_at = now + 60 minutes (if more escalation levels)

Scenario: Acknowledgment stops escalation
  Given alert pending escalation (next_escalation_at in future)
  When any recipient acknowledges
  Then next_escalation_at = NULL
  And no further escalation
```

### AC-14: Alert Bell UI

```gherkin
Scenario: Alert bell in header
  Given user is authenticated
  When viewing any page
  Then alert bell icon visible in header
  And unread count badge displayed if > 0
  And badge color: red for critical, orange for high, gray otherwise

Scenario: Alert dropdown
  Given user clicks alert bell
  Then dropdown shows recent 10 alerts
  And each shows: severity icon, subject (truncated), time ago
  And unread alerts highlighted
  And "View All" link at bottom

Scenario: Quick acknowledge from dropdown
  Given user opens dropdown
  And hovers over alert
  When clicks [Acknowledge] icon
  Then confirmation dialog: "Acknowledge this alert?"
  And on confirm: alert acknowledged
  And dropdown refreshes
```

### AC-15: Alert Preferences Page

```gherkin
Scenario: Navigate to preferences
  Given user navigates to Settings > Notifications
  When page loads
  Then alert preferences form displayed

Scenario: Preference form sections
  Given preferences page loads
  Then sections displayed:
    | Section | Fields |
    | Global | Alerts enabled toggle |
    | Channels | Email toggle, SMS toggle (+ phone), Push toggle |
    | Quiet Hours | Enabled, Start time, End time, Timezone |
    | Per Severity | Critical, High, Medium, Low channel overrides |
    | Per Alert Type | ccp_deviation, ncr_critical, etc. overrides |

Scenario: SMS requires phone number
  Given user enables SMS
  When phone number is empty
  Then error: "Phone number required for SMS alerts"
  And cannot save until phone provided
```

### AC-16: Admin Alert Management

```gherkin
Scenario: Admin sends manual alert
  Given user is QA_MANAGER
  When POST /api/quality/alerts/send with:
    | Field | Value |
    | template_code | manual_alert |
    | recipients | [userId1, userId2] |
    | subject | "Urgent: Lab results pending" |
    | body | "Please prioritize lab analysis for batch B-2025-00789" |
  Then alert created and sent
  And sender logged in metadata

Scenario: Admin sends test notification
  Given user is QA_MANAGER
  When POST /api/quality/alerts/test
  Then test alert sent ONLY to current user
  And alert.metadata.is_test = true
  And subject = "Test Alert - Delivery Verification"
```

### AC-17: Audit Trail

```gherkin
Scenario: All alert actions logged
  Given any alert action (create, deliver, read, acknowledge)
  When action completes
  Then quality_alert_delivery_log entry created with:
    | Field | Value |
    | channel | websocket/email/sms |
    | status | sent/delivered/failed |
    | provider | internal/sendgrid/twilio |
    | provider_message_id | <external id> |

Scenario: Delivery log is immutable
  Given delivery log entry exists
  When attempting to UPDATE
  Then operation blocked (append-only)
```

### AC-18: Performance Requirements

```gherkin
Scenario: Alert creation performance
  Given valid alert data
  When creating alert with 10 recipients
  Then operation completes < 500ms (excluding async delivery)

Scenario: WebSocket delivery latency
  Given user connected via WebSocket
  When critical alert created
  Then WebSocket message delivered < 1 second

Scenario: Unread count performance
  Given user with 100+ alerts
  When GET /api/quality/alerts/unread-count
  Then response < 100ms
```

---

## Implementation Notes

### API Endpoints

```typescript
// =============================================================================
// Alert Endpoints
// =============================================================================

// GET /api/quality/alerts
// List user's alerts with pagination and filters
interface AlertListParams {
  severity?: 'critical' | 'high' | 'medium' | 'low';
  status?: 'pending' | 'delivered' | 'read' | 'acknowledged';
  alert_type?: string;
  unread_only?: boolean;
  date_from?: string;
  date_to?: string;
  page?: number;
  limit?: number;
}

interface AlertListResponse {
  alerts: QualityAlert[];
  pagination: Pagination;
  unread_count: UnreadCount;
}

interface QualityAlert {
  id: string;
  alert_number: string;
  alert_type: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  subject: string;
  body: string;
  source_type?: string;
  source_id?: string;
  source_reference?: string;
  status: 'pending' | 'delivered' | 'read' | 'acknowledged';
  created_at: string;
  read_at?: string;
  acknowledged_at?: string;
  acknowledged_by?: string;
  escalation_level: number;
}

interface UnreadCount {
  total: number;
  critical: number;
  high: number;
  medium: number;
  low: number;
}

// GET /api/quality/alerts/unread-count
interface UnreadCountResponse {
  count: UnreadCount;
}

// POST /api/quality/alerts/:id/acknowledge
interface AcknowledgeAlertRequest {
  notes?: string;
}

// PUT /api/quality/alerts/:id/read
// No body - marks as read

// GET /api/quality/alerts/preferences
interface AlertPreferencesResponse {
  preferences: UserAlertPreferences;
}

interface UserAlertPreferences {
  alerts_enabled: boolean;
  websocket_enabled: boolean;
  email_enabled: boolean;
  sms_enabled: boolean;
  sms_phone_number?: string;
  push_enabled: boolean;
  quiet_hours_enabled: boolean;
  quiet_hours_start?: string;
  quiet_hours_end?: string;
  quiet_hours_timezone: string;
  severity_preferences?: Record<string, ChannelConfig>;
  alert_type_preferences?: Record<string, ChannelConfig>;
}

interface ChannelConfig {
  websocket: boolean;
  email: boolean;
  sms: boolean;
  push: boolean;
}

// PUT /api/quality/alerts/preferences
interface UpdatePreferencesRequest {
  alerts_enabled?: boolean;
  email_enabled?: boolean;
  sms_enabled?: boolean;
  sms_phone_number?: string;
  push_enabled?: boolean;
  quiet_hours_enabled?: boolean;
  quiet_hours_start?: string;
  quiet_hours_end?: string;
  quiet_hours_timezone?: string;
  severity_preferences?: Record<string, Partial<ChannelConfig>>;
  alert_type_preferences?: Record<string, Partial<ChannelConfig>>;
}

// POST /api/quality/alerts/send (admin)
interface SendAlertRequest {
  template_code?: string;
  alert_type: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  subject: string;
  body: string;
  sms_body?: string;
  recipients: string[];  // User IDs
  source_type?: string;
  source_id?: string;
  source_reference?: string;
}

// POST /api/quality/alerts/test
// Sends test alert to current user only
```

### Validation Schemas (Zod)

```typescript
import { z } from 'zod';

export const alertSeverityEnum = z.enum(['critical', 'high', 'medium', 'low']);
export const alertStatusEnum = z.enum(['pending', 'delivered', 'read', 'acknowledged', 'expired']);
export const alertChannelEnum = z.enum(['websocket', 'email', 'sms', 'push']);

export const acknowledgeAlertSchema = z.object({
  notes: z.string().max(500).optional(),
});

export const updatePreferencesSchema = z.object({
  alerts_enabled: z.boolean().optional(),
  email_enabled: z.boolean().optional(),
  sms_enabled: z.boolean().optional(),
  sms_phone_number: z.string()
    .regex(/^\+[1-9]\d{1,14}$/, 'Invalid phone number. Use E.164 format (+1234567890)')
    .optional()
    .nullable(),
  push_enabled: z.boolean().optional(),
  quiet_hours_enabled: z.boolean().optional(),
  quiet_hours_start: z.string()
    .regex(/^([01]\d|2[0-3]):([0-5]\d)$/, 'Invalid time format (HH:MM)')
    .optional()
    .nullable(),
  quiet_hours_end: z.string()
    .regex(/^([01]\d|2[0-3]):([0-5]\d)$/, 'Invalid time format (HH:MM)')
    .optional()
    .nullable(),
  quiet_hours_timezone: z.string().optional(),
  severity_preferences: z.record(z.object({
    websocket: z.boolean().optional(),
    email: z.boolean().optional(),
    sms: z.boolean().optional(),
    push: z.boolean().optional(),
  })).optional(),
  alert_type_preferences: z.record(z.object({
    websocket: z.boolean().optional(),
    email: z.boolean().optional(),
    sms: z.boolean().optional(),
    push: z.boolean().optional(),
  })).optional(),
}).refine(
  (data) => {
    if (data.sms_enabled && !data.sms_phone_number) {
      return false;
    }
    return true;
  },
  { message: 'Phone number required when SMS is enabled', path: ['sms_phone_number'] }
);

export const sendAlertSchema = z.object({
  template_code: z.string().optional(),
  alert_type: z.string().min(1),
  severity: alertSeverityEnum,
  subject: z.string().min(5).max(200),
  body: z.string().min(10).max(2000),
  sms_body: z.string().max(160).optional(),
  recipients: z.array(z.string().uuid()).min(1),
  source_type: z.string().optional(),
  source_id: z.string().uuid().optional(),
  source_reference: z.string().optional(),
});

export const alertListQuerySchema = z.object({
  severity: alertSeverityEnum.optional(),
  status: alertStatusEnum.optional(),
  alert_type: z.string().optional(),
  unread_only: z.coerce.boolean().optional(),
  date_from: z.string().optional(),
  date_to: z.string().optional(),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(50).default(20),
});
```

### Service Layer

```typescript
// lib/services/alert-service.ts

export class AlertService {
  // ==========================================================================
  // Alert CRUD
  // ==========================================================================

  /**
   * Create and send alert
   */
  static async createAlert(input: CreateAlertInput): Promise<QualityAlert>;

  /**
   * Get user's alerts
   */
  static async getUserAlerts(userId: string, params: AlertListParams): Promise<PaginatedResult<QualityAlert>>;

  /**
   * Get single alert
   */
  static async getById(alertId: string, userId: string): Promise<QualityAlert | null>;

  /**
   * Get unread count for user
   */
  static async getUnreadCount(userId: string): Promise<UnreadCount>;

  // ==========================================================================
  // Alert Actions
  // ==========================================================================

  /**
   * Mark alert as read
   */
  static async markAsRead(alertId: string, userId: string): Promise<void>;

  /**
   * Acknowledge alert
   */
  static async acknowledge(alertId: string, userId: string, notes?: string): Promise<void>;

  // ==========================================================================
  // Delivery
  // ==========================================================================

  /**
   * Send alert to all recipients
   */
  static async deliverAlert(alert: QualityAlert): Promise<void>;

  /**
   * Send WebSocket notification
   */
  static async sendWebSocket(userId: string, alert: QualityAlert): Promise<boolean>;

  /**
   * Queue email notification
   */
  static async sendEmail(userId: string, alert: QualityAlert): Promise<void>;

  /**
   * Queue SMS notification
   */
  static async sendSMS(userId: string, alert: QualityAlert): Promise<void>;

  // ==========================================================================
  // Preferences
  // ==========================================================================

  /**
   * Get user preferences
   */
  static async getPreferences(userId: string): Promise<UserAlertPreferences>;

  /**
   * Update user preferences
   */
  static async updatePreferences(userId: string, prefs: Partial<UserAlertPreferences>): Promise<void>;

  /**
   * Check if channel enabled for user/severity/type
   */
  static async isChannelEnabled(
    userId: string,
    channel: AlertChannel,
    severity: AlertSeverity,
    alertType: string
  ): Promise<boolean>;

  // ==========================================================================
  // Escalation
  // ==========================================================================

  /**
   * Process pending escalations (cron job)
   */
  static async processEscalations(): Promise<number>;

  /**
   * Escalate single alert
   */
  static async escalateAlert(alertId: string): Promise<void>;

  // ==========================================================================
  // Templates
  // ==========================================================================

  /**
   * Get template by code
   */
  static async getTemplate(orgId: string, templateCode: string): Promise<AlertTemplate | null>;

  /**
   * Render template with data
   */
  static renderTemplate(template: string, data: Record<string, unknown>): string;

  // ==========================================================================
  // Utility
  // ==========================================================================

  /**
   * Generate alert number
   */
  static async generateAlertNumber(orgId: string): Promise<string>;

  /**
   * Determine recipients from template
   */
  static async resolveRecipients(orgId: string, roles: string[]): Promise<string[]>;
}
```

### Frontend Components

```
apps/frontend/app/(authenticated)/settings/
  notifications/
    page.tsx                           -- Alert preferences page

components/quality/alerts/
  AlertBell.tsx                        -- Alert bell icon with badge
  AlertDropdown.tsx                    -- Dropdown with recent alerts
  AlertList.tsx                        -- Full alert list (for page)
  AlertItem.tsx                        -- Single alert row
  AlertSeverityBadge.tsx               -- Severity badge (critical/high/medium/low)
  AlertStatusBadge.tsx                 -- Status badge (pending/read/acknowledged)
  AlertDetail.tsx                      -- Alert detail modal
  AcknowledgeAlertDialog.tsx           -- Acknowledge confirmation
  AlertPreferencesForm.tsx             -- Preferences form
  ChannelToggle.tsx                    -- Individual channel toggle
  QuietHoursConfig.tsx                 -- Quiet hours configuration
  SeverityPreferencesTable.tsx         -- Per-severity channel matrix
  AlertTypePreferencesTable.tsx        -- Per-type channel matrix
  SendAlertModal.tsx                   -- Admin send alert modal
  TestAlertButton.tsx                  -- Send test notification
```

### WebSocket Integration

```typescript
// lib/websocket/alert-handler.ts

interface AlertWebSocketMessage {
  type: 'quality_alert';
  payload: {
    alert_id: string;
    alert_number: string;
    alert_type: string;
    severity: 'critical' | 'high' | 'medium' | 'low';
    subject: string;
    source_reference?: string;
    created_at: string;
  };
}

// On client connection
// Subscribe user to their alert channel: `user:${userId}:alerts`

// On alert creation
// Publish to each recipient's channel
```

### Email Integration

```typescript
// lib/email/alert-email.ts

interface AlertEmailData {
  to: string;
  subject: string;
  body: string;
  alert_url: string;
  unsubscribe_url: string;
  severity: string;
  source_reference?: string;
}

// Use SendGrid or Resend
// Template: emails/quality-alert.html
```

### SMS Integration

```typescript
// lib/sms/alert-sms.ts

interface AlertSMSData {
  to: string;  // E.164 format
  body: string; // Max 160 chars
}

// Use Twilio
// Only for critical severity by default
```

---

## Key Business Rules

1. **Critical Alerts Always Deliver**: Critical alerts bypass quiet hours and are sent via all enabled channels
2. **SMS Only for Critical**: SMS notifications are only sent for critical severity (unless overridden)
3. **WebSocket First**: WebSocket is attempted first, with email/SMS as async follow-up
4. **Escalation Stops on Acknowledgment**: Any acknowledgment stops the escalation chain
5. **One Acknowledgment Sufficient**: First acknowledgment updates alert status; others just update their recipient record
6. **Quiet Hours Respected**: Non-critical alerts respect user's quiet hours (except WebSocket)
7. **Template Required for Auto-Trigger**: Auto-triggered alerts require a configured template
8. **Immutable Delivery Log**: Delivery log is append-only for audit compliance
9. **Phone Validation**: SMS requires valid E.164 phone number
10. **Retry with Backoff**: Failed deliveries retry up to 3 times with exponential backoff

---

## Deliverables

### Database
- [ ] Migration: `quality_alert_templates` table
- [ ] Migration: `quality_alerts` table
- [ ] Migration: `quality_alert_recipients` table
- [ ] Migration: `user_alert_preferences` table
- [ ] Migration: `quality_alert_delivery_log` table
- [ ] Migration: `quality_alert_sequences` table
- [ ] Function: `generate_alert_number(org_id)`
- [ ] RLS policies for all tables
- [ ] Seed: Default alert templates

### API Routes
- [ ] `GET /api/quality/alerts` - List user's alerts
- [ ] `GET /api/quality/alerts/unread-count` - Badge count
- [ ] `GET /api/quality/alerts/:id` - Get single alert
- [ ] `POST /api/quality/alerts/:id/acknowledge` - Acknowledge
- [ ] `PUT /api/quality/alerts/:id/read` - Mark as read
- [ ] `GET /api/quality/alerts/preferences` - Get preferences
- [ ] `PUT /api/quality/alerts/preferences` - Update preferences
- [ ] `POST /api/quality/alerts/send` - Admin send alert
- [ ] `POST /api/quality/alerts/test` - Send test alert

### Service Layer
- [ ] `AlertService.createAlert()` - Create and deliver
- [ ] `AlertService.getUserAlerts()` - List with filters
- [ ] `AlertService.getUnreadCount()` - Badge count
- [ ] `AlertService.markAsRead()` - Mark read
- [ ] `AlertService.acknowledge()` - Acknowledge
- [ ] `AlertService.deliverAlert()` - Multi-channel delivery
- [ ] `AlertService.sendWebSocket()` - WebSocket push
- [ ] `AlertService.sendEmail()` - Email queue
- [ ] `AlertService.sendSMS()` - SMS queue
- [ ] `AlertService.getPreferences()` - Get prefs
- [ ] `AlertService.updatePreferences()` - Update prefs
- [ ] `AlertService.processEscalations()` - Cron job

### Validation
- [ ] `acknowledgeAlertSchema`
- [ ] `updatePreferencesSchema`
- [ ] `sendAlertSchema`
- [ ] `alertListQuerySchema`

### Frontend
- [ ] AlertBell component with badge
- [ ] AlertDropdown with recent alerts
- [ ] Alert preferences page
- [ ] AlertPreferencesForm component
- [ ] ChannelToggle component
- [ ] QuietHoursConfig component
- [ ] AcknowledgeAlertDialog
- [ ] TestAlertButton

### Integration
- [ ] WebSocket handler for alerts
- [ ] Email template (SendGrid/Resend)
- [ ] SMS integration (Twilio)
- [ ] Escalation cron job

### Tests
- [ ] Unit tests: AlertService methods (>80% coverage)
- [ ] Integration tests: All API endpoints
- [ ] WebSocket tests: Real-time delivery
- [ ] RLS tests: Multi-tenancy isolation
- [ ] E2E: Full alert flow (create -> deliver -> acknowledge)

---

## Test Strategy

### Unit Tests

```typescript
describe('AlertService', () => {
  describe('createAlert', () => {
    it('creates alert with correct fields', async () => {});
    it('generates alert number', async () => {});
    it('resolves recipients from roles', async () => {});
    it('creates recipient records for each user', async () => {});
    it('renders template with data', async () => {});
  });

  describe('deliverAlert', () => {
    it('sends WebSocket to online users', async () => {});
    it('queues email for enabled users', async () => {});
    it('queues SMS for critical + enabled users', async () => {});
    it('respects quiet hours for non-critical', async () => {});
    it('logs all delivery attempts', async () => {});
  });

  describe('acknowledge', () => {
    it('updates recipient record', async () => {});
    it('updates alert on first acknowledgment', async () => {});
    it('stops escalation', async () => {});
    it('logs acknowledgment', async () => {});
  });

  describe('processEscalations', () => {
    it('escalates overdue alerts', async () => {});
    it('adds escalation recipients', async () => {});
    it('increments escalation level', async () => {});
    it('skips acknowledged alerts', async () => {});
  });

  describe('isChannelEnabled', () => {
    it('returns default preference', async () => {});
    it('respects severity override', async () => {});
    it('respects alert type override', async () => {});
    it('critical always enables websocket', async () => {});
  });
});
```

### Integration Tests

```typescript
describe('Alerts API', () => {
  describe('GET /api/quality/alerts', () => {
    it('returns user alerts only', async () => {});
    it('filters by severity', async () => {});
    it('filters by status', async () => {});
    it('paginates correctly', async () => {});
    it('enforces RLS', async () => {});
  });

  describe('POST /api/quality/alerts/:id/acknowledge', () => {
    it('acknowledges as recipient', async () => {});
    it('returns 404 for non-recipient', async () => {});
    it('stops escalation', async () => {});
    it('creates audit log', async () => {});
  });

  describe('PUT /api/quality/alerts/preferences', () => {
    it('updates preferences', async () => {});
    it('validates phone number', async () => {});
    it('requires phone for SMS', async () => {});
  });

  describe('POST /api/quality/alerts/send', () => {
    it('sends to specified recipients', async () => {});
    it('requires QA_MANAGER role', async () => {});
  });
});
```

### E2E Tests

```typescript
describe('Quality Alerts E2E', () => {
  it('complete flow: trigger -> deliver -> acknowledge', async () => {
    // 1. Create critical NCR (triggers alert)
    // 2. Verify alert created
    // 3. Verify WebSocket received
    // 4. Verify email sent
    // 5. Open alert dropdown
    // 6. Acknowledge alert
    // 7. Verify escalation stopped
  });

  it('alert preferences flow', async () => {
    // 1. Navigate to Settings > Notifications
    // 2. Enable SMS, enter phone
    // 3. Configure quiet hours
    // 4. Save preferences
    // 5. Trigger test alert
    // 6. Verify delivery per preferences
  });

  it('escalation flow', async () => {
    // 1. Create critical alert
    // 2. Wait for escalation timeout
    // 3. Verify escalation recipients added
    // 4. Acknowledge
    // 5. Verify escalation stopped
  });
});
```

---

## Definition of Done

### Database
- [ ] All tables created with correct schemas
- [ ] All indexes created for performance
- [ ] RLS policies enforce org + user isolation
- [ ] Alert number generation works
- [ ] Default templates seeded

### API
- [ ] All endpoints return correct HTTP status codes
- [ ] Validation errors return 400 with details
- [ ] Cross-tenant access returns 404
- [ ] Response times:
  - Alert list: < 200ms
  - Unread count: < 100ms
  - Acknowledge: < 200ms
  - Preferences: < 100ms

### Service
- [ ] Alerts created with correct data
- [ ] Recipients resolved from roles
- [ ] Multi-channel delivery works
- [ ] Quiet hours respected
- [ ] Escalation engine works
- [ ] Audit trail created

### Delivery
- [ ] WebSocket delivery < 1 second
- [ ] Email queued < 5 seconds
- [ ] SMS queued < 5 seconds
- [ ] Retry logic works
- [ ] Delivery log populated

### Frontend
- [ ] Alert bell shows correct count
- [ ] Badge color reflects severity
- [ ] Dropdown shows recent alerts
- [ ] Acknowledge works from dropdown
- [ ] Preferences form saves correctly
- [ ] Phone validation works
- [ ] Quiet hours config works

### Testing
- [ ] Unit tests: >80% coverage on service
- [ ] Integration tests: All endpoints covered
- [ ] WebSocket tests: Delivery verified
- [ ] RLS tests: Multi-tenancy verified
- [ ] E2E tests: Full workflow passing

### Integration
- [ ] Ready for story 06.25-06.26 (CCP Deviation Alerts)
- [ ] Alert hooks exposed for quality events
- [ ] Template system extensible

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| WebSocket reliability | HIGH | MEDIUM | Fallback to polling, email always sent |
| Email deliverability | MEDIUM | LOW | Use reputable provider, monitor bounces |
| SMS costs | MEDIUM | MEDIUM | Only critical by default, rate limiting |
| Escalation timing | MEDIUM | LOW | Conservative timeouts, clear documentation |
| Alert fatigue | MEDIUM | MEDIUM | Good defaults, easy preferences |
| Performance at scale | MEDIUM | LOW | Async delivery, proper indexes |

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2026-01-15 | Initial story creation | ARCHITECT-AGENT |

---

**Document Status**: Ready for Implementation
**Created**: 2026-01-15
**Lines**: ~1500
**Complexity**: M (Medium)
**Phase**: 2B (NCR Workflow & Advanced QA)
