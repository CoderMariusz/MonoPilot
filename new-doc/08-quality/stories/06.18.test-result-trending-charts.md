# 06.18 - Test Result Trending & Charts

**Priority**: P1 (Enhancement)
**Story Points**: M (Medium)
**Type**: frontend (data visualization)
**Phase**: 2B (Quality Analytics)
**Model**: OPUS

**State:** ready
**Estimate:** M (3-4 days)
**Primary PRD:** `docs/1-BASELINE/product/modules/quality.md` (FR-QA-004)
**Architecture:** Data visualization layer over `quality_test_results` table

---

## Goal

Implement interactive trend charts for quality test results, enabling QA teams to visualize test parameter trends over time. The charts display test result values with control limits (spec min/max), highlight out-of-spec points, show trend indicators (improving/stable/degrading), and support export to PNG/PDF. This is a key analytics feature for proactive quality management.

---

## User Story

As a **QA Manager**, I want to **view trend charts of test results over time for specific parameters** so that **I can identify quality trends, detect drift before failures occur, and make data-driven decisions about process adjustments**.

As a **Quality Engineer**, I want to **compare test results across date ranges and aggregation levels** so that **I can analyze patterns and prepare quality reports with visual evidence**.

---

## PRD Reference

**Primary FR:** FR-QA-004 (Test Templates & Recording)
- Section 15: KPIs & Metrics - "Test result trending and charting"

**Related FRs:**
- FR-QA-022 (Quality Analytics)
- FR-QA-020 (Quality Dashboard)

---

## Scope

**In scope (this story)**
- Test result trend chart page at `/quality/trends`
- Parameter selection (single or multi-select)
- Product filter
- Date range picker (last 7/30/90 days, custom)
- Aggregation options (daily/weekly/monthly average)
- Line/area chart visualization with Recharts
- Control limits visualization (spec min/max as dashed red lines)
- Out-of-spec highlighting (red points for failures)
- Trend analysis indicators (trending up/down/stable arrow badges)
- Interactive tooltips (hover shows value, date, inspection link)
- Export chart as PNG
- Export chart as PDF (with data table)
- Database view for aggregated trends

**Out of scope (this story)**
- Statistical process control (SPC) charts (Phase 3)
- Cpk/Ppk calculations (Phase 3)
- Automated alerts on trend detection (Story 06.17+)
- Multi-product comparison charts (Phase 3)
- Real-time streaming updates (Phase 4)

---

## Dependencies

### Required (Must Exist)

| Dependency | Story | Type | What It Provides | Status |
|------------|-------|------|------------------|--------|
| **Epic 01.1** | Org Context + RLS | HARD | organizations, users | Required |
| **Epic 02.1** | Products CRUD | HARD | products table for filtering | Required |
| **Story 06.3** | Product Specifications | HARD | quality_specifications (spec limits) | Required |
| **Story 06.4** | Test Parameters | HARD | quality_spec_parameters (parameter names, limits) | Required |
| **Story 06.5** | Incoming Inspection | SOFT | quality_inspections (inspection reference) | Required |
| **Story 06.6** | Test Results Recording | HARD | quality_test_results table with numeric_value | Required |

### Provides To (Downstream)

| Story | What This Provides |
|-------|-------------------|
| 06.20 | Quality Dashboard - Embedded trend mini-charts |
| 06.22 | Quality Analytics - Trend data for advanced analytics |
| Phase 3 | SPC Charts - Base visualization patterns |

---

## Database Migration

### Migration: Create test_result_trends view

```sql
-- Migration: YYYYMMDDHHMMSS_create_test_result_trends_view.sql

-- =============================================================================
-- View: test_result_trends
-- Aggregated test results by date, product, and parameter for trending
-- =============================================================================

CREATE OR REPLACE VIEW test_result_trends AS
SELECT
    tr.org_id,
    DATE(tr.tested_at) AS test_date,
    tr.parameter_id,
    qsp.parameter_name,
    qsp.unit,
    qsp.min_value AS spec_min,
    qsp.max_value AS spec_max,
    qsp.target_value,
    qs.product_id,
    p.name AS product_name,
    p.code AS product_code,

    -- Aggregation metrics
    COUNT(*) AS sample_count,
    AVG(tr.numeric_value) AS avg_value,
    MIN(tr.numeric_value) AS min_value,
    MAX(tr.numeric_value) AS max_value,
    STDDEV(tr.numeric_value) AS std_dev,

    -- Result status counts
    COUNT(*) FILTER (WHERE tr.result_status = 'pass') AS pass_count,
    COUNT(*) FILTER (WHERE tr.result_status = 'fail') AS fail_count,
    COUNT(*) FILTER (WHERE tr.result_status = 'marginal') AS marginal_count,

    -- Pass rate
    ROUND(
        (COUNT(*) FILTER (WHERE tr.result_status = 'pass')::DECIMAL / NULLIF(COUNT(*), 0)) * 100,
        2
    ) AS pass_rate

FROM quality_test_results tr
JOIN quality_spec_parameters qsp ON qsp.id = tr.parameter_id
JOIN quality_specifications qs ON qs.id = qsp.spec_id
JOIN products p ON p.id = qs.product_id
WHERE tr.numeric_value IS NOT NULL
GROUP BY
    tr.org_id,
    DATE(tr.tested_at),
    tr.parameter_id,
    qsp.parameter_name,
    qsp.unit,
    qsp.min_value,
    qsp.max_value,
    qsp.target_value,
    qs.product_id,
    p.name,
    p.code
ORDER BY test_date DESC;

-- =============================================================================
-- View: test_result_trends_weekly
-- Weekly aggregation for longer-term trends
-- =============================================================================

CREATE OR REPLACE VIEW test_result_trends_weekly AS
SELECT
    org_id,
    DATE_TRUNC('week', test_date)::DATE AS week_start,
    parameter_id,
    parameter_name,
    unit,
    spec_min,
    spec_max,
    target_value,
    product_id,
    product_name,
    product_code,

    -- Aggregation metrics
    SUM(sample_count) AS sample_count,
    AVG(avg_value) AS avg_value,
    MIN(min_value) AS min_value,
    MAX(max_value) AS max_value,
    AVG(std_dev) AS avg_std_dev,

    -- Result status counts
    SUM(pass_count) AS pass_count,
    SUM(fail_count) AS fail_count,
    SUM(marginal_count) AS marginal_count,

    -- Pass rate
    ROUND(
        (SUM(pass_count)::DECIMAL / NULLIF(SUM(sample_count), 0)) * 100,
        2
    ) AS pass_rate

FROM test_result_trends
GROUP BY
    org_id,
    DATE_TRUNC('week', test_date),
    parameter_id,
    parameter_name,
    unit,
    spec_min,
    spec_max,
    target_value,
    product_id,
    product_name,
    product_code
ORDER BY week_start DESC;

-- =============================================================================
-- View: test_result_trends_monthly
-- Monthly aggregation for high-level dashboards
-- =============================================================================

CREATE OR REPLACE VIEW test_result_trends_monthly AS
SELECT
    org_id,
    DATE_TRUNC('month', test_date)::DATE AS month_start,
    parameter_id,
    parameter_name,
    unit,
    spec_min,
    spec_max,
    target_value,
    product_id,
    product_name,
    product_code,

    -- Aggregation metrics
    SUM(sample_count) AS sample_count,
    AVG(avg_value) AS avg_value,
    MIN(min_value) AS min_value,
    MAX(max_value) AS max_value,
    AVG(std_dev) AS avg_std_dev,

    -- Result status counts
    SUM(pass_count) AS pass_count,
    SUM(fail_count) AS fail_count,
    SUM(marginal_count) AS marginal_count,

    -- Pass rate
    ROUND(
        (SUM(pass_count)::DECIMAL / NULLIF(SUM(sample_count), 0)) * 100,
        2
    ) AS pass_rate

FROM test_result_trends
GROUP BY
    org_id,
    DATE_TRUNC('month', test_date),
    parameter_id,
    parameter_name,
    unit,
    spec_min,
    spec_max,
    target_value,
    product_id,
    product_name,
    product_code
ORDER BY month_start DESC;

-- =============================================================================
-- RLS: Views inherit RLS from base tables via org_id
-- No additional policies needed - Supabase applies RLS on underlying tables
-- =============================================================================

-- =============================================================================
-- Indexes for performance on base table queries
-- =============================================================================

-- Index for trending queries by parameter and date
CREATE INDEX IF NOT EXISTS idx_test_results_parameter_date
ON quality_test_results(parameter_id, tested_at DESC)
WHERE numeric_value IS NOT NULL;

-- Index for product-based trending
CREATE INDEX IF NOT EXISTS idx_test_results_org_date
ON quality_test_results(org_id, tested_at DESC)
WHERE numeric_value IS NOT NULL;
```

---

## Acceptance Criteria (Given/When/Then)

### AC-1: Trend Chart Page Display

```gherkin
Scenario: Load trend chart page
  Given user navigates to /quality/trends
  When page loads
  Then page displays:
    | Component | Content |
    | Header | "Test Result Trends" title |
    | Filters | Product dropdown, Parameter multi-select |
    | Date Range | Preset buttons (7d, 30d, 90d), custom picker |
    | Aggregation | Radio: Daily/Weekly/Monthly |
    | Chart Area | Empty state with "Select parameters to view trends" |
    | Export | [Export PNG] [Export PDF] buttons (disabled until chart loads) |
  And page loads within 500ms
```

### AC-2: Parameter Selection

```gherkin
Scenario: Select single parameter for trending
  Given user on trends page
  And product "Flour (SKU-001)" selected
  When user selects parameter "Moisture Content"
  Then chart loads with single line for "Moisture Content"
  And Y-axis label shows parameter unit (%)
  And legend shows parameter name
  And export buttons become enabled

Scenario: Select multiple parameters
  Given user on trends page
  And product selected
  When user selects parameters: "Moisture Content", "pH Level"
  Then chart displays two lines with different colors
  And legend shows both parameters
  And Y-axis adapts to combined range

Scenario: Clear parameter selection
  Given chart displaying parameters
  When user clears parameter selection
  Then chart shows empty state message
  And export buttons disabled
```

### AC-3: Date Range Selection

```gherkin
Scenario: Select preset date range
  Given parameters selected
  When user clicks "Last 30 Days" button
  Then chart updates to show last 30 days of data
  And X-axis shows appropriate date labels
  And filter button shows active state

Scenario: Select custom date range
  Given parameters selected
  When user clicks "Custom" and selects:
    | From | 2025-01-01 |
    | To | 2025-01-15 |
  Then chart displays data for Jan 1-15
  And date picker shows selected range

Scenario: Date range with no data
  Given parameters selected
  When user selects date range with no test results
  Then chart shows "No data available for selected range" message
  And export buttons disabled
```

### AC-4: Aggregation Options

```gherkin
Scenario: Daily aggregation
  Given parameters selected with 30-day range
  When aggregation = "Daily" (default)
  Then chart shows individual daily data points
  And tooltip shows "Date: Jan 15, Avg: 12.5%, Samples: 3"

Scenario: Weekly aggregation
  Given parameters selected with 90-day range
  When user selects aggregation = "Weekly"
  Then chart consolidates data into weekly averages
  And X-axis shows week labels (e.g., "Week of Jan 6")
  And tooltip shows weekly summary

Scenario: Monthly aggregation
  Given parameters selected with 365-day range
  When user selects aggregation = "Monthly"
  Then chart shows monthly averages
  And X-axis shows month labels (e.g., "Jan 2025")
```

### AC-5: Control Limits Visualization

```gherkin
Scenario: Display spec limits on chart
  Given parameter "Moisture Content" selected
  And spec min = 8.0, spec max = 12.0
  When chart renders
  Then horizontal dashed line at y=8.0 (green, label "Min")
  And horizontal dashed line at y=12.0 (red, label "Max")
  And Y-axis range extends slightly beyond limits

Scenario: Single limit parameter
  Given parameter with only max_value = 5.0
  When chart renders
  Then only upper limit line displayed
  And lower area not bounded

Scenario: Target value display
  Given parameter with target_value = 10.0
  When chart renders
  Then horizontal dotted line at y=10.0 (blue, label "Target")
  And target line distinguishable from limits
```

### AC-6: Out-of-Spec Highlighting

```gherkin
Scenario: Highlight failed data points
  Given trend data with some failed results
  When chart renders
  Then failed points display as red dots (larger size)
  And passed points display as green dots
  And marginal points display as yellow dots

Scenario: Hover on failed point
  Given chart with failed point on Jan 10
  When user hovers over red point
  Then tooltip shows:
    | Field | Value |
    | Date | Jan 10, 2025 |
    | Value | 13.5% |
    | Status | FAIL |
    | Deviation | +1.5% over max |
    | Inspection | Link to INS-INC-2025-00042 |
```

### AC-7: Trend Analysis Indicators

```gherkin
Scenario: Display trend direction
  Given 30-day trend data loaded
  When chart calculates trend (linear regression)
  Then trend indicator badge displayed:
    | Trend | Icon | Color |
    | Improving | Arrow down toward target | Green |
    | Stable | Horizontal arrow | Blue |
    | Degrading | Arrow away from target | Red |
  And tooltip explains trend calculation

Scenario: Trend calculation logic
  Given test results over 30 days
  When trend is calculated
  Then system uses simple linear regression
  And slope < -0.5 = "Decreasing"
  And slope > 0.5 = "Increasing"
  And -0.5 <= slope <= 0.5 = "Stable"
  And direction is labeled relative to spec compliance

Scenario: Insufficient data for trend
  Given less than 5 data points
  When trend analysis runs
  Then indicator shows "Insufficient data"
  And no trend arrow displayed
```

### AC-8: Interactive Tooltip

```gherkin
Scenario: Hover tooltip content
  Given chart with data
  When user hovers over data point
  Then tooltip displays:
    | Field | Content |
    | Date | Full date (e.g., "January 15, 2025") |
    | Parameter | "Moisture Content" |
    | Value | "11.2%" (with unit) |
    | Samples | "5 samples" (for aggregated) |
    | Status | Pass/Fail/Marginal badge |
    | Range | "8.0% - 12.0%" |
  And tooltip follows cursor

Scenario: Click data point to view inspection
  Given chart with individual result points
  When user clicks on a data point
  Then modal shows test result details
  And "View Inspection" link navigates to inspection page
```

### AC-9: Export to PNG

```gherkin
Scenario: Export chart as PNG
  Given chart with data displayed
  When user clicks [Export PNG]
  Then system generates PNG image
  And image includes:
    | Element |
    | Chart with all visible lines |
    | Control limits |
    | Legend |
    | Title with product and parameters |
    | Date range label |
  And download starts with filename "trend-{product}-{date}.png"

Scenario: PNG export with multiple parameters
  Given chart with 3 parameters
  When exporting PNG
  Then all 3 lines included in image
  And legend shows all parameter names
```

### AC-10: Export to PDF

```gherkin
Scenario: Export chart as PDF
  Given chart with data displayed
  When user clicks [Export PDF]
  Then system generates PDF document
  And PDF includes:
    | Page 1 | Chart image with title, legends |
    | Page 2+ | Data table with all values |
  And table columns:
    | Date | Parameter | Value | Status | Inspection # |
  And download with filename "trend-report-{product}-{date}.pdf"

Scenario: PDF export loading state
  Given large dataset (>500 points)
  When user clicks [Export PDF]
  Then button shows loading spinner
  And progress indicator displays
  And user can cancel export
```

### AC-11: Chart Type Selection

```gherkin
Scenario: Switch to area chart
  Given line chart displayed
  When user clicks [Area Chart] toggle
  Then chart displays as filled area chart
  And area fill is semi-transparent
  And control limits remain visible

Scenario: Toggle between chart types
  Given chart displayed
  When user toggles Line/Area
  Then chart smoothly transitions
  And data remains the same
```

### AC-12: Performance Requirements

```gherkin
Scenario: Large dataset performance
  Given 1000 data points selected
  When chart loads
  Then render time < 1 second
  And interactions remain smooth

Scenario: API response time
  Given trend query with 90-day range
  When API called
  Then response time < 500ms
  And data paginated if exceeds 1000 points

Scenario: Export performance
  Given chart with 500 points
  When exporting PNG
  Then export completes < 3 seconds
  When exporting PDF
  Then export completes < 5 seconds
```

### AC-13: Permission Enforcement

```gherkin
Scenario: Viewer can view trends
  Given user with VIEWER role
  When accessing /quality/trends
  Then page loads with full chart functionality
  And export buttons visible and functional

Scenario: RLS enforcement
  Given User A from Org A
  And test results exist in Org B
  When User A views trends
  Then only Org A data displayed
```

---

## Implementation Notes

### API Endpoints

```typescript
// =============================================================================
// Trends API Endpoints
// =============================================================================

// GET /api/quality/test-results/trends
// Query aggregated trend data
interface TrendQueryParams {
  product_id?: string;
  parameter_ids: string[];          // Required, comma-separated UUIDs
  date_from: string;                // ISO date string
  date_to: string;                  // ISO date string
  aggregation: 'daily' | 'weekly' | 'monthly';
}

interface TrendDataPoint {
  date: string;                     // ISO date
  parameter_id: string;
  parameter_name: string;
  unit: string;
  avg_value: number;
  min_value: number;
  max_value: number;
  sample_count: number;
  pass_count: number;
  fail_count: number;
  marginal_count: number;
  pass_rate: number;
  spec_min: number | null;
  spec_max: number | null;
  target_value: number | null;
}

interface TrendResponse {
  data: TrendDataPoint[];
  meta: {
    product_id: string;
    product_name: string;
    parameters: Array<{
      id: string;
      name: string;
      unit: string;
    }>;
    date_from: string;
    date_to: string;
    aggregation: string;
    total_points: number;
  };
  trend_analysis: {
    [parameter_id: string]: {
      direction: 'improving' | 'stable' | 'degrading';
      slope: number;
      confidence: number;
    };
  };
}

// GET /api/quality/test-results/trends/export
// Export chart data as PDF or image data
interface TrendExportParams {
  product_id: string;
  parameter_ids: string[];
  date_from: string;
  date_to: string;
  aggregation: string;
  format: 'pdf' | 'csv';            // PNG handled client-side
}

// Response: Binary PDF or CSV file
```

### Validation Schemas (Zod)

**File:** `apps/frontend/lib/validation/quality-trends-schema.ts`

```typescript
import { z } from 'zod';

export const trendQuerySchema = z.object({
  product_id: z.string().uuid('Invalid product ID').optional(),
  parameter_ids: z.array(z.string().uuid()).min(1, 'At least one parameter required'),
  date_from: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Invalid date format'),
  date_to: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Invalid date format'),
  aggregation: z.enum(['daily', 'weekly', 'monthly']).default('daily'),
}).refine(
  (data) => new Date(data.date_from) <= new Date(data.date_to),
  { message: 'date_from must be before date_to', path: ['date_from'] }
);

export const trendExportSchema = z.object({
  product_id: z.string().uuid(),
  parameter_ids: z.array(z.string().uuid()).min(1),
  date_from: z.string(),
  date_to: z.string(),
  aggregation: z.enum(['daily', 'weekly', 'monthly']),
  format: z.enum(['pdf', 'csv']),
});

export type TrendQuery = z.infer<typeof trendQuerySchema>;
export type TrendExport = z.infer<typeof trendExportSchema>;
```

### Service Layer

**File:** `apps/frontend/lib/services/trend-analysis-service.ts`

```typescript
import { createClient } from '@/lib/supabase/server';
import type { TrendQuery, TrendDataPoint, TrendResponse } from '@/lib/types/quality-trends';

export class TrendAnalysisService {
  /**
   * Get aggregated trend data for parameters
   */
  static async getTrends(params: TrendQuery): Promise<TrendResponse> {
    const supabase = await createClient();

    // Select view based on aggregation
    const viewName = params.aggregation === 'weekly'
      ? 'test_result_trends_weekly'
      : params.aggregation === 'monthly'
        ? 'test_result_trends_monthly'
        : 'test_result_trends';

    const dateColumn = params.aggregation === 'weekly'
      ? 'week_start'
      : params.aggregation === 'monthly'
        ? 'month_start'
        : 'test_date';

    let query = supabase
      .from(viewName)
      .select('*')
      .in('parameter_id', params.parameter_ids)
      .gte(dateColumn, params.date_from)
      .lte(dateColumn, params.date_to)
      .order(dateColumn, { ascending: true });

    if (params.product_id) {
      query = query.eq('product_id', params.product_id);
    }

    const { data, error } = await query;

    if (error) throw error;

    // Get product info
    const productIds = [...new Set(data?.map(d => d.product_id) || [])];
    const { data: products } = await supabase
      .from('products')
      .select('id, name')
      .in('id', productIds);

    // Calculate trend analysis
    const trendAnalysis = this.calculateTrendAnalysis(data || [], params.parameter_ids);

    return {
      data: data || [],
      meta: {
        product_id: params.product_id || '',
        product_name: products?.[0]?.name || '',
        parameters: this.extractParameters(data || []),
        date_from: params.date_from,
        date_to: params.date_to,
        aggregation: params.aggregation,
        total_points: data?.length || 0,
      },
      trend_analysis: trendAnalysis,
    };
  }

  /**
   * Calculate linear regression for trend direction
   */
  static calculateTrendAnalysis(
    data: TrendDataPoint[],
    parameterIds: string[]
  ): Record<string, { direction: string; slope: number; confidence: number }> {
    const result: Record<string, any> = {};

    for (const paramId of parameterIds) {
      const paramData = data.filter(d => d.parameter_id === paramId);

      if (paramData.length < 5) {
        result[paramId] = {
          direction: 'insufficient_data',
          slope: 0,
          confidence: 0,
        };
        continue;
      }

      // Simple linear regression
      const n = paramData.length;
      const xValues = paramData.map((_, i) => i);
      const yValues = paramData.map(d => d.avg_value);

      const sumX = xValues.reduce((a, b) => a + b, 0);
      const sumY = yValues.reduce((a, b) => a + b, 0);
      const sumXY = xValues.reduce((a, x, i) => a + x * yValues[i], 0);
      const sumX2 = xValues.reduce((a, x) => a + x * x, 0);

      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);

      // Determine direction relative to spec limits
      const specMin = paramData[0]?.spec_min;
      const specMax = paramData[0]?.spec_max;
      let direction = 'stable';

      if (Math.abs(slope) > 0.5) {
        // Heading toward limits = degrading, away = improving
        if (slope > 0 && specMax !== null) {
          direction = 'degrading'; // Rising toward max
        } else if (slope < 0 && specMin !== null) {
          direction = 'degrading'; // Falling toward min
        } else {
          direction = 'improving';
        }
      }

      // Calculate R-squared for confidence
      const meanY = sumY / n;
      const ssTotal = yValues.reduce((a, y) => a + (y - meanY) ** 2, 0);
      const predictions = xValues.map(x => slope * x + (meanY - slope * (sumX / n)));
      const ssRes = yValues.reduce((a, y, i) => a + (y - predictions[i]) ** 2, 0);
      const rSquared = 1 - ssRes / ssTotal;

      result[paramId] = {
        direction,
        slope: parseFloat(slope.toFixed(4)),
        confidence: parseFloat((rSquared * 100).toFixed(1)),
      };
    }

    return result;
  }

  /**
   * Extract unique parameter info from data
   */
  private static extractParameters(data: TrendDataPoint[]) {
    const seen = new Map();
    for (const d of data) {
      if (!seen.has(d.parameter_id)) {
        seen.set(d.parameter_id, {
          id: d.parameter_id,
          name: d.parameter_name,
          unit: d.unit,
        });
      }
    }
    return Array.from(seen.values());
  }

  /**
   * Export trends to CSV
   */
  static async exportToCSV(params: TrendQuery): Promise<string> {
    const { data } = await this.getTrends(params);

    const headers = [
      'Date', 'Parameter', 'Avg Value', 'Min Value', 'Max Value',
      'Sample Count', 'Pass Count', 'Fail Count', 'Pass Rate (%)',
      'Spec Min', 'Spec Max'
    ];

    const rows = data.map(d => [
      d.date,
      d.parameter_name,
      d.avg_value,
      d.min_value,
      d.max_value,
      d.sample_count,
      d.pass_count,
      d.fail_count,
      d.pass_rate,
      d.spec_min ?? '',
      d.spec_max ?? '',
    ]);

    return [headers, ...rows].map(row => row.join(',')).join('\n');
  }
}
```

### Frontend Components

```
apps/frontend/app/(authenticated)/quality/
  trends/
    page.tsx                         -- Trend chart page

components/quality/trends/
  TrendChartPage.tsx                 -- Main page container
  TrendFilters.tsx                   -- Product, parameter, date filters
  TrendChart.tsx                     -- Recharts line/area chart
  TrendChartTooltip.tsx              -- Custom tooltip component
  TrendIndicatorBadge.tsx            -- Trend direction badge
  ControlLimitLines.tsx              -- Spec limit reference lines
  TrendExportButtons.tsx             -- Export PNG/PDF buttons
  TrendDataTable.tsx                 -- Tabular view of data
  TrendEmptyState.tsx                -- Empty state message
  DateRangePicker.tsx                -- Date range selector (reuse)
  AggregationSelector.tsx            -- Daily/Weekly/Monthly radio
  ParameterMultiSelect.tsx           -- Multi-select for parameters
```

### Chart Component Structure

**File:** `apps/frontend/components/quality/trends/TrendChart.tsx`

```typescript
'use client';

import { useMemo, useRef } from 'react';
import {
  LineChart,
  Line,
  AreaChart,
  Area,
  XAxis,
  YAxis,
  Tooltip,
  Legend,
  ResponsiveContainer,
  ReferenceLine,
} from 'recharts';
import { toPng } from 'html-to-image';
import { TrendChartTooltip } from './TrendChartTooltip';
import type { TrendDataPoint } from '@/lib/types/quality-trends';

// Chart colors for parameters (up to 6)
const PARAM_COLORS = [
  '#3b82f6', // blue
  '#22c55e', // green
  '#f97316', // orange
  '#a855f7', // purple
  '#ec4899', // pink
  '#14b8a6', // teal
];

export interface TrendChartProps {
  data: TrendDataPoint[];
  parameters: Array<{ id: string; name: string; unit: string }>;
  specLimits: {
    min: number | null;
    max: number | null;
    target: number | null;
  };
  chartType: 'line' | 'area';
  onPointClick?: (point: TrendDataPoint) => void;
}

export function TrendChart({
  data,
  parameters,
  specLimits,
  chartType,
  onPointClick,
}: TrendChartProps) {
  const chartRef = useRef<HTMLDivElement>(null);

  // Format data for chart (group by date)
  const chartData = useMemo(() => {
    const dateMap = new Map();

    for (const point of data) {
      const key = point.date;
      if (!dateMap.has(key)) {
        dateMap.set(key, { date: key });
      }
      dateMap.get(key)[point.parameter_id] = point.avg_value;
      dateMap.get(key)[`${point.parameter_id}_status`] =
        point.fail_count > 0 ? 'fail' :
        point.marginal_count > 0 ? 'marginal' : 'pass';
    }

    return Array.from(dateMap.values());
  }, [data]);

  // Export chart as PNG
  const exportToPng = async () => {
    if (!chartRef.current) return;

    const dataUrl = await toPng(chartRef.current, {
      quality: 1.0,
      backgroundColor: '#ffffff',
    });

    const link = document.createElement('a');
    link.download = `trend-chart-${new Date().toISOString().split('T')[0]}.png`;
    link.href = dataUrl;
    link.click();
  };

  // Format X axis date labels
  const formatXAxis = (date: string) => {
    return new Date(date).toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
    });
  };

  // Calculate Y axis domain with padding
  const yDomain = useMemo(() => {
    const values = data.map(d => d.avg_value);
    const min = Math.min(...values, specLimits.min ?? Infinity);
    const max = Math.max(...values, specLimits.max ?? -Infinity);
    const padding = (max - min) * 0.1;
    return [min - padding, max + padding];
  }, [data, specLimits]);

  const ChartComponent = chartType === 'area' ? AreaChart : LineChart;
  const DataComponent = chartType === 'area' ? Area : Line;

  return (
    <div ref={chartRef} className="w-full" style={{ minHeight: '400px' }}>
      <ResponsiveContainer width="100%" height={400}>
        <ChartComponent
          data={chartData}
          margin={{ top: 20, right: 30, left: 20, bottom: 20 }}
        >
          <XAxis
            dataKey="date"
            tickFormatter={formatXAxis}
            tick={{ fontSize: 12 }}
          />
          <YAxis
            domain={yDomain}
            tick={{ fontSize: 12 }}
            tickFormatter={(v) => v.toFixed(1)}
          />
          <Tooltip content={<TrendChartTooltip />} />
          <Legend />

          {/* Spec limit lines */}
          {specLimits.min !== null && (
            <ReferenceLine
              y={specLimits.min}
              stroke="#dc2626"
              strokeDasharray="5 5"
              label={{ value: 'Min', fill: '#dc2626', fontSize: 10 }}
            />
          )}
          {specLimits.max !== null && (
            <ReferenceLine
              y={specLimits.max}
              stroke="#dc2626"
              strokeDasharray="5 5"
              label={{ value: 'Max', fill: '#dc2626', fontSize: 10 }}
            />
          )}
          {specLimits.target !== null && (
            <ReferenceLine
              y={specLimits.target}
              stroke="#3b82f6"
              strokeDasharray="3 3"
              label={{ value: 'Target', fill: '#3b82f6', fontSize: 10 }}
            />
          )}

          {/* Data lines for each parameter */}
          {parameters.map((param, index) => (
            <DataComponent
              key={param.id}
              type="monotone"
              dataKey={param.id}
              name={param.name}
              stroke={PARAM_COLORS[index % PARAM_COLORS.length]}
              fill={chartType === 'area' ? `${PARAM_COLORS[index]}33` : undefined}
              strokeWidth={2}
              dot={(props: any) => {
                const status = props.payload[`${param.id}_status`];
                const color = status === 'fail' ? '#dc2626' :
                              status === 'marginal' ? '#f59e0b' : '#22c55e';
                return (
                  <circle
                    cx={props.cx}
                    cy={props.cy}
                    r={status === 'fail' ? 6 : 4}
                    fill={color}
                    stroke="#fff"
                    strokeWidth={1}
                    style={{ cursor: 'pointer' }}
                  />
                );
              }}
              activeDot={{ r: 8, cursor: 'pointer' }}
            />
          ))}
        </ChartComponent>
      </ResponsiveContainer>
    </div>
  );
}
```

---

## Key Business Rules

1. **Numeric Values Only**: Trending only works for parameters with `numeric_value` (not text/boolean).
2. **Minimum Data Points**: Trend analysis requires at least 5 data points.
3. **Aggregation Logic**: Weekly = sum/avg of daily values; Monthly = sum/avg of daily values.
4. **Control Limits**: Always show spec_min/max if defined for parameter.
5. **Out-of-Spec Detection**: Any aggregation period with fail_count > 0 highlighted.
6. **Trend Direction**: Calculated via linear regression; slope thresholds determine direction.
7. **Multi-Parameter Charts**: Max 6 parameters per chart for readability.
8. **Export Includes Limits**: PNG/PDF exports include control limit lines.
9. **RLS Enforced**: All queries filter by user's org_id automatically.
10. **Performance Limit**: Max 1000 data points per query; paginate or suggest smaller range.

---

## Deliverables

### Database
- [ ] Migration: `test_result_trends` view (daily aggregation)
- [ ] Migration: `test_result_trends_weekly` view
- [ ] Migration: `test_result_trends_monthly` view
- [ ] Performance indexes on quality_test_results

### API Routes
- [ ] `GET /api/quality/test-results/trends` - Query trend data
- [ ] `GET /api/quality/test-results/trends/export` - Export PDF/CSV

### Service Layer
- [ ] `TrendAnalysisService.getTrends()` - Query aggregated data
- [ ] `TrendAnalysisService.calculateTrendAnalysis()` - Linear regression
- [ ] `TrendAnalysisService.exportToCSV()` - CSV export

### Validation
- [ ] `trendQuerySchema`
- [ ] `trendExportSchema`

### Frontend
- [ ] Trend chart page (`/quality/trends`)
- [ ] TrendFilters component (product, parameters, date range)
- [ ] TrendChart component (Recharts line/area)
- [ ] TrendChartTooltip component
- [ ] TrendIndicatorBadge component
- [ ] ControlLimitLines (ReferenceLine wrappers)
- [ ] TrendExportButtons component
- [ ] AggregationSelector component
- [ ] ParameterMultiSelect component

### Tests
- [ ] Unit tests: TrendAnalysisService (>80% coverage)
- [ ] Unit tests: Trend calculation logic
- [ ] Integration tests: Trends API endpoints
- [ ] Component tests: TrendChart rendering
- [ ] E2E: Full trend workflow (select params -> view chart -> export)

---

## Test Strategy

### Unit Tests

```typescript
describe('TrendAnalysisService', () => {
  describe('calculateTrendAnalysis', () => {
    it('should detect increasing trend', () => {
      const data = [
        { parameter_id: 'p1', avg_value: 10 },
        { parameter_id: 'p1', avg_value: 11 },
        { parameter_id: 'p1', avg_value: 12 },
        { parameter_id: 'p1', avg_value: 13 },
        { parameter_id: 'p1', avg_value: 14 },
      ];
      const result = TrendAnalysisService.calculateTrendAnalysis(data, ['p1']);
      expect(result.p1.slope).toBeGreaterThan(0.5);
    });

    it('should detect stable trend', () => {
      const data = [
        { parameter_id: 'p1', avg_value: 10 },
        { parameter_id: 'p1', avg_value: 10.1 },
        { parameter_id: 'p1', avg_value: 9.9 },
        { parameter_id: 'p1', avg_value: 10 },
        { parameter_id: 'p1', avg_value: 10.05 },
      ];
      const result = TrendAnalysisService.calculateTrendAnalysis(data, ['p1']);
      expect(result.p1.direction).toBe('stable');
    });

    it('should return insufficient_data for small datasets', () => {
      const data = [
        { parameter_id: 'p1', avg_value: 10 },
        { parameter_id: 'p1', avg_value: 11 },
      ];
      const result = TrendAnalysisService.calculateTrendAnalysis(data, ['p1']);
      expect(result.p1.direction).toBe('insufficient_data');
    });
  });

  describe('getTrends', () => {
    it('should return aggregated data with meta', async () => {});
    it('should filter by date range', async () => {});
    it('should filter by product_id', async () => {});
  });
});
```

### Component Tests

```typescript
describe('TrendChart', () => {
  it('should render chart with data points', () => {});
  it('should display control limit lines', () => {});
  it('should highlight failed points in red', () => {});
  it('should show tooltip on hover', () => {});
  it('should switch between line and area chart', () => {});
});

describe('TrendFilters', () => {
  it('should filter by product', () => {});
  it('should allow multi-select parameters', () => {});
  it('should handle date range selection', () => {});
});
```

### E2E Tests

```typescript
test.describe('Test Result Trending', () => {
  test('should display trend chart for selected parameter', async ({ page }) => {
    // Navigate to /quality/trends
    // Select product
    // Select parameter
    // Verify chart displays with data points
    // Verify control limits visible
  });

  test('should export chart as PNG', async ({ page }) => {
    // Load chart with data
    // Click Export PNG
    // Verify download initiated
  });

  test('should change aggregation and update chart', async ({ page }) => {
    // Load daily chart
    // Switch to weekly
    // Verify X-axis labels change to weeks
    // Verify data points consolidated
  });
});
```

---

## Definition of Done

### Database
- [ ] Views created and returning correct aggregated data
- [ ] Indexes improve query performance (<500ms for 90-day range)
- [ ] RLS enforced via org_id in underlying tables

### API
- [ ] Endpoints return correct data structure
- [ ] Validation errors return 400 with messages
- [ ] Response times < 500ms for normal ranges

### Frontend
- [ ] Chart renders correctly with Recharts
- [ ] Control limits display as reference lines
- [ ] Out-of-spec points highlighted in red
- [ ] Trend indicator badge shows direction
- [ ] Date range picker works (presets + custom)
- [ ] Aggregation toggle updates chart
- [ ] Export PNG works (html-to-image)
- [ ] Export PDF works (jsPDF)
- [ ] Empty state shown when no data
- [ ] Loading state during data fetch

### Testing
- [ ] Unit tests: >80% coverage on service
- [ ] Component tests: Chart rendering verified
- [ ] E2E tests: Full workflow passing
- [ ] Performance tests: Large dataset renders <1s

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Large dataset performance | HIGH | MEDIUM | Pagination, aggregation, limit 1000 points |
| Recharts bundle size | MEDIUM | LOW | Already in bundle from 02.15 |
| Linear regression accuracy | LOW | MEDIUM | Document limitations, simple algo |
| PDF export memory | MEDIUM | LOW | Stream generation, chunked tables |
| View performance | MEDIUM | LOW | Materialized views if needed |
| Multi-parameter Y-axis scaling | MEDIUM | MEDIUM | Normalize or separate axes option |

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-01-15 | Initial story creation | ARCHITECT-AGENT |

---

**Document Status**: Ready for Implementation
**Created**: 2025-01-15
**Lines**: ~950
**Complexity**: M (Medium)
**Phase**: 2B (Quality Analytics)
