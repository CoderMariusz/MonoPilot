<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <story_id>1.4</story_id>
    <batch_id>01A-auth-users</batch_id>
    <epic_id>1</epic_id>
    <title>Session Management</title>
    <status>done (backend complete, frontend/tests deferred to Story 1.14)</status>
    <created>2025-11-20</created>
    <last_updated>2025-11-27</last_updated>
    <priority>high</priority>
    <complexity>medium</complexity>
    <estimated_hours>8-12</estimated_hours>
    <tech_spec_ref>docs/batches/01A-auth-users/tech-spec.md</tech_spec_ref>
  </metadata>

  <story>
    <user_story>
      As a User,
      I want to see my active sessions and logout from all devices,
      so that I can maintain security of my account.
    </user_story>

    <business_value>
      - Enhanced security: Users can terminate compromised sessions immediately
      - Multi-device awareness: Users see all active login locations
      - Admin oversight: Admins can manage sessions for compliance
      - Instant logout: Real-time session termination (sub-1s propagation)
    </business_value>

    <acceptance_criteria>
      <criterion id="AC-003.1">
        <title>User views active sessions list</title>
        <details>
          - Navigate to /settings/users/:id/sessions (own profile) or Admin viewing any user
          - Table columns: Device Info, IP Address, Location (city/country), Login Time, Last Activity, Status, Actions
          - Device Info format: "Chrome 120 on Windows 10 (Desktop)"
          - Status values: Active (green badge), Expired (gray badge)
          - Only active sessions displayed by default (filter to show expired)
          - Current session highlighted with different background color
        </details>
        <verification>
          - Login from 2 devices
          - Navigate to sessions page
          - Verify 2 sessions visible with correct device info
          - Verify current session has distinct styling
        </verification>
      </criterion>

      <criterion id="AC-003.2">
        <title>Logout All Devices functionality</title>
        <details>
          - "Logout All Devices" button visible top-right of sessions table
          - Click → confirmation modal: "This will log you out of all devices except the current one"
          - On confirm: DELETE /api/settings/users/:id/sessions
          - All sessions except current terminated (is_active = false)
          - All JWT tokens added to Redis blacklist (TTL = token expiry)
          - Success toast: "Logged out from all devices"
          - Table auto-refreshes showing only current session
        </details>
        <verification>
          - Login from 3 browsers
          - Click "Logout All Devices" in browser A
          - Confirm modal
          - Verify browsers B and C logged out within 1s
          - Verify browser A still authenticated
        </verification>
      </criterion>

      <criterion id="AC-003.3">
        <title>Admin can view and terminate any user's sessions</title>
        <details>
          - Admin navigates to /settings/users/:userId/sessions
          - Sees all active sessions for that user
          - Can click "Terminate" action on individual session
          - Can click "Logout All Devices" for that user
          - Terminated user logged out immediately (within 1s via realtime)
          - Admin session not affected
        </details>
        <verification>
          - Admin opens user X's sessions page
          - User X has 2 active sessions
          - Admin terminates one session
          - Verify user X's device logged out
          - Verify admin still authenticated
        </verification>
      </criterion>

      <criterion id="AC-003.4">
        <title>Session invalidation propagated via realtime</title>
        <details>
          - Terminated session triggers Supabase Realtime event: 'session.terminated'
          - All devices with that session listen for event via 'session_events' channel
          - On event received: check if token_id matches current JWT jti
          - If match: force logout (clear localStorage, redirect to /login)
          - Show toast: "Your session has been terminated"
          - Propagation time: &lt;1s (Supabase SLA)
        </details>
        <verification>
          - Open 2 browsers with same user
          - Browser A terminates browser B's session
          - Verify browser B receives realtime event within 1s
          - Verify browser B redirected to login
          - Verify toast displayed
        </verification>
      </criterion>

      <criterion id="AC-003.5">
        <title>Session tracking on login</title>
        <details>
          - On successful login: POST /api/auth/login creates user_sessions record
          - Capture: device_info (parsed user agent), IP address, location (GeoIP - optional), login_time
          - JWT token_id (jti claim) stored in session record
          - Session marked as active (is_active = true)
          - Device info format: "Chrome 120 on Windows 10 (Desktop)"
          - GeoIP skipped for MVP (display IP only)
        </details>
        <verification>
          - Login via browser
          - Query user_sessions table for new record
          - Verify device_info parsed correctly
          - Verify token_id matches JWT jti claim
          - Verify is_active = true
        </verification>
      </criterion>

      <criterion id="AC-003.6">
        <title>Session cleanup on logout</title>
        <details>
          - Normal logout: update user_sessions.is_active = false, set logged_out_at = NOW()
          - Session remains in DB for audit trail (soft delete pattern)
          - JWT not blacklisted on normal logout (natural expiry after 7 days)
          - Reason: Normal logout doesn't need instant invalidation (user logged out willingly)
        </details>
        <verification>
          - Login then logout normally
          - Query user_sessions: is_active = false, logged_out_at set
          - Verify JWT not in Redis blacklist
          - Verify session record still in DB
        </verification>
      </criterion>

      <criterion id="AC-003.7">
        <title>Expired sessions detection</title>
        <details>
          - Session expires if JWT exp claim passed (7 days for standard, 30 days for "remember me")
          - Expired sessions marked with Status = "Expired" badge in table (gray)
          - Auto-cleanup cron job: DELETE expired sessions WHERE logged_out_at &lt; NOW() - 90 days
          - Cron runs weekly (e.g., Sunday 3am UTC)
          - Log deleted count for monitoring
        </details>
        <verification>
          - Create session with expired JWT (manual test or mock)
          - Verify Status = "Expired" in sessions table UI
          - Run cleanup cron manually
          - Verify sessions older than 90 days deleted
        </verification>
      </criterion>

      <criterion id="AC-003.8">
        <title>Individual session termination</title>
        <details>
          - Click "Terminate" button on specific session in table
          - Confirmation modal: "Are you sure you want to terminate this session?"
          - On confirm: DELETE /api/settings/users/:id/sessions/:sessionId
          - That session terminated: JWT blacklisted in Redis, is_active = false
          - Terminated device logged out immediately via realtime event
          - Current session cannot be terminated (button disabled with tooltip)
        </details>
        <verification>
          - Login from 3 browsers
          - In browser A, terminate browser B's session (not current)
          - Verify browser B logged out within 1s
          - Verify "Terminate" button disabled for current session
        </verification>
      </criterion>
    </acceptance_criteria>
  </story>

  <database>
    <schema>
      <table name="user_sessions">
        <purpose>Track all user login sessions for multi-device management</purpose>
        <rls_enabled>false</rls_enabled>
        <rls_note>Managed server-side only (user_id check in API endpoints)</rls_note>
        <columns>
          <column name="id" type="UUID" constraints="PK" description="Primary key" />
          <column name="user_id" type="UUID" constraints="FK → users, NOT NULL" description="User account" />
          <column name="token_id" type="VARCHAR(255)" constraints="UNIQUE, NOT NULL" description="JWT jti claim (unique token identifier)" />
          <column name="device_info" type="TEXT" constraints="-" description="Chrome 120 on Windows 10 (Desktop) - parsed from user agent" />
          <column name="ip_address" type="VARCHAR(45)" constraints="-" description="IPv4 or IPv6" />
          <column name="location" type="VARCHAR(255)" constraints="-" description="City, Country from GeoIP (optional, MVP skips)" />
          <column name="login_time" type="TIMESTAMPTZ" constraints="DEFAULT NOW()" description="When session started" />
          <column name="last_activity" type="TIMESTAMPTZ" constraints="DEFAULT NOW()" description="Last API request timestamp (updated by middleware)" />
          <column name="is_active" type="BOOLEAN" constraints="DEFAULT true" description="Active flag (false = terminated or logged out)" />
          <column name="logged_out_at" type="TIMESTAMPTZ" constraints="-" description="When user logged out (soft delete)" />
          <column name="created_at" type="TIMESTAMPTZ" constraints="DEFAULT NOW()" description="Record creation timestamp" />
        </columns>
        <indexes>
          <index>PRIMARY KEY (id)</index>
          <index>INDEX idx_user_sessions_user_id ON user_sessions(user_id)</index>
          <index>INDEX idx_user_sessions_token_id ON user_sessions(token_id)</index>
          <index>INDEX idx_user_sessions_is_active ON user_sessions(is_active)</index>
        </indexes>
        <constraints>
          <check>CHECK (logged_out_at IS NULL OR is_active = false)</check>
          <check_description>If logged out, session must be inactive</check_description>
        </constraints>
        <migration_file>supabase/migrations/007_create_user_sessions_table.sql</migration_file>
        <estimated_rows>~500-1000 (10 users × 5-10 sessions/user avg, 90-day retention)</estimated_rows>
      </table>
    </schema>

    <redis>
      <purpose>JWT blacklist for instant session invalidation</purpose>
      <service>Upstash Redis</service>
      <key_format>blacklist:{jti}</key_format>
      <value>"1" (boolean flag)</value>
      <ttl>Calculated from JWT exp claim (seconds until natural expiry)</ttl>
      <rationale>
        After natural JWT expiry, token invalid anyway, no need to keep in blacklist.
        TTL auto-cleanup prevents memory leak.
      </rationale>
      <operations>
        <operation name="addToBlacklist">
          <code>SET blacklist:{jti} "1" EX {ttl_seconds}</code>
          <use_case>Called when session terminated (logout all, individual terminate, user deactivation)</use_case>
        </operation>
        <operation name="isBlacklisted">
          <code>GET blacklist:{jti}</code>
          <returns>boolean (exists = blacklisted)</returns>
          <use_case>Called in auth middleware on every API request</use_case>
        </operation>
      </operations>
      <env_vars>
        <var name="UPSTASH_REDIS_REST_URL" required="true" />
        <var name="UPSTASH_REDIS_REST_TOKEN" required="true" />
      </env_vars>
    </redis>
  </database>

  <api>
    <endpoints>
      <endpoint method="GET" path="/api/settings/users/:id/sessions">
        <description>List user's active sessions</description>
        <auth>User (self) or Admin (any user)</auth>
        <params>
          <param name="id" type="UUID" description="User ID (from URL)" />
        </params>
        <query_params>
          <param name="include_expired" type="boolean" default="false" description="Show expired sessions" />
        </query_params>
        <response>
          <type>UserSession[]</type>
          <example>
            [
              {
                "id": "session-uuid",
                "user_id": "user-uuid",
                "token_id": "jti-value",
                "device_info": "Chrome 120 on Windows 10 (Desktop)",
                "ip_address": "192.168.1.1",
                "location": null,
                "login_time": "2025-11-27T10:00:00Z",
                "last_activity": "2025-11-27T12:30:00Z",
                "is_active": true,
                "logged_out_at": null,
                "created_at": "2025-11-27T10:00:00Z"
              }
            ]
          </example>
        </response>
        <filters>
          - org_id from JWT (RLS-like check in API)
          - is_active = true (unless include_expired = true)
          - Sort by last_activity DESC
        </filters>
        <validation>
          - If not Admin: userId must match current user
          - If Admin: can view any user in same org
        </validation>
        <performance_target>
          &lt;200ms for 10 sessions
        </performance_target>
      </endpoint>

      <endpoint method="DELETE" path="/api/settings/users/:id/sessions">
        <description>Logout All Devices (except current)</description>
        <auth>User (self) or Admin</auth>
        <params>
          <param name="id" type="UUID" description="User ID" />
        </params>
        <response>
          <type>{ terminated_count: number }</type>
          <example>{ "terminated_count": 2 }</example>
        </response>
        <side_effects>
          1. Get all active sessions for user_id
          2. Extract current token_id from JWT (jti claim)
          3. Filter out current session
          4. For each remaining session:
             - Update is_active = false, logged_out_at = NOW()
             - Add token_id to Redis blacklist (TTL = token expiry)
             - Emit Supabase Realtime event: { event: 'session.terminated', payload: { token_id } }
          5. Return count of terminated sessions
        </side_effects>
        <validation>
          - If not Admin: userId must match current user
          - Current session never terminated (validation logic)
        </validation>
        <performance_target>
          &lt;500ms (incl. Redis blacklist writes)
        </performance_target>
      </endpoint>

      <endpoint method="DELETE" path="/api/settings/users/:id/sessions/:sessionId">
        <description>Terminate individual session</description>
        <auth>User (self) or Admin</auth>
        <params>
          <param name="id" type="UUID" description="User ID" />
          <param name="sessionId" type="UUID" description="Session ID" />
        </params>
        <response>
          <type>{ success: boolean }</type>
          <example>{ "success": true }</example>
        </response>
        <side_effects>
          1. Validate session belongs to userId
          2. Validate sessionId != current session (cannot terminate self)
          3. Update is_active = false, logged_out_at = NOW()
          4. Add token_id to Redis blacklist
          5. Emit Realtime event: 'session.terminated'
        </side_effects>
        <validation>
          - Session must belong to userId
          - Cannot terminate current session (400 Bad Request)
        </validation>
        <error_cases>
          - 400: Attempting to terminate current session
          - 404: Session not found or belongs to different user
        </error_cases>
        <performance_target>
          &lt;300ms
        </performance_target>
      </endpoint>
    </endpoints>
  </api>

  <services>
    <service name="SessionService">
      <location>apps/frontend/lib/services/SessionService.ts</location>
      <purpose>Session CRUD and termination logic</purpose>
      <methods>
        <method name="createSession">
          <signature>
            async createSession(userId: string, tokenId: string, deviceInfo: string, ipAddress: string): Promise&lt;UserSession&gt;
          </signature>
          <description>Create session record on login</description>
          <steps>
            1. Parse user agent → browser, OS, device type (use DeviceInfoParser)
            2. GeoIP lookup → city, country (optional, skip for MVP)
            3. Insert user_sessions record with is_active = true
            4. Return session object
          </steps>
          <called_from>POST /api/auth/login (after Supabase Auth success)</called_from>
        </method>

        <method name="terminateSession">
          <signature>
            async terminateSession(sessionId: string, userId: string): Promise&lt;void&gt;
          </signature>
          <description>Terminate individual session</description>
          <steps>
            1. Validate: session belongs to userId (throw if not)
            2. Update is_active = false, logged_out_at = NOW()
            3. Get token_id from session
            4. Add token_id to Redis blacklist (call JWTBlacklistService)
            5. Emit Supabase Realtime event: 'session.terminated' with { token_id }
          </steps>
          <throws>Error if session not found or wrong user</throws>
        </method>

        <method name="terminateAllSessions">
          <signature>
            async terminateAllSessions(userId: string, exceptCurrentToken?: string): Promise&lt;number&gt;
          </signature>
          <description>Terminate all sessions except current</description>
          <steps>
            1. Get all active sessions for userId (is_active = true)
            2. Filter out current session (by exceptCurrentToken if provided)
            3. For each session: call terminateSession(session.id, userId)
            4. Return count of terminated sessions
          </steps>
          <called_from>
            - DELETE /api/settings/users/:id/sessions (Logout All)
            - DELETE /api/settings/users/:id (User deactivation - Story 1.2)
          </called_from>
        </method>

        <method name="getSessions">
          <signature>
            async getSessions(userId: string, includeExpired = false): Promise&lt;UserSession[]&gt;
          </signature>
          <description>Fetch sessions for user</description>
          <steps>
            1. Query user_sessions WHERE user_id = userId
            2. Filter is_active = true OR includeExpired
            3. Sort by last_activity DESC
            4. Return sessions array
          </steps>
        </method>

        <method name="updateLastActivity">
          <signature>
            async updateLastActivity(tokenId: string): Promise&lt;void&gt;
          </signature>
          <description>Update last_activity timestamp</description>
          <steps>
            1. Update last_activity = NOW() WHERE token_id = tokenId
          </steps>
          <called_from>Auth middleware on every API request</called_from>
          <performance>Should be fast (&lt;10ms) - runs on every request</performance>
        </method>
      </methods>
    </service>

    <service name="JWTBlacklistService">
      <location>apps/frontend/lib/services/JWTBlacklistService.ts</location>
      <purpose>Redis-based JWT blacklist operations</purpose>
      <dependencies>
        <dependency>@upstash/redis</dependency>
      </dependencies>
      <methods>
        <method name="addToBlacklist">
          <signature>
            async addToBlacklist(tokenId: string, expiresAt: Date): Promise&lt;void&gt;
          </signature>
          <description>Add JWT to blacklist with TTL</description>
          <steps>
            1. Calculate TTL = expiresAt - NOW() (in seconds)
            2. If TTL &lt;= 0: skip (already expired naturally)
            3. SET blacklist:{tokenId} "1" EX {ttl}
          </steps>
        </method>

        <method name="isBlacklisted">
          <signature>
            async isBlacklisted(tokenId: string): Promise&lt;boolean&gt;
          </signature>
          <description>Check if JWT is blacklisted</description>
          <steps>
            1. GET blacklist:{tokenId}
            2. Return true if exists, false otherwise
          </steps>
          <called_from>Auth middleware on every API request (after JWT verification)</called_from>
        </method>
      </methods>
      <redis_client>
        <init>
          import { Redis } from '@upstash/redis'
          const redis = new Redis({
            url: process.env.UPSTASH_REDIS_REST_URL,
            token: process.env.UPSTASH_REDIS_REST_TOKEN
          })
        </init>
      </redis_client>
    </service>

    <service name="DeviceInfoParser">
      <location>apps/frontend/lib/utils/DeviceInfoParser.ts</location>
      <purpose>Parse user agent to extract device info</purpose>
      <dependencies>
        <dependency>ua-parser-js</dependency>
      </dependencies>
      <methods>
        <method name="parseUserAgent">
          <signature>
            parseUserAgent(userAgent: string): string
          </signature>
          <description>Parse user agent to formatted string</description>
          <input>Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0...</input>
          <output>Chrome 120 on Windows 10 (Desktop)</output>
          <steps>
            1. Use UAParser(userAgent)
            2. Extract: browser.name, browser.version, os.name, os.version, device.type
            3. Format: "{browser} {version} on {OS} ({device_type})"
            4. Device type: Desktop (if undefined), Mobile, Tablet
          </steps>
        </method>
      </methods>
      <library_usage>
        <code>
          import UAParser from 'ua-parser-js'

          const parser = new UAParser(userAgent)
          const browser = parser.getBrowser()
          const os = parser.getOS()
          const device = parser.getDevice()

          const deviceType = device.type || 'Desktop'
          return `${browser.name} ${browser.version} on ${os.name} ${os.version} (${deviceType})`
        </code>
      </library_usage>
    </service>
  </services>

  <middleware>
    <auth_middleware>
      <location>apps/frontend/lib/middleware/auth.ts</location>
      <purpose>Verify JWT + check blacklist + update last activity</purpose>
      <flow>
        1. Extract JWT from request (cookie or Authorization header)
        2. Verify JWT signature (Supabase Auth verification)
        3. Extract jti claim (token ID)
        4. Check if blacklisted: await JWTBlacklistService.isBlacklisted(jti)
        5. If blacklisted → return 401 Unauthorized, clear session cookie
        6. If valid → call SessionService.updateLastActivity(jti)
        7. Attach user to request context
        8. Continue to protected route
      </flow>
      <performance>
        - Redis check: ~5-10ms
        - DB update (last_activity): ~5-10ms
        - Total overhead: ~10-20ms per request
      </performance>
      <error_handling>
        - JWT expired naturally → 401 (redirect to login)
        - JWT blacklisted → 401 + toast: "Session terminated"
        - Redis unavailable → allow request (graceful degradation, log error)
      </error_handling>
    </auth_middleware>

    <login_enhancement>
      <location>POST /api/auth/login</location>
      <add_after_supabase_auth>
        1. Extract JWT from Supabase Auth response
        2. Decode JWT to get jti claim (token ID)
        3. Parse user agent from request headers
        4. Get IP address from request (x-forwarded-for or request.ip)
        5. Call SessionService.createSession(userId, jti, userAgent, ip)
        6. Return user + session object
      </add_after_supabase_auth>
    </login_enhancement>
  </middleware>

  <realtime>
    <supabase_realtime>
      <channel_name>session_events</channel_name>
      <purpose>Broadcast session termination events for instant logout</purpose>
      <event_type>session.terminated</event_type>
      <payload>
        {
          "token_id": "jti-value-of-terminated-session"
        }
      </payload>
      <server_emit>
        <code>
          import { createClient } from '@/lib/supabase/server'

          const supabase = await createClient()
          await supabase
            .channel('session_events')
            .send({
              type: 'broadcast',
              event: 'session.terminated',
              payload: { token_id: jti }
            })
        </code>
        <called_from>
          - SessionService.terminateSession
          - SessionService.terminateAllSessions (for each session)
        </called_from>
      </server_emit>
      <client_listen>
        <code>
          // In useRealtimeSessionTermination.ts hook
          useEffect(() => {
            const supabase = createClient()
            const currentJti = getCurrentJtiFromJWT() // Extract from stored JWT

            const channel = supabase
              .channel('session_events')
              .on('broadcast', { event: 'session.terminated' }, (payload) => {
                if (payload.token_id === currentJti) {
                  // Force logout
                  localStorage.clear()
                  sessionStorage.clear()
                  router.push('/login')
                  toast.error('Your session has been terminated')
                }
              })
              .subscribe()

            return () => {
              channel.unsubscribe()
            }
          }, [])
        </code>
        <use_in_components>
          - Add to app layout (apps/frontend/app/layout.tsx) for all authenticated pages
          - Alternative: Add to each protected page individually
        </use_in_components>
      </client_listen>
      <propagation_time>
        Target: &lt;1s (Supabase Realtime SLA)
      </propagation_time>
      <status>Deferred to Story 1.14</status>
    </supabase_realtime>
  </realtime>

  <ui>
    <deferred_note>
      All UI components deferred to Story 1.14 (backend complete in Story 1.4)
    </deferred_note>

    <page path="/settings/users/[id]/sessions">
      <component>apps/frontend/app/settings/users/[id]/sessions/page.tsx</component>
      <purpose>Display user's active sessions with termination controls</purpose>
      <sections>
        <section name="Page Header">
          - Title: "Active Sessions" or "John Doe's Sessions" (if Admin viewing other user)
          - Subtitle: "Manage your login sessions across devices"
          - "Logout All Devices" button (top-right)
        </section>
        <section name="Sessions Table">
          - Component: SessionsTable (see below)
        </section>
      </sections>
      <access_control>
        - Users can only view own sessions (/settings/users/{currentUserId}/sessions)
        - Admins can view any user's sessions (/settings/users/{anyUserId}/sessions)
      </access_control>
    </page>

    <component name="SessionsTable">
      <location>apps/frontend/components/settings/SessionsTable.tsx</location>
      <columns>
        <column name="Device Info" width="30%">
          - Display: device_info string
          - Icon: Browser icon (Chrome, Firefox, Safari, etc.)
        </column>
        <column name="IP Address" width="15%">
          - Display: ip_address
        </column>
        <column name="Location" width="15%">
          - Display: location (GeoIP city/country) or "N/A" if null
        </column>
        <column name="Login Time" width="15%">
          - Display: login_time (formatted: "Nov 27, 10:00 AM")
        </column>
        <column name="Last Activity" width="15%">
          - Display: last_activity (formatted: "2 hours ago" or "Just now")
          - Auto-refresh every 30s (polling or realtime)
        </column>
        <column name="Status" width="10%">
          - Badge: "Active" (green) if is_active = true
          - Badge: "Expired" (gray) if is_active = false or JWT expired
        </column>
        <column name="Actions" width="10%">
          - "Terminate" button (red, outline)
          - Disabled if current session (with tooltip: "Cannot terminate current session")
        </column>
      </columns>
      <current_session_highlight>
        - Background color: bg-blue-50 (light blue tint)
        - Badge: "Current Session" (blue badge in Device Info cell)
      </current_session_highlight>
      <actions>
        <action name="Terminate Individual Session">
          1. Click "Terminate" button
          2. Show confirmation modal: "Are you sure you want to terminate this session?"
          3. On confirm: DELETE /api/settings/users/:id/sessions/:sessionId
          4. On success: refresh table, show toast: "Session terminated"
        </action>
        <action name="Logout All Devices">
          1. Click "Logout All Devices" button (page header)
          2. Show confirmation modal: "This will log you out of all devices except the current one"
          3. On confirm: DELETE /api/settings/users/:id/sessions
          4. On success: refresh table, show toast: "Logged out from all devices"
        </action>
      </actions>
    </component>

    <shadcn_components>
      - Table, TableHeader, TableBody, TableRow, TableCell (sessions table)
      - Badge (Active/Expired status)
      - Button (Terminate, Logout All)
      - Dialog (confirmation modals)
      - useToast (success/error toasts)
    </shadcn_components>
  </ui>

  <testing>
    <deferred_note>
      All tests deferred to Story 1.14 (backend logic complete in Story 1.4)
    </deferred_note>

    <unit_tests>
      <test_file>apps/frontend/__tests__/unit/device-info-parser.test.ts</test_file>
      <test_cases>
        - Parse Chrome user agent → correct device info
        - Parse Firefox user agent → correct device info
        - Parse Safari mobile user agent → Mobile device type
        - Parse Edge desktop user agent → Desktop device type
        - Handle malformed user agent → fallback to "Unknown Browser"
      </test_cases>
    </unit_tests>

    <unit_tests>
      <test_file>apps/frontend/__tests__/unit/jwt-blacklist.test.ts</test_file>
      <test_cases>
        - Add token to blacklist → exists in Redis
        - Check blacklisted token → returns true
        - Check non-blacklisted token → returns false
        - Add token with TTL → auto-expires after TTL
        - Add token with expired JWT → skips Redis write
      </test_cases>
    </unit_tests>

    <integration_tests>
      <test_file>apps/frontend/__tests__/integration/sessions.test.ts</test_file>
      <test_cases>
        - Login → session created in user_sessions table
        - Login → device_info parsed correctly
        - Login → token_id matches JWT jti
        - GET /api/settings/users/:id/sessions → returns active sessions
        - DELETE /api/settings/users/:id/sessions → terminates all except current
        - DELETE /api/settings/users/:id/sessions → JWTs blacklisted in Redis
        - Blacklisted JWT → 401 on next API request
        - Normal logout → session is_active = false, not blacklisted
      </test_cases>
    </integration_tests>

    <e2e_tests>
      <test_file>tests/e2e/sessions.spec.ts</test_file>
      <test_cases>
        <test name="User views own sessions">
          1. Login as user A
          2. Navigate to /settings/users/{userId}/sessions
          3. Verify current session visible in table
          4. Verify device info displayed correctly
          5. Verify "Terminate" button disabled for current session
        </test>

        <test name="Logout all devices (multi-browser)">
          1. Login as user A in browser A (Chromium)
          2. Login as user A in browser B (Firefox)
          3. In browser A: view sessions → 2 sessions visible
          4. In browser A: click "Logout All Devices" → confirm modal
          5. Verify browser B redirected to /login within 1s
          6. Verify browser A still authenticated
          7. In browser A: refresh sessions → only 1 session visible
        </test>

        <test name="Terminate individual session">
          1. Login as user A in browser A
          2. Login as user A in browser B
          3. In browser A: open sessions page
          4. Click "Terminate" on browser B's session → confirm
          5. Verify browser B logged out within 1s
          6. Verify toast displayed in browser B: "Your session has been terminated"
        </test>

        <test name="Admin terminates other user's session">
          1. Login as Admin in browser A
          2. Login as user B in browser B
          3. In browser A: navigate to /settings/users/{userBId}/sessions
          4. Verify user B's sessions visible
          5. Click "Terminate" on user B's session → confirm
          6. Verify browser B logged out within 1s
          7. Verify Admin still authenticated in browser A
        </test>

        <test name="Expired session display">
          1. Create session with expired JWT (manual DB insert)
          2. Login as user
          3. Navigate to sessions page
          4. Enable "Show Expired" filter
          5. Verify expired session shows "Expired" badge (gray)
        </test>
      </test_cases>
      <playwright_config>
        - Multi-browser support: chromium, firefox, webkit
        - Parallel execution for cross-browser logout tests
        - Realtime event timeout: 1500ms (allow 1s SLA + 500ms buffer)
      </playwright_config>
    </e2e_tests>

    <performance_tests>
      <test name="Session list load time">
        - Scenario: User with 10 active sessions
        - Target: &lt;200ms
        - Verify: GET /api/settings/users/:id/sessions response time
      </test>
      <test name="Logout all devices execution time">
        - Scenario: User with 5 active sessions
        - Target: &lt;500ms
        - Verify: DELETE /api/settings/users/:id/sessions response time
      </test>
      <test name="Realtime propagation">
        - Scenario: Terminate session in browser A
        - Target: Browser B logged out in &lt;1s
        - Verify: Time from DELETE request to browser B redirect
      </test>
    </performance_tests>
  </testing>

  <dependencies>
    <npm_packages>
      <package name="@upstash/redis" version="latest" purpose="Redis client for JWT blacklist" />
      <package name="ua-parser-js" version="latest" purpose="User agent parsing for device info" />
      <package name="@supabase/supabase-js" version="latest" purpose="Supabase client with Realtime support" />
    </npm_packages>

    <external_services>
      <service name="Upstash Redis">
        <purpose>JWT blacklist storage</purpose>
        <env_vars>
          <var name="UPSTASH_REDIS_REST_URL" required="true" />
          <var name="UPSTASH_REDIS_REST_TOKEN" required="true" />
        </env_vars>
        <free_tier>10000 requests/day, 256MB storage (sufficient for MVP)</free_tier>
      </service>

      <service name="Supabase Realtime">
        <purpose>Broadcast session termination events</purpose>
        <channel>session_events</channel>
        <event>session.terminated</event>
        <sla>Message propagation &lt;1s</sla>
        <config>Enable Realtime in Supabase project settings</config>
      </service>

      <service name="GeoIP (Optional - Skipped for MVP)">
        <purpose>IP to location lookup</purpose>
        <options>
          <option>ipapi.co (1000 requests/day free)</option>
          <option>ip-api.com (45 requests/minute free)</option>
        </options>
        <decision>Skip for MVP, add in Phase 2</decision>
      </service>
    </external_services>

    <internal_dependencies>
      <dependency story="1.2" reason="users table required, user deactivation calls terminateAllSessions" />
      <dependency story="1.0" reason="Supabase Auth JWT with jti claim required" />
    </internal_dependencies>
  </dependencies>

  <implementation_notes>
    <backend_status>
      ✅ Complete (Story 1.4)
      - Database: user_sessions table with indexes
      - Services: SessionService, JWTBlacklistService, DeviceInfoParser
      - API: GET/DELETE /api/settings/users/:id/sessions, DELETE /api/settings/users/:id/sessions/:sessionId
      - Middleware: Auth middleware enhanced with blacklist check + last activity update
      - Dependencies: @upstash/redis, ua-parser-js installed
    </backend_status>

    <deferred_to_story_1_14>
      ❌ Deferred
      - Frontend: SessionsTable component, sessions page
      - Realtime: Supabase Realtime integration (server emit + client listen)
      - Testing: Unit, integration, E2E tests
      - Cron: Auto-cleanup job for expired sessions (&gt;90 days)
      - Effort estimate: ~8 hours
    </deferred_to_story_1_14>

    <key_decisions>
      <decision>
        <title>JWT Blacklist with Redis TTL</title>
        <rationale>
          - Redis TTL auto-cleanup prevents memory leak
          - TTL = token expiry means no manual cleanup needed
          - After natural JWT expiry, token invalid anyway
          - Performance: Redis check adds ~5-10ms per request (acceptable)
        </rationale>
      </decision>

      <decision>
        <title>Skip GeoIP for MVP</title>
        <rationale>
          - External API dependency (rate limits, cost)
          - Not critical for session management (IP address sufficient)
          - Can add in Phase 2 as enhancement
        </rationale>
      </decision>

      <decision>
        <title>Soft Delete Sessions</title>
        <rationale>
          - Audit trail: keep session history for 90 days
          - Security: track login patterns, detect anomalies
          - Compliance: some regulations require session logs
          - Cleanup: auto-delete after 90 days (cron job)
        </rationale>
      </decision>

      <decision>
        <title>No RLS on user_sessions</title>
        <rationale>
          - Sessions managed server-side only (not exposed to client queries)
          - User_id check in API endpoints (explicit validation)
          - RLS overhead not needed (API already enforces access control)
        </rationale>
      </decision>

      <decision>
        <title>Last Activity Update on Every Request</title>
        <rationale>
          - Shows real-time session usage
          - Helps identify abandoned sessions
          - Performance: ~5-10ms overhead per request (indexed query)
          - Trade-off: Slight performance cost for security insight
        </rationale>
      </decision>
    </key_decisions>

    <security_considerations>
      <item>JWT Blacklist: Prevents terminated sessions from API access</item>
      <item>Realtime Force Logout: Immediate invalidation on client side (&lt;1s)</item>
      <item>Session Ownership: Users can only view/terminate own sessions (except Admin)</item>
      <item>Current Session Protection: Cannot terminate own current session (prevent lockout)</item>
      <item>Audit Trail: All sessions logged with device info, IP, timestamps</item>
      <item>Redis TTL: Auto-cleanup prevents memory leak from abandoned blacklist entries</item>
      <item>Normal Logout: JWT not blacklisted (reduces Redis load, natural expiry after 7 days)</item>
    </security_considerations>

    <performance_targets>
      <target>Session list load (10 sessions): &lt;200ms</target>
      <target>Logout all devices: &lt;500ms (incl. Redis blacklist)</target>
      <target>Realtime propagation: &lt;1s (Supabase SLA)</target>
      <target>Last activity update: &lt;10ms (middleware overhead)</target>
      <target>Redis blacklist check: &lt;10ms (per request)</target>
    </performance_targets>

    <monitoring>
      <metric>Active sessions/user (avg)</metric>
      <metric>Session termination events/day</metric>
      <metric>Redis blacklist size (track memory usage)</metric>
      <metric>Realtime event propagation time (p95)</metric>
      <metric>Auth middleware overhead (last activity + blacklist check)</metric>
      <alert>Redis connection failures (critical)</alert>
      <alert>Realtime event propagation &gt;2s (warning)</alert>
    </monitoring>
  </implementation_notes>

  <integration_with_other_stories>
    <story_1_2_user_crud>
      <integration_point>User deactivation calls SessionService.terminateAllSessions</integration_point>
      <flow>
        1. Admin clicks "Deactivate" on user in /settings/users
        2. API: DELETE /api/settings/users/:id
        3. Server updates user.status = 'inactive'
        4. Server calls SessionService.terminateAllSessions(userId) (no exceptCurrentToken)
        5. All user's sessions terminated, JWTs blacklisted
        6. Realtime events emitted
        7. User logged out from all devices within 1s
      </flow>
      <code_location>
        apps/frontend/app/api/settings/users/[id]/route.ts (DELETE handler)
      </code_location>
    </story_1_2_user_crud>

    <story_1_0_auth>
      <integration_point>Login flow creates session record</integration_point>
      <flow>
        1. User submits login form
        2. API: POST /api/auth/login
        3. Supabase Auth verifies credentials → returns JWT
        4. Extract jti claim from JWT
        5. Parse user agent from request headers
        6. Get IP address from request (x-forwarded-for)
        7. Call SessionService.createSession(userId, jti, userAgent, ip)
        8. Return user + session
      </flow>
      <code_location>
        apps/frontend/app/api/auth/login/route.ts (POST handler)
      </code_location>
    </story_1_0_auth>

    <story_1_3_invitations>
      <integration_point>No direct integration</integration_point>
      <note>
        Both use Supabase Auth (auth.users table) but no shared logic.
        Invitation signup flow creates new user → login → session created.
      </note>
    </story_1_3_invitations>
  </integration_with_other_stories>

  <data_model>
    <typescript_interface>
      <code>
        interface UserSession {
          id: string                    // UUID PK
          user_id: string               // FK → users
          token_id: string              // JWT jti claim (unique)
          device_info: string           // "Chrome 120 on Windows 10 (Desktop)"
          ip_address: string            // IPv4 or IPv6
          location?: string             // "San Francisco, US" (optional, GeoIP)
          login_time: Date              // When session started
          last_activity: Date           // Last API request timestamp
          is_active: boolean            // true = active, false = terminated
          logged_out_at?: Date          // When user logged out
          created_at: Date
        }

        // Redis Blacklist Entry
        // Key: `blacklist:{jti}`
        // Value: "1"
        // TTL: seconds until JWT exp
      </code>
    </typescript_interface>

    <example_data>
      <code>
        // Active session
        {
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "user_id": "user-uuid",
          "token_id": "jti-abc123",
          "device_info": "Chrome 120 on Windows 10 (Desktop)",
          "ip_address": "192.168.1.100",
          "location": null,
          "login_time": "2025-11-27T10:00:00Z",
          "last_activity": "2025-11-27T12:30:00Z",
          "is_active": true,
          "logged_out_at": null,
          "created_at": "2025-11-27T10:00:00Z"
        }

        // Terminated session
        {
          "id": "550e8400-e29b-41d4-a716-446655440001",
          "user_id": "user-uuid",
          "token_id": "jti-def456",
          "device_info": "Firefox 119 on macOS 14 (Desktop)",
          "ip_address": "192.168.1.101",
          "location": null,
          "login_time": "2025-11-26T14:00:00Z",
          "last_activity": "2025-11-27T09:00:00Z",
          "is_active": false,
          "logged_out_at": "2025-11-27T10:05:00Z",
          "created_at": "2025-11-26T14:00:00Z"
        }
      </code>
    </example_data>
  </data_model>

  <file_structure>
    <files>
      <file path="supabase/migrations/007_create_user_sessions_table.sql" status="created">
        Database migration: user_sessions table with indexes and constraints
      </file>
      <file path="apps/frontend/lib/services/SessionService.ts" status="created">
        Session CRUD, termination logic, last activity updates
      </file>
      <file path="apps/frontend/lib/services/JWTBlacklistService.ts" status="created">
        Redis blacklist operations (add, check)
      </file>
      <file path="apps/frontend/lib/utils/DeviceInfoParser.ts" status="created">
        User agent parsing with ua-parser-js
      </file>
      <file path="apps/frontend/lib/middleware/auth.ts" status="modified">
        Enhanced with blacklist check + last activity update
      </file>
      <file path="apps/frontend/app/api/settings/users/[id]/sessions/route.ts" status="created">
        GET (list sessions), DELETE (logout all)
      </file>
      <file path="apps/frontend/app/api/settings/users/[id]/sessions/[sessionId]/route.ts" status="created">
        DELETE (terminate individual session)
      </file>
      <file path="apps/frontend/app/api/auth/login/route.ts" status="modified">
        Added SessionService.createSession call after Supabase Auth
      </file>
      <file path="apps/frontend/app/settings/users/[id]/sessions/page.tsx" status="deferred">
        Sessions page (deferred to Story 1.14)
      </file>
      <file path="apps/frontend/components/settings/SessionsTable.tsx" status="deferred">
        Sessions table component (deferred to Story 1.14)
      </file>
      <file path="apps/frontend/hooks/useRealtimeSessionTermination.ts" status="deferred">
        Realtime listener hook (deferred to Story 1.14)
      </file>
    </files>
  </file_structure>

  <changelog>
    <entry date="2025-11-20" author="Mariusz">
      Story drafted from Epic 1 + Tech Spec Epic 1
    </entry>
    <entry date="2025-11-22" author="Claude Sonnet 4.5">
      Backend implementation completed (Tasks 1-7):
      - Database: user_sessions table with indexes and constraints
      - Services: SessionService, JWTBlacklistService, DeviceInfoParser
      - API endpoints: GET/DELETE sessions (list, logout all, terminate individual)
      - Dependencies: @upstash/redis, ua-parser-js
      - GeoIP skipped for MVP (as per notes)
      - Deferred to Story 1.14: Tasks 8-11 (Frontend, Realtime, Tests, Cron)
    </entry>
    <entry date="2025-11-27" author="Mariusz">
      Context XML created for Story 1.4
    </entry>
  </changelog>
</story-context>
