<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <story-id>04-19</story-id>
    <story-name>Genealogy Record Creation</story-name>
    <epic>4 - Production Execution</epic>
    <status>drafted</status>
    <priority>P0</priority>
    <story-points>2</story-points>
    <effort>1 day</effort>
    <created>2025-11-27</created>
    <dependencies>
      <dependency>Story 4.7 - Material Reservation (Desktop)</dependency>
      <dependency>Story 4.12 - Output Registration (Desktop)</dependency>
      <dependency>Story 4.16 - Multiple Outputs per WO</dependency>
    </dependencies>
  </metadata>

  <story-content>
    <user-story>
      As a System
      I want to record genealogy links
      So that traceability is maintained
    </user-story>

    <acceptance-criteria>
      <criterion id="AC-4.19.1">
        <title>Output Genealogy Entry Creation (at Output Registration)</title>
        <description>
          Given output registered
          When output LP created (Story 4.12)
          Then lp_genealogy entries created for each consumed LP:
          - parent_lp_id = consumed LP (from sequential allocation)
          - child_lp_id = output LP (now known)
          - wo_id = current WO
          - consumed_qty = qty consumed from this LP for this output
          - produced_at = timestamp
          - created_at = timestamp

          Note: Genealogy created at output registration, not at reservation
        </description>
      </criterion>

      <criterion id="AC-4.19.2">
        <title>Partial LP Consumption Tracking</title>
        <description>
          When LP is consumed partially across multiple outputs (Story 4.16)
          Then genealogy tracks partial consumption:
          - LP-2 (30kg) → Output-1 (20kg) + Output-2 (10kg)
          - Two lp_genealogy records created with consumed_qty = 20kg and 10kg respectively
        </description>
      </criterion>

      <criterion id="AC-4.19.3">
        <title>Multiple Outputs & Parent-Child Relationships</title>
        <description>
          When multiple outputs from same WO
          Then Genealogy structure:
          - Per WO output: Each output LP has many parent LPs (materials consumed in that WO) → many-to-one per output
          - Per parent LP: Each parent LP can have many children (from different WOs using that material) → one-to-many from parent perspective
          - Result: From genealogy table view: many consumed parent LPs → one output LP per record, but one parent LP can appear in multiple genealogy records (to different children)
        </description>
      </criterion>

      <criterion id="AC-4.19.4">
        <title>Genealogy Tree View</title>
        <description>
          Then Forward tracing: input LP → WO → output LP
          Then Backward tracing: output LP → WO → input LPs
        </description>
      </criterion>

      <criterion id="AC-4.19.5">
        <title>Data Integrity</title>
        <description>
          Then FK constraints: parent_lp_id, child_lp_id, wo_id are valid
        </description>
      </criterion>

      <criterion id="AC-4.19.6">
        <title>Audit Trail</title>
        <description>
          Then created_at, created_by_user_id recorded for compliance
        </description>
      </criterion>

      <criterion id="AC-4.19.7">
        <title>FDA Compliance</title>
        <description>
          Then Genealogy supports FDA 21 CFR Part 117 traceability requirements
        </description>
      </criterion>

      <criterion id="AC-4.19.8">
        <title>Prerequisites</title>
        <description>
          Then Requires Stories 4.7 (Consumption) and 4.12 (Output)
        </description>
      </criterion>
    </acceptance-criteria>

    <tasks>
      <task id="1" status="pending">Verify lp_genealogy table schema</task>
      <task id="2" status="pending">Genealogy entry creation on consumption</task>
      <task id="3" status="pending">Genealogy update on output</task>
      <task id="4" status="pending">Many-to-many genealogy support</task>
      <task id="5" status="pending">Genealogy query logic (forward/backward)</task>
      <task id="6" status="pending">FK constraint validation</task>
      <task id="7" status="pending">Tests</task>
    </tasks>
  </story-content>

  <!-- Database Schema -->
  <database-schema>
    <table name="lp_genealogy">
      <description>
        License Plate genealogy graph for forward and backward traceability. Immutable audit trail.
        Migration: 030_create_lp_genealogy_table.sql
      </description>

      <columns>
        <column name="id" type="UUID" primary-key="true">Primary key, auto-generated</column>
        <column name="parent_lp_id" type="UUID" nullable="false" references="license_plates(id)">
          Input LP (material consumed) - CASCADE delete
        </column>
        <column name="child_lp_id" type="UUID" nullable="false" references="license_plates(id)">
          Output LP (finished good produced) - CASCADE delete
        </column>
        <column name="relationship_type" type="VARCHAR(20)" nullable="false">
          Type: split (1→many), combine (many→1), transform (WO production)
        </column>
        <column name="work_order_id" type="UUID" references="work_orders(id)">
          WO context - SET NULL on delete
        </column>
        <column name="transfer_order_id" type="UUID" references="transfer_orders(id)">
          TO context - SET NULL on delete
        </column>
        <column name="quantity_from_parent" type="DECIMAL(12,3)" nullable="false">
          Quantity transferred/consumed from parent to child LP
        </column>
        <column name="uom" type="VARCHAR(10)" nullable="false">Unit of measure</column>
        <column name="created_by" type="UUID" references="users(id)">Audit: who created</column>
        <column name="created_at" type="TIMESTAMP WITH TIME ZONE" nullable="false" default="NOW()">
          Audit: when created
        </column>
      </columns>

      <constraints>
        <constraint type="CHECK" name="lp_genealogy_type_check">
          relationship_type IN ('split', 'combine', 'transform')
        </constraint>
        <constraint type="CHECK" name="lp_genealogy_no_self_reference">
          parent_lp_id != child_lp_id
        </constraint>
        <constraint type="CHECK" name="lp_genealogy_quantity_positive">
          quantity_from_parent > 0
        </constraint>
      </constraints>

      <indexes>
        <index name="idx_lp_genealogy_parent" on="parent_lp_id">
          Critical for forward trace queries (parent → children)
        </index>
        <index name="idx_lp_genealogy_child" on="child_lp_id">
          Critical for backward trace queries (child → parents)
        </index>
        <index name="idx_lp_genealogy_wo" on="work_order_id" where="work_order_id IS NOT NULL">
          Performance for WO-specific queries
        </index>
        <index name="idx_lp_genealogy_to" on="transfer_order_id" where="transfer_order_id IS NOT NULL">
          Performance for TO-specific queries
        </index>
        <index name="idx_lp_genealogy_composite" on="parent_lp_id, child_lp_id, relationship_type">
          Composite index for genealogy traversal
        </index>
      </indexes>

      <rls-policies>
        <policy name="Users can view genealogy in their org" operation="SELECT">
          EXISTS (
            SELECT 1 FROM license_plates lp
            WHERE lp.id = lp_genealogy.parent_lp_id
              AND lp.org_id = (auth.jwt() ->> 'org_id')::uuid
          )
        </policy>
        <policy name="Technical/Admin/QC can create genealogy" operation="INSERT">
          EXISTS (
            SELECT 1 FROM license_plates lp
            WHERE lp.id = lp_genealogy.parent_lp_id
              AND lp.org_id = (auth.jwt() ->> 'org_id')::uuid
          )
          AND (auth.jwt() ->> 'role') IN ('technical', 'admin', 'qc_manager', 'warehouse', 'production')
        </policy>
        <policy name="UPDATE/DELETE not allowed" operation="UPDATE/DELETE">
          Immutable audit trail - no updates or deletes allowed
        </policy>
      </rls-policies>
    </table>

    <table name="license_plates">
      <description>
        License Plates (LP) - STUB for Epic 2 testing. Full implementation in Epic 5.
        Migration: 027_create_license_plates_stub.sql
      </description>

      <key-columns>
        <column name="id" type="UUID">Primary key</column>
        <column name="org_id" type="UUID">Organization reference</column>
        <column name="lp_number" type="VARCHAR(50)" unique="true">Unique LP identifier (e.g., LP-2024-001)</column>
        <column name="batch_number" type="VARCHAR(50)">Batch number for traceability</column>
        <column name="product_id" type="UUID">Product reference</column>
        <column name="quantity" type="DECIMAL(12,3)">Current quantity (must be > 0)</column>
        <column name="uom" type="VARCHAR(10)">Unit of measure</column>
        <column name="status" type="VARCHAR(20)" default="available">
          Status: available, consumed, shipped, quarantine, recalled
        </column>
        <column name="manufacturing_date" type="DATE">When manufactured</column>
        <column name="expiry_date" type="DATE">Expiration date</column>
      </key-columns>
    </table>

    <table name="work_orders">
      <description>Work orders for production execution</description>
      <key-columns>
        <column name="id" type="UUID">Primary key</column>
        <column name="wo_number" type="VARCHAR(50)">Work order number</column>
        <column name="product_id" type="UUID">Output product</column>
        <column name="planned_qty" type="DECIMAL(12,3)">Planned output quantity</column>
        <column name="output_qty" type="DECIMAL(12,3)">Cumulative registered output quantity</column>
        <column name="status" type="VARCHAR(20)">Status: draft, ready, in_progress, completed, cancelled</column>
      </key-columns>
    </table>
  </database-schema>

  <!-- Integration Points -->
  <integration-points>
    <integration name="Story 4.7 - Material Reservation">
      <description>
        Material reservation creates initial genealogy entry skeleton:
        - lp_genealogy record created with parent_lp_id (reserved LP) known
        - child_lp_id remains NULL until output registration
        - wo_id links reservation to specific work order
        - sequence_number determines LP consumption order
      </description>
      <data-flow>
        Reserve Material → Create wo_material_reservations entry → Create lp_genealogy skeleton (parent known, child NULL)
      </data-flow>
    </integration>

    <integration name="Story 4.12 - Output Registration">
      <description>
        Output registration completes genealogy records:
        - Output LP created with batch_number, expiry_date, status
        - Sequential LP allocation: consume reserved LPs in order based on cumulative output
        - Update lp_genealogy records: set child_lp_id = output LP
        - Set quantity_from_parent = actual consumed qty (can be partial)
        - Set relationship_type = 'transform' for WO production
        - Multiple lp_genealogy records per output if multiple parent LPs consumed
      </description>
      <data-flow>
        Register Output → Create output LP → Determine consumed LPs (sequential) → Update genealogy records with child_lp_id
      </data-flow>
    </integration>

    <integration name="Story 4.16 - Multiple Outputs per WO">
      <description>
        Multiple outputs share reserved LP pool, consumed sequentially:
        - Each output creates separate LP (not cumulative)
        - Sequential allocation: Output-1 consumes LP-A, Output-2 consumes LP-B, etc.
        - Partial LP consumption: LP can span multiple outputs
        - Each output gets separate genealogy records linking to consumed LPs
        - work_orders.output_qty = sum of all outputs
      </description>
      <example>
        WO: 200kg planned
        Reserved: LP-A (80kg), LP-B (40kg), LP-C (80kg)

        Output-1 (70kg): consumes LP-A (70kg of 80kg)
          → genealogy: LP-A → Output-1 (70kg consumed)

        Output-2 (20kg): consumes LP-A (10kg remaining) + LP-B (10kg of 40kg)
          → genealogy: LP-A → Output-2 (10kg), LP-B → Output-2 (10kg)

        Output-3 (80kg): consumes LP-B (30kg remaining) + LP-C (50kg of 80kg)
          → genealogy: LP-B → Output-3 (30kg), LP-C → Output-3 (50kg)
      </example>
    </integration>

    <integration name="Story 4.9 - 1:1 Consumption Enforcement">
      <description>
        consume_whole_lp flag affects genealogy quantity tracking:
        - If consume_whole_lp = true: entire LP consumed when reached in sequence
        - quantity_from_parent = LP.quantity (full LP consumed)
        - No partial consumption allowed for these materials
      </description>
    </integration>
  </integration-points>

  <!-- Genealogy Service Pattern -->
  <service-pattern>
    <file>apps/frontend/lib/services/genealogy-service.ts</file>
    <description>Service for forward/backward traceability using recursive CTEs</description>

    <functions>
      <function name="traceForward">
        <signature>async traceForward(lpId: string, maxDepth: number = 20): Promise&lt;TraceResult&gt;</signature>
        <description>
          Forward trace: Find all descendants (children) of an LP
          Uses recursive CTE query via RPC: trace_forward(p_lp_id, p_max_depth)
          Returns tree structure with total_descendants and max_depth summary
        </description>
      </function>

      <function name="traceBackward">
        <signature>async traceBackward(lpId: string, maxDepth: number = 20): Promise&lt;TraceResult&gt;</signature>
        <description>
          Backward trace: Find all ancestors (parents) of an LP
          Uses recursive CTE query via RPC: trace_backward(p_lp_id, p_max_depth)
          Returns tree structure with total_ancestors and max_depth summary
        </description>
      </function>

      <function name="buildTree">
        <signature>function buildTree(flatData: any[]): TraceNode[]</signature>
        <description>
          Transforms flat CTE result into hierarchical tree structure
          Groups by depth for rendering
        </description>
      </function>
    </functions>

    <types>
      <type name="TraceNode">
        <properties>
          <property name="lp" type="LicensePlate">License plate data</property>
          <property name="product_code" type="string">Product code for display</property>
          <property name="product_name" type="string">Product name for display</property>
          <property name="relationship_type" type="string">split, combine, or transform</property>
          <property name="depth" type="number">Tree depth level</property>
          <property name="children" type="TraceNode[]">Child nodes</property>
        </properties>
      </type>

      <type name="TraceResult">
        <properties>
          <property name="root_lp" type="LicensePlate">Starting LP</property>
          <property name="trace_tree" type="TraceNode[]">Hierarchical tree</property>
          <property name="summary" type="object">Statistics (total descendants/ancestors, max depth)</property>
        </properties>
      </type>
    </types>

    <database-functions>
      <function name="trace_forward" type="RPC">
        <description>
          Recursive CTE query for forward trace (parent → children)
          Migration: 033_create_trace_functions.sql
        </description>
      </function>

      <function name="trace_backward" type="RPC">
        <description>
          Recursive CTE query for backward trace (child → parents)
          Migration: 033_create_trace_functions.sql
        </description>
      </function>
    </database-functions>
  </service-pattern>

  <!-- UI Components -->
  <ui-components>
    <component name="GenealogyTree">
      <file>apps/frontend/components/technical/GenealogyTree.tsx</file>
      <description>
        Visual genealogy tree using ReactFlow for interactive graph visualization
        Story 2.21 implementation
      </description>

      <features>
        <feature>Forward/backward trace visualization with directional arrows</feature>
        <feature>Search by LP number, product code, or batch number</feature>
        <feature>Highlight matching nodes, dim non-matches</feature>
        <feature>Navigate between search matches</feature>
        <feature>Pan/zoom controls with minimap</feature>
        <feature>Export as PNG for documentation</feature>
        <feature>Color-coded nodes by LP status (available, consumed, shipped, etc.)</feature>
        <feature>Interactive node clicks for drill-down</feature>
      </features>

      <props>
        <prop name="traceTree" type="TraceNode[]" required="true">Hierarchical trace data</prop>
        <prop name="direction" type="'forward' | 'backward'" required="true">Trace direction</prop>
        <prop name="onNodeClick" type="(nodeId: string) => void">Optional node click handler</prop>
      </props>

      <layout>
        <parameter name="HORIZONTAL_SPACING" value="300">Horizontal space between sibling nodes</parameter>
        <parameter name="VERTICAL_SPACING" value="150">Vertical space between parent-child levels</parameter>
        <parameter name="fitViewOptions.padding" value="0.2">Padding around tree when auto-fitting</parameter>
      </layout>
    </component>

    <component name="LPNode">
      <description>Custom ReactFlow node for displaying License Plate information</description>
      <displays>
        <field>LP number</field>
        <field>Product code and name</field>
        <field>Quantity and UOM</field>
        <field>Batch number</field>
        <field>Status (color-coded)</field>
        <field>Relationship type (transform, split, combine)</field>
      </displays>
    </component>
  </ui-components>

  <!-- API Patterns -->
  <api-patterns>
    <pattern name="Genealogy Creation on Output Registration">
      <endpoint>POST /api/production/work-orders/:id/outputs</endpoint>
      <description>
        Create output LP and complete genealogy records
        This endpoint integrates Story 4.12 and 4.19
      </description>

      <request-body>
        <field name="quantity" type="number" required="true">Output quantity</field>
        <field name="qa_status" type="string">QA status if required</field>
        <field name="location_id" type="UUID">Storage location</field>
        <field name="notes" type="string">Optional notes</field>
      </request-body>

      <processing-steps>
        <step>1. Validate WO is in_progress status</step>
        <step>2. Create output LP:
          - product_id from WO
          - batch_number from WO.wo_number
          - expiry_date from product.shelf_life
          - status = 'available'
          - quantity = request.quantity
        </step>
        <step>3. Determine consumed LPs (sequential allocation):
          - Get reserved LPs ordered by sequence_number
          - Track cumulative output qty
          - Allocate LPs in order until output qty met
          - Handle partial LP consumption
        </step>
        <step>4. Create/update lp_genealogy records:
          - For each consumed LP:
            * parent_lp_id = consumed LP
            * child_lp_id = output LP
            * wo_id = current WO
            * quantity_from_parent = consumed qty (can be partial)
            * relationship_type = 'transform'
            * created_at, created_by = audit fields
        </step>
        <step>5. Update work_orders.output_qty += request.quantity</step>
        <step>6. Update LP statuses (consumed LPs → 'consumed')</step>
        <step>7. Create production_outputs audit record</step>
      </processing-steps>

      <response>
        <field name="output_lp" type="LicensePlate">Created output LP</field>
        <field name="genealogy_records" type="LPGenealogy[]">Created genealogy records</field>
        <field name="consumed_lps" type="LicensePlate[]">LPs consumed for this output</field>
        <field name="wo_output_qty" type="number">Updated cumulative WO output</field>
      </response>

      <error-handling>
        <error code="400">WO not in_progress status</error>
        <error code="400">Insufficient reserved materials</error>
        <error code="400">Over-production without valid LP selection</error>
        <error code="500">Database transaction failure (rollback all changes)</error>
      </error-handling>
    </pattern>

    <pattern name="Genealogy Query">
      <endpoints>
        <endpoint>GET /api/technical/license-plates/:id/trace/forward</endpoint>
        <endpoint>GET /api/technical/license-plates/:id/trace/backward</endpoint>
      </endpoints>
      <description>Retrieve genealogy tree for visualization</description>

      <query-params>
        <param name="max_depth" type="number" default="20">Maximum trace depth</param>
      </query-params>

      <response>
        <field name="root_lp" type="LicensePlate">Starting LP</field>
        <field name="trace_tree" type="TraceNode[]">Hierarchical genealogy tree</field>
        <field name="summary" type="object">
          total_descendants/ancestors: number
          max_depth: number
        </field>
      </response>

      <uses-service>genealogy-service.ts (traceForward/traceBackward)</uses-service>
    </pattern>

    <pattern name="Material Reservation with Genealogy Init">
      <endpoint>POST /api/production/work-orders/:id/materials/reserve</endpoint>
      <description>
        Reserve material and create genealogy skeleton (Story 4.7)
        Not used in Story 4.19, but creates parent_lp_id for later completion
      </description>

      <genealogy-initialization>
        Create lp_genealogy with:
        - parent_lp_id = reserved LP
        - child_lp_id = NULL (filled during output registration)
        - wo_id = current WO
        - relationship_type = 'transform'
        - quantity_from_parent = 0 (updated during output)
      </genealogy-initialization>
    </pattern>
  </api-patterns>

  <!-- Testing Strategy -->
  <testing-strategy>
    <test-type name="Unit Tests">
      <description>Test genealogy service functions in isolation</description>
      <file>apps/frontend/lib/services/__tests__/genealogy-service.test.ts</file>

      <test-cases>
        <test>traceForward returns correct tree structure</test>
        <test>traceBackward returns correct tree structure</test>
        <test>buildTree transforms flat data to hierarchy</test>
        <test>maxDepth parameter limits traversal</test>
        <test>handles circular references (should not occur with constraints)</test>
      </test-cases>
    </test-type>

    <test-type name="E2E Tests">
      <description>Test genealogy creation through output registration flow</description>
      <file>tests/e2e/production-genealogy.spec.ts</file>

      <test-cases>
        <test>AC-4.19.1: Output registration creates genealogy records
          - Create WO with reserved materials
          - Register output
          - Verify lp_genealogy records created with correct parent/child links
          - Verify quantity_from_parent matches consumed qty
        </test>

        <test>AC-4.19.2: Partial LP consumption tracked correctly
          - Reserve LP with 30kg
          - Register output 1 (20kg) → verify genealogy qty = 20kg
          - Register output 2 (10kg) → verify genealogy qty = 10kg
          - Both genealogy records reference same parent LP
        </test>

        <test>AC-4.19.3: Multiple outputs create separate genealogy records
          - Reserve 3 LPs for WO
          - Register 3 outputs consuming different LP combinations
          - Verify each output LP has correct parent linkages
          - Verify parent LPs can appear in multiple genealogy records
        </test>

        <test>AC-4.19.4: Forward and backward tracing works
          - Create genealogy chain: LP-A → Output-1 → LP-B (via second WO)
          - Forward trace from LP-A → should find Output-1 and LP-B
          - Backward trace from LP-B → should find Output-1 and LP-A
        </test>

        <test>AC-4.19.5: FK constraints enforced
          - Attempt to create genealogy with invalid parent_lp_id → fail
          - Attempt to create genealogy with invalid child_lp_id → fail
          - Attempt to create genealogy with invalid wo_id → fail
        </test>

        <test>AC-4.19.6: Audit trail captured
          - Register output
          - Verify genealogy records have created_at and created_by
        </test>
      </test-cases>

      <fixtures>
        <fixture name="createTestOrganization">Returns orgId from .env.test</fixture>
        <fixture name="createTestUser">Creates auth user + JWT for orgId</fixture>
        <fixture name="createTestWarehouses">Creates 2 test warehouses</fixture>
        <fixture name="createTestProducts">Creates products with shelf_life</fixture>
        <fixture name="createTestLicensePlates">Creates LPs with quantities</fixture>
        <fixture name="createTestWorkOrder">Creates WO with materials list</fixture>
        <fixture name="cleanupTestData">Cleans genealogy, LPs, WOs after test</fixture>
      </fixtures>
    </test-type>

    <test-type name="Integration Tests">
      <description>Test genealogy integration with reservation and output flows</description>

      <test-scenarios>
        <scenario name="Full Production Flow with Genealogy">
          <steps>
            <step>1. Create WO with BOM (3 materials)</step>
            <step>2. Reserve materials (3 LPs in sequence)</step>
            <step>3. Register output 1 (partial) → verify genealogy created</step>
            <step>4. Register output 2 (partial) → verify genealogy updated</step>
            <step>5. Register output 3 (complete) → verify all genealogy complete</step>
            <step>6. Query forward trace → verify tree shows all outputs</step>
            <step>7. Query backward trace → verify tree shows all inputs</step>
          </steps>
        </scenario>

        <scenario name="consume_whole_lp with Genealogy">
          <steps>
            <step>1. Create material with consume_whole_lp = true</step>
            <step>2. Reserve LP (80kg) for this material</step>
            <step>3. Register output (70kg) → LP fully consumed</step>
            <step>4. Verify genealogy shows quantity_from_parent = 80kg (full LP)</step>
          </steps>
        </scenario>

        <scenario name="Over-production Genealogy">
          <steps>
            <step>1. Reserve materials for 100kg planned</step>
            <step>2. Register outputs totaling 120kg (over-production)</step>
            <step>3. Verify operator prompted to select LP for extra 20kg</step>
            <step>4. Verify genealogy records include operator-selected LP</step>
          </steps>
        </scenario>
      </test-scenarios>
    </test-type>

    <test-type name="RLS Policy Tests">
      <description>Verify genealogy RLS policies enforce org isolation</description>

      <test-cases>
        <test>User can view genealogy only for LPs in their org</test>
        <test>Technical/Admin/QC/Warehouse/Production roles can create genealogy</test>
        <test>Other roles cannot create genealogy</test>
        <test>No user can update or delete genealogy (immutable)</test>
      </test-cases>
    </test-type>
  </testing-strategy>

  <!-- FDA Compliance Notes -->
  <compliance>
    <standard name="FDA 21 CFR Part 117">
      <requirement id="117.210">Traceability lot code system</requirement>
      <implementation>
        - lp_genealogy.parent_lp_id links to input lot (batch_number)
        - lp_genealogy.child_lp_id links to output lot (batch_number)
        - quantity_from_parent tracks exact qty consumed per lot
        - work_order_id provides production context
      </implementation>
    </standard>

    <standard name="FDA 21 CFR Part 117">
      <requirement id="117.310">Records for ingredients and processes</requirement>
      <implementation>
        - Genealogy records are immutable (no UPDATE/DELETE policies)
        - created_at and created_by provide audit trail
        - relationship_type documents transformation type
        - Forward/backward tracing enables rapid recall response
      </implementation>
    </standard>

    <recall-readiness>
      <capability>Forward trace: Identify all finished goods from suspect raw material</capability>
      <capability>Backward trace: Identify all raw materials in suspect finished good</capability>
      <capability>Quantity tracking: Determine exact qty of suspect material in each output</capability>
      <capability>WO context: Link genealogy to production batch for investigation</capability>
    </recall-readiness>
  </compliance>

  <!-- Implementation Notes -->
  <implementation-notes>
    <note priority="high">
      Genealogy creation is transactional:
      - Must rollback all changes if any genealogy record fails
      - Use database transaction for output LP + genealogy + WO updates
    </note>

    <note priority="high">
      Sequential LP allocation algorithm:
      - Sort reserved LPs by sequence_number ASC
      - Track cumulative output qty across all previous outputs
      - Allocate LPs in order until output qty requirement met
      - Support partial LP consumption across multiple outputs
      - Handle edge case: over-production requires operator LP selection
    </note>

    <note priority="medium">
      Genealogy query performance:
      - Indexes on parent_lp_id and child_lp_id are critical for recursive CTEs
      - Composite index speeds up traversal with relationship_type filter
      - max_depth parameter prevents infinite loops (20 is reasonable default)
    </note>

    <note priority="medium">
      UI considerations for genealogy tree:
      - Large trees (>100 nodes) may need pagination or lazy loading
      - Export PNG functionality requires html-to-image library
      - ReactFlow fitView ensures entire tree visible on load
      - Search/highlight improves navigation in complex trees
    </note>

    <note priority="low">
      Future enhancements:
      - Genealogy visualization in mobile view (Story 4.13 integration)
      - Genealogy tree filtering by date range, status, product
      - Genealogy analytics: most-used LPs, average consumption rates
      - PDF export for regulatory submissions
    </note>
  </implementation-notes>
</story-context>
