# Story 5.7b: Genealogy Validation & Atomicity ⭐ CRITICAL

**ID:** 5.7b
**Batch:** 5A-2 (LP Operations) - SPLIT from 5.7 (Part 2)
**Story Points:** 3
**Effort:** 4-5 hours
**Status:** Todo
**Created:** 2025-11-28 (CRITICAL atomicity story)

---

## User Story

> As a **System**, I want to validate genealogy integrity and prevent circular dependencies, so that traceability remains clean and consistent.

---

## Goal

Implement **FK validation**, **circular dependency detection**, and **atomic transactions** for genealogy creation. This is **Gap 2 (Sprint 0)** critical.

---

## Acceptance Criteria

### AC 1: Foreign Key Validation (Atomic Transaction)

**Given** genealogy record being created
**When** inserting parent_lp_id, child_lp_id, wo_id
**Then** validate in single transaction:
- `parent_lp_id` exists in license_plates ✓
- `child_lp_id` exists in license_plates ✓
- Both LPs belong to same org_id ✓
- `wo_id` exists (if provided) ✓
- operation_type is valid enum ✓

If ANY validation fails → entire transaction ROLLBACK

### AC 2: Circular Dependency Detection

**Given** attempting to create genealogy link
**When** parent_lp_id → child_lp_id
**Then** check: "Is child_lp_id already ancestor of parent_lp_id?"
- Use recursive CTE to find all ancestors of parent
- If child found in ancestors → REJECT with error
- Error message: "Circular dependency detected: LP-XYZ is already descendant of LP-ABC"

### AC 3: Duplicate Link Detection (Idempotent)

**Given** genealogy link already exists
**When** attempting to create same link again
**Then** SILENT SUCCESS (idempotent operation)
- Check UNIQUE(parent_lp_id, child_lp_id) constraint
- If duplicate: return existing genealogy_id (don't error)

### AC 4: Transaction Atomicity Guarantee

**Transaction Flow (ALL-OR-NOTHING):**

```
1. START transaction
2. VALIDATE all FKs (parent, child, wo exist)
3. CHECK circular dependency (recursive CTE)
4. CHECK duplicate link exists
5. INSERT lp_genealogy record
6. VERIFY insert succeeded
7. COMMIT or ROLLBACK

If ANY step fails:
   - ROLLBACK entire transaction
   - Return specific error message
   - No partial records created
```

### AC 5: Specific Error Messages

| Failure Point | Error Message |
|---|---|
| Parent not exists | "Parent LP-001 does not exist" |
| Child not exists | "Child LP-005 does not exist" |
| Different orgs | "LPs belong to different organizations" |
| Invalid operation_type | "Invalid operation type. Use: split, merge, consume, produce" |
| Circular dependency | "Circular dependency: LP-ABC is descendant of LP-XYZ" |
| Duplicate link | Success (silently return existing ID) |
| Invalid WO | "Work Order #999 does not exist" |

---

## Technical Tasks

### Backend

- [ ] Implement genealogy validation function (transactional):
  ```
  validateAndCreateGenealogy(
    parent_lp_id, child_lp_id, operation_type, wo_id, user_id, org_id
  )
  ```
  - Wrapped in database transaction
  - All validations before INSERT
  - Specific error messages

- [ ] Implement circular dependency detection:
  - Recursive CTE: `SELECT ancestors_of_X WHERE X = parent_lp_id`
  - Check if child_lp_id in result set
  - Return boolean: has_circular_dependency

- [ ] Implement POST /api/warehouse/license-plates/genealogy endpoint:
  - Validate all inputs
  - Call validateAndCreateGenealogy
  - Return created genealogy record
  - Handle and return specific error messages

### Database

- [ ] Create circular dependency detection CTE:
  ```sql
  WITH RECURSIVE ancestors_of_parent AS (
    SELECT parent_lp_id, 1 AS depth
    FROM lp_genealogy WHERE child_lp_id = $1 AND org_id = $2

    UNION ALL

    SELECT g.parent_lp_id, a.depth + 1
    FROM lp_genealogy g
    JOIN ancestors_of_parent a ON g.child_lp_id = a.parent_lp_id
    WHERE a.depth < 10 AND g.org_id = $2
  )
  SELECT COUNT(*) FROM ancestors_of_parent
  WHERE parent_lp_id = $3; -- If > 0, circular dependency
  ```

- [ ] Verify UNIQUE(parent_lp_id, child_lp_id, org_id) constraint exists

- [ ] Add FK constraints:
  - parent_lp_id → license_plates(id)
  - child_lp_id → license_plates(id)
  - wo_id → work_orders(id) (if provided)

### Frontend

- [ ] Error handling for genealogy creation:
  - Show specific error message
  - Allow retry
  - Suggest next steps

- [ ] Display validation errors to user:
  - FK failures: "LP not found"
  - Circular dependency: "Cannot create this link"
  - Duplicate: silent success (user sees "Link already exists")

---

## Testing

### Unit Tests
- Circular dependency detection (all depths)
  - A → B → A (detect)
  - A → B → C → A (detect)
  - A → B → C (no cycle)
- FK validation: parent exists, child exists, wo_id exists
- Duplicate detection (UNIQUE constraint)

### Integration Tests
- Successful genealogy creation (happy path)
- FK violation → rollback
- Circular dependency → rollback
- Duplicate → silently succeed
- Deep genealogy (5+ levels) → no false positives

### E2E Tests
- Create valid genealogy → verify in trace
- Try circular → see error
- Retry same genealogy → see success

---

## Acceptance Criteria Checklist

- ✅ FK validation prevents invalid links
- ✅ Circular dependency detection prevents cycles
- ✅ Duplicate detection (idempotent)
- ✅ Transaction atomicity enforced
- ✅ Specific error messages displayed
- ✅ No partial records created on failure

---

## Dependencies

**Requires:** Story 5.7a (Genealogy Recording)

**Enables:** Story 5.7c (Advanced features), Story 5.28 (Traceability)

**Blocks:** Cannot proceed to 5.7c until 5.7b fully tested

---

## Important Notes

- ⭐ **CRITICAL Story**: Gap 2 (Sprint 0) addresses atomicity
- Must have comprehensive transaction handling
- Circular dependency detection is complex (recursive CTE)
- Must test with deep genealogies (10+ levels)
- Idempotency prevents duplicate genealogy errors
- All-or-nothing guarantee maintains data consistency

