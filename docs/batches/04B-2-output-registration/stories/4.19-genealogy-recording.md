# Story 4.19: Genealogy Recording - Technical Foundation

**Epic:** 4 - Production Execution | **Type:** Technical Foundation Story | **Status:** To Be Designed | **Story Points:** 3 | **Effort:** 3-4 hours

---

## Purpose

This Technical Foundation Story defines **how genealogy records are created, updated, and marked for reversal** across all production operations. Instead of embedding genealogy logic in each story (4.7, 4.10, 4.12, 4.12a, 4.12b), this defines a reusable genealogy service that all operations use.

**Used by:**
- Story 4.7: Material Consumption & Reservation
- Story 4.10: Consumption Correction (reversal)
- Story 4.12: Output Registration
- Story 4.12a: Output-Driven Sequential Consumption
- Story 4.12b: Over-Production Handling
- Story 4.16: Multiple Outputs per WO

---

## User Story

> As a **System**, I want to maintain complete genealogy records of LP relationships through production, so that full traceability is preserved even when operations are reversed.

---

## Acceptance Criteria

### AC 4.19.1: Genealogy Record Structure

**Then** lp_genealogy table stores complete relationship between parent and child LPs:

```sql
CREATE TABLE lp_genealogy (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id),

  -- Parent-Child Relationship
  parent_lp_id UUID NOT NULL REFERENCES license_plates(id),
  child_lp_id UUID REFERENCES license_plates(id),  -- Can be NULL initially

  -- Operation Type
  operation_type VARCHAR(50) NOT NULL CHECK (operation_type IN (
    'consume',        -- Material consumed in WO
    'split',          -- LP split into multiple LPs
    'merge',          -- Multiple LPs merged
    'produce',        -- Output LP produced from WO
    'adjustment'      -- Inventory adjustment
  )),

  -- Consumption Tracking
  consumed_qty DECIMAL(15,4),               -- Qty consumed from parent
  produced_at TIMESTAMPTZ,                  -- When child LP created

  -- Work Order & Material Reference
  wo_id UUID REFERENCES work_orders(id),    -- Which WO this genealogy belongs to
  material_id UUID REFERENCES wo_materials(id), -- Which material in WO

  -- Over-Production Tracking
  is_over_production BOOLEAN DEFAULT false,
  over_production_source VARCHAR(50),       -- 'operator_selected', 'scrap_loss', etc.

  -- Reversal Tracking (Compliance)
  status VARCHAR(50) DEFAULT 'active' CHECK (status IN (
    'active',         -- Normal genealogy link
    'reversed',       -- Consumption was reversed
    'void'            -- Deleted (rare, compliance tracking)
  )),
  reversed_at TIMESTAMPTZ,
  reversed_by UUID REFERENCES users(id),
  reverse_reason TEXT,

  -- Audit
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by_user_id UUID NOT NULL REFERENCES users(id),
  updated_at TIMESTAMPTZ DEFAULT now(),
  updated_by_user_id UUID REFERENCES users(id)
);

-- Indexes for fast lookups
CREATE INDEX idx_lp_genealogy_parent_lp_id ON lp_genealogy(parent_lp_id);
CREATE INDEX idx_lp_genealogy_child_lp_id ON lp_genealogy(child_lp_id);
CREATE INDEX idx_lp_genealogy_wo_id ON lp_genealogy(wo_id);
CREATE INDEX idx_lp_genealogy_status ON lp_genealogy(status);
```

### AC 4.19.2: Genealogy Creation - Consumption (Story 4.7, 4.12a)

**Given** material consumed in WO (via Story 4.12a sequential allocation)

**When** wo_consumption record created

**Then** genealogy record created:

```
Operation: 4.12a creates wo_consumption → 4.19 creates genealogy

Example:
- Output-1 (70kg) registered
- Sequential allocation consumes LP-A (80kg) fully
- Create wo_consumption: wo_id, material_id, lp_id=LP-A, qty=70

Genealogy created:
├─ parent_lp_id: LP-A
├─ child_lp_id: NULL (output LP doesn't exist yet, filled in step 3)
├─ operation_type: 'consume'
├─ consumed_qty: 70
├─ wo_id: WO-1
├─ material_id: MAT-1
├─ status: 'active'
└─ created_by_user_id: operator
```

### AC 4.19.3: Genealogy Update - Output Registration (Story 4.12)

**Given** genealogy record exists with child_lp_id = NULL

**When** output LP is created (Story 4.12)

**Then** genealogy updated with output LP:

```
Step 1: Genealogy created (AC 4.19.2) - pending output LP
Step 2: Output LP created
Step 3: Update genealogy with output LP

UPDATE lp_genealogy SET
  child_lp_id = 'LP-OUTPUT-1',  -- New output LP
  produced_at = now(),
  status = 'active'
WHERE wo_id = 'WO-1' AND parent_lp_id = 'LP-A' AND child_lp_id IS NULL;

Result:
├─ parent_lp_id: LP-A
├─ child_lp_id: LP-OUTPUT-1
├─ operation_type: 'consume'
├─ consumed_qty: 70
└─ status: 'active'
```

### AC 4.19.4: Genealogy for Over-Production (Story 4.12b)

**Given** over-production output registered

**When** operator selects parent LP for over-production

**Then** genealogy created with over-production flags:

```
Genealogy record:
├─ parent_lp_id: LP-A (operator selected)
├─ child_lp_id: LP-OUTPUT-4 (over-production LP)
├─ operation_type: 'consume'
├─ consumed_qty: 30 (over-production qty)
├─ is_over_production: true
├─ over_production_source: 'operator_selected'
└─ status: 'active'

Traceability: Over-production LP linked back to material source LP
```

### AC 4.19.5: Genealogy Reversal (Story 4.10)

**Given** consumption is reversed (manager reverses in Story 4.10)

**When** reversal confirmed

**Then** genealogy marked as reversed (NEVER DELETED):

```
Reversal Scenario:
1. Original genealogy: LP-A → Output-1 (active)
2. Manager reverses consumption of Output-1
3. Genealogy status updated:

UPDATE lp_genealogy SET
  status = 'reversed',
  reversed_at = now(),
  reversed_by = manager_user_id,
  reverse_reason = 'Operator error - incorrect consumption recorded'
WHERE parent_lp_id = 'LP-A' AND child_lp_id = 'LP-OUTPUT-1';

Result:
├─ parent_lp_id: LP-A
├─ child_lp_id: LP-OUTPUT-1
├─ operation_type: 'consume'
├─ status: 'reversed'  ← Changed to 'reversed'
├─ reversed_at: timestamp
├─ reversed_by: manager_user_id
└─ reverse_reason: "Operator error..."

Key: Genealogy record STAYS (compliance), only status changed
```

### AC 4.19.6: Genealogy Query API

**Then** genealogy service provides API for tracing:

```typescript
interface GenealogyService {
  /**
   * Get all genealogy records for an LP (both parent and child)
   */
  getForwardTrace(lp_id: UUID): Promise<GenealogyRecord[]>;
  // Returns: all child LPs (descendants)
  // Filters: status='active' (or includes 'reversed' if requested)

  /**
   * Get all genealogy records that led to an LP
   */
  getBackwardTrace(lp_id: UUID): Promise<GenealogyRecord[]>;
  // Returns: all parent LPs (ancestors)

  /**
   * Create genealogy record for consumption
   */
  recordConsumption(
    parent_lp_id: UUID,
    wo_id: UUID,
    material_id: UUID,
    consumed_qty: number,
    user_id: UUID
  ): Promise<GenealogyRecord>;

  /**
   * Update genealogy with child LP (after output created)
   */
  updateWithOutput(
    genealogy_id: UUID,
    child_lp_id: UUID,
    produced_at: Date
  ): Promise<void>;

  /**
   * Mark genealogy as reversed (consumption reversal)
   */
  markAsReversed(
    genealogy_id: UUID,
    reversed_by: UUID,
    reverse_reason: string
  ): Promise<void>;

  /**
   * Create genealogy for over-production
   */
  recordOverProduction(
    parent_lp_id: UUID,
    child_lp_id: UUID,
    qty: number,
    user_id: UUID
  ): Promise<GenealogyRecord>;
}
```

### AC 4.19.7: Genealogy Display - Forward & Backward Tracing

**Given** genealogy records exist

**When** user views LP detail and clicks "Trace Forward/Backward"

**Then** display genealogy tree:

```
Forward Trace Example (LP-A → children):
LP-A (parent)
  ├─ Output-1 [active] (consumed 70kg)
  └─ Output-4 [active] (over-production 30kg)

Backward Trace Example (LP-OUTPUT-1 → parents):
LP-OUTPUT-1 (child)
  ├─ LP-A [active] (consumed 70kg)
  └─ LP-B [active] (consumed 20kg)

Reversed Genealogy Example:
LP-A
  ├─ Output-1 [REVERSED] ✗ (consumption was reversed)
  └─ Output-4 [active] ✓

Display shows:
- Status badge: [active] ✓ or [REVERSED] ✗
- Operation type icon (consume, split, merge, produce)
- Qty consumed
- WO reference
- If reversed: who/when/why
```

### AC 4.19.8: Genealogy Compliance Requirements

**Then** genealogy records NEVER deleted (compliance):

```
Compliance Rules:
1. Genealogy records are IMMUTABLE audit trail
2. Reversal marks genealogy as 'reversed', not deleted
3. Full history preserved: active → reversed → potentially reactivated
4. Audit fields track:
   - creation: created_by, created_at
   - reversal: reversed_by, reversed_at, reverse_reason
   - updates: updated_by, updated_at

FDA/Compliance: Full genealogy history required for recalls
Example: If product recalled, genealogy shows all LPs involved, even reversed ones
```

### AC 4.19.9: Genealogy for Split/Merge (Future Stories)

**Note**: This story focuses on consumption genealogy. Future stories (4.5 - LP Split, 4.6 - LP Merge) will use this genealogy service:

```
Story 4.5 (LP Split):
- Parent LP (80kg) split into LP-A (50kg) + LP-B (30kg)
- Genealogy: 80kg LP → LP-A (50kg), LP-B (30kg)
- operation_type: 'split'

Story 4.6 (LP Merge):
- LP-A (50kg) + LP-B (30kg) merged into LP-C (80kg)
- Genealogy: LP-A → LP-C, LP-B → LP-C
- operation_type: 'merge'

Both use same GenealogyService.recordConsumption() pattern
```

---

## Technical Implementation

### Genealogy Service Pattern

All operations use same pattern:

```typescript
// 1. CREATION - Consumption starts
async recordConsumption(parent_lp_id, wo_id, material_id, qty, user_id) {
  const genealogy = await db.insert('lp_genealogy', {
    parent_lp_id,
    wo_id,
    material_id,
    consumed_qty: qty,
    operation_type: 'consume',
    status: 'active',
    created_by_user_id: user_id
  });
  return genealogy;
}

// 2. UPDATE - Output created, complete the link
async updateWithOutput(genealogy_id, child_lp_id, produced_at) {
  await db.update('lp_genealogy', genealogy_id, {
    child_lp_id,
    produced_at,
    updated_at: now(),
    updated_by_user_id: current_user_id
  });
}

// 3. REVERSAL - Mark as reversed (never delete)
async markAsReversed(genealogy_id, reversed_by, reverse_reason) {
  await db.update('lp_genealogy', genealogy_id, {
    status: 'reversed',
    reversed_at: now(),
    reversed_by,
    reverse_reason
  });
}
```

### Transaction Safety

Genealogy creation/update MUST be atomic with consumption:

```sql
BEGIN TRANSACTION;

-- 1. Create wo_consumption record
INSERT INTO wo_consumption (wo_id, material_id, lp_id, qty, output_id, consumed_by_user_id)
VALUES (...);

-- 2. Create genealogy record
INSERT INTO lp_genealogy (parent_lp_id, wo_id, material_id, consumed_qty, operation_type, status, created_by_user_id)
VALUES (...);

-- 3. Update LP current_qty
UPDATE license_plates SET current_qty = current_qty - $qty WHERE id = $lp_id;

COMMIT; -- All succeed or all rollback
```

---

## Testing Strategy

### Unit Tests

- Create genealogy: correct fields populated
- Update with output: child_lp_id and produced_at set
- Mark as reversed: status changes, audit fields populated
- Query forward/backward traces: correct LPs returned

### Integration Tests

- Full consumption flow: genealogy created, updated, reversed
- Multiple outputs: genealogy for each consumption
- Over-production: genealogy with is_over_production flag
- Compliance: reversed genealogy not deleted

### E2E Tests

1. Register Output-1 (70kg) → genealogy created (parent_lp_id=LP-A, child_lp_id=NULL)
2. Output LP created → genealogy updated (child_lp_id=LP-OUTPUT-1)
3. Manager reverses consumption → genealogy marked as reversed
4. View trace: LP-A shows Output-1 as [REVERSED]

---

## Acceptance Criteria Checklist

- ✅ Genealogy record structure defined (table schema)
- ✅ Genealogy creation on consumption (Story 4.7, 4.12a)
- ✅ Genealogy update on output creation (Story 4.12)
- ✅ Genealogy for over-production (Story 4.12b)
- ✅ Genealogy reversal (Story 4.10) - mark as reversed, never delete
- ✅ Genealogy query API (forward/backward traces)
- ✅ Genealogy display with status badges (active/reversed)
- ✅ Compliance: full audit trail preserved
- ✅ Transaction atomicity for genealogy + consumption

---

## Dependencies

**Used by:**
- Story 4.7: Material Consumption & Reservation
- Story 4.10: Consumption Correction (reversal)
- Story 4.12: Output Registration
- Story 4.12a: Output-Driven Sequential Consumption
- Story 4.12b: Over-Production Handling
- Story 4.16: Multiple Outputs per WO
- Future: Story 4.5 (LP Split), Story 4.6 (LP Merge)

**Requires:**
- Story 4.7: Consumption endpoint exists

---

## Notes

- Genealogy is **immutable audit trail** - compliance requirement (FDA, recalls)
- Reversal **marks as reversed** (Approach A) - preserves full history
- Genealogy can have NULL child_lp_id temporarily (pending output creation)
- Queries filter by status (active vs reversed) based on traceability needs
- Over-production genealogy tracks alternative material source
- Same GenealogyService used for consumption, split, merge, adjust operations
