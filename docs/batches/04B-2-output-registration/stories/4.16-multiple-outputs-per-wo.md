# Story 4.16: Multiple Outputs per WO

**Epic:** 4 - Production Execution | **Status:** To Be Designed | **Priority:** P0 | **Story Points:** 1 | **Effort:** 0.5 day

## User Story

**As an** Operator
**I want** to register multiple outputs (partial production) against same WO
**So that** I can track production progress without completing the entire WO at once

---

## Purpose

Story 4.16 describes how multiple output registrations work when an operator produces output incrementally (partial outputs) instead of all at once. The heavy lifting is delegated to Stories 4.12a (sequential LP allocation), 4.12b (over-production), and 4.19 (genealogy). Story 4.16 is about UI/UX flow and output tracking accumulation.

---

## Acceptance Criteria

### AC-4.16.1: Multiple Output Support (Partial Production)

**Given** WO is in_progress status

**When** operator registers first output

**Then** WO remains in_progress (not auto-completed)

**When** operator registers second output

**Then** each output registration creates separate LP and separate genealogy

```
WO-001 in_progress
├─ Output-1 (70 kg) → Output-LP-1
├─ Output-2 (20 kg) → Output-LP-2
├─ Output-3 (80 kg) → Output-LP-3
└─ (WO still open for more outputs)
```

**Key**: WO does NOT auto-complete when outputs are registered - operator must manually click "Complete WO" button

### AC-4.16.2: Output History & Tracking

**Given** multiple outputs registered

**When** viewing WO detail

**Then** display:

```
WO Summary:
├─ Planned: 200 kg
├─ Total Output Registered: 170 kg (sum of all outputs)
├─ Remaining to Produce: 30 kg
├─ Progress: 85% (170/200)
├─ Status: In Progress
└─ [Register Output] [Complete WO] buttons

Output History:
┌─────────────────────────────────────────┐
│ Output │ Qty  │ Operator │ Time         │
├─────────────────────────────────────────┤
│ 1      │ 70kg │ John     │ 14:30:15    │
│ 2      │ 20kg │ John     │ 14:35:42    │
│ 3      │ 80kg │ Mary     │ 14:45:08    │
└─────────────────────────────────────────┘

Total: 170 kg
```

**Database**: work_orders.output_qty = SUM(all production_outputs.qty for this WO)

### AC-4.16.3: Output Tracking via production_outputs Table

**Then** each output registered creates production_outputs record:

```sql
production_outputs table:
├─ id (UUID, PK)
├─ wo_id (FK to work_orders) - links output to WO
├─ product_id (FK to products)
├─ qty (decimal) - actual registered qty
├─ qa_status (pass/fail/pending)
├─ location_id (FK to locations)
├─ output_lp_id (FK to license_plates) - the output LP created
├─ is_over_production (boolean) - flag for Story 4.12b
├─ over_production_parent_lp_id (UUID, FK) - Story 4.12b
├─ created_at (timestamp)
├─ created_by_user_id (FK to users)
└─ notes (text, optional)
```

**Key**: wo_consumption records link to production_outputs via output_id (FK) - tracks which LP consumed in which output

### AC-4.16.4: Sequential LP Allocation Across Multiple Outputs (4.12a)

**Given** WO with reserved LPs and multiple outputs being registered

**When** each output registered sequentially

**Then** use sequential LP consumption algorithm from **Story 4.12a**:

```
WO Reserved Materials:
├─ LP-A: 50 kg
├─ LP-B: 40 kg
├─ LP-C: 80 kg
└─ Total: 170 kg

Sequential Allocation:
┌─────────────────────────────────────────────┐
│ Output-1 (70 kg)                           │
│ Allocation:                                 │
│ ├─ LP-A: 50 kg (fully consumed)           │
│ ├─ LP-B: 20 kg (partial, 20kg remaining) │
│ └─ Total from LPs: 70 kg                  │
│                                            │
│ wo_consumption records:                    │
│ ├─ {wo_id, material_id, lp_id: LP-A, qty: 50, output_id: OUT-1}
│ └─ {wo_id, material_id, lp_id: LP-B, qty: 20, output_id: OUT-1}
└─────────────────────────────────────────────┘

Cumulative after Output-1: 70 kg consumed

┌─────────────────────────────────────────────┐
│ Output-2 (30 kg)                           │
│ System remembers: LP-B has 20kg remaining │
│ Allocation:                                 │
│ ├─ LP-B: 20 kg (finish remaining)         │
│ ├─ LP-C: 10 kg (partial, 70kg remaining) │
│ └─ Total from LPs: 30 kg                  │
│                                            │
│ wo_consumption records:                    │
│ ├─ {wo_id, material_id, lp_id: LP-B, qty: 20, output_id: OUT-2}
│ └─ {wo_id, material_id, lp_id: LP-C, qty: 10, output_id: OUT-2}
└─────────────────────────────────────────────┘

Cumulative after Output-2: 100 kg consumed

┌─────────────────────────────────────────────┐
│ Output-3 (70 kg)                           │
│ System remembers: LP-C has 70kg remaining │
│ Allocation:                                 │
│ ├─ LP-C: 70 kg (fully consume remaining)  │
│ └─ Total from LPs: 70 kg                  │
│                                            │
│ wo_consumption record:                     │
│ └─ {wo_id, material_id, lp_id: LP-C, qty: 70, output_id: OUT-3}
└─────────────────────────────────────────────┘

Total consumed: 170 kg (all reserved)
```

**Key**: Story 4.12a handles the complex LP allocation logic - Story 4.16 just triggers it for each output

**See Story 4.12a** for complete algorithm details

### AC-4.16.5: Genealogy Per Output

**Given** each output registered

**When** genealogy records created

**Then** each output has separate genealogy records linking to its consumed parent LPs:

```
Output-1 genealogy:
├─ LP-A (50kg) → Output-LP-1
└─ LP-B (20kg) → Output-LP-1

Output-2 genealogy:
├─ LP-B (20kg) → Output-LP-2
└─ LP-C (10kg) → Output-LP-2

Output-3 genealogy:
└─ LP-C (70kg) → Output-LP-3

Result: Full traceability per output
- Output-LP-1 traces back to LP-A and LP-B
- Output-LP-2 traces back to LP-B (partial) and LP-C (partial)
- Output-LP-3 traces back to LP-C
```

**See Story 4.19** for genealogy service details

### AC-4.16.6: Over-Consumption Across Multiple Outputs

**Given** multiple outputs and total consumption exceeds reserved LPs

**When** over-consumption detected (via Story 4.12a/4.12b)

**Then** handle same as single output:
- Show over-consumption warning with operator confirmation
- OR show over-production dialog if all reserved exhausted

```
Example:
Output-1: 70 kg (consumes LP-A fully)
Output-2: 30 kg (consumes LP-B fully)
Output-3: 80 kg (consumes LP-C fully)
Total reserved consumed: 180 kg

Output-4: 40 kg
├─ Reserved: all 180 kg consumed
├─ Remaining: 40 kg is over-production
├─ System shows: "Over-production detected. Which LP source?"
├─ Operator selects: LP-A
└─ Output-4 created with is_over_production=true

See Story 4.12b for complete over-production flow
```

### AC-4.16.7: Manual WO Completion (NOT Auto-Complete)

**Given** operator has registered outputs and output_qty >= planned_qty

**When** viewing WO detail

**Then** system DOES NOT auto-complete:

```
Display:
├─ Output registered: 200 kg
├─ Planned: 200 kg
├─ Status: Still "In Progress" (not auto-completed)
└─ [Complete WO] button available

Operator must manually click [Complete WO] to finish:
├─ Confirmation: "Complete WO-001 with 200 kg output?"
├─ Yes → WO status = 'completed'
└─ No → Continue registering more outputs
```

**Key**: No auto-complete. Operator has full control. If over-produced (230 kg when 200 kg planned), WO shows alert but still in_progress until operator confirms completion.

### AC-4.16.8: By-Product Registration Per Output

**Given** WO has by-products

**When** each main output registered

**Then** trigger by-product prompt (Story 4.14) after each output:

```
Flow:
1. Operator registers Output-1 (70kg)
2. By-product dialog shown: "Scrap (expected 7kg)"
3. Operator enters/skips
4. Return to WO detail (can register next output)
5. Operator registers Output-2 (30kg)
6. By-product dialog shown again (if by-products not yet registered)
   OR
   Skip if already registered once per WO

Question for design: Do by-products register:
- Once per WO (after first main output) → covers all main outputs
- OR Per each output (after each main output) → allow different by-product qty per output

Recommendation: Once per WO (after main output is registered once)
```

**See Story 4.14** for by-product details

### AC-4.16.9: Output QA Status & Location Tracking

**Given** multiple outputs registered

**When** viewing output history

**Then** show per-output tracking:

```
Output Details:
├─ Output #1: 70kg, QA=PASS, Loc=Shelf-A, John 14:30
├─ Output #2: 30kg, QA=FAIL, Loc=Hold, John 14:35
├─ Output #3: 80kg, QA=PASS, Loc=Shelf-B, Mary 14:45
└─ Output #4: 20kg, QA=PENDING, Loc=Quarantine, Mary 15:00

Each output stored with:
- qa_status per output (PASS/FAIL/PENDING)
- location_id per output (different outputs can go to different locations)
- created_by_user_id per output (track which operator)
- notes per output (optional)
```

### AC-4.16.10: Prerequisites & Dependencies

**Requires:**
- Story 4.12: Output Registration (uses same API endpoint)
- Story 4.12a: Sequential LP Consumption (handles LP allocation across outputs)
- Story 4.12b: Over-Production Handling (handles over-consumption across outputs)
- Story 4.14: By-Product Registration (triggered after each output)
- Story 4.19: Genealogy Recording (genealogy per output)

---

## Technical Implementation

### Output Accumulation Pattern

```typescript
// When registering new output
async registerOutput(wo_id, qty, qa_status, user_id) {
  const wo = await getWO(wo_id);

  // 1. Calculate consumption via 4.12a algorithm
  const allocation = await sequential_consumption_service
    .calculateAllocation(wo_id, qty);

  // 2. Create output LP
  const output_lp = await create_output_lp(wo.product_id, qty);

  // 3. Record in production_outputs
  const output = await db.insert('production_outputs', {
    wo_id,
    product_id: wo.product_id,
    qty,
    qa_status,
    output_lp_id: output_lp.id,
    created_by_user_id: user_id
  });

  // 4. Execute consumption (creates wo_consumption records)
  await sequential_consumption_service.executeConsumption(
    wo_id, output.id, allocation, user_id
  );

  // 5. Create genealogy records
  await genealogy_service.recordConsumption(/*...*/);

  // 6. Update WO cumulative qty
  const total_qty = await db.query(
    'SELECT SUM(qty) FROM production_outputs WHERE wo_id = ?',
    [wo_id]
  );
  await db.update('work_orders', wo_id, {
    output_qty: total_qty
  });

  // 7. Return success
  return { output_lp, output, total_registered_qty: total_qty };
}
```

### Database Views (Optional but useful)

```sql
-- View for cumulative output tracking
CREATE VIEW wo_output_summary AS
SELECT
  wo_id,
  SUM(qty) as total_output_qty,
  COUNT(*) as output_count,
  MIN(created_at) as first_output_at,
  MAX(created_at) as last_output_at
FROM production_outputs
GROUP BY wo_id;

-- Track LP consumption across outputs
CREATE VIEW wo_lp_consumption_summary AS
SELECT
  wo_id,
  lp_id,
  SUM(qty) as total_consumed,
  COUNT(DISTINCT output_id) as outputs_using_lp
FROM wo_consumption
GROUP BY wo_id, lp_id;
```

---

## Testing Strategy

### Unit Tests

- Sequential allocation calculation across multiple outputs
- Cumulative qty tracking (sum of all outputs)
- Per-output genealogy creation

### Integration Tests

- Register Output-1 (70kg): LP-A consumed, Output-LP-1 created, genealogy linked
- Register Output-2 (30kg): LP-B consumed, Output-LP-2 created, genealogy linked
- Verify WO.output_qty = 100 kg (sum of outputs)
- Verify partial LP consumption: LP-B has 10kg remaining after Output-2
- Register Output-3 (10kg): consumes remaining LP-B, Output-LP-3 created
- Verify total consumed matches WO expectation

### E2E Tests

**Full Multiple Output Scenario**
1. Create WO: 200 kg planned, Reserved: LP-A(50) + LP-B(40) + LP-C(80) = 170kg
2. Operator registers Output-1 (70kg)
   - Sequential allocation: LP-A(50) + LP-B(20)
   - Output-LP-1 created
   - Genealogy: LP-A → Output-LP-1, LP-B (partial) → Output-LP-1
   - WO.output_qty = 70
3. Operator registers Output-2 (30kg)
   - Sequential allocation: LP-B(20 remaining) + LP-C(10)
   - Output-LP-2 created
   - Genealogy: LP-B (partial) → Output-LP-2, LP-C (partial) → Output-LP-2
   - WO.output_qty = 100
4. Operator registers Output-3 (70kg)
   - Sequential allocation: LP-C(70 remaining)
   - Output-LP-3 created
   - Genealogy: LP-C (partial) → Output-LP-3
   - WO.output_qty = 170
5. WO shows: "All reserved consumed (170/170). 30kg remaining to complete 200kg target"
6. Operator tries Output-4 (30kg)
   - All reserved exhausted → Over-production dialog
   - Operator selects LP-A as source
   - Output-LP-4 created with is_over_production=true
7. Operator views output history: All 4 outputs with qty, operator, timestamp
8. Operator clicks [Complete WO]
   - Status → completed
   - All genealogy records preserved

---

## Acceptance Criteria Checklist

- ✅ Multiple outputs can be registered against single WO
- ✅ Each output creates separate output LP (not cumulative)
- ✅ Output history shows all outputs with qty, operator, timestamp, QA status
- ✅ Sequential LP consumption across outputs (from 4.12a)
- ✅ WO.output_qty = sum of all outputs
- ✅ Genealogy per output (linked to specific output LP)
- ✅ Over-consumption handled across multiple outputs
- ✅ Manual WO completion (NOT auto-complete)
- ✅ By-product prompting after each output (from 4.14)
- ✅ production_outputs table tracks all outputs

---

## Dependencies

**Requires:**
- Story 4.12: Output Registration (same API endpoint)
- Story 4.12a: Sequential LP Consumption (LP allocation algorithm)
- Story 4.12b: Over-Production Handling (over-consumption logic)
- Story 4.14: By-Product Registration (by-product prompting)
- Story 4.19: Genealogy Recording (genealogy service)

**Used by:**
- Story 4.15: Yield Tracking (uses output_qty tracking)

---

## Notes

- **Sequential Not Simultaneous**: Outputs registered one at a time sequentially - system remembers LP state between outputs
- **Cumulative Consumption**: wo_consumption table with output_id FK tracks which LP used in which output
- **Manual Completion**: Operator must click "Complete WO" button - no auto-complete even if planned qty reached
- **Over-Production Allowed**: WO can be completed with more output than planned (handled via over-production dialog)
- **By-Products Per Output**: By-product registration can happen after each output registration or once per WO (design decision needed)

---

## Status

- **Created:** 2025-11-27
- **Current Status:** Refactored (Added 4.12a/4.12b dependencies; clarified manual completion; added output tracking details)
