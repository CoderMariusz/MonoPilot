# Story 4.12a: Output-Driven Sequential Consumption - Technical Foundation

**Epic:** 4 - Production Execution | **Type:** Technical Foundation Story | **Status:** To Be Designed | **Story Points:** 3 | **Effort:** 3-4 hours

---

## Purpose

This Technical Foundation Story defines the **sequential LP allocation algorithm** used by output registration (Story 4.12, 4.13) and by-product registration (Story 4.14). Instead of embedding this complex logic in each story, this defines a reusable consumption algorithm that all output operations use.

**Used by:**
- Story 4.12: Output Registration (Desktop)
- Story 4.13: Output Registration (Scanner)
- Story 4.14: By-Product Registration
- Story 4.16: Multiple Outputs per WO (uses this for partial LP tracking across outputs)

---

## User Story

> As a **System**, I want to automatically allocate reserved LPs to outputs sequentially, so that consumption is deterministic and traceable across multiple outputs.

---

## Acceptance Criteria

### AC 4.12a.1: Sequential Consumption Algorithm Definition

**Given** WO with reserved LPs and output registration

**When** output qty is registered

**Then** system automatically consumes reserved LPs in sequence:

```
Reserved LPs (in reservation order):
  - LP-A: 80 kg
  - LP-B: 40 kg
  - LP-C: 80 kg
  - Total: 200 kg reserved

Output-1 (70 kg):
  ├─ Consume LP-A fully: 70 kg from 80 kg
  ├─ LP-A: consumed=70 kg, remaining=10 kg (status: reserved)
  └─ Cumulative consumed: 70 kg

Output-2 (20 kg):
  ├─ Consume LP-B fully: 20 kg from 40 kg
  ├─ LP-B: consumed=20 kg, remaining=20 kg (status: reserved)
  └─ Cumulative consumed: 90 kg

Output-3 (80 kg):
  ├─ Consume LP-C fully: 80 kg from 80 kg
  ├─ LP-C: consumed=80 kg, remaining=0 kg (status: available)
  └─ Cumulative consumed: 170 kg

Output-4 (30 kg) - Over-Production:
  ├─ All reserved LPs exhausted (170 kg consumed of 200 kg reserved)
  ├─ Remaining 30 kg is over-production
  └─ System shows warning: "Over-production detected. All reserved LPs consumed."
```

### AC 4.12a.2: Consumption Tracking in wo_consumption Table

**Then** each consumption recorded in wo_consumption:

```
wo_consumption records:
┌─────────────────────────────────────────────────┐
│ wo_id | material_id | lp_id  | qty | output_id │
├───────────────────────────────────────────────────┤
│ WO-1  │ MAT-1      │ LP-A   │ 70  │ OUT-1     │
│ WO-1  │ MAT-1      │ LP-B   │ 20  │ OUT-2     │
│ WO-1  │ MAT-1      │ LP-C   │ 80  │ OUT-3     │
└─────────────────────────────────────────────────┘

Key points:
- output_id: Links consumption to specific output (FK to production_outputs)
- qty: Actual qty consumed from this LP for this output
- Cumulative: SUM(qty) per wo_id = total consumed
```

### AC 4.12a.3: Partial LP Consumption Across Multiple Outputs

**Given** LP partially consumed in one output, remaining available for next

**Then** system tracks LP state:

```
Example: LP-B partial consumption
─────────────────────────────────────────────
Status:     reserved
current_qty: 20 kg (remaining after Output-2)
consumed_in_wo: 20 kg (in wo_consumption)
available_for_next: 20 kg

Next output (Output-2.5) can consume remaining 20 kg of LP-B
- LP-B would then have current_qty=0 and be fully consumed
```

**In database:**
```sql
-- license_plates table
SELECT id, current_qty, status FROM license_plates WHERE id = 'LP-B';
-- Returns: (LP-B, 20, 'reserved')

-- wo_consumption table
SELECT SUM(qty) FROM wo_consumption WHERE lp_id='LP-B' AND wo_id='WO-1';
-- Returns: 20 kg (consumed in Output-2)

-- Remaining: current_qty (20) - SUM(qty from wo_consumption) = 0 (if more consumed)
```

### AC 4.12a.4: Over-Consumption Detection (Warning, Not Blocking)

**Given** cumulative output would exceed reserved LPs

**When** output registration triggers over-consumption

**Then** system shows warning dialog:

```
┌─────────────────────────────────────────────────┐
│ ⚠️  Over-Consumption Detected                  │
├─────────────────────────────────────────────────┤
│ Material: Flour (MAT-1)                         │
│ Required: 200 kg                                │
│ Reserved: 200 kg total                          │
│ Already consumed: 170 kg (Outputs 1-3)          │
│ Requested output: 30 kg                         │
│ Total if accepted: 200 kg (at limit)           │
│                                                  │
│ Do you want to register 30 kg over-production? │
│ [ No ]  [ Yes ]                                 │
└─────────────────────────────────────────────────┘
```

### AC 4.12a.5: Respect allow_over_consumption Setting

**Then** behavior depends on production_settings:

```
If allow_over_consumption = false:
  - Show warning dialog
  - If operator confirms: Accept and register output
  - If operator declines: Cancel output registration

If allow_over_consumption = true:
  - Show warning dialog (same as above)
  - Allow operator to confirm or decline
  - Both options available

Note: Setting does NOT block, only influences messaging
```

### AC 4.12a.6: Consume Whole LP Enforcement (Story 4.9 Integration)

**Given** material has consume_whole_lp = true

**Then** sequential allocation respects full-LP consumption:

```
Reserved LPs:
  - LP-A: 80 kg (consume_whole_lp=true for MAT-1)
  - LP-B: 40 kg (consume_whole_lp=false for MAT-1)

Output-1 (70 kg):
  ├─ Check consume_whole_lp for MAT-1: true
  ├─ LP-A marked as consume_whole_lp
  ├─ Sequential algorithm: consume LP-A fully (80 kg)
  └─ If output is 70 kg but LP-A is 80 kg:
     - Consume 80 kg (full LP)
     - LP-A status=available, current_qty=0

Output-2 (30 kg):
  ├─ LP-A exhausted
  ├─ Allocate LP-B (20 kg consumed, 20 kg remaining)
  ├─ Still need 10 kg more
  └─ Move to next reserved LP or prompt for over-production
```

### AC 4.12a.7: API for Sequential Consumption

**Then** POST `/api/production/work-orders/:id/outputs` uses internal service:

```typescript
// Internal service (not exposed to frontend)
interface OutputConsumptionService {
  /**
   * Calculate which LPs will be consumed for this output
   * Returns: allocation plan (which LPs, what qty each)
   */
  calculateConsumptionAllocation(
    wo_id: UUID,
    output_qty: number,
    reserved_lps: LP[]
  ): {
    allocations: { lp_id: UUID, qty_to_consume: number }[],
    is_over_consumption: boolean,
    cumulative_after: number
  }

  /**
   * Execute consumption - creates wo_consumption records
   * Atomic transaction
   */
  executeConsumption(
    wo_id: UUID,
    output_id: UUID,
    allocations: AllocationPlan[],
    consumed_by_user_id: UUID
  ): Promise<void>
}
```

### AC 4.12a.8: Genealogy Creation (4.19 Integration)

**Given** consumption allocation complete

**When** genealogy records created

**Then** each consumption mapped to genealogy:

```
For each wo_consumption record:
  CREATE lp_genealogy:
    parent_lp_id: consumed LP
    child_lp_id: output LP
    operation_type: 'consume'
    consumed_qty: qty consumed
    wo_id: WO reference
    produced_at: output registration timestamp
    created_by_user_id: operator

Result: Full traceability from input LPs to output LP
```

### AC 4.12a.9: State Machine Diagram

```
[Output Registration Start]
    ↓
[Get WO, Reserved LPs]
    ↓
[Calculate Consumption Allocation]
    ├─ Sequential through reserved LPs
    ├─ Track cumulative consumption
    └─ Detect over-consumption
    ↓
[Over-Consumption?]
    ├─ YES → Show Warning Dialog → Operator choice
    │         ├─ Decline → CANCEL
    │         └─ Confirm → CONTINUE
    └─ NO → CONTINUE
    ↓
[Execute Consumption - ATOMIC TRANSACTION]
    ├─ Create wo_consumption records
    ├─ Update license_plates.current_qty
    ├─ Update wo_materials.consumed_qty
    └─ Create genealogy records
    ↓
[Update WO output_qty]
    ↓
[Output Registration Complete]
```

---

## Technical Implementation

### Database Schema Changes

**Add to wo_consumption table:**
```sql
ALTER TABLE wo_consumption ADD COLUMN IF NOT EXISTS output_id UUID REFERENCES production_outputs(id);
-- Links consumption to specific output (for multi-output tracking)

ALTER TABLE wo_consumption ADD COLUMN IF NOT EXISTS consumed_at TIMESTAMPTZ DEFAULT now();
-- Timestamp of consumption
```

### Consumption Allocation Algorithm (Pseudocode)

```typescript
function calculateConsumptionAllocation(
  wo_id: UUID,
  output_qty: number,
  reserved_lps: LP[],
  allow_over_consumption: boolean
): AllocationPlan {

  // Get already-consumed qty
  let cumulative_consumed = await getWOConsumedQty(wo_id);
  let remaining_to_allocate = output_qty;
  let allocations = [];
  let is_over_consumption = false;

  for (const lp of reserved_lps) {
    if (remaining_to_allocate <= 0) break;

    // Check if LP already fully consumed
    if (lp.current_qty <= 0) continue;

    // Calculate qty to consume from this LP
    const qty_to_consume = Math.min(remaining_to_allocate, lp.current_qty);

    allocations.push({
      lp_id: lp.id,
      qty_to_consume: qty_to_consume,
      consume_whole_lp: lp.material.consume_whole_lp
    });

    remaining_to_allocate -= qty_to_consume;
    cumulative_consumed += qty_to_consume;
  }

  // Check over-consumption
  const total_reserved = reserved_lps.sum(lp => lp.quantity);
  if (cumulative_consumed > total_reserved) {
    is_over_consumption = true;
  }

  return {
    allocations,
    is_over_consumption,
    cumulative_after: cumulative_consumed,
    remaining_unallocated: remaining_to_allocate // > 0 if over-production
  };
}
```

### Transaction Atomicity

All consumption operations must be atomic:

```sql
BEGIN TRANSACTION;

-- 1. Lock rows
SELECT * FROM wo_materials WHERE wo_id = $1 FOR UPDATE;
SELECT * FROM license_plates WHERE id = ANY($reserved_lp_ids) FOR UPDATE;

-- 2. Validate
-- WO in_progress, reserved LPs exist, etc.

-- 3. Create consumption records
INSERT INTO wo_consumption (wo_id, material_id, lp_id, qty, output_id, consumed_by_user_id)
VALUES (...);

-- 4. Update LP current_qty
UPDATE license_plates SET current_qty = current_qty - $qty
WHERE id = $lp_id;

-- 5. Update WO tracked quantities
UPDATE wo_materials SET consumed_qty = consumed_qty + $qty
WHERE wo_id = $wo_id AND id = $material_id;

-- 6. Create genealogy
INSERT INTO lp_genealogy (parent_lp_id, child_lp_id, operation_type, wo_id, consumed_qty)
VALUES (...);

COMMIT; -- All succeed or all rollback
```

---

## Testing Strategy

### Unit Tests

- Calculate allocation: correctly identifies which LPs consumed for given output qty
- Partial LP consumption: remaining qty tracked correctly
- Over-consumption detection: correctly identifies when cumulative > reserved
- Whole LP enforcement: when consume_whole_lp=true, entire LP consumed

### Integration Tests

- Sequential allocation across 4 outputs: all LPs consumed in correct order
- Partial LP spanning multiple outputs: LP state tracked correctly across outputs
- Over-consumption warning: dialog shown, operator can confirm/cancel
- Atomic transaction: all-or-nothing (if genealogy fails, all rolls back)

### E2E Tests

- Register Output-1 (70kg) → LP-A consumed fully
- Register Output-2 (20kg) → LP-B consumed partially
- Register Output-3 (80kg) → LP-C consumed fully
- Register Output-4 (30kg) → Over-consumption warning shown
- Operator confirms → Output-4 registered
- Verify consumption records in wo_consumption table
- Verify genealogy records created for each consumption

---

## Acceptance Criteria Checklist

- ✅ Sequential LP allocation algorithm defined
- ✅ Consumption tracked in wo_consumption per output
- ✅ Partial LP consumption tracked across outputs
- ✅ Over-consumption detection (warning, not blocking)
- ✅ Respect allow_over_consumption setting
- ✅ Consume whole LP enforcement (Story 4.9)
- ✅ Genealogy creation per consumption
- ✅ Atomic transaction for all operations
- ✅ Clear state machine diagram

---

## Dependencies

**Used by:**
- Story 4.12: Output Registration (Desktop)
- Story 4.13: Output Registration (Scanner)
- Story 4.14: By-Product Registration
- Story 4.16: Multiple Outputs per WO

**Requires:**
- Story 4.7: Material Consumption & Reservation
- Story 4.9: Whole LP Consumption Enforcement
- Story 4.19: Genealogy Recording (genealogy creation)

---

## Notes

- This is a **Technical Foundation Story** - not user-facing, provides algorithm for 4 dependent stories
- Sequential allocation ensures deterministic, traceable consumption
- Over-consumption warning (not blocking) allows flexibility while maintaining audit trail
- Atomic transaction guarantees consistency: if any step fails, entire consumption fails
- Consumption allocation algorithm can be reused by mobile/scanner (4.13) and by-products (4.14)
