# Story 5.23a: Scanner Workflow Definitions - Technical Foundation

**ID:** 5.23a
**Batch:** 5C-1 (Scanner Core)
**Type:** Technical Foundation Story
**Story Points:** 5
**Effort:** 5-6 hours
**Status:** Todo

---

## Purpose

This Technical Foundation Story defines the workflow state machines and step configurations used by scanner operations (Stories 5.23, 5.26, 5.27, 5.34, 5.35). Instead of embedding workflow definitions in multiple stories, this defines a reusable workflow configuration standard that all scanner workflows follow.

**Used by:**
- Story 5.23: Scanner Guided Workflows (renders these configs)
- Story 5.26: Scanner Operations Menu (navigates between workflows)
- Story 5.27: Scanner Session Timeout (preserves workflow state)
- Story 5.34: Scanner Receive Workflow (specific receive implementation)
- Story 5.35: Inventory Count (count workflow implementation)

---

## Workflow Configuration Standard

### Core Structure

Every workflow configuration follows this TypeScript interface:

```typescript
interface WorkflowConfig {
  workflow_type: WorkflowType;
  display_name: string;
  description: string;
  icon: string;
  max_steps: number;
  steps: WorkflowStep[];
  context_schema: JSONSchema; // Validates workflow context data
}

type WorkflowType = 'receive' | 'put_away' | 'pick' | 'consume' | 'output' | 'move' | 'count';

interface WorkflowStep {
  step_number: number;
  action: StepAction;
  instruction: string; // Displayed to user
  hint?: string; // Additional context
  required_fields: string[]; // What data this step must collect
  validation: StepValidation;
  feedback: FeedbackType; // visual/haptic feedback on success
  error_messages?: Record<string, string>; // Context-specific errors
  ui_component: UIComponentType; // What UI component renders this step
}

type StepAction = 'scan_barcode' | 'select_option' | 'enter_number' | 'enter_text' | 'confirm';
type FeedbackType = 'green_check' | 'error' | 'warning';
type UIComponentType = 'barcode_input' | 'dropdown_select' | 'numeric_input' | 'text_input' | 'confirmation';

interface StepValidation {
  pattern?: string; // Regex for barcode format
  required: boolean;
  custom_validator?: string; // Function name in backend
  dependencies?: {
    requires_step: number; // Can't run until this step is done
    context_field: string; // Field from context data
  };
}
```

### Workflow Context

Each workflow maintains a context object that flows through all steps:

```typescript
interface WorkflowContext {
  workflow_type: WorkflowType;
  session_id: UUID;
  started_at: ISO8601;
  current_step: number;
  user_id: UUID;
  org_id: UUID;
  device_id: string;

  // Workflow-specific data
  [key: string]: any; // Filled by individual step actions
}
```

---

## Workflow Definitions

### Workflow 1: Receive

**Purpose:** Receive new inventory from Purchase Orders or Transfer Orders into warehouse.

**Steps:**

```
1. Select source
   Action: select_option
   Options: ['Receive from PO', 'Receive from Transfer Order', 'Manual Receive']
   Context: source_type

2. Scan source document barcode
   Action: scan_barcode
   Instruction: "Scan PO/TO Barcode"
   Pattern: PO-\d+ or TO-\d+
   Context: source_document_id, source_lines[]

3. Product validation
   Action: scan_barcode
   Instruction: "Scan Product Barcode"
   Pattern: (EAN128 or Product ID)
   Validation: Match current PO/TO line item
   Context: product_id, expected_product
   (Repeat for each line item)

4. Enter quantity
   Action: enter_number
   Instruction: "Enter Quantity"
   Hint: "Remaining: {remaining_qty} {uom}"
   Validation: 0 < qty ≤ remaining
   Context: received_qty

5. Batch & Expiry
   Action: enter_text (batch), optional dates
   Instruction: "Enter Batch Number"
   Validation: batch required (FDA compliance)
   Context: batch_number, manufacture_date?, expiry_date?

6. Scan storage location
   Action: scan_barcode
   Instruction: "Scan Destination Location"
   Pattern: LOC-\d+ or similar
   Validation: Location active, type=storage
   Context: location_id

7. Confirm & Create LP
   Action: confirm
   Instruction: "Confirm to create LP"
   Summary: Shows product, qty, batch, location
   Backend: Create GRN + LP
   Context: lp_id, grn_id
   Feedback: "✅ LP-20250120-0001 created"

8. Next item or Done
   Action: select_option
   Options: ['Next Item', 'Done']
   Condition: If more PO lines → 'Next Item' loops to step 3
             If no more lines → 'Done' completes workflow
```

**Key Constraints:**
- Product scan must match current PO/TO line
- Batch number required (FDA compliance)
- Location must be storage type
- Offline: Steps 1-6 queued, step 7 (create LP) syncs on reconnect

---

### Workflow 2: Put Away

**Purpose:** Move received LPs from receiving dock to storage locations.

**Steps:**

```
1. Scan LP barcode
   Action: scan_barcode
   Instruction: "Scan LP to Put Away"
   Pattern: LP-\d+
   Validation: LP exists, status='received'
   Context: lp_id, lp_number

2. Confirm product
   Action: confirm
   Instruction: "Confirm: {product_name} - {qty} {uom}"
   Hint: "Product will be stored in warehouse"
   (Auto-filled from LP, no user input needed)
   Context: product_id, qty

3. Scan destination location
   Action: scan_barcode
   Instruction: "Scan Storage Location"
   Pattern: LOC-\d+
   Validation: Location active, type=storage, has capacity
   Context: destination_location_id

4. Confirm put away
   Action: confirm
   Instruction: "Confirm to complete put away"
   Summary: LP {number} → {location}
   Backend: Create stock_move (movement_type='put_away')
   Feedback: "✅ Put away complete"
   Context: stock_move_id
```

**Key Constraints:**
- LP status must be 'received' (not already put away)
- Destination must be storage location type
- Auto-fills from GRN during GRN creation (Story 5.11)
- Offline: Steps 1-3 cached, step 4 synced on reconnect

---

### Workflow 3: Pick

**Purpose:** Allocate inventory for Work Orders or Transfer Orders.

**Steps:**

```
1. Scan allocation source (WO or TO)
   Action: scan_barcode
   Instruction: "Scan Work Order or Transfer Order"
   Pattern: WO-\d+ or TO-\d+
   Validation: WO/TO exists, status=open
   Context: allocation_type, allocation_id, allocation_lines[]

2. Pick product
   Action: scan_barcode
   Instruction: "Scan Product Barcode"
   Pattern: EAN128 or Product ID
   Validation: Match allocation line item
   Context: product_id, expected_product

3. Scan LP to pick
   Action: scan_barcode
   Instruction: "Scan LP to Pick From"
   Pattern: LP-\d+
   Validation: LP contains product, qty sufficient
   Context: source_lp_id

4. Enter quantity to pick
   Action: enter_number
   Instruction: "Enter Qty to Pick"
   Hint: "Available: {lp_qty}, Needed: {allocation_qty}"
   Validation: 0 < qty ≤ available
   Context: pick_qty

5. Scan destination (optional)
   Action: scan_barcode (optional)
   Instruction: "Scan Destination Location (optional)"
   Pattern: LOC-\d+
   Validation: Location active
   Context: destination_location_id?

6. Confirm pick
   Action: confirm
   Instruction: "Confirm pick"
   Summary: {product} {qty} from LP-{number}
   Backend: Create stock_move (movement_type='pick'), update LP qty
   Feedback: "✅ Pick complete"
   Context: stock_move_id, new_lp_id (if LP split)
```

**Key Constraints:**
- WO/TO must be open (not completed)
- LP must contain allocation product
- Qty picked ≤ available qty (no over-pick)
- Destination optional (some WOs have fixed locations)
- Offline: Steps 1-5 cached, step 6 synced on reconnect

---

### Workflow 4: Consume

**Purpose:** Record material consumption in Work Order production.

**Steps:**

```
1. Scan Work Order
   Action: scan_barcode
   Instruction: "Scan Work Order"
   Pattern: WO-\d+
   Validation: WO exists, status=in_progress
   Context: wo_id, consumed_materials[]

2. Product validation
   Action: scan_barcode
   Instruction: "Scan Product Barcode"
   Pattern: EAN128 or Product ID
   Validation: Match WO material requirement
   Context: product_id, required_qty

3. Scan LP being consumed
   Action: scan_barcode
   Instruction: "Scan LP Being Consumed"
   Pattern: LP-\d+
   Validation: LP contains product
   Context: source_lp_id

4. Enter consumed quantity
   Action: enter_number
   Instruction: "Enter Qty Consumed"
   Hint: "Available: {lp_qty}, Required: {required_qty}"
   Validation: 0 < qty ≤ available
   Context: consumed_qty

5. Confirm consumption
   Action: confirm
   Instruction: "Confirm consumption"
   Summary: {product} {qty} consumed from LP-{number}
   Backend: Create genealogy record (LP consumed by WO), update LP qty
   Feedback: "✅ Consumed {qty}"
   Context: consumed_record_id
```

**Key Constraints:**
- WO must be in progress (status='in_progress')
- Product must be required material in WO
- Can't consume more than LP contains
- Records genealogy: LP→WO consumption relationship
- Offline: Steps 1-4 cached, step 5 synced on reconnect

---

### Workflow 5: Output

**Purpose:** Record finished product output from Work Order.

**Steps:**

```
1. Scan Work Order
   Action: scan_barcode
   Instruction: "Scan Work Order"
   Pattern: WO-\d+
   Validation: WO exists, status=in_progress
   Context: wo_id, output_product, output_qty

2. Confirm output product
   Action: confirm
   Instruction: "Confirm Output Product"
   Hint: "{product_name} - Expected Qty: {output_qty} {uom}"
   (Auto-filled from WO, no user input)
   Context: output_product_id, expected_output_qty

3. Enter actual output quantity
   Action: enter_number
   Instruction: "Enter Actual Output Qty"
   Hint: "Expected: {expected_qty}, Produced: ?"
   Validation: qty > 0 (allow over/under production)
   Context: actual_output_qty

4. Batch & Serial (if required)
   Action: enter_text
   Instruction: "Enter Batch/Serial Number"
   Condition: Only if product requires batch tracking
   Context: batch_number?, serial_number?

5. Scan destination location
   Action: scan_barcode
   Instruction: "Scan Storage Location"
   Pattern: LOC-\d+
   Validation: Location active, type=storage
   Context: destination_location_id

6. Confirm output
   Action: confirm
   Instruction: "Confirm Production Output"
   Summary: {output_qty} {product} → {location}
   Backend: Create new LP for output, update WO status if complete
   Feedback: "✅ Output LP-20250120-0002 created"
   Context: output_lp_id
```

**Key Constraints:**
- WO must be in progress
- Output qty can be different from expected (under/over production)
- Creates new LP for output (genealogy: WO→output LP)
- Offline: Steps 1-5 cached, step 6 synced on reconnect

---

### Workflow 6: Move

**Purpose:** Relocate inventory between storage locations (internal reorganization).

**Steps:**

```
1. Scan LP to move
   Action: scan_barcode
   Instruction: "Scan LP to Move"
   Pattern: LP-\d+
   Validation: LP exists, status=stored
   Context: lp_id, lp_number, current_location

2. Confirm product
   Action: confirm
   Instruction: "Confirm Product"
   Summary: "{product_name} - {qty} {uom} at {current_location}"
   (Auto-filled from LP)

3. Scan destination location
   Action: scan_barcode
   Instruction: "Scan Destination Location"
   Pattern: LOC-\d+
   Validation: Location active, different from current, has capacity
   Context: destination_location_id

4. Enter move reason (optional)
   Action: select_option (optional)
   Instruction: "Reason for Move (optional)"
   Options: ['Reorganization', 'Consolidation', 'Stock Rotation', 'Other']
   Context: move_reason?

5. Confirm move
   Action: confirm
   Instruction: "Confirm Move"
   Summary: "LP-{number} → {destination_location}"
   Backend: Create stock_move (movement_type='transfer'), update LP.location_id
   Feedback: "✅ Moved to {location}"
   Context: stock_move_id
```

**Key Constraints:**
- LP status must be 'stored' (not received, not on pallet)
- Destination must be different from current location
- Move reason is optional (for analytics)
- movement_type='transfer' in stock_moves
- Offline: Steps 1-4 cached, step 5 synced on reconnect

---

### Workflow 7: Count

**Purpose:** Physical inventory count and reconciliation.

**Steps:**

```
1. Select count area
   Action: scan_barcode or select_option
   Instruction: "Scan Location or Select Warehouse Area"
   Pattern: LOC-\d+ (optional)
   Validation: Location exists and active
   Context: count_location_id (optional), count_area

2. Display expected inventory
   Action: confirm
   Instruction: "Expected Inventory at {location}"
   Summary: Shows list of expected LPs and quantities
   (Read-only, auto-filled from database)
   Context: expected_items[]

3. Scan LP in area
   Action: scan_barcode
   Instruction: "Scan LP Found"
   Pattern: LP-\d+
   Validation: LP exists
   Context: scanned_lp_id

4. Confirm quantity
   Action: enter_number
   Instruction: "Confirm Physical Qty"
   Hint: "System: {system_qty} {uom}, Physical: ?"
   Validation: qty ≥ 0 (allow 0 for missing LP)
   Context: physical_qty

5. Repeat or finish items
   Action: select_option
   Options: ['Next LP', 'Scan Another Location', 'Done']
   Condition: User can continue scanning in same area or move to new location

6. Review discrepancies
   Action: confirm
   Instruction: "Review Count Results"
   Summary: Shows items with variances (system vs physical)
   Display: variance = physical_qty - system_qty
   Context: variance_items[]

7. Confirm count completion
   Action: select_option
   Instruction: "Action on Variances"
   Options: ['Accept & Adjust', 'Investigate', 'Save Draft']
   Backend: Create inventory_count record with all results
   Feedback: "✅ Count {location} completed"
   Context: count_record_id
```

**Key Constraints:**
- Can count at location level or warehouse-wide
- Shows expected vs physical quantities
- Records variances for reconciliation
- Can save draft and continue later
- Offline: Steps 1-6 cached, step 7 syncs on reconnect

---

## Workflow Progression Rules

### Valid Transitions

- **Can skip steps?** No. Steps must be completed in order.
- **Can go backwards?** Yes, but only to previous steps. Example: in Receive workflow, after entering quantity, user can go back to product validation but not skip to location.
- **Can exit workflow?** Yes, at any point. Offline: Partial workflow saved to IndexedDB.
- **Can resume?** Yes. On reconnect, user can resume from last completed step.

### State Machine Validation

```typescript
interface StepTransition {
  from_step: number;
  to_step: number;
  condition?: string; // Optional validation before allowing transition
  action?: string; // Side effect function to execute
}

// Example for Receive workflow:
const transitions: StepTransition[] = [
  { from_step: 1, to_step: 2, action: 'load_po' },
  { from_step: 2, to_step: 3, action: 'validate_po' },
  { from_step: 3, to_step: 4, condition: 'product_matches' },
  { from_step: 4, to_step: 5, condition: 'qty_valid' },
  // ... etc
];
```

---

## Validation Patterns

### Barcode Format Recognition

Workflows identify barcode types by prefix (auto-detection):

```
LP Barcode:      LP-\d{8}-\d{4}        (e.g., LP-20250120-0001)
PO Barcode:      PO-\d+                (e.g., PO-001234)
TO Barcode:      TO-\d+                (e.g., TO-005678)
WO Barcode:      WO-\d+                (e.g., WO-009012)
Product Barcode: EAN128 or custom      (e.g., 5901234123457)
Location Barcode: LOC-\d+ or custom    (e.g., LOC-A-01-01)
```

### Context Validation

Each workflow validates context schema at key checkpoints:

```typescript
// Receive workflow context schema
const receiveContextSchema = {
  source_type: 'enum:po,to,manual',
  source_document_id: 'uuid',
  product_id: 'uuid',
  received_qty: 'number:0<x<=remaining',
  batch_number: 'string:required',
  location_id: 'uuid:type=storage',
};

// Validation: Before step 7 (create LP), verify all required fields filled
```

---

## Error Handling

### Common Errors by Step Type

**Barcode Scan Errors:**
- Invalid format: "Barcode doesn't match expected format"
- Not found: "{item} not found"
- Already processed: "This item already received"

**Numeric Input Errors:**
- Out of range: "Qty must be between {min} and {max}"
- Decimals invalid: "Enter whole number only"

**Validation Errors:**
- Status mismatch: "Item status is {current}, expected {required}"
- Capacity exceeded: "Location at capacity, select another"

### Error Recovery

All errors are **non-fatal**. User can:
1. Retry (re-enter data)
2. Go back (previous step)
3. Skip (for optional steps)
4. Abandon (lose partial progress, restart workflow)

---

## Offline Support

### IndexedDB Schema

Partial workflows stored per session:

```typescript
interface OfflineWorkflowSession {
  session_id: UUID;
  workflow_type: WorkflowType;
  current_step: number;
  context: WorkflowContext;
  timestamp: ISO8601;
  synced: boolean;
}

// Key: `scanner_workflow_sessions_{session_id}`
// Removed after 24 hours
```

### Sync Strategy

1. **Steps 1-6 (data collection):** Cached in IndexedDB
2. **Step 7 (create/update):**
   - If online: Execute immediately
   - If offline: Queue in offline queue (Story 5.36a), sync on reconnect

### Dependency Resolution

Workflows with dependencies (Consume/Output depend on WO existence) handled by 5.36b:
- If dependency fails during sync: Mark workflow as failed, notify user
- User can retry or discard

---

## Multi-Workflow Sequencing

### Menu Flow (Story 5.26)

Users can chain workflows:

```
1. User selects "Receive" → completes workflow
2. System shows: "Receive Complete!"
3. User chooses: "Start New Workflow" → back to menu
4. User selects "Put Away" → completes workflow
5. Continue...
```

### Session Persistence (Story 5.27)

Sessions timeout after configurable idle time (default 15 min):
- Workflow progress saved to IndexedDB before timeout
- On re-login: User can "Resume Last Workflow"

---

## Localization & Customization

### Multi-Language Support

All instructions, hints, error messages are configurable per org/locale:

```typescript
interface LocalizedWorkflow {
  workflow_type: WorkflowType;
  locale: string; // en, es, fr, etc.
  steps: LocalizedStep[];
}

// Stored in: `workflow_configs_{org_id}_{workflow_type}_{locale}`
```

### Customization Points

Orgs can customize (Story 5.31 settings):
- Step instructions (hint text)
- Optional vs. required fields
- Validation patterns (barcode formats)
- Feedback types (visual/haptic/audio)

---

## Technical Tasks

### Backend

- [ ] Create workflow configuration database tables
  - `scanner_workflow_configs` (workflow_type, steps JSON, context_schema)
  - `workflow_customizations` (org_id, workflow_type, overrides)
  - `workflow_step_validators` (step_type, validation_function)

- [ ] Implement WorkflowConfigService
  ```typescript
  class WorkflowConfigService {
    getConfig(workflow_type): WorkflowConfig
    validateStep(workflow_type, step_number, data): ValidationResult
    getNextStep(workflow_type, current_step): WorkflowStep
    validateContext(workflow_type, context): ContextValidationResult
  }
  ```

- [ ] Create barcode pattern validators
  - `validateLPBarcode(barcode): boolean`
  - `validatePOBarcode(barcode): boolean`
  - `validateProductBarcode(barcode, product_id): boolean`
  - etc.

- [ ] Implement context schema validation
  - Validate all required fields filled before step completion
  - Support conditional requirements (e.g., batch only if product requires)

### Frontend

- [ ] Create WorkflowState management
  - `useWorkflowState(workflow_type)` hook
  - Tracks: current_step, context, validation_state
  - Methods: nextStep(), previousStep(), abandonWorkflow()

- [ ] Implement StepRenderer component
  - Dynamically renders based on step.ui_component
  - Handles: barcode_input, dropdown_select, numeric_input, text_input, confirmation
  - Passes step data and validation rules

- [ ] Create workflow configuration loader
  - Fetch configs from backend
  - Cache in localStorage with TTL
  - Support offline: pre-load common workflows

### Database

- [ ] Create scanner_workflow_configs table
- [ ] Create workflow_customizations table (for org overrides)
- [ ] Create indices on workflow_type, org_id
- [ ] Pre-populate with 7 default workflows (receive, put_away, pick, consume, output, move, count)

---

## Testing

### Unit Tests
- Workflow config validation: valid configs load, invalid rejected
- Step progression: valid transitions allowed, invalid blocked
- Context validation: all required fields checked
- Barcode pattern matching: each barcode type recognized

### Integration Tests
- GET /api/scanner/workflow-config/:type returns proper config
- POST /api/scanner/sessions/:id/step validates and progresses
- Offline: workflow saved to IndexedDB, resumed on reconnect
- Multi-user: different users have different workflow states

### E2E Tests
- Load workflow selection → select "Receive"
- Workflow steps render in correct order
- Step progression: can't advance until validation passes
- Error handling: invalid input shows error, can retry
- Save/resume: close app in middle of workflow, reopen, can resume

---

## Acceptance Criteria Checklist

- ✅ Workflow configuration standard defined (TypeScript interface)
- ✅ 7 workflows fully specified (receive, put_away, pick, consume, output, move, count)
- ✅ Each workflow defines: steps, validations, error handling, UI components
- ✅ State machine transitions documented (forward, backward, exit rules)
- ✅ Barcode format recognition patterns defined
- ✅ Offline support: workflows cached in IndexedDB
- ✅ Error handling: non-fatal, user can retry/skip/abandon
- ✅ Localization: instructions translatable per org/locale
- ✅ Customization: orgs can override steps/validations

---

## Dependencies

**Used by:**
- Story 5.23: Scanner Guided Workflows (renders these configs)
- Story 5.26: Scanner Operations Menu (navigation)
- Story 5.27: Scanner Session Timeout (saves workflow state)
- Story 5.34: Scanner Receive Workflow (specific implementation)
- Story 5.35: Inventory Count (count workflow)

**Requires:**
- Story 5.1: License Plates (LP data structure)
- Story 5.11: GRN & LP Creation (receive creates LP)
- Epic 4: Work Orders (WO data for consume/output)

---

## Notes

- This is a **Technical Foundation Story** - not directly visible to users, but provides infrastructure for 5 dependent stories
- Workflow steps are **stateless and replayable** - enables offline sync (5.36a/b)
- Validation happens on **client and server** - client-side prevents invalid steps, server validates for security
- Customization happens at story level (5.31 settings) - this defines the defaults
- Performance: Configs cached in browser (localStorage), lazy-load on demand
- Accessibility: All text translatable, error messages user-friendly, no jargon
