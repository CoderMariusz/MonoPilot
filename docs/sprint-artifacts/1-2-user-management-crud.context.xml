<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1.2</storyId>
    <title>User Management - CRUD</title>
    <status>drafted</status>
    <generatedAt>2025-11-20</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/1-2-user-management-crud.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Admin</asA>
    <iWant>create, view, edit, and deactivate users</iWant>
    <soThat>I can control who has access to the system</soThat>
    <tasks>
      - Task 1: Database Schema &amp; Migrations (users table with RLS, indexes, constraints)
      - Task 2: API Endpoints (GET/POST/PUT/DELETE for /api/settings/users)
      - Task 3: Zod Validation Schemas (CreateUserSchema, UpdateUserSchema)
      - Task 4: Frontend User Management Page (UserTable, UserForm, EditUserDrawer, Deactivate modal)
      - Task 5: Session Termination Service (terminateAllSessions method, JWT blacklist, realtime events)
      - Task 6: Last Admin Validation (canDeactivateUser function)
      - Task 7: Integration &amp; Testing (Unit, Integration, E2E tests)
      - Task 8: RLS Policy Testing (cross-org isolation tests)
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC-002.1">
      <title>Admin może stworzyć usera z wymaganymi polami</title>
      <details>
        - email (required, valid email format, unique per org)
        - first_name (required, max 50 chars)
        - last_name (required, max 50 chars)
        - role (dropdown z 10 opcji: admin, manager, operator, viewer, planner, technical, purchasing, warehouse, qc, finance)
        - User created with status = 'invited'
      </details>
    </criterion>

    <criterion id="AC-002.2">
      <title>User table wyświetla listę użytkowników</title>
      <details>
        - Columns: Email, Name, Role, Status, Last Login, Actions
        - Table sortowalna po wszystkich kolumnach
        - Search bar: wyszukiwanie po name lub email (case-insensitive)
        - Filters: role (multi-select dropdown), status (Invited, Active, Inactive)
      </details>
    </criterion>

    <criterion id="AC-002.3">
      <title>Edit user functionality</title>
      <details>
        - Click Edit action → drawer/modal opens
        - Editable fields: first_name, last_name, role, status
        - Email NIE jest edytowalny (read-only)
        - Submit → user updated, table refreshes, success toast
      </details>
    </criterion>

    <criterion id="AC-002.4">
      <title>Deactivate user with session termination</title>
      <details>
        - Click Deactivate action → confirmation modal
        - On confirm: user.status → 'inactive'
        - All active sessions terminated (JWT blacklist)
        - User logged out immediately on all devices
        - Success toast: "User deactivated and logged out"
      </details>
    </criterion>

    <criterion id="AC-002.5">
      <title>Cannot deactivate last admin</title>
      <details>
        - If attempting to deactivate last admin in org → show error
        - Error message: "Cannot deactivate the last admin user"
        - Validate on server before status change
      </details>
    </criterion>

    <criterion id="AC-002.6">
      <title>Supabase Auth Integration</title>
      <details>
        - User creation in public.users table synced with auth.users
        - User ID matches between tables (same UUID)
      </details>
    </criterion>

    <criterion id="AC-002.7">
      <title>RLS Policy Enforcement</title>
      <details>
        - Users can only see users from their own org (org_id isolation)
        - Admin/Manager roles only can access user management page
      </details>
    </criterion>

    <criterion id="AC-002.8">
      <title>Audit Trail</title>
      <details>
        - created_by, updated_by, created_at, updated_at tracked
        - Display "Created by X on YYYY-MM-DD" in user details
      </details>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-1.md</path>
        <title>Technical Specification - Epic 1 (Foundation &amp; Settings)</title>
        <section>FR-SET-002: User Management</section>
        <snippet>Defines users table schema with 10 roles, RLS policy, API endpoints, and integration with Supabase Auth. Includes complete data model with constraints and indexes.</snippet>
      </doc>

      <doc>
        <path>docs/epics/epic-1-settings.md</path>
        <title>Epic 1: Foundation &amp; Settings</title>
        <section>Story 1.2: User Management - CRUD</section>
        <snippet>User story definition with role system, status lifecycle, and functional requirements for user administration.</snippet>
      </doc>

      <doc>
        <path>docs/architecture/index-architecture.md</path>
        <title>Architecture Index</title>
        <section>Multi-tenancy &amp; Security Patterns</section>
        <snippet>RLS policy patterns, org_id isolation, audit trail requirements, and session management architecture.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>tests/support/helpers/auth-helper.ts</path>
        <kind>test-helper</kind>
        <symbol>AuthHelper</symbol>
        <lines>all</lines>
        <reason>Existing Supabase auth integration patterns for testing - reuse for user creation/login tests</reason>
      </artifact>

      <artifact>
        <path>tests/support/fixtures/factories/user-factory.ts</path>
        <kind>test-factory</kind>
        <symbol>UserFactory</symbol>
        <lines>all</lines>
        <reason>Test data factory for users - extend with new fields (role, status, org_id)</reason>
      </artifact>

      <artifact>
        <path>app/lib/supabase/server.ts</path>
        <kind>lib</kind>
        <symbol>createClient</symbol>
        <lines>all</lines>
        <reason>Supabase server client setup - use for server-side auth operations</reason>
      </artifact>

      <artifact>
        <path>app/lib/types.ts</path>
        <kind>types</kind>
        <symbol>Database types</symbol>
        <lines>all</lines>
        <reason>TypeScript types for database tables - will be updated after users table migration</reason>
      </artifact>

      <artifact>
        <path>app/middleware.ts</path>
        <kind>middleware</kind>
        <symbol>middleware</symbol>
        <lines>all</lines>
        <reason>Next.js middleware for auth - extend with role-based access control checks</reason>
      </artifact>

      <artifact>
        <path>packages/shared/schemas.ts</path>
        <kind>schemas</kind>
        <symbol>Zod schemas</symbol>
        <lines>all</lines>
        <reason>Shared validation schemas - add CreateUserSchema and UpdateUserSchema here</reason>
      </artifact>

      <artifact>
        <path>packages/shared/types.ts</path>
        <kind>types</kind>
        <symbol>Shared types</symbol>
        <lines>all</lines>
        <reason>Shared TypeScript types - add User, UserRole, UserStatus enums</reason>
      </artifact>
    </code>

    <dependencies>
      <ecosystem name="node">
        <package name="@supabase/supabase-js" version="latest">Supabase client for auth and database</package>
        <package name="zod" version="latest">Schema validation (CreateUserSchema, UpdateUserSchema)</package>
        <package name="react-hook-form" version="latest">Form state management</package>
        <package name="@tanstack/react-table" version="latest">Data table with sorting/filtering</package>
        <package name="@faker-js/faker" version="^9.3.0">Test data generation (already installed)</package>
        <package name="ioredis" version="latest">Redis client for JWT blacklist (NEW - needs install)</package>
      </ecosystem>

      <ecosystem name="shadcn">
        <component name="table">User table component</component>
        <component name="form">User creation/edit forms</component>
        <component name="dialog">Deactivate confirmation modal</component>
        <component name="drawer">Edit user drawer</component>
        <component name="select">Role and status dropdowns</component>
        <component name="input">Form fields</component>
        <component name="toast">Success/error notifications</component>
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="architecture">
      <rule>Multi-tenancy: All queries MUST filter by org_id from JWT (auth.jwt() ->> 'org_id')</rule>
      <rule>RLS Policy REQUIRED: org_id = (auth.jwt() ->> 'org_id')::uuid on users table</rule>
      <rule>Auth Sync: public.users.id MUST match auth.users.id (same UUID)</rule>
      <rule>Audit Trail: created_by, updated_by, created_at, updated_at REQUIRED on all writes</rule>
    </constraint>

    <constraint type="security">
      <rule>Role-Based Access: Admin only for POST/PUT/DELETE, Manager can view (GET)</rule>
      <rule>Email Immutability: Email CANNOT be changed after user creation</rule>
      <rule>Last Admin Guard: MUST prevent deactivation of last admin in org</rule>
      <rule>Session Security: Deactivated users MUST be logged out within 1s (JWT blacklist + realtime)</rule>
      <rule>Input Validation: Zod schemas MUST be used on both client and server</rule>
    </constraint>

    <constraint type="data">
      <rule>Unique Constraint: (org_id, email) - email unique per organization</rule>
      <rule>Indexes REQUIRED: org_id, email, status, role for query performance</rule>
      <rule>10 Role System: admin, manager, operator, viewer, planner, technical, purchasing, warehouse, qc, finance</rule>
      <rule>3 Status Values: invited, active, inactive</rule>
    </constraint>

    <constraint type="testing">
      <rule>RLS Testing: MUST add to RLS test suite (Sprint 0 Gap 4)</rule>
      <rule>Integration Tests: MUST verify auth.users ↔ public.users sync</rule>
      <rule>E2E Tests: MUST test last admin protection end-to-end</rule>
      <rule>Session Tests: MUST verify terminated user logged out in <1s</rule>
    </constraint>
  </constraints>

  <interfaces>
    <interface name="GET /api/settings/users">
      <kind>REST endpoint</kind>
      <signature>
        Query: { role?: string[], status?: string, search?: string }
        Response: User[]
        Auth: Admin or Manager role required
        Cache: 5 min TTL (SWR)
      </signature>
      <path>app/api/settings/users/route.ts</path>
    </interface>

    <interface name="POST /api/settings/users">
      <kind>REST endpoint</kind>
      <signature>
        Body: CreateUserInput { email, first_name, last_name, role }
        Response: User + InvitationToken
        Auth: Admin role only
        Side effects: Create in auth.users, insert public.users, send invitation (Story 1.3)
      </signature>
      <path>app/api/settings/users/route.ts</path>
    </interface>

    <interface name="PUT /api/settings/users/:id">
      <kind>REST endpoint</kind>
      <signature>
        Params: { id: UUID }
        Body: UpdateUserInput { first_name?, last_name?, role?, status? }
        Response: User
        Auth: Admin role only
        Validation: Cannot change email, cannot deactivate last admin
      </signature>
      <path>app/api/settings/users/[id]/route.ts</path>
    </interface>

    <interface name="DELETE /api/settings/users/:id">
      <kind>REST endpoint</kind>
      <signature>
        Params: { id: UUID }
        Response: { success: boolean }
        Auth: Admin role only
        Side effects: Set status=inactive, terminate all sessions, emit realtime event
      </signature>
      <path>app/api/settings/users/[id]/route.ts</path>
    </interface>

    <interface name="SessionService.terminateAllSessions">
      <kind>Service method</kind>
      <signature>
        async terminateAllSessions(userId: string): Promise&lt;number&gt;
        Returns: Count of terminated sessions
        Side effects: Update user_sessions.is_active=false, add JWTs to Redis blacklist, emit realtime event
      </signature>
      <path>lib/services/SessionService.ts (NEW - create in Story 1.4)</path>
    </interface>

    <interface name="CreateUserSchema">
      <kind>Zod schema</kind>
      <signature>
        z.object({
          email: z.string().email(),
          first_name: z.string().min(1).max(50),
          last_name: z.string().min(1).max(50),
          role: z.enum(['admin', 'manager', 'operator', 'viewer', 'planner', 'technical', 'purchasing', 'warehouse', 'qc', 'finance'])
        })
      </signature>
      <path>packages/shared/schemas.ts</path>
    </interface>

    <interface name="UpdateUserSchema">
      <kind>Zod schema</kind>
      <signature>
        z.object({
          first_name: z.string().min(1).max(50).optional(),
          last_name: z.string().min(1).max(50).optional(),
          role: z.enum([...]).optional(),
          status: z.enum(['invited', 'active', 'inactive']).optional()
        })
        Note: Email explicitly excluded (immutable)
      </signature>
      <path>packages/shared/schemas.ts</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing stack: Vitest for unit/integration tests, Playwright for E2E tests.
      Unit tests in same directory as source files (*.test.ts).
      Integration tests in tests/integration/.
      E2E tests in tests/e2e/ using Playwright with Supabase test client.
      Use @faker-js/faker for test data generation.
      RLS tests MUST be added to tests/integration/rls/ suite (Sprint 0 Gap 4).
      All auth operations use tests/support/helpers/auth-helper.ts patterns.
      Test factories in tests/support/fixtures/factories/.
    </standards>

    <locations>
      - app/api/settings/users/**/*.test.ts (API endpoint tests)
      - packages/shared/schemas.test.ts (Zod schema validation tests)
      - lib/services/SessionService.test.ts (Session termination logic tests)
      - tests/integration/users/ (Integration tests: DB + Auth sync, RLS)
      - tests/integration/rls/users-rls.test.ts (RLS policy tests - add to Gap 4 suite)
      - tests/e2e/settings/users.spec.ts (E2E user management flow)
    </locations>

    <ideas>
      <test id="AC-002.1" type="unit">
        - Validate CreateUserSchema with valid inputs (all roles)
        - Validate CreateUserSchema with invalid email formats
        - Validate CreateUserSchema with empty/too-long names
      </test>

      <test id="AC-002.1" type="integration">
        - POST /api/settings/users → user created in both public.users AND auth.users with matching UUID
        - Verify user.status = 'invited' on creation
        - Verify unique constraint (org_id, email) - duplicate email in same org fails
      </test>

      <test id="AC-002.2" type="integration">
        - GET /api/settings/users → returns only users from current org (RLS)
        - GET with role filter → filters correctly
        - GET with status filter → filters correctly
        - GET with search → case-insensitive search on name/email works
      </test>

      <test id="AC-002.3" type="integration">
        - PUT /api/settings/users/:id → updates first_name, last_name, role, status
        - PUT with email change → fails (email immutable)
        - PUT → audit trail (updated_by, updated_at) populated correctly
      </test>

      <test id="AC-002.4" type="integration">
        - DELETE /api/settings/users/:id → status changed to 'inactive'
        - DELETE → SessionService.terminateAllSessions called
        - DELETE → JWT added to Redis blacklist
        - DELETE → subsequent API call with terminated JWT returns 401
      </test>

      <test id="AC-002.5" type="integration">
        - DELETE last admin → returns 400 error with message "Cannot deactivate the last admin user"
        - DELETE non-last admin → succeeds
        - PUT to change last admin to inactive → returns 400 error
      </test>

      <test id="AC-002.7" type="integration">
        - RLS Test: User A (Org 1) creates user → User B (Org 2) cannot see it
        - RLS Test: GET /api/settings/users cross-org isolation verified
        - Add to tests/integration/rls/users-rls.test.ts (Gap 4 suite)
      </test>

      <test id="all" type="e2e">
        - E2E: Login as admin → navigate to /settings/users → see user table
        - E2E: Click "Add User" → fill form → submit → user appears in table
        - E2E: Search for user by name → user filtered
        - E2E: Filter by role "admin" → only admins shown
        - E2E: Edit user → change role → verify updated in table
        - E2E: Deactivate user → confirm modal → user status = inactive
        - E2E: Try deactivate last admin → error shown in UI
        - E2E: Deactivate user in one browser → verify logged out in second browser (realtime test)
      </test>
    </ideas>
  </tests>
</story-context>
