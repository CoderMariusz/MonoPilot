<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1</storyId>
    <title>Enable pgAudit Extension</title>
    <status>drafted</status>
    <generatedAt>2025-11-16</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/1-1-enable-pgaudit-extension.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Compliance Officer / System Administrator</asA>
    <iWant>database-level audit trail using pgAudit PostgreSQL extension</iWant>
    <soThat>all data changes are logged immutably for FDA 21 CFR Part 11 compliance</soThat>
    <tasks>
### Task 1: Enable pgAudit Extension (AC-1) - 3 hours
- [ ] 1.1: Research pgAudit extension for Supabase/PostgreSQL
- [ ] 1.2: Enable pgAudit extension via Supabase dashboard or SQL
- [ ] 1.3: Configure pgAudit settings (pgaudit.log, pgaudit.log_catalog)
- [ ] 1.4: Test extension is active
- [ ] 1.5: Document configuration steps

### Task 2: Configure Audit Scope (AC-2) - 2 hours
- [ ] 2.1: Configure pgAudit to log all DML operations on public schema
- [ ] 2.2: Configure logging format (JSON preferred for parsing)
- [ ] 2.3: Test audit capture on sample tables (po_header, work_orders, license_plates)
- [ ] 2.4: Verify before/after values are captured
- [ ] 2.5: Exclude system tables from audit (pg_* tables)

### Task 3: Audit Log Access Layer (AC-3) - 4 hours
- [ ] 3.1: Create `audit_log_view` read-only view
- [ ] 3.2: Implement RLS policy for org_id filtering
- [ ] 3.3: Create `AuditLogsAPI` class with `getAll()` method
- [ ] 3.4: Implement filters: user, date range, table, operation type
- [ ] 3.5: Implement pagination (limit, offset)
- [ ] 3.6: Add unit tests for AuditLogsAPI

### Task 4: Audit Log UI (AC-4) - 6 hours
- [ ] 4.1: Create `/settings/audit-logs` page
- [ ] 4.2: Implement RBAC check (Admin/Manager only)
- [ ] 4.3: Build table view with columns: timestamp, user, operation, table, summary
- [ ] 4.4: Implement filter controls (date picker, user dropdown, table dropdown)
- [ ] 4.5: Implement CSV export functionality
- [ ] 4.6: Build detail modal with JSON diff view (before/after)
- [ ] 4.7: Add loading states and error handling

### Task 5: Performance Testing (AC-5) - 3 hours
- [ ] 5.1: Benchmark write performance with/without pgAudit (measure overhead)
- [ ] 5.2: Run stress test: 1000 concurrent writes
- [ ] 5.3: Monitor database size growth over 7 days
- [ ] 5.4: Implement log retention policy (DELETE audit logs >90 days)
- [ ] 5.5: Schedule retention job (daily cron or Supabase edge function)

### Task 6: E2E Tests (3 hours)
- [ ] 6.1: E2E test: Create PO → verify audit log entry
- [ ] 6.2: E2E test: Update WO → verify before/after captured
- [ ] 6.3: E2E test: Delete LP → verify delete operation logged
- [ ] 6.4: E2E test: Audit log UI loads and filters work
- [ ] 6.5: E2E test: CSV export downloads file

### Task 7: Documentation (AC-6) - 2 hours
- [ ] 7.1: Run `pnpm docs:update` to regenerate API docs
- [ ] 7.2: Update `docs/architecture.md` with pgAudit section
- [ ] 7.3: Document audit log schema and RLS policies
- [ ] 7.4: Add compliance section: FDA 21 CFR Part 11 audit trail
</tasks>
  </story>

  <acceptanceCriteria>
### AC-1: pgAudit Extension Installation
- pgAudit extension enabled on Supabase PostgreSQL database
- Extension configured to log all DML operations (INSERT, UPDATE, DELETE)
- Extension configured to log DDL operations (CREATE, ALTER, DROP)
- Audit logs stored in immutable format (append-only)
- Verify extension is active using `SELECT * FROM pg_extension WHERE extname='pgaudit';`

### AC-2: Audit Scope Configuration
- Configure pgAudit to audit all tables in `public` schema
- Configure audit to capture: user, timestamp, operation type, table name, row data (before/after)
- Exclude system tables from audit (performance optimization)
- Test audit capture on sample operations (create PO, update WO, delete LP)

### AC-3: Audit Log Access
- Create read-only view for audit log access: `audit_log_view`
- Implement RLS policy: users can only view audit logs for their org_id
- Create API endpoint: `GET /api/audit-logs` with filters (user, date range, table, operation)
- Pagination support (limit, offset)

### AC-4: Audit Log UI
- New page: `/settings/audit-logs` (Admin/Manager only)
- Table view: timestamp, user, operation, table, changes summary
- Filters: date range, user, table name, operation type
- Export to CSV functionality
- Detail modal: show full before/after JSON diff

### AC-5: Performance Testing
- Verify pgAudit overhead <5% on write operations
- Test with 1000 concurrent writes (stress test)
- Monitor database size growth (audit logs)
- Implement log retention policy (90 days default, configurable)

### AC-6: Documentation
- Update `docs/architecture.md` with pgAudit configuration
- Document audit log schema and access patterns
- Update `docs/API_REFERENCE.md` with `/api/audit-logs` endpoint
- Add compliance note: FDA 21 CFR Part 11 audit trail requirement
</acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/MonoPilot-PRD-2025-11-13.md" title="Main PRD" section="G4. Audit Trail & Electronic Signatures">
        pgAudit Extension features: Database-level audit trail, all data changes logged, immutable audit records. Compliance: FDA 21 CFR Part 11, EU GMP Annex 11. Electronic signatures system with JWT-based signatures for critical operations (WO release, BOM approval, QC approval).
      </doc>
      <doc path="docs/architecture.md" title="Architecture Document" section="Executive Summary">
        Multi-tenant SaaS with RLS (org_id isolation). Class-Based API Layer with 28 API classes. Technology Stack: Next.js 15, React 19, TypeScript 5.7, Supabase PostgreSQL 15 with RLS, Playwright (100+ E2E tests), Vitest unit tests.
      </doc>
      <doc path="docs/architecture.md" title="Architecture Document" section="Decision Summary">
        Decision #10: Audit Trail - Basic MVP (created_by/updated_by/timestamps) sufficient for MVP. pgAudit + e-signatures deferred to Growth (P2). Decision #5: Multi-Tenancy - RLS + Application-Level Filtering for bulletproof safety net.
      </doc>
    </docs>
    <code>
      <artifact path="apps/frontend/lib/api/users.ts" kind="API Class" symbol="UsersAPI" lines="1-50">
        Example API class pattern: static methods (getAll, getById, create), Supabase client usage, error handling, TypeScript types from lib/types
      </artifact>
      <artifact path="apps/frontend/lib/supabase/migrations/040_rls_policies.sql" kind="Migration" symbol="RLS Policies">
        Existing RLS pattern: Enable RLS on tables, create policies using org_id filtering with current_setting('app.current_org_id')::bigint for multi-tenant isolation
      </artifact>
      <artifact path="apps/frontend/e2e/01-auth.spec.ts" kind="E2E Test" symbol="Playwright Tests">
        E2E test pattern: Playwright framework, test structure for user workflows, authentication flow testing
      </artifact>
      <artifact path="apps/frontend/lib/types.ts" kind="TypeScript Types">
        Existing type definitions for domain entities (User, PurchaseOrder, WorkOrder, etc.) - will need AuditLog type
      </artifact>
    </code>
    <dependencies>
      <framework>Next.js 15 (App Router)</framework>
      <framework>React 19</framework>
      <framework>TypeScript 5.7</framework>
      <framework>Tailwind CSS 3.4</framework>
      <framework>Supabase PostgreSQL 15 with pgAudit extension support</framework>
      <testing>Playwright (E2E testing framework)</testing>
      <testing>Vitest (unit testing framework)</testing>
      <package>@supabase/supabase-js (client library)</package>
      <package>pnpm 8.15+ (package manager)</package>
      <package>Node.js >= 20.0.0</package>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="architectural">All API classes must be static class pattern with methods: getAll(), getById(), create(), update(), delete()</constraint>
    <constraint type="security">All database tables must have RLS policies with org_id filtering for multi-tenant isolation</constraint>
    <constraint type="testing">HIGH RISK features (RLS, multi-tenant) require E2E tests. COMPLEX features (JSON diff) require E2E tests.</constraint>
    <constraint type="documentation">After schema changes: run pnpm gen-types to regenerate Supabase types, then pnpm docs:update to update API_REFERENCE.md and DATABASE_SCHEMA.md</constraint>
    <constraint type="performance">pgAudit overhead must be <5% on write operations. Log retention policy required (90 days default)</constraint>
    <constraint type="mvp">MVP Scope: pgAudit extension + basic UI + RLS + CSV export. Defer: analytics, anomaly detection, archival to S3</constraint>
  </constraints>
  <interfaces>
    <interface name="AuditLogsAPI" kind="Class API">
      <signature>
        static async getAll(filters?: { user?: string, dateRange?: [Date, Date], table?: string, operation?: string }, pagination?: { limit: number, offset: number }): Promise&lt;AuditLog[]&gt;
      </signature>
      <path>apps/frontend/lib/api/auditLogs.ts</path>
    </interface>
    <interface name="GET /api/audit-logs" kind="REST endpoint">
      <signature>
        GET /api/audit-logs?user={user}&amp;from={date}&amp;to={date}&amp;table={table}&amp;operation={operation}&amp;limit={n}&amp;offset={n}
        Response: { data: AuditLog[], total: number }
      </signature>
      <path>apps/frontend/app/api/audit-logs/route.ts</path>
    </interface>
    <interface name="audit_log_view" kind="Database View">
      <signature>
        CREATE VIEW audit_log_view AS SELECT timestamp, user_id, operation, table_name, row_data_before, row_data_after, org_id FROM (pgaudit logs or dedicated audit table)
      </signature>
      <path>apps/frontend/lib/supabase/migrations/XXX_enable_pgaudit.sql</path>
    </interface>
  </interfaces>
  <tests>
    <standards>
      Risk-Based E2E Testing Strategy (from Epic 0 Retrospective): HIGH RISK features (multi-tenant isolation, RLS policies) require E2E tests. COMPLEX features (JSON diff rendering, UI interactions) require E2E tests. Simple features (filters, CSV export) can use unit tests only. Testing frameworks: Playwright for E2E (100+ existing tests), Vitest for unit tests (24/28 API classes tested - 86% coverage target). All E2E tests must verify multi-tenant isolation (user A cannot see user B's data).
    </standards>
    <locations>
      <e2e>apps/frontend/e2e/*.spec.ts</e2e>
      <unit>apps/frontend/__tests__/*.test.ts</unit>
      <unit>apps/frontend/lib/api/__tests__/*.test.ts</unit>
    </locations>
    <ideas>
      <test ac="AC-1" risk="HIGH">E2E: Enable pgAudit extension → verify extension is active using SELECT * FROM pg_extension</test>
      <test ac="AC-2" risk="HIGH">E2E: Create PO → verify audit log captures operation with user, timestamp, table, before/after data</test>
      <test ac="AC-2" risk="HIGH">E2E: Update WO → verify audit log captures before/after values</test>
      <test ac="AC-2" risk="HIGH">E2E: Delete LP → verify audit log captures delete operation</test>
      <test ac="AC-3" risk="CRITICAL">E2E: Multi-tenant RLS test - User A creates PO → User B (different org) cannot see audit log entry (RLS policy enforces org_id isolation)</test>
      <test ac="AC-4" risk="COMPLEX">E2E: Audit log UI loads → filters work (date range, user, table) → detail modal shows JSON diff (before/after)</test>
      <test ac="AC-4" risk="MEDIUM">E2E: CSV export downloads file with correct audit log data</test>
      <test ac="AC-5" risk="MEDIUM">Unit: Performance benchmark - write 1000 records with/without pgAudit → verify overhead <5%</test>
      <test ac="AC-3" risk="LOW">Unit: AuditLogsAPI.getAll() with filters → returns filtered results</test>
      <test ac="AC-3" risk="LOW">Unit: AuditLogsAPI.getAll() with pagination → returns correct limit/offset</test>
    </ideas>
  </tests>
</story-context>
