<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1.4</storyId>
    <title>Session Management</title>
    <status>drafted</status>
    <generatedAt>2025-11-20</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/1-4-session-management.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>User</asA>
    <iWant>see my active sessions and logout from all devices</iWant>
    <soThat>I can maintain security of my account</soThat>
    <tasks>
      - Task 1: Database Schema - Sessions Table (user_sessions with RLS, indexes, token tracking)
      - Task 2: Session Service - Core Logic (create, terminate, terminateAll, getSessions, updateLastActivity)
      - Task 3: Redis Blacklist - JWT Invalidation (blacklist operations with TTL)
      - Task 4: Device Info Parser (ua-parser-js library integration)
      - Task 5: GeoIP Lookup (Optional enhancement - skip for MVP)
      - Task 6: API Endpoints (GET sessions, DELETE all, DELETE individual)
      - Task 7: Auth Middleware Enhancement (blacklist check, last activity update)
      - Task 8: Supabase Realtime Integration (session termination events)
      - Task 9: Frontend Sessions Page (SessionsTable, logout all, terminate individual)
      - Task 10: Auto-Cleanup Expired Sessions (weekly cron job)
      - Task 11: Integration &amp; Testing (Unit, Integration, E2E tests)
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC-003.1">
      <title>User widzi listę active sessions</title>
      <details>
        - Navigate to /settings/users/:id/sessions (own profile) lub Admin viewing any user
        - Table columns: Device Info, IP Address, Location (city/country), Login Time, Last Activity, Status, Actions
        - Device Info: browser name, OS, device type (desktop/mobile/tablet)
        - Status: Active, Expired
        - Only active sessions displayed by default (filter to show expired)
      </details>
    </criterion>

    <criterion id="AC-003.2">
      <title>"Logout All Devices" functionality</title>
      <details>
        - Button visible on sessions page
        - Click → confirmation modal: "This will log you out of all devices except the current one"
        - On confirm: all sessions except current terminated
        - All JWT tokens added to Redis blacklist (TTL = token expiry)
        - Success toast: "Logged out from all devices"
        - Table refreshes showing only current session
      </details>
    </criterion>

    <criterion id="AC-003.3">
      <title>Admin może view i terminate any user's sessions</title>
      <details>
        - Admin navigates to /settings/users/:id/sessions for any user
        - Sees all active sessions for that user
        - Can terminate individual session (click "Terminate" action)
        - Can terminate all sessions for that user
        - Terminated user logged out immediately (within 1s via realtime)
      </details>
    </criterion>

    <criterion id="AC-003.4">
      <title>Session invalidation propagated via realtime</title>
      <details>
        - Terminated session triggers Supabase Realtime event: 'session.terminated'
        - All devices with that session listen for event
        - On event received: force logout (clear localStorage, redirect to login)
        - Show toast: "Your session has been terminated"
        - Propagation time: &lt;1s
      </details>
    </criterion>

    <criterion id="AC-003.5">
      <title>Session tracking on login</title>
      <details>
        - On successful login: create user_sessions record
        - Capture: device_info (user agent), IP address, location (GeoIP), login_time
        - JWT token_id stored in session record
        - Session marked as active (is_active = true)
      </details>
    </criterion>

    <criterion id="AC-003.6">
      <title>Session cleanup on logout</title>
      <details>
        - Normal logout: update user_sessions.is_active = false, set logged_out_at
        - Session remains in DB for audit trail (soft delete pattern)
        - JWT not blacklisted (natural expiry after 7 days)
      </details>
    </criterion>

    <criterion id="AC-003.7">
      <title>Expired sessions detection</title>
      <details>
        - Session expires if JWT exp claim passed
        - Expired sessions marked with Status = "Expired" in table
        - Auto-cleanup: delete expired sessions &gt;90 days old (weekly cron)
      </details>
    </criterion>

    <criterion id="AC-003.8">
      <title>Individual session termination</title>
      <details>
        - Click "Terminate" on specific session → confirmation modal
        - On confirm: that session terminated (JWT blacklisted, is_active = false)
        - Terminated device logged out immediately
        - Current session cannot be terminated (button disabled)
      </details>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-1.md</path>
        <title>Technical Specification - Epic 1 (Foundation &amp; Settings)</title>
        <section>FR-SET-003: Session Management</section>
        <snippet>Complete session tracking system with JWT blacklist, device tracking, realtime termination. Includes user_sessions table schema, Redis blacklist strategy with TTL, and multi-device logout patterns.</snippet>
      </doc>

      <doc>
        <path>docs/epics/epic-1-settings.md</path>
        <title>Epic 1: Foundation &amp; Settings</title>
        <section>Story 1.4: Session Management</section>
        <snippet>User story definition for multi-device session tracking and security-focused logout patterns.</snippet>
      </doc>

      <doc>
        <path>docs/architecture/index-architecture.md</path>
        <title>Architecture Index</title>
        <section>Security Patterns - Session Management</section>
        <snippet>JWT blacklist patterns, Redis TTL strategy, Supabase Realtime session termination propagation.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>app/lib/supabase/server.ts</path>
        <kind>lib</kind>
        <symbol>createClient</symbol>
        <lines>all</lines>
        <reason>Supabase server client for auth operations and realtime event emission</reason>
      </artifact>

      <artifact>
        <path>app/lib/types.ts</path>
        <kind>types</kind>
        <symbol>Database types</symbol>
        <lines>all</lines>
        <reason>TypeScript types for database tables - will be updated after user_sessions table migration</reason>
      </artifact>

      <artifact>
        <path>app/middleware.ts</path>
        <kind>middleware</kind>
        <symbol>middleware</symbol>
        <lines>all</lines>
        <reason>Next.js auth middleware - extend with JWT blacklist check and last activity updates</reason>
      </artifact>

      <artifact>
        <path>packages/shared/schemas.ts</path>
        <kind>schemas</kind>
        <symbol>Zod schemas</symbol>
        <lines>all</lines>
        <reason>Shared validation schemas - add UserSessionSchema if needed</reason>
      </artifact>

      <artifact>
        <path>packages/shared/types.ts</path>
        <kind>types</kind>
        <symbol>Shared types</symbol>
        <lines>all</lines>
        <reason>Shared TypeScript types - add UserSession interface</reason>
      </artifact>

      <artifact>
        <path>tests/support/helpers/auth-helper.ts</path>
        <kind>test-helper</kind>
        <symbol>AuthHelper</symbol>
        <lines>all</lines>
        <reason>Existing Supabase auth integration patterns - reuse for session testing</reason>
      </artifact>
    </code>

    <dependencies>
      <ecosystem name="node">
        <package name="@supabase/supabase-js" version="latest">Supabase client for realtime events and database</package>
        <package name="ua-parser-js" version="latest">Device info parsing from user agent (NEW - needs install)</package>
        <package name="ioredis" version="latest">Redis client for JWT blacklist (NEW - needs install)</package>
        <package name="@upstash/redis" version="latest">Alternative Redis client (Upstash compatible)</package>
      </ecosystem>

      <ecosystem name="shadcn">
        <component name="table">Sessions table component</component>
        <component name="dialog">Confirmation modals</component>
        <component name="badge">Status badges (Active, Expired)</component>
        <component name="toast">Success/error notifications</component>
        <component name="button">Action buttons</component>
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="architecture">
      <rule>Session Tracking: user_sessions table records all login sessions with device info, IP, timestamps</rule>
      <rule>JWT Blacklist: Redis with TTL = token expiry (efficient invalidation without memory leak)</rule>
      <rule>Realtime Logout: Supabase Realtime broadcast for &lt;1s session termination propagation</rule>
      <rule>Last Activity: Updated on each API request via middleware (shows when session last used)</rule>
    </constraint>

    <constraint type="security">
      <rule>JWT Token ID (jti): Supabase Auth JWT includes jti claim - store in user_sessions for blacklist lookup</rule>
      <rule>Blacklist Check: After JWT verification, check Redis blacklist before allowing API access</rule>
      <rule>Session Ownership: Users can only view/terminate own sessions (except Admin can view/terminate any)</rule>
      <rule>Current Session Protection: Cannot terminate own current session (prevents self-lockout)</rule>
      <rule>Audit Trail: All sessions logged with device info, IP, login/logout timestamps for security audits</rule>
    </constraint>

    <constraint type="data">
      <rule>user_sessions table: user_id FK, token_id UNIQUE, device_info, ip_address, location, is_active, timestamps</rule>
      <rule>Indexes REQUIRED: user_id, token_id, is_active for query performance</rule>
      <rule>NO RLS policy needed: user_id check in API layer (sessions accessed by user or admin only)</rule>
      <rule>Redis TTL: Calculate from JWT exp claim (seconds until natural expiry)</rule>
    </constraint>

    <constraint type="performance">
      <rule>Session list load (10 sessions): &lt;200ms</rule>
      <rule>Logout all devices: &lt;500ms (incl. Redis blacklist operations)</rule>
      <rule>Realtime propagation: &lt;1s (Supabase SLA)</rule>
      <rule>Last activity update: &lt;10ms (Redis write, non-blocking)</rule>
    </constraint>

    <constraint type="testing">
      <rule>Unit Tests: Device info parser, JWT blacklist add/check, session termination logic</rule>
      <rule>Integration Tests: Login → session created, GET sessions, DELETE all/single, blacklisted JWT → 401</rule>
      <rule>E2E Tests: Multi-browser session tracking, logout all devices, individual termination, admin control</rule>
      <rule>Realtime Tests: Session terminated event propagates to other devices within 1s</rule>
    </constraint>
  </constraints>

  <interfaces>
    <interface name="GET /api/settings/users/:id/sessions">
      <kind>REST endpoint</kind>
      <signature>
        Params: { id: UUID }
        Response: UserSession[]
        Auth: User (self) or Admin (any user)
        Returns: All active sessions (or all sessions if includeExpired=true)
      </signature>
      <path>app/api/settings/users/[id]/sessions/route.ts (NEW)</path>
    </interface>

    <interface name="DELETE /api/settings/users/:id/sessions">
      <kind>REST endpoint</kind>
      <signature>
        Params: { id: UUID }
        Response: { terminated_count: number }
        Auth: User (self) or Admin (any user)
        Side effects: All sessions terminated except current, JWTs blacklisted, realtime events emitted
      </signature>
      <path>app/api/settings/users/[id]/sessions/route.ts (NEW)</path>
    </interface>

    <interface name="DELETE /api/settings/users/:id/sessions/:sessionId">
      <kind>REST endpoint</kind>
      <signature>
        Params: { id: UUID, sessionId: UUID }
        Response: { success: boolean }
        Auth: User (self) or Admin (any user)
        Validation: Cannot terminate current session
        Side effects: Session terminated, JWT blacklisted, realtime event emitted
      </signature>
      <path>app/api/settings/users/[id]/sessions/[sessionId]/route.ts (NEW)</path>
    </interface>

    <interface name="SessionService.createSession">
      <kind>Service method</kind>
      <signature>
        async createSession(userId: string, tokenId: string, deviceInfo: string, ipAddress: string): Promise&lt;UserSession&gt;
        Returns: Created session object
        Side effects: Insert user_sessions record with parsed device info, GeoIP lookup (optional)
      </signature>
      <path>lib/services/SessionService.ts (NEW)</path>
    </interface>

    <interface name="SessionService.terminateSession">
      <kind>Service method</kind>
      <signature>
        async terminateSession(sessionId: string, userId: string): Promise&lt;boolean&gt;
        Returns: Success status
        Side effects: Update is_active=false, add JWT to Redis blacklist, emit Realtime event
      </signature>
      <path>lib/services/SessionService.ts (NEW)</path>
    </interface>

    <interface name="SessionService.terminateAllSessions">
      <kind>Service method</kind>
      <signature>
        async terminateAllSessions(userId: string, exceptCurrentToken: string): Promise&lt;number&gt;
        Returns: Count of terminated sessions
        Side effects: Terminate all sessions except current, blacklist all JWTs, emit events
      </signature>
      <path>lib/services/SessionService.ts (NEW)</path>
    </interface>

    <interface name="SessionService.getSessions">
      <kind>Service method</kind>
      <signature>
        async getSessions(userId: string, includeExpired?: boolean): Promise&lt;UserSession[]&gt;
        Returns: Sessions array sorted by last_activity DESC
      </signature>
      <path>lib/services/SessionService.ts (NEW)</path>
    </interface>

    <interface name="SessionService.updateLastActivity">
      <kind>Service method</kind>
      <signature>
        async updateLastActivity(tokenId: string): Promise&lt;void&gt;
        Side effects: Update last_activity timestamp (called on each API request via middleware)
      </signature>
      <path>lib/services/SessionService.ts (NEW)</path>
    </interface>

    <interface name="JWTBlacklistService.addToBlacklist">
      <kind>Service method</kind>
      <signature>
        async addToBlacklist(tokenId: string, expiresAt: Date): Promise&lt;boolean&gt;
        Returns: Success status
        Side effects: Store in Redis with key `blacklist:{tokenId}`, TTL = expiresAt - NOW
      </signature>
      <path>lib/services/JWTBlacklistService.ts (NEW)</path>
    </interface>

    <interface name="JWTBlacklistService.isBlacklisted">
      <kind>Service method</kind>
      <signature>
        async isBlacklisted(tokenId: string): Promise&lt;boolean&gt;
        Returns: Boolean (exists in Redis = blacklisted)
      </signature>
      <path>lib/services/JWTBlacklistService.ts (NEW)</path>
    </interface>

    <interface name="DeviceInfoParser.parseUserAgent">
      <kind>Utility function</kind>
      <signature>
        parseUserAgent(userAgent: string): string
        Returns: Formatted string "Chrome 120 on Windows 10 (Desktop)"
      </signature>
      <path>lib/utils/DeviceInfoParser.ts (NEW)</path>
    </interface>

    <interface name="Supabase Realtime Event: session.terminated">
      <kind>Realtime broadcast</kind>
      <signature>
        Event: 'session.terminated'
        Payload: { token_id: string }
        Channel: 'session_events'
        Client behavior: Check if token_id === current JWT jti, if match → force logout
      </signature>
      <path>Server: SessionService.terminateSession, Client: useRealtimeSessionTermination hook (NEW)</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing stack: Vitest for unit/integration tests, Playwright for E2E tests.
      Unit tests in same directory as source files (*.test.ts).
      Integration tests in tests/integration/.
      E2E tests in tests/e2e/ using Playwright with multi-browser support.
      Use @faker-js/faker for test data generation.
      Mock Redis for unit tests, use real Redis for integration tests.
      Mock SendGrid for unit tests.
      All session tests verify realtime propagation &lt;1s.
    </standards>

    <locations>
      - lib/services/SessionService.test.ts (Session CRUD, termination logic)
      - lib/services/JWTBlacklistService.test.ts (Redis blacklist operations)
      - lib/utils/DeviceInfoParser.test.ts (User agent parsing)
      - app/api/settings/users/[id]/sessions/**/*.test.ts (API endpoint tests)
      - tests/integration/sessions/ (Integration tests: DB + Redis + Realtime)
      - tests/e2e/settings/sessions.spec.ts (E2E multi-device session tracking)
    </locations>

    <ideas>
      <test id="AC-003.1" type="unit">
        - Parse various user agents: Chrome, Firefox, Safari, Edge, mobile browsers
        - Verify formatted output: "Browser Version on OS (Device Type)"
      </test>

      <test id="AC-003.2" type="integration">
        - Login → session created in DB with device info
        - GET sessions → returns all active sessions
        - DELETE all sessions → all terminated except current
        - Verify JWTs added to Redis blacklist with correct TTL
        - Verify realtime events emitted
      </test>

      <test id="AC-003.3" type="integration">
        - Admin GET /api/settings/users/:id/sessions → returns other user's sessions
        - Admin DELETE session → user logged out
        - Non-admin cannot access other user's sessions (403)
      </test>

      <test id="AC-003.4" type="integration">
        - Terminate session → realtime event emitted
        - Client receives event within 1s
        - Client with matching token_id logs out automatically
      </test>

      <test id="AC-003.5" type="integration">
        - Login → session record created with user_id, token_id, device_info, ip_address
        - Verify device info parsed correctly
        - Verify is_active = true
      </test>

      <test id="AC-003.6" type="integration">
        - Normal logout → is_active = false, logged_out_at set
        - Session remains in DB (not deleted)
        - JWT NOT blacklisted (natural expiry)
      </test>

      <test id="AC-003.7" type="integration">
        - Create expired session (login_time &gt; 90 days ago)
        - Weekly cron job deletes expired sessions
        - Active sessions not deleted
      </test>

      <test id="AC-003.8" type="integration">
        - DELETE individual session → session terminated
        - JWT blacklisted
        - Realtime event emitted
        - Cannot terminate current session (validation error)
      </test>

      <test id="all" type="e2e">
        - E2E: Login → view sessions page → current session visible
        - E2E: Open 2 browsers → login same user → both sessions visible
        - E2E: Logout all devices → both browsers logged out within 1s
        - E2E: Terminate individual session → specific browser logged out
        - E2E: Admin views other user's sessions → can terminate
        - E2E: Blacklisted JWT → 401 on next API request
      </test>
    </ideas>
  </tests>
</story-context>
