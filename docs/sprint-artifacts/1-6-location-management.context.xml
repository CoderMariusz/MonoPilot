<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1.6</storyId>
    <title>Location Management</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-20</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/1-6-location-management.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Admin</asA>
    <iWant>define locations within warehouses</iWant>
    <soThat>I can track where inventory is stored</soThat>
    <tasks>
      - Task 1: Database Schema - Locations Table (with RLS, indexes, constraints, CRITICAL idx_locations_warehouse)
      - Task 2: Barcode Generation Service (auto-generate LOC-{warehouse}-{seq}, QR code)
      - Task 3: Location Service - Core Logic (create, update, get, delete with validation)
      - Task 4: Zod Validation Schemas (CreateLocationSchema with zone/capacity refinements)
      - Task 5: API Endpoints (GET, POST, PUT, DELETE for /api/settings/locations)
      - Task 6: Frontend Locations List Page (nested under warehouse + global list)
      - Task 7: Location Form Modal (with zone/capacity toggles)
      - Task 8: Location Detail Page (with QR code display)
      - Task 9: Bulk Location Creation (CSV import - optional)
      - Task 10: QR Code Integration (qrcode library, print support)
      - Task 11: Cache Invalidation & Events (location.created/updated/deleted)
      - Task 12: Integration & Testing (Unit, Integration, E2E tests)
      - Task 13: Performance Optimization (CRITICAL: idx_locations_warehouse index)
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC-005.1">
      <title>Admin może stworzyć location</title>
      <details>
        - Navigate to /settings/warehouses/:id/locations or /settings/locations
        - Form fields: code (required, unique within warehouse, uppercase), name (required, max 100), warehouse_id (dropdown), type (required: Receiving, Production, Storage, Shipping, Transit, Quarantine), zone (optional, toggle-controlled), capacity (optional, toggle-controlled), barcode (auto-generated, can override), is_active (toggle, default true)
        - Validation: code unique within warehouse
        - On save: location created with auto-generated barcode
      </details>
    </criterion>

    <criterion id="AC-005.2">
      <title>Zone and capacity optional fields</title>
      <details>
        - zone_enabled toggle controls zone field visibility
        - If false: zone hidden, zone = NULL
        - If true: zone visible and required
        - capacity_enabled toggle controls capacity field visibility
        - If false: capacity hidden, capacity = NULL
        - If true: capacity visible and required (must be > 0)
        - Toggles stored in DB (zone_enabled, capacity_enabled boolean columns)
      </details>
    </criterion>

    <criterion id="AC-005.3">
      <title>Barcode auto-generated</title>
      <details>
        - Format: LOC-{warehouse_code}-{sequence}
        - Example: warehouse WH-01, sequence 001 → LOC-WH-01-001
        - Sequence: auto-increment per warehouse (1, 2, 3, ...)
        - User can override barcode (manual input), must be globally unique
        - Barcode displayed as QR code on location detail page
        - QR code generation: use qrcode library
      </details>
    </criterion>

    <criterion id="AC-005.4">
      <title>Locations table nested under warehouse</title>
      <details>
        - Navigate to /settings/warehouses/:id → "Locations" tab
        - Columns: Code, Name, Type, Zone, Capacity, Barcode, Active, Actions
        - Zone column: show zone name or "N/A" if zone_enabled = false
        - Capacity column: show number or "N/A" if capacity_enabled = false
        - Filter by type (All, 6 types)
        - Search by code or name
        - Sort by code, name, type, created_at
      </details>
    </criterion>

    <criterion id="AC-005.5">
      <title>Cannot delete location if used as warehouse default</title>
      <details>
        - FK constraint ON DELETE RESTRICT on warehouses.default_*_location_id
        - Error message: "Cannot delete - this is the default receiving location for Warehouse X"
        - Offer: "Change warehouse default first, then delete"
        - Archive option: set is_active = false (soft disable)
      </details>
    </criterion>

    <criterion id="AC-005.6">
      <title>Location detail page</title>
      <details>
        - Navigate to /settings/locations/:id
        - Display: code, name, warehouse, type, zone, capacity, barcode (as text + QR code)
        - QR code: scannable, contains location barcode
        - Actions: Edit, Archive/Activate, Print QR Code
        - Related entities: LPs in this location (Epic 5), WOs using this location (Epic 4)
      </details>
    </criterion>

    <criterion id="AC-005.7">
      <title>Bulk location creation</title>
      <details>
        - Option 1: CSV import (columns: code, name, type, zone, capacity)
        - Option 2: Quick Add mode (add multiple locations in single form)
        - Validation: check all codes unique, valid types
        - On save: all locations created, show success count
        - Error handling: show row-by-row errors if validation fails
      </details>
    </criterion>

    <criterion id="AC-005.8">
      <title>Cache invalidation events</title>
      <details>
        - On location create/update/delete: emit 'location.created/updated/deleted' event
        - Epic 4, 5, 6, 7 refetch location list on event
        - Redis cache TTL: 5 min
        - Cache key: `locations:{warehouse_id}`
      </details>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-1.md</path>
        <title>Technical Specification - Epic 1 (Foundation & Settings)</title>
        <section>FR-SET-005: Location Management</section>
        <snippet>Complete location management with barcode auto-generation, zone/capacity toggles, QR code support, critical warehouse index for performance.</snippet>
      </doc>

      <doc>
        <path>docs/epics/epic-1-settings.md</path>
        <title>Epic 1: Foundation & Settings</title>
        <section>Story 1.6: Location Management</section>
        <snippet>Location hierarchy within warehouses with auto-generated barcodes and QR code support for physical labeling.</snippet>
      </doc>

      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-1.md</path>
        <title>Technical Specification - Epic 1</title>
        <section>Critical Index Performance</section>
        <snippet>idx_locations_warehouse ON (warehouse_id) - CRITICAL: prevents 30s query on 500+ locations, must be created in migration.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>app/lib/supabase/server.ts</path>
        <kind>lib</kind>
        <symbol>createClient</symbol>
        <lines>all</lines>
        <reason>Supabase server client for database operations and realtime events</reason>
      </artifact>

      <artifact>
        <path>app/lib/types.ts</path>
        <kind>types</kind>
        <symbol>Database types</symbol>
        <lines>all</lines>
        <reason>TypeScript types for database tables - will be updated after locations table migration</reason>
      </artifact>

      <artifact>
        <path>packages/shared/schemas.ts</path>
        <kind>schemas</kind>
        <symbol>Zod schemas</symbol>
        <lines>all</lines>
        <reason>Shared validation schemas - add CreateLocationSchema and UpdateLocationSchema</reason>
      </artifact>

      <artifact>
        <path>packages/shared/types.ts</path>
        <kind>types</kind>
        <symbol>Shared types</symbol>
        <lines>all</lines>
        <reason>Shared TypeScript types - add Location interface and LocationType enum</reason>
      </artifact>

      <artifact>
        <path>tests/support/fixtures/factories/user-factory.ts</path>
        <kind>test-factory</kind>
        <symbol>UserFactory</symbol>
        <lines>all</lines>
        <reason>Test factory patterns - create LocationFactory for test data generation</reason>
      </artifact>
    </code>

    <dependencies>
      <ecosystem name="node">
        <package name="@supabase/supabase-js" version="latest">Supabase client for database and realtime</package>
        <package name="zod" version="latest">Schema validation (CreateLocationSchema, UpdateLocationSchema)</package>
        <package name="react-hook-form" version="latest">Form state management</package>
        <package name="swr" version="latest">Data fetching and caching (stale-while-revalidate)</package>
        <package name="qrcode" version="latest">QR code generation (NEW - needs install)</package>
        <package name="ioredis" version="latest">Redis client for caching</package>
      </ecosystem>

      <ecosystem name="shadcn">
        <component name="table">Locations table component</component>
        <component name="dialog">Location form modal, confirmation dialogs</component>
        <component name="drawer">Edit location drawer (alternative to dialog)</component>
        <component name="badge">Type badges (Receiving, Storage, etc.), status badges</component>
        <component name="switch">zone_enabled, capacity_enabled toggles</component>
        <component name="toast">Success/error notifications</component>
        <component name="select">Warehouse and type dropdowns</component>
        <component name="input">Form fields</component>
        <component name="tabs">Warehouse detail page tabs (Locations tab)</component>
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="architecture">
      <rule>Multi-tenancy: RLS policy on locations table (org_id isolation)</rule>
      <rule>Hierarchical Data: Locations belong to warehouses (parent-child relationship)</rule>
      <rule>Auto-Generated Barcode: LOC-{warehouse_code}-{sequence} format, globally unique</rule>
      <rule>Optional Fields: zone_enabled, capacity_enabled toggles control field visibility and requirement</rule>
      <rule>Soft Delete: is_active flag instead of hard delete (preserves history)</rule>
      <rule>Cache Invalidation: Events emitted on mutations, consumed by Epic 4, 5, 6, 7</rule>
      <rule>FK Constraints: ON DELETE RESTRICT prevents deletion if location is warehouse default</rule>
    </constraint>

    <constraint type="security">
      <rule>RLS Policy REQUIRED: org_id = (auth.jwt() ->> 'org_id')::uuid on locations table</rule>
      <rule>Admin Only: Only Admin role can create/edit/delete locations</rule>
      <rule>Cross-Org Isolation: Users cannot access locations from other organizations</rule>
      <rule>Audit Trail: created_by, updated_by tracked on all mutations</rule>
    </constraint>

    <constraint type="data">
      <rule>Unique Constraint: (org_id, warehouse_id, code) - location code unique within warehouse</rule>
      <rule>Unique Constraint: (barcode) - globally unique across all organizations</rule>
      <rule>Indexes REQUIRED: org_id, warehouse_id (CRITICAL), type, barcode for query performance</rule>
      <rule>Check Constraint: IF zone_enabled = true THEN zone NOT NULL</rule>
      <rule>Check Constraint: IF capacity_enabled = true THEN capacity > 0</rule>
      <rule>Location Types: receiving, production, storage, shipping, transit, quarantine (6 types)</rule>
      <rule>Barcode Format: LOC-{warehouse_code}-{sequence}, sequence auto-increment per warehouse</rule>
    </constraint>

    <constraint type="performance">
      <rule>Location list load (500 locations): &lt;300ms p95 (with idx_locations_warehouse)</rule>
      <rule>Create location: &lt;300ms</rule>
      <rule>Update location: &lt;250ms</rule>
      <rule>QR code generation: &lt;100ms</rule>
      <rule>Cache hit rate: &gt;80%</rule>
      <rule>CRITICAL INDEX: idx_locations_warehouse ON (warehouse_id) prevents 30s query on 500+ locations</rule>
    </constraint>

    <constraint type="testing">
      <rule>RLS Testing: MUST add to RLS test suite (Sprint 0 Gap 4)</rule>
      <rule>Integration Tests: MUST verify barcode generation, zone/capacity validation</rule>
      <rule>E2E Tests: MUST test location creation, QR code display, print functionality</rule>
      <rule>Performance Tests: MUST verify idx_locations_warehouse index usage with EXPLAIN</rule>
    </constraint>
  </constraints>

  <interfaces>
    <interface name="GET /api/settings/locations">
      <kind>REST endpoint</kind>
      <signature>
        Query: { warehouse_id, type?, is_active?, search? }
        Response: Location[] (with warehouse name)
        Auth: Authenticated user
        Cache: 5 min TTL (Redis)
        Filters: org_id (from JWT), warehouse_id, type, is_active, search (code/name case-insensitive)
      </signature>
      <path>app/api/settings/locations/route.ts (NEW)</path>
    </interface>

    <interface name="POST /api/settings/locations">
      <kind>REST endpoint</kind>
      <signature>
        Body: CreateLocationInput { warehouse_id, code, name, type, zone?, zone_enabled, capacity?, capacity_enabled, barcode?, is_active }
        Response: Location (with auto-generated barcode and QR code data URL)
        Auth: Admin only
        Validation: Code unique within warehouse, barcode globally unique, zone/capacity rules
        Side effects: Generate barcode if not provided, emit location.created event
      </signature>
      <path>app/api/settings/locations/route.ts (NEW)</path>
    </interface>

    <interface name="GET /api/settings/locations/:id">
      <kind>REST endpoint</kind>
      <signature>
        Params: { id: UUID }
        Response: Location (with QR code data URL, warehouse details)
        Auth: Authenticated user
      </signature>
      <path>app/api/settings/locations/[id]/route.ts (NEW)</path>
    </interface>

    <interface name="PUT /api/settings/locations/:id">
      <kind>REST endpoint</kind>
      <signature>
        Params: { id: UUID }
        Body: UpdateLocationInput { code?, name?, type?, zone?, zone_enabled?, capacity?, capacity_enabled?, barcode?, is_active? }
        Response: Location
        Auth: Admin only
        Validation: Code still unique if changed, barcode unique, zone/capacity rules
        Side effects: Emit location.updated event, invalidate cache
      </signature>
      <path>app/api/settings/locations/[id]/route.ts (NEW)</path>
    </interface>

    <interface name="DELETE /api/settings/locations/:id">
      <kind>REST endpoint</kind>
      <signature>
        Params: { id: UUID }
        Response: { success: boolean } or { error: string }
        Auth: Admin only
        Note: FK constraints prevent deletion if used as warehouse default
        Alternative: Soft delete (is_active = false)
        Side effects: Emit location.deleted event, invalidate cache
      </signature>
      <path>app/api/settings/locations/[id]/route.ts (NEW)</path>
    </interface>

    <interface name="BarcodeGeneratorService.generateLocationBarcode">
      <kind>Service method</kind>
      <signature>
        async generateLocationBarcode(warehouseCode: string, orgId: string): Promise&lt;string&gt;
        Returns: LOC-{warehouseCode}-{sequence.padStart(3, '0')}
        Logic: Query max sequence for warehouse, increment by 1
        Example: WH-01, sequence 1 → LOC-WH-01-001
      </signature>
      <path>lib/services/BarcodeGeneratorService.ts (NEW)</path>
    </interface>

    <interface name="BarcodeGeneratorService.generateQRCode">
      <kind>Service method</kind>
      <signature>
        async generateQRCode(barcode: string): Promise&lt;string&gt;
        Returns: Base64 data URL for QR code image
        Uses: qrcode library
        Size: 300x300px, error correction: Medium
      </signature>
      <path>lib/services/BarcodeGeneratorService.ts (NEW)</path>
    </interface>

    <interface name="LocationService.createLocation">
      <kind>Service method</kind>
      <signature>
        async createLocation(input: CreateLocationInput): Promise&lt;Location&gt;
        Validation: Code unique within warehouse, zone/capacity rules, barcode unique
        Side effects: Generate barcode if not provided, insert location, emit cache event
      </signature>
      <path>lib/services/LocationService.ts (NEW)</path>
    </interface>

    <interface name="LocationService.updateLocation">
      <kind>Service method</kind>
      <signature>
        async updateLocation(id: string, input: UpdateLocationInput): Promise&lt;Location&gt;
        Validation: Location exists + belongs to org, code unique, zone/capacity rules, barcode unique
        Side effects: Update location, emit cache event
      </signature>
      <path>lib/services/LocationService.ts (NEW)</path>
    </interface>

    <interface name="LocationService.getLocations">
      <kind>Service method</kind>
      <signature>
        async getLocations(warehouseId: string, filters?: LocationFilters): Promise&lt;Location[]&gt;
        Returns: Locations array with warehouse name (JOIN warehouses)
        Filters: type, is_active, search (code/name)
        Sort: By specified column (code, name, type, created_at)
      </signature>
      <path>lib/services/LocationService.ts (NEW)</path>
    </interface>

    <interface name="LocationService.deleteLocation">
      <kind>Service method</kind>
      <signature>
        async deleteLocation(id: string, orgId: string): Promise&lt;{ success: boolean, error?: string }&gt;
        Validation: Location exists + belongs to org, not used as warehouse default
        Note: FK constraints prevent deletion if has dependencies (catch error, return friendly message)
        Alternative: Soft delete (is_active = false)
        Side effects: Delete or soft delete, emit cache event
      </signature>
      <path>lib/services/LocationService.ts (NEW)</path>
    </interface>

    <interface name="CreateLocationSchema">
      <kind>Zod schema</kind>
      <signature>
        z.object({
          warehouse_id: z.string().uuid(),
          code: z.string().regex(/^[A-Z0-9-]+$/).min(2).max(50),
          name: z.string().min(1).max(100),
          type: z.enum(['receiving', 'production', 'storage', 'shipping', 'transit', 'quarantine']),
          zone: z.string().max(100).optional(),
          zone_enabled: z.boolean().default(false),
          capacity: z.number().positive().optional(),
          capacity_enabled: z.boolean().default(false),
          barcode: z.string().max(100).optional(),
          is_active: z.boolean().default(true)
        })
        .refine(data => !data.zone_enabled || data.zone, { message: 'Zone required when zone_enabled is true', path: ['zone'] })
        .refine(data => !data.capacity_enabled || data.capacity, { message: 'Capacity required when capacity_enabled is true', path: ['capacity'] })
      </signature>
      <path>packages/shared/schemas.ts</path>
    </interface>

    <interface name="UpdateLocationSchema">
      <kind>Zod schema</kind>
      <signature>
        CreateLocationSchema.extend({}) (all fields optional for partial update)
        Same refinements: zone/capacity validation
      </signature>
      <path>packages/shared/schemas.ts</path>
    </interface>

    <interface name="Cache Event: location.updated">
      <kind>Event emitter</kind>
      <signature>
        Event: 'location.created' | 'location.updated' | 'location.deleted'
        Payload: { type: string, org_id: string, warehouse_id: string, location_id: string, timestamp: Date }
        Consumers: Epic 4 (WO operations), Epic 5 (LP moves), Epic 6 (QA locations), Epic 7 (Shipping)
        Action: Invalidate Redis cache key `locations:{warehouse_id}`, refetch location list
      </signature>
      <path>Server: LocationService, Consumers: Epic 4/5/6/7 services</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing stack: Vitest for unit/integration tests, Playwright for E2E tests.
      Unit tests in same directory as source files (*.test.ts).
      Integration tests in tests/integration/.
      E2E tests in tests/e2e/ using Playwright.
      Use @faker-js/faker for test data generation.
      RLS tests MUST be added to tests/integration/rls/ suite (Sprint 0 Gap 4).
      Test factories in tests/support/fixtures/factories/.
      Performance tests MUST verify idx_locations_warehouse index usage.
    </standards>

    <locations>
      - lib/services/BarcodeGeneratorService.test.ts (Barcode generation, QR code generation)
      - lib/services/LocationService.test.ts (Location CRUD, validation logic)
      - packages/shared/schemas.test.ts (Zod schema validation tests)
      - app/api/settings/locations/**/*.test.ts (API endpoint tests)
      - tests/integration/locations/ (Integration tests: DB operations, barcode generation, cache invalidation)
      - tests/integration/rls/locations-rls.test.ts (RLS policy tests - add to Gap 4 suite)
      - tests/e2e/settings/locations.spec.ts (E2E location management flow)
    </locations>

    <ideas>
      <test id="AC-005.1" type="unit">
        - Validate CreateLocationSchema with valid inputs (all types)
        - Validate code format: uppercase + hyphens only (reject lowercase, special chars)
        - Validate type enum (reject invalid types)
      </test>

      <test id="AC-005.1" type="integration">
        - POST /api/settings/locations → location created with auto-generated barcode
        - Verify unique constraint (org_id, warehouse_id, code) - duplicate code in warehouse fails
        - Verify global unique barcode - duplicate barcode across orgs fails
        - RLS: User A (Org 1) creates location → User B (Org 2) cannot see it
      </test>

      <test id="AC-005.2" type="integration">
        - Create location with zone_enabled=false → zone NULL
        - Create location with zone_enabled=true, zone empty → validation error
        - Create location with capacity_enabled=true, capacity 0 → validation error
        - Update location: toggle zone_enabled off → zone cleared
      </test>

      <test id="AC-005.3" type="integration">
        - Barcode generation: correct format LOC-{warehouse}-{seq}
        - Barcode sequence increments per warehouse
        - Manual barcode override: saved if unique
        - Duplicate barcode validation: global uniqueness enforced
        - QR code generation: returns valid base64 data URL
      </test>

      <test id="AC-005.4" type="integration">
        - GET /api/settings/locations?warehouse_id=X → returns locations for warehouse
        - GET with type filter → filters correctly
        - GET with search → case-insensitive search on code/name works
        - Zone/capacity columns: show value or "N/A" based on enabled flags
      </test>

      <test id="AC-005.5" type="integration">
        - DELETE location used as warehouse default → FK constraint error
        - Error message includes warehouse name and default type
        - Soft delete (is_active=false) → succeeds
      </test>

      <test id="AC-005.6" type="e2e">
        - E2E: Navigate to location detail → QR code displayed
        - E2E: Print QR code → print dialog opens
      </test>

      <test id="AC-005.7" type="e2e">
        - E2E: CSV import → multiple locations created
        - E2E: CSV import with errors → show row-by-row validation errors
      </test>

      <test id="AC-005.8" type="integration">
        - Create location → location.created event emitted
        - Update location → location.updated event emitted
        - Redis cache key invalidated on mutation
        - Cache hit rate >80% after initial load
      </test>

      <test id="performance" type="integration">
        - Query 500 locations: verify idx_locations_warehouse used (EXPLAIN query)
        - Query time <300ms p95 with index
        - Without index: query takes >30s (regression test)
      </test>

      <test id="all" type="e2e">
        - E2E: Create location → appears in table with QR code
        - E2E: Search location by code → filtered correctly
        - E2E: Filter by type "Receiving" → only receiving locations shown
        - E2E: Edit location → toggle zone_enabled, zone field appears/disappears
        - E2E: Archive location → hidden from active list, visible in "All" filter
        - E2E: Cannot delete location used as default → error modal shown
        - E2E: Print QR code → print dialog opens with large QR code
      </test>
    </ideas>
  </tests>
</story-context>
