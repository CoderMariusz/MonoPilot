<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1.5</storyId>
    <title>Warehouse Configuration</title>
    <status>drafted</status>
    <generatedAt>2025-11-20</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/1-5-warehouse-configuration.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Admin</asA>
    <iWant>define warehouses with default locations</iWant>
    <soThat>inventory can be properly organized</soThat>
    <tasks>
      - Task 1: Database Schema - Warehouses Table (with RLS, indexes, FK constraints)
      - Task 2: Warehouse Service - Core Logic (create, update, get, delete with constraints)
      - Task 3: Zod Validation Schemas (CreateWarehouseSchema, UpdateWarehouseSchema with code regex)
      - Task 4: API Endpoints (GET, POST, PUT, DELETE with caching)
      - Task 5: Frontend Warehouses List Page (WarehousesTable, search, filter, sort)
      - Task 6: Warehouse Form Modal (create/edit with inline location creation)
      - Task 7: Archive/Activate Functionality (soft delete with constraint handling)
      - Task 8: Cache Invalidation &amp; Events (Redis cache, realtime events for Epic 3/5/7)
      - Task 9: Circular Dependency Handling (3-step setup: warehouse → locations → defaults)
      - Task 10: Integration &amp; Testing (Unit, Integration, E2E tests)
      - Task 11: Performance Optimization (indexes, Redis caching, SWR)
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC-004.1">
      <title>Admin może stworzyć warehouse</title>
      <details>
        - Navigate to /settings/warehouses
        - Click "Add Warehouse" button
        - Form fields: code (required, unique per org, uppercase alphanumeric + hyphens), name (required, max 100 chars), address (optional, multi-line text), is_active (toggle, default true)
        - Validation: code unique constraint checked, show error if duplicate
        - On save: warehouse created with default_*_location_id = NULL initially
      </details>
    </criterion>

    <criterion id="AC-004.2">
      <title>Default locations nullable initially</title>
      <details>
        - default_receiving_location_id: FK → locations (nullable)
        - default_shipping_location_id: FK → locations (nullable)
        - transit_location_id: FK → locations (nullable)
        - These are set after locations are created (Story 1.6)
        - Circular dependency resolution: create warehouse → create locations → update defaults
      </details>
    </criterion>

    <criterion id="AC-004.3">
      <title>Warehouses list view</title>
      <details>
        - Table columns: Code, Name, Address, Receiving Location, Shipping Location, Transit Location, Active, Actions
        - Search by code or name
        - Filter by is_active (Active, Inactive, All)
        - Sort by code, name, created_at
        - Location columns show location code or "Not set" if NULL
      </details>
    </criterion>

    <criterion id="AC-004.4">
      <title>Cannot delete warehouse with constraints</title>
      <details>
        - FK constraint ON DELETE RESTRICT prevents deletion if: warehouse has active POs (Epic 3), warehouse has active LPs (Epic 5), warehouse has active locations (Story 1.6)
        - Error message: "Cannot delete warehouse - it has X active entities. Archive it instead."
        - Archive option: set is_active = false (soft disable)
      </details>
    </criterion>

    <criterion id="AC-004.5">
      <title>Edit warehouse</title>
      <details>
        - Click Edit action → drawer opens with form
        - All fields editable (code, name, address, default locations, is_active)
        - Default location dropdowns filtered to locations within this warehouse
        - Can update default locations after locations created
        - Validation: code still unique per org
        - On save: warehouse updated, cache invalidated
      </details>
    </criterion>

    <criterion id="AC-004.6">
      <title>Inline location creation</title>
      <details>
        - When selecting default locations, show "+ Create Location" option
        - Opens location creation modal (from Story 1.6)
        - After creating location, it's auto-selected in dropdown
        - Enables quick setup: create warehouse → create key locations → assign defaults
      </details>
    </criterion>

    <criterion id="AC-004.7">
      <title>Warehouse card/list view toggle</title>
      <details>
        - Default: Table view (compact, sortable, searchable)
        - Toggle to Card view (visual, shows more details per warehouse)
        - Card shows: code, name, address, default locations, active status
        - Card actions: Edit, Archive/Activate, View Locations
      </details>
    </criterion>

    <criterion id="AC-004.8">
      <title>Cache invalidation events</title>
      <details>
        - On warehouse create/update/delete: emit 'warehouse.updated' event
        - Epic 3, 5, 7 invalidate warehouse cache on event
        - Redis cache TTL: 5 min
        - Cache key: `warehouses:{org_id}`
      </details>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-1.md</path>
        <title>Technical Specification - Epic 1 (Foundation &amp; Settings)</title>
        <section>FR-SET-004: Warehouse Configuration</section>
        <snippet>Complete warehouse management with default location assignments, circular dependency resolution, cache invalidation events for Epic 3/5/7. Includes warehouses table schema, unique constraints, FK patterns.</snippet>
      </doc>

      <doc>
        <path>docs/epics/epic-1-settings.md</path>
        <title>Epic 1: Foundation &amp; Settings</title>
        <section>Story 1.5: Warehouse Configuration</section>
        <snippet>Multi-warehouse support with default receiving/shipping/transit locations for inventory organization.</snippet>
      </doc>

      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-1.md</path>
        <title>Technical Specification - Epic 1</title>
        <section>Circular Dependency Resolution</section>
        <snippet>3-step warehouse setup flow: create warehouse (defaults NULL) → create locations (Story 1.6) → update warehouse defaults. Prevents FK constraint issues.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>app/lib/supabase/server.ts</path>
        <kind>lib</kind>
        <symbol>createClient</symbol>
        <lines>all</lines>
        <reason>Supabase server client for database operations and realtime events</reason>
      </artifact>

      <artifact>
        <path>app/lib/types.ts</path>
        <kind>types</kind>
        <symbol>Database types</symbol>
        <lines>all</lines>
        <reason>TypeScript types for database tables - will be updated after warehouses table migration</reason>
      </artifact>

      <artifact>
        <path>packages/shared/schemas.ts</path>
        <kind>schemas</kind>
        <symbol>Zod schemas</symbol>
        <lines>all</lines>
        <reason>Shared validation schemas - add CreateWarehouseSchema and UpdateWarehouseSchema</reason>
      </artifact>

      <artifact>
        <path>packages/shared/types.ts</path>
        <kind>types</kind>
        <symbol>Shared types</symbol>
        <lines>all</lines>
        <reason>Shared TypeScript types - add Warehouse interface</reason>
      </artifact>

      <artifact>
        <path>tests/support/fixtures/factories/user-factory.ts</path>
        <kind>test-factory</kind>
        <symbol>UserFactory</symbol>
        <lines>all</lines>
        <reason>Test factory patterns - create WarehouseFactory for test data generation</reason>
      </artifact>
    </code>

    <dependencies>
      <ecosystem name="node">
        <package name="@supabase/supabase-js" version="latest">Supabase client for database and realtime</package>
        <package name="zod" version="latest">Schema validation (CreateWarehouseSchema, UpdateWarehouseSchema)</package>
        <package name="react-hook-form" version="latest">Form state management</package>
        <package name="swr" version="latest">Data fetching and caching (stale-while-revalidate)</package>
        <package name="ioredis" version="latest">Redis client for caching (NEW - needs install)</package>
        <package name="@upstash/redis" version="latest">Alternative Redis client (Upstash compatible)</package>
      </ecosystem>

      <ecosystem name="shadcn">
        <component name="table">Warehouses table component</component>
        <component name="dialog">Warehouse form modal, confirmation dialogs</component>
        <component name="drawer">Edit warehouse drawer (alternative to dialog)</component>
        <component name="badge">Status badges (Active, Inactive, "Not set")</component>
        <component name="switch">is_active toggle</component>
        <component name="toast">Success/error notifications</component>
        <component name="select">Location dropdowns with search</component>
        <component name="input">Form fields</component>
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="architecture">
      <rule>Multi-tenancy: RLS policy on warehouses table (org_id isolation)</rule>
      <rule>Circular Dependency: 3-step setup (warehouse → locations → update defaults) to prevent FK issues</rule>
      <rule>Soft Delete: is_active flag instead of hard delete (preserves history, prevents FK constraint violations)</rule>
      <rule>Cache Invalidation: Events emitted on mutations (warehouse.created, warehouse.updated, warehouse.deleted) consumed by Epic 3, 5, 7</rule>
      <rule>FK Constraints: ON DELETE RESTRICT prevents accidental data loss (locations, POs, LPs reference warehouses)</rule>
    </constraint>

    <constraint type="security">
      <rule>RLS Policy REQUIRED: org_id = (auth.jwt() ->> 'org_id')::uuid on warehouses table</rule>
      <rule>Admin Only: Only Admin role can create/edit/delete warehouses</rule>
      <rule>Cross-Org Isolation: Users cannot access warehouses from other organizations</rule>
      <rule>Audit Trail: created_by, updated_by tracked on all mutations</rule>
    </constraint>

    <constraint type="data">
      <rule>Unique Constraint: (org_id, code) - warehouse code unique per organization</rule>
      <rule>Indexes REQUIRED: org_id, code, is_active for query performance</rule>
      <rule>Code Format: Uppercase alphanumeric + hyphens only (regex: ^[A-Z0-9-]+$)</rule>
      <rule>Default Locations: FK → locations (nullable initially, updated after locations created)</rule>
      <rule>FK Constraint: default_*_location_id ON DELETE RESTRICT (cannot delete location if it's a warehouse default)</rule>
    </constraint>

    <constraint type="performance">
      <rule>Warehouse list load (100 warehouses): &lt;200ms p95</rule>
      <rule>Create warehouse: &lt;300ms</rule>
      <rule>Update warehouse: &lt;250ms</rule>
      <rule>Redis cache: 5 min TTL, invalidate on create/update/delete</rule>
      <rule>Cache hit rate: &gt;80%</rule>
    </constraint>

    <constraint type="integration">
      <rule>Story 1.1 Dependency: Organizations table must exist (org_id FK)</rule>
      <rule>Story 1.6 Dependency: Locations table created in parallel (mutual FK relationship)</rule>
      <rule>Epic 3 Dependency: Purchase Orders reference warehouse_id (cache consumption)</rule>
      <rule>Epic 5 Dependency: License Plates reference warehouse_id (cache consumption)</rule>
      <rule>Epic 7 Dependency: Sales Orders reference warehouse_id (cache consumption)</rule>
    </constraint>
  </constraints>

  <interfaces>
    <interface name="GET /api/settings/warehouses">
      <kind>REST endpoint</kind>
      <signature>
        Query: { is_active?: boolean, search?: string }
        Response: Warehouse[] (with location names for default receiving/shipping/transit)
        Auth: Authenticated user
        Cache: 5 min TTL (Redis)
        Filters: org_id (from JWT), is_active, search (code/name case-insensitive)
      </signature>
      <path>app/api/settings/warehouses/route.ts (NEW)</path>
    </interface>

    <interface name="POST /api/settings/warehouses">
      <kind>REST endpoint</kind>
      <signature>
        Body: CreateWarehouseInput { code, name, address?, is_active }
        Response: Warehouse
        Auth: Admin only
        Validation: Unique code per org, code format (uppercase, alphanumeric, hyphens)
        Side effects: Cache invalidated, warehouse.created event emitted
      </signature>
      <path>app/api/settings/warehouses/route.ts (NEW)</path>
    </interface>

    <interface name="PUT /api/settings/warehouses/:id">
      <kind>REST endpoint</kind>
      <signature>
        Params: { id: UUID }
        Body: UpdateWarehouseInput { code?, name?, address?, default_receiving_location_id?, default_shipping_location_id?, transit_location_id?, is_active? }
        Response: Warehouse
        Auth: Admin only
        Validation: Code still unique if changed, default locations belong to this warehouse
        Side effects: Cache invalidated, warehouse.updated event emitted
      </signature>
      <path>app/api/settings/warehouses/[id]/route.ts (NEW)</path>
    </interface>

    <interface name="DELETE /api/settings/warehouses/:id">
      <kind>REST endpoint</kind>
      <signature>
        Params: { id: UUID }
        Response: { success: boolean } or { error: string }
        Auth: Admin only
        Note: FK constraints may prevent deletion (locations, POs, LPs reference warehouse)
        Alternative: Return friendly error message suggesting Archive instead
        Side effects: Cache invalidated, warehouse.deleted event emitted
      </signature>
      <path>app/api/settings/warehouses/[id]/route.ts (NEW)</path>
    </interface>

    <interface name="WarehouseService.createWarehouse">
      <kind>Service method</kind>
      <signature>
        async createWarehouse(input: CreateWarehouseInput): Promise&lt;Warehouse&gt;
        Returns: Created warehouse object (default locations = NULL)
        Validation: Code unique per org, code format validation
        Side effects: Insert warehouse record, emit cache event
      </signature>
      <path>lib/services/WarehouseService.ts (NEW)</path>
    </interface>

    <interface name="WarehouseService.updateWarehouse">
      <kind>Service method</kind>
      <signature>
        async updateWarehouse(id: string, input: UpdateWarehouseInput): Promise&lt;Warehouse&gt;
        Returns: Updated warehouse object
        Validation: Warehouse exists + belongs to org, code still unique, default locations belong to warehouse
        Side effects: Update warehouse record, emit cache event
      </signature>
      <path>lib/services/WarehouseService.ts (NEW)</path>
    </interface>

    <interface name="WarehouseService.getWarehouses">
      <kind>Service method</kind>
      <signature>
        async getWarehouses(orgId: string, filters?: WarehouseFilters): Promise&lt;Warehouse[]&gt;
        Returns: Warehouses array with related location names (JOIN locations for defaults)
        Filters: is_active, search (code/name)
        Sort: By specified column (code, name, created_at)
      </signature>
      <path>lib/services/WarehouseService.ts (NEW)</path>
    </interface>

    <interface name="WarehouseService.deleteWarehouse">
      <kind>Service method</kind>
      <signature>
        async deleteWarehouse(id: string, orgId: string): Promise&lt;{ success: boolean, error?: string }&gt;
        Returns: Success status or friendly error message
        Validation: Warehouse exists + belongs to org
        Note: FK constraints prevent deletion if has dependencies (catch error, return friendly message)
        Alternative: Soft delete (is_active = false)
        Side effects: Delete warehouse or set is_active=false, emit cache event
      </signature>
      <path>lib/services/WarehouseService.ts (NEW)</path>
    </interface>

    <interface name="CreateWarehouseSchema">
      <kind>Zod schema</kind>
      <signature>
        z.object({
          code: z.string().regex(/^[A-Z0-9-]+$/, 'Code must be uppercase, numbers, hyphens only').min(2).max(50),
          name: z.string().min(1, 'Name is required').max(100, 'Name must be at most 100 characters'),
          address: z.string().optional(),
          is_active: z.boolean().default(true)
        })
      </signature>
      <path>packages/shared/schemas.ts</path>
    </interface>

    <interface name="UpdateWarehouseSchema">
      <kind>Zod schema</kind>
      <signature>
        CreateWarehouseSchema.extend({
          default_receiving_location_id: z.string().uuid().optional(),
          default_shipping_location_id: z.string().uuid().optional(),
          transit_location_id: z.string().uuid().optional()
        })
        Note: All fields optional in UpdateWarehouseSchema (partial update support)
      </signature>
      <path>packages/shared/schemas.ts</path>
    </interface>

    <interface name="Cache Event: warehouse.updated">
      <kind>Event emitter</kind>
      <signature>
        Event: 'warehouse.updated'
        Payload: { type: 'warehouse.updated', org_id: string, warehouse_id: string, timestamp: Date }
        Consumers: Epic 3 (PO receiving), Epic 5 (LP storage), Epic 7 (Shipping)
        Action: Invalidate Redis cache key `warehouses:{org_id}`, refetch warehouse list
      </signature>
      <path>Server: WarehouseService, Consumers: Epic 3/5/7 services</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing stack: Vitest for unit/integration tests, Playwright for E2E tests.
      Unit tests in same directory as source files (*.test.ts).
      Integration tests in tests/integration/.
      E2E tests in tests/e2e/ using Playwright.
      Use @faker-js/faker for test data generation.
      RLS tests MUST be added to tests/integration/rls/ suite (Sprint 0 Gap 4).
      Test factories in tests/support/fixtures/factories/.
    </standards>

    <locations>
      - lib/services/WarehouseService.test.ts (Warehouse CRUD, validation logic)
      - packages/shared/schemas.test.ts (Zod schema validation tests)
      - app/api/settings/warehouses/**/*.test.ts (API endpoint tests)
      - tests/integration/warehouses/ (Integration tests: DB operations, cache invalidation)
      - tests/integration/rls/warehouses-rls.test.ts (RLS policy tests - add to Gap 4 suite)
      - tests/e2e/settings/warehouses.spec.ts (E2E warehouse management flow)
    </locations>

    <ideas>
      <test id="AC-004.1" type="unit">
        - Validate CreateWarehouseSchema with valid inputs (various code formats)
        - Validate code format: uppercase + hyphens only (reject lowercase, special chars)
        - Validate name max length (reject &gt;100 chars)
      </test>

      <test id="AC-004.1" type="integration">
        - POST /api/settings/warehouses → warehouse created with default locations = NULL
        - Verify unique constraint (org_id, code) - duplicate code in same org fails
        - Verify RLS: User A (Org 1) creates warehouse → User B (Org 2) cannot see it
      </test>

      <test id="AC-004.2" type="integration">
        - Create warehouse → default locations NULL initially
        - Update warehouse → set default location IDs after locations created (Story 1.6)
        - Validation: default locations must belong to this warehouse (FK check)
      </test>

      <test id="AC-004.3" type="integration">
        - GET /api/settings/warehouses → returns warehouses with location names
        - GET with is_active filter → filters correctly
        - GET with search → case-insensitive search on code/name works
        - Location columns: show code or "Not set" if NULL
      </test>

      <test id="AC-004.4" type="integration">
        - DELETE warehouse with locations → FK constraint error
        - Catch error → return friendly message "Cannot delete - X active entities. Archive instead?"
        - Archive warehouse (is_active = false) → succeeds
      </test>

      <test id="AC-004.5" type="integration">
        - PUT /api/settings/warehouses/:id → updates all fields
        - PUT with code change → validates still unique per org
        - PUT with default locations → validates locations belong to warehouse
        - PUT → cache invalidated, warehouse.updated event emitted
      </test>

      <test id="AC-004.6" type="e2e">
        - E2E: Create warehouse → inline create location → location auto-selected in dropdown
        - Verify location dropdown shows only locations within warehouse
      </test>

      <test id="AC-004.7" type="e2e">
        - E2E: Toggle table/card view → state persists in localStorage
        - Card view shows all warehouse details
      </test>

      <test id="AC-004.8" type="integration">
        - Create warehouse → warehouse.created event emitted
        - Update warehouse → warehouse.updated event emitted
        - Redis cache key invalidated on mutation
        - Cache hit rate &gt;80% after initial load
      </test>

      <test id="all" type="e2e">
        - E2E: Create warehouse → appears in list
        - E2E: Search warehouse by code → filtered correctly
        - E2E: Filter by Active → only active warehouses shown
        - E2E: Edit warehouse → changes saved, cache refreshed
        - E2E: Archive warehouse → hidden from active list, visible in "All" filter
        - E2E: Activate warehouse → visible in active list again
        - E2E: Cannot delete warehouse with locations → error modal shown with Archive option
      </test>
    </ideas>
  </tests>
</story-context>
