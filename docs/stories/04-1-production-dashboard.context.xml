<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <story-id>04-1-production-dashboard</story-id>
    <epic>Epic 4 - Production Execution</epic>
    <priority>P0 (MVP)</priority>
    <story-points>3</story-points>
    <estimated-effort>1 day</estimated-effort>
    <status>drafted</status>
    <created>2025-11-27</created>
  </metadata>

  <!-- ============================================================================ -->
  <!-- STORY CONTENT -->
  <!-- ============================================================================ -->

  <story-content>
    <goal>
      Create a real-time production dashboard showing KPIs, active work orders, and alerts
      for production managers to monitor operations.
    </goal>

    <user-story>
      As a Production Manager
      I want to see real-time production KPIs (orders completed today, units produced, yield,
      active WOs, material shortages)
      So that I can monitor operations and respond quickly to issues
    </user-story>

    <problem-statement>
      Production managers currently have no centralized view of:
      1. Today's production metrics (orders completed, units, yield)
      2. Active work orders and their progress
      3. Real-time alerts (shortages, delays, quality holds)
      4. Auto-refreshing dashboard for real-time monitoring
    </problem-statement>

    <key-acceptance-criteria>
      <criterion id="AC-4.1.1">
        Dashboard KPI Cards displaying:
        - Orders Today: COUNT(work_orders WHERE completed_at >= TODAY)
        - Units Produced: SUM(production_outputs.quantity WHERE created_at >= TODAY)
        - Avg Yield: Weighted SUM(actual_output)/SUM(planned_qty) × 100% for WOs completed today
        - Active WOs: COUNT(work_orders WHERE status IN ['in_progress', 'paused'])
        - Material Shortages: COUNT(wo_materials WHERE available_qty &lt; required_qty)
        Color coding: Green >=95%, Yellow 80-95%, Red &lt;80%
      </criterion>

      <criterion id="AC-4.1.2">
        Active Work Orders Table with columns:
        - WO Number (clickable link to detail page)
        - Product (from products table)
        - Quantity (Planned vs actual output)
        - Status (in_progress, paused)
        - Progress (visual bar: actual_output / planned_qty)
        - Started (timestamp)
        - Line (production line assignment)
        - Actions (View, Pause/Resume buttons)
        Sorted by started_at ascending, max 10 rows with pagination
      </criterion>

      <criterion id="AC-4.1.3">
        Alerts Panel displaying:
        - Material Shortage (wo_materials.available_qty &lt; required_qty)
        - WO Delayed (WO > scheduled_date + 4 hours)
        - Quality Hold (QA status = 'hold' on input LP)
        Max 5 alerts, sorted by severity (Critical > Warning) then timestamp
      </criterion>

      <criterion id="AC-4.1.4">
        Auto-Refresh Mechanism:
        - Dashboard auto-refreshes every X seconds (configurable via production_settings.dashboard_refresh_seconds)
        - Default: 30 seconds, Range: 30-300 seconds
        - Manual refresh button available
        - Visual indicator: "Last updated: X seconds ago"
      </criterion>

      <criterion id="AC-4.1.5">
        API Endpoints:
        - GET /api/production/dashboard/kpis → {orders_today, units_produced_today, avg_yield_today, active_wos, material_shortages}
        - GET /api/production/dashboard/active-wos → [{id, wo_number, product_name, planned_qty, output_qty, status, progress_percent, started_at, line_name}]
        - GET /api/production/dashboard/alerts → [{id, type, severity, description, wo_id, created_at}]
        All endpoints enforce org_id isolation and authentication
      </criterion>

      <criterion id="AC-4.1.6">
        Permission & Role-Based Access:
        - Production Manager: Full access, can pause/resume
        - Operator: Read-only (no pause/resume)
        - Planner: Read-only (for planning reference)
        - Admin: Full access
        - Other roles: 403 Forbidden
      </criterion>

      <criterion id="AC-4.1.7">
        Responsive Design:
        - Desktop (>1200px): 2-column layout (KPIs left, alerts right)
        - Tablet (768-1200px): Stacked layout, full width
        - Mobile (&lt;768px): Single column, KPIs collapse to summary row
        - Table scrollable on mobile (horizontal)
        - All buttons touch-friendly (>44px) on mobile
      </criterion>

      <criterion id="AC-4.1.8">
        Empty State & Loading States:
        - Loading state: Skeleton screens for KPIs, table, alerts
        - Error state: "Failed to load dashboard. Retry?" button
        - Empty KPIs: Show "0" with appropriate message
        - Empty table: "No active work orders"
        - Empty alerts: "No active alerts"
      </criterion>
    </key-acceptance-criteria>

    <implementation-tasks>
      <task-phase name="Phase 1: Database & Service Layer">
        - Review production_settings table for dashboard_refresh_seconds config
        - Create dashboard service methods: getKPIs(), getActiveWorkOrders(), getAlerts()
        - Add org_id isolation and error handling to all methods
      </task-phase>

      <task-phase name="Phase 2: API Routes">
        - Create /api/production/dashboard/kpis endpoint
        - Create /api/production/dashboard/active-wos endpoint
        - Create /api/production/dashboard/alerts endpoint
        - Add request validation and proper HTTP status codes
      </task-phase>

      <task-phase name="Phase 3: Frontend UI">
        - Create /app/production/dashboard/page.tsx
        - Create KPI cards component (4 cards, color-coded)
        - Create Active WOs table component with sorting
        - Create Alerts panel component with type/severity icons
        - Implement auto-refresh logic (useEffect with interval)
        - Add loading skeleton screens and empty states
        - Implement responsive breakpoints
      </task-phase>

      <task-phase name="Phase 4: Testing">
        - Unit tests: Service layer (getKPIs, getActiveWorkOrders, getAlerts) - 95% coverage
        - Integration tests: API endpoints (200 OK, 401, 403) - 70% coverage
        - E2E tests: Full user journey (dashboard load, auto-refresh, interactions) - 100% critical path
      </task-phase>
    </implementation-tasks>
  </story-content>

  <!-- ============================================================================ -->
  <!-- UX DESIGN SPECIFICATION -->
  <!-- ============================================================================ -->

  <ux-design>
    <shared-system>
      <reference>docs/ux-design/ux-design-shared-system.md</reference>
      <components-used>
        <component>ModuleHeader - Production | Dashboard | Active WOs | Completed | Yields | ⚙️</component>
        <component>Stats Cards - 5 KPI cards (120px height, 2×2 grid)</component>
        <component>Colors - app-colors.ts (green Create, gray View/Edit, red Delete)</component>
        <component>Mobile Responsive - Tables → Card view on &lt; 768px</component>
        <component>Dark Mode - Settings → Appearance</component>
        <component>Keyboard Navigation - Tab, Enter, Escape</component>
      </components-used>
    </shared-system>

    <production-specific>
      <reference>docs/ux-design/ux-design-production-module.md</reference>
      <features>
        <feature name="Real-Time Dashboard (Variant B)">
          KPI Cards Section (Top, 140px height):
          - 5 KPI cards (Orders Today, Units Produced, Avg Yield, Active WOs, Material Shortages)
          - Horizontal scroll if needed
          - Click card → drill-down modal

          Active WOs Table (Middle):
          - Columns: WO#, Product, Quantity, Status, Progress, Started, Line, Actions
          - Progress bars with color coding (green >=100%, yellow 50-99%, gray 0-49%)
          - Pause button visible only if status = 'in_progress'
          - Resume button visible only if status = 'paused'

          Alerts Feed (Bottom, 120px height):
          - Latest 5 alerts (horizontal scroll)
          - Live indicator (LIVE Updated 3s ago)
          - Alert types: Critical (red), Warning (amber)
          - Click alert → open related WO modal

          Real-Time Updates:
          - Auto-refresh every 30 seconds (configurable)
          - Live indicator shows last update time
          - No flash/flicker on refresh
        </feature>

        <feature name="Mobile/Tablet View (1280×800)">
          - Single-column layout
          - Larger touch targets (48px minimum)
          - Simplified KPIs
          - Swipe gestures (swipe down → refresh)
        </feature>
      </features>
    </production-specific>

    <color-palette>
      <color name="PRIMARY (Create/CTA)" value="green-600" hex="#16a34a"/>
      <color name="SECONDARY (Actions)" value="gray-600" hex="#4b5563"/>
      <color name="DANGER (Delete)" value="red-600" hex="#dc2626"/>
      <color name="STATUS - Active/Confirmed" bg="green-200" text="green-800"/>
      <color name="STATUS - Pending/Draft" bg="yellow-200" text="yellow-800"/>
      <color name="STATUS - Inactive/Archived" bg="gray-200" text="gray-800"/>
      <color name="STATUS - Error/Expired" bg="red-200" text="red-800"/>
    </color-palette>

    <typography>
      <font-scale>
        h1: Text-3xl (30px) - Page titles
        h2: Text-2xl (24px) - Section headers
        h3: Text-xl (20px) - Card titles
        h4: Text-lg (18px) - Metric values in stats cards
        p: Text-base (16px) - Body text, table data
        sm: Text-sm (14px) - Labels, secondary text
        xs: Text-xs (12px) - Hints, metadata, stat labels
      </font-scale>
      <font-family>Body: Inter, system font stack; Mono: Monaco, monospace (for codes)</font-family>
    </typography>

    <spacing>
      <page-padding>px-6 py-6 (24px all sides)</page-padding>
      <card-padding>p-4 (16px all sides)</card-padding>
      <button-padding>px-4 py-2 (12px vertical, 16px horizontal)</button-padding>
      <section-gap>gap-6 (24px)</section-gap>
      <items-gap>gap-4 (16px)</items-gap>
    </spacing>

    <responsive-breakpoints>
      <breakpoint name="sm" size="640px">Mobile phone - Single column, stacked, Hamburger menu, Card view</breakpoint>
      <breakpoint name="md" size="768px">Tablet portrait - 2 columns, Collapsed tabs, Card view</breakpoint>
      <breakpoint name="lg" size="1024px">Tablet landscape - 2-3 columns, Full tabs, Full table</breakpoint>
      <breakpoint name="xl" size="1280px">Desktop - 3-4 columns, Full tabs, Full table</breakpoint>
    </responsive-breakpoints>
  </ux-design>

  <!-- ============================================================================ -->
  <!-- DATABASE SCHEMA -->
  <!-- ============================================================================ -->

  <database-schema>
    <existing-tables>
      <table name="work_orders">
        <description>Work Orders - STUB for Epic 2 testing. Full implementation in Epic 4.</description>
        <columns>
          id UUID PRIMARY KEY
          org_id UUID NOT NULL REFERENCES organizations(id)
          wo_number VARCHAR(50) NOT NULL UNIQUE
          product_id UUID NOT NULL REFERENCES products(id)
          planned_quantity DECIMAL(12,3) NOT NULL
          produced_quantity DECIMAL(12,3) DEFAULT 0
          uom VARCHAR(10) NOT NULL
          status VARCHAR(20) NOT NULL DEFAULT 'draft' -- draft, released, in_progress, completed, closed, cancelled
          planned_start_date DATE
          planned_end_date DATE
          actual_start_date DATE
          actual_end_date DATE
          production_line_id UUID REFERENCES machines(id)
          routing_id UUID
          created_by UUID REFERENCES users(id)
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        </columns>
        <indexes>
          idx_work_orders_org ON work_orders(org_id)
          idx_work_orders_product ON work_orders(product_id)
          idx_work_orders_status ON work_orders(status)
          idx_work_orders_dates ON work_orders(planned_start_date, planned_end_date)
        </indexes>
        <rls-policies>
          Users can view work orders in their org (SELECT)
          Production/Technical/Admin can create work orders (INSERT)
          Production/Technical/Admin can update work orders (UPDATE)
          Admin can delete work orders (DELETE)
        </rls-policies>
      </table>

      <table name="production_lines">
        <description>Production lines with warehouse assignment and default output location</description>
        <columns>
          id UUID PRIMARY KEY
          org_id UUID NOT NULL REFERENCES organizations(id)
          code VARCHAR(50) NOT NULL -- Unique per org (uppercase alphanumeric + hyphens, e.g., LINE-01)
          name VARCHAR(100) NOT NULL
          warehouse_id UUID NOT NULL REFERENCES warehouses(id)
          default_output_location_id UUID REFERENCES locations(id)
          created_by UUID REFERENCES users(id)
          updated_by UUID REFERENCES users(id)
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        </columns>
        <indexes>
          idx_production_lines_org_id ON production_lines(org_id)
          idx_production_lines_code ON production_lines(org_id, code)
          idx_production_lines_warehouse_id ON production_lines(warehouse_id)
        </indexes>
        <rls-policies>
          Users can only see production lines from their own organization (SELECT)
          Admin can insert/update/delete production lines in their organization
        </rls-policies>
      </table>

      <table name="production_outputs">
        <description>Production outputs recorded during work order execution (PR, FG, BP)</description>
        <columns>
          id UUID PRIMARY KEY
          org_id UUID NOT NULL
          wo_id UUID REFERENCES work_orders(id)
          product_id UUID REFERENCES products(id)
          quantity DECIMAL(12,3) NOT NULL
          operation_seq INTEGER
          qa_status VARCHAR(20) -- 'pass', 'hold', 'fail'
          type VARCHAR(5) -- 'PR' (Production Receipt), 'FG' (Finished Goods), 'BP' (By-Product)
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        </columns>
        <note>Used for Units Produced and Avg Yield calculations in dashboard KPIs</note>
      </table>

      <table name="wo_materials">
        <description>Materials required for work orders (BOM snapshot)</description>
        <columns>
          id UUID PRIMARY KEY
          wo_id UUID REFERENCES work_orders(id)
          material_id UUID REFERENCES products(id)
          qty_planned DECIMAL(12,3)
          qty_required DECIMAL(12,3)
          available_qty DECIMAL(12,3) -- Calculated from license_plates
          consume_whole_lp BOOLEAN DEFAULT false
        </columns>
        <note>Used for Material Shortages alert: COUNT(WHERE available_qty &lt; required_qty)</note>
      </table>

      <table name="license_plates">
        <description>License plates for inventory tracking</description>
        <columns>
          id UUID PRIMARY KEY
          lp_number VARCHAR(50) UNIQUE
          product_id UUID REFERENCES products(id)
          quantity DECIMAL(12,3)
          uom VARCHAR(10)
          status VARCHAR(20) -- 'available', 'reserved', 'consumed', 'hold'
          expiry_date DATE
          batch_number VARCHAR(50)
        </columns>
        <note>Used for QA status checks in Quality Hold alerts</note>
      </table>

      <table name="products">
        <description>Products master data</description>
        <columns>
          id UUID PRIMARY KEY
          org_id UUID NOT NULL
          sku VARCHAR(50) UNIQUE
          name VARCHAR(100)
          default_uom VARCHAR(10) -- Used for Units Produced display (e.g., "1,250 kg")
        </columns>
      </table>
    </existing-tables>

    <new-tables-required>
      <table name="production_settings">
        <description>Production module configuration (similar to planning_settings)</description>
        <columns>
          id UUID PRIMARY KEY
          org_id UUID NOT NULL REFERENCES organizations(id)
          dashboard_refresh_seconds INTEGER DEFAULT 30 -- Range: 30-300 seconds
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        </columns>
        <note>Stores dashboard auto-refresh interval config (AC-4.1.4)</note>
      </table>
    </new-tables-required>
  </database-schema>

  <!-- ============================================================================ -->
  <!-- API PATTERNS -->
  <!-- ============================================================================ -->

  <api-patterns>
    <standard-route-pattern>
      <location>apps/frontend/app/api/[module]/[resource]/route.ts</location>
      <example>apps/frontend/app/api/planning/purchase-orders/route.ts</example>
      <code-pattern><![CDATA[
import { NextRequest, NextResponse } from 'next/server'
import { createServerSupabase, createServerSupabaseAdmin } from '@/lib/supabase/server'

export async function GET(request: NextRequest) {
  try {
    const supabase = await createServerSupabase()

    // Check authentication
    const { data: { session }, error: authError } = await supabase.auth.getSession()
    if (authError || !session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get current user
    const { data: currentUser, error: userError } = await supabase
      .from('users')
      .select('role, org_id')
      .eq('id', session.user.id)
      .single()

    if (userError || !currentUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 })
    }

    // Use admin client for queries
    const supabaseAdmin = createServerSupabaseAdmin()
    const { searchParams } = new URL(request.url)

    // Build query with filters
    let query = supabaseAdmin
      .from('table_name')
      .select('*')
      .eq('org_id', currentUser.org_id)
      .order('created_at', { ascending: false })

    // Apply filters from searchParams
    const filter = searchParams.get('filter')
    if (filter) {
      query = query.eq('status', filter)
    }

    const { data, error } = await query

    if (error) {
      console.error('Error fetching data:', error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ data: data || [], total: data?.length || 0 })
  } catch (error) {
    console.error('Error in GET /api/...:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
      ]]></code-pattern>
      <authentication>Always check session via supabase.auth.getSession()</authentication>
      <authorization>Always enforce org_id isolation via .eq('org_id', currentUser.org_id)</authorization>
      <error-handling>Return proper HTTP status codes: 200, 400, 401, 403, 404, 500</error-handling>
    </standard-route-pattern>

    <dashboard-kpis-endpoint>
      <path>GET /api/production/dashboard/kpis</path>
      <response><![CDATA[
{
  data: {
    orders_today: number,          // COUNT(work_orders WHERE completed_at >= TODAY)
    units_produced_today: number,  // SUM(production_outputs.quantity WHERE created_at >= TODAY)
    avg_yield_today: number,       // Weighted: SUM(actual_output)/SUM(planned_qty) × 100
    active_wos: number,            // COUNT(work_orders WHERE status IN ['in_progress', 'paused'])
    material_shortages: number     // COUNT(wo_materials WHERE available_qty < required_qty)
  }
}
      ]]></response>
      <calculation-notes>
        - Orders Today: Use work_orders.completed_at for filtering (NOT planned_end_date)
        - Units Produced: Use product.default_uom for display (e.g., "1,250 kg")
        - Avg Yield: Weighted average across all WOs completed today (NOT simple average)
        - Active WOs: Include both 'in_progress' AND 'paused' status
        - Material Shortages: Query wo_materials table, calculate available_qty from license_plates
      </calculation-notes>
    </dashboard-kpis-endpoint>

    <active-wos-endpoint>
      <path>GET /api/production/dashboard/active-wos</path>
      <response><![CDATA[
{
  data: [
    {
      id: uuid,
      wo_number: string,           // "WO-20251127-0001"
      product_name: string,        // "Flour 50kg"
      planned_qty: number,         // 100
      output_qty: number,          // 75
      status: string,              // "in_progress" | "paused"
      progress_percent: number,    // 75
      started_at: timestamp,
      line_name: string            // "Line A"
    }
  ]
}
      ]]></response>
      <query-logic>
        - Join work_orders with products (for product_name)
        - Join work_orders with production_lines (for line_name)
        - Filter: status IN ['in_progress', 'paused']
        - Calculate progress_percent: (output_qty / planned_qty) * 100
        - Order by started_at ASC (oldest first)
        - Limit 10 rows (pagination support)
      </query-logic>
    </active-wos-endpoint>

    <alerts-endpoint>
      <path>GET /api/production/dashboard/alerts</path>
      <response><![CDATA[
{
  data: [
    {
      id: uuid,
      type: string,                // "material_shortage" | "wo_delayed" | "quality_hold"
      severity: string,            // "warning" | "critical"
      description: string,         // "Material 'Flour' shortage: need 50kg, have 30kg"
      wo_id: uuid,
      created_at: timestamp
    }
  ]
}
      ]]></response>
      <alert-types>
        - Material Shortage: wo_materials.available_qty &lt; required_qty (severity: warning)
        - WO Delayed: WO > scheduled_date + 4 hours (severity: warning)
        - Quality Hold: QA status = 'hold' on input LP (severity: critical)
      </alert-types>
      <sorting>Sort by severity (Critical > Warning) then timestamp (newest first)</sorting>
      <limit>Max 5 alerts returned</limit>
    </alerts-endpoint>
  </api-patterns>

  <!-- ============================================================================ -->
  <!-- COMPONENT PATTERNS -->
  <!-- ============================================================================ -->

  <component-patterns>
    <planning-stats-card-reference>
      <location>apps/frontend/components/planning/PlanningStatsCard.tsx</location>
      <description>2×2 grid stats card with icon, label, and value. 120px height. Clickable navigation.</description>
      <usage>Reference for creating ProductionStatsCard component with similar structure</usage>
    </planning-stats-card-reference>

    <planning-header-reference>
      <location>apps/frontend/components/planning/PlanningHeader.tsx</location>
      <description>Module header with tabs navigation (Planning | PO | TO | WO | Suppliers | ⚙️)</description>
      <usage>Reference for creating ProductionHeader component with Production tabs</usage>
    </planning-header-reference>

    <planning-table-reference>
      <location>apps/frontend/components/planning/PurchaseOrdersTable.tsx</location>
      <description>Data table with sortable columns, filters, pagination, row actions (View/Edit/Delete)</description>
      <usage>Reference for creating ActiveWOsTable component with similar structure</usage>
    </planning-table-reference>

    <auto-refresh-pattern>
      <code-pattern><![CDATA[
'use client'

import { useState, useEffect } from 'react'

export default function DashboardPage() {
  const [data, setData] = useState(null)
  const [lastUpdated, setLastUpdated] = useState<Date>(new Date())
  const [refreshInterval, setRefreshInterval] = useState(30) // seconds

  useEffect(() => {
    fetchData()

    const interval = setInterval(() => {
      fetchData()
    }, refreshInterval * 1000)

    return () => clearInterval(interval)
  }, [refreshInterval])

  async function fetchData() {
    const response = await fetch('/api/production/dashboard/kpis')
    const result = await response.json()
    setData(result.data)
    setLastUpdated(new Date())
  }

  const secondsAgo = Math.floor((new Date().getTime() - lastUpdated.getTime()) / 1000)

  return (
    <div>
      <div className="text-sm text-gray-500">
        Last updated: {secondsAgo}s ago
      </div>
      {/* Dashboard content */}
    </div>
  )
}
      ]]></code-pattern>
    </auto-refresh-pattern>
  </component-patterns>

  <!-- ============================================================================ -->
  <!-- TESTING STRATEGY -->
  <!-- ============================================================================ -->

  <testing-strategy>
    <unit-tests target-coverage="95%">
      <test-suite name="Service Layer">
        - Test getKPIs() with mock data (various date ranges, empty results)
        - Test getActiveWorkOrders() filtering (status, line, date)
        - Test getAlerts() with various alert types (shortage, delayed, hold)
        - Test org_id isolation (ensure cross-org data leakage prevented)
        - Test error scenarios (no data, DB errors, invalid inputs)
      </test-suite>
    </unit-tests>

    <integration-tests target-coverage="70%">
      <test-suite name="API Endpoints">
        - Test GET /api/production/dashboard/kpis (200 OK, correct calculations)
        - Test GET /api/production/dashboard/active-wos (200 OK, empty array)
        - Test GET /api/production/dashboard/alerts (200 OK, sorted correctly)
        - Test 401 without authentication
        - Test 403 with wrong org_id
        - Test response times &lt; 500ms
      </test-suite>
    </integration-tests>

    <e2e-tests target-coverage="100%" tool="Playwright">
      <test-suite name="Full User Journey">
        - Navigate to /production/dashboard
        - Verify KPI cards load with values (Orders Today, Units Produced, etc.)
        - Verify Active WOs table shows data (or empty state)
        - Verify Alerts panel displays (or empty state: "No active alerts")
        - Click manual refresh button → verify data updates
        - Wait 30 seconds → verify auto-refresh occurs
        - Click WO number → detail page opens in new tab
        - Click Pause button (if WO status = in_progress) → verify pause successful
        - Click Resume button (if WO status = paused) → verify resume successful
      </test-suite>

      <fixtures>
        - Use createTestOrganization() from tests/e2e/fixtures/test-setup.ts
        - Use createTestUser(orgId) for auth
        - Create test work orders with various statuses (in_progress, paused, completed)
        - Create test production_outputs for KPI calculations
        - Create test wo_materials for shortage alerts
      </fixtures>
    </e2e-tests>
  </testing-strategy>

  <!-- ============================================================================ -->
  <!-- ARCHITECTURE NOTES -->
  <!-- ============================================================================ -->

  <architecture-notes>
    <pattern name="Dashboard Pattern">
      Real-time KPI aggregation with auto-refresh using interval polling (NOT WebSocket for MVP).
      Reference: Standard dashboard pattern with setInterval for periodic data fetching.
      Location: /app/production/dashboard/
    </pattern>

    <pattern name="Service Layer">
      Production-specific calculations (yield, shortages, etc.) in dedicated service.
      Location: /lib/services/production-dashboard-service.ts (new file to create)
      Methods: getKPIs(orgId), getActiveWorkOrders(orgId), getAlerts(orgId)
    </pattern>

    <pattern name="API Response Pattern">
      Consistent with existing endpoints:
      Format: { data: {...}, message?: string }
      Status codes: 200 OK, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 500 Server Error
    </pattern>

    <learnings-from-previous-stories>
      From Story 3.22 (Planning Settings) & 3.10 (Work Order CRUD):
      - Production module will have production_settings table for config (like planning_settings)
      - Refresh_seconds pattern already established in planning_settings
      - WO status tracking patterns established in Story 3.10
      - Table UI patterns from Story 3.1-3.8 (PO/TO CRUD)
    </learnings-from-previous-stories>

    <constraints-and-decisions>
      - Auto-refresh: Polling via setInterval (NOT WebSocket) for simplicity
      - Alert prioritization: Severity-based (Critical > Warning) then timestamp
      - Calculation timing: Daily KPIs based on timestamps (>=TODAY start)
      - Future enhancements: Real-time WebSocket, customizable KPIs, export reports
    </constraints-and-decisions>
  </architecture-notes>

  <!-- ============================================================================ -->
  <!-- RELATED FILES -->
  <!-- ============================================================================ -->

  <related-files>
    <epic-file>docs/epics/04-epic-production-execution.md</epic-file>
    <story-file>docs/stories/04-1-production-dashboard.md</story-file>
    <ux-design>docs/ux-design/ux-design-production-module.md</ux-design>
    <shared-ux>docs/ux-design/ux-design-shared-system.md</shared-ux>

    <migrations>
      apps/frontend/lib/supabase/migrations/028_create_work_orders_stub.sql
      apps/frontend/lib/supabase/migrations/009_create_production_lines_table.sql
    </migrations>

    <existing-components>
      apps/frontend/components/planning/PlanningHeader.tsx
      apps/frontend/components/planning/PlanningStatsCard.tsx
      apps/frontend/components/planning/PurchaseOrdersTable.tsx
      apps/frontend/components/planning/TopPOCards.tsx
    </existing-components>

    <api-references>
      apps/frontend/app/api/planning/purchase-orders/route.ts
      apps/frontend/app/api/planning/settings/route.ts
    </api-references>
  </related-files>

  <!-- ============================================================================ -->
  <!-- PREREQUISITES & DEPENDENCIES -->
  <!-- ============================================================================ -->

  <prerequisites>
    <dependency>Work orders table exists (migration 028_create_work_orders_stub.sql)</dependency>
    <dependency>Production lines table exists (migration 009_create_production_lines_table.sql)</dependency>
    <dependency>Products table exists (from Epic 2 - Technical module)</dependency>
    <dependency>Supabase auth configured (session management)</dependency>
    <dependency>Tailwind CSS configured (color palette, responsive breakpoints)</dependency>
    <dependency>Planning module components (reference for patterns)</dependency>
  </prerequisites>

  <blockers>
    <blocker status="resolved">
      Work orders table schema needs to support status tracking (in_progress, paused, completed).
      Resolution: Existing migration 028 already includes status field with correct values.
    </blocker>
    <blocker status="open">
      production_settings table does not exist yet.
      Action: Create migration in Phase 1 (Task 1) to add production_settings table.
    </blocker>
    <blocker status="open">
      production_outputs table schema unknown.
      Action: Verify/create schema in Phase 1 (Task 1) before implementing KPI calculations.
    </blocker>
  </blockers>

</story-context>
