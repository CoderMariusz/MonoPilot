# Story 01.6 - Role-Based Permissions: Security Assessment & Refactoring Summary

**Story:** 01.6 - Role-Based Permissions (10 Roles)
**Phase:** REFACTOR (Security Review Phase)
**Status:** Assessment Complete - Ready for Implementation Refactoring
**Date:** 2025-12-17
**Reviewer:** SENIOR-DEV

---

## Executive Summary

The permission system implementation from Story 01.1 provides a solid foundation for role-based access control. The permission-service.ts uses a clean, functional approach with the `hasPermission()` function implementing correct permission logic. However, the current implementation is incomplete for Story 01.6 full scope. This document provides a security assessment of existing code and identifies refactoring opportunities before implementation begins.

**Overall Security Rating:** PASS (No Critical Issues)

**Recommendation:** Proceed with refactoring to enhance clarity, add owner role protection, and prepare for frontend implementation.

---

## Current Implementation Analysis

### Existing Files (From Story 01.1)

#### 1. Permission Service (`lib/services/permission-service.ts`)
**Status:** Core implementation exists, ready for 01.6 expansion

**Current Functions:**
- `hasAdminAccess(roleCode)` - Checks if user is owner or admin
- `canModifyOrganization(roleCode)` - Delegates to hasAdminAccess
- `canModifyUsers(roleCode)` - Delegates to hasAdminAccess
- `isSystemRole(roleCode)` - Validates system role membership
- `hasPermission(module, operation, permissions)` - Core permission check

**Code Quality:** EXCELLENT
- 146 lines, 5 functions, all well-documented
- No code duplication
- No magic strings/numbers
- Clear function responsibilities
- Good JSDoc coverage

**Security Strengths:**
- Falsy checks protect against null/undefined
- Type safety with operation union type
- Correct logic for permission checking (includes operation in permissions string)
- No permission bypasses detected
- Handles dash ('-') correctly as "no access"

#### 2. Role Constants (`lib/constants/roles.ts`)
**Status:** Complete and correct

**Current Content:**
```typescript
export const ADMIN_ROLES = ['owner', 'admin']
export const SYSTEM_ROLES = [10 roles in order]
export type AdminRole = (typeof ADMIN_ROLES)[number]
export type SystemRole = (typeof SYSTEM_ROLES)[number]
```

**Security Strengths:**
- Owner role explicitly included
- Admin role correctly distinguished from owner
- All 10 roles from ADR-012 present
- Type helpers prevent string typos
- Immutable (const) prevents accidental mutation

#### 3. Organization Types (`lib/types/organization.ts`)
**Status:** Complete

**Contains:**
- `Organization` interface
- `OrgContext` interface with permissions

**OrgContext Structure:**
```typescript
{
  org_id: string
  user_id: string
  role_code: string
  role_name: string
  permissions: Record<string, string>  // ← Module permission map
  organization: { ... }
}
```

**Security Strengths:**
- Structured data model prevents permission typos
- Type-safe permissions access
- Clear separation between org data and permissions

#### 4. Org Context Service (`lib/services/org-context-service.ts`)
**Status:** Excellent implementation

**Key Functions:**
- `getOrgContext(userId)` - Fetches user context with permissions via Supabase
- `validateOrgContext(context)` - Validates structure
- `deriveUserIdFromSession()` - Safely extracts user ID from session

**Security Strengths:**
- ✅ Returns 404 (not 403) for cross-tenant access - prevents enumeration
- ✅ UUID validation prevents SQL injection
- ✅ Session expiration check
- ✅ User/org active status verification
- ✅ Single query with JOINs (no N+1 vulnerability)

---

## Security Assessment

### 1. Permission Check Logic - PASS

**Function:** `hasPermission(module, operation, permissions)`

**Code:**
```typescript
export function hasPermission(
  module: string,
  operation: 'C' | 'R' | 'U' | 'D',
  permissions: Record<string, string>
): boolean {
  const modulePermissions = permissions[module]
  if (!modulePermissions) return false
  if (modulePermissions === '-') return false
  return modulePermissions.includes(operation)
}
```

**Security Verification:**
- ✅ Line 141-142: Falsy check for missing module returns false (deny by default)
- ✅ Line 143: Dash ('-') correctly treated as "no access"
- ✅ Line 144: Operation inclusion check is correct
- ✅ No bypass via empty string (empty string !== '-', will fail on undefined)
- ✅ No bypass via null/undefined (caught by line 142)

**Test Cases Covered:**
```typescript
// ✅ Normal permissions
hasPermission('settings', 'C', {settings: 'CRUD'}) // true
hasPermission('settings', 'U', {settings: 'RU'}) // true
hasPermission('settings', 'D', {settings: 'RU'}) // false

// ✅ No access case
hasPermission('production', 'C', {production: '-'}) // false

// ✅ Missing module
hasPermission('unknown_module', 'R', {settings: 'R'}) // false

// ✅ Edge cases
hasPermission('settings', 'C', {}) // false
hasPermission('settings', 'C', null) // false (type error caught at compile)
```

**No Security Issues Found:** PASS

---

### 2. Owner Role Protection - NEEDS ENHANCEMENT

**Current Implementation:**
```typescript
export const ADMIN_ROLES = ['owner', 'admin']

export function hasAdminAccess(roleCode: string): boolean {
  if (!roleCode) return false
  return ADMIN_ROLES.includes(roleCode as any)
}
```

**Story 01.6 Requirement (AC-4):**
> "GIVEN non-owner (e.g., admin), WHEN attempting to assign owner role, THEN error 'Only owner can assign owner role' displays."

**Current Code Gap:**
The current implementation treats owner and admin as equivalent for `hasAdminAccess()`. Story 01.6 needs explicit owner-only checks.

**Refactoring Needed:**
1. Add `isOwner(roleCode)` function
2. Document that ADMIN_ROLES should NOT be used for owner-only operations
3. Add security comment explaining the distinction

**Recommendation:**
```typescript
/**
 * Checks if user is ONLY the owner role.
 * Use this for owner-only operations (role assignment, org deletion).
 * Different from hasAdminAccess() which includes both owner and admin.
 *
 * SECURITY: Owner role is the only role that can assign the owner role.
 * Admin cannot assign owner. This prevents privilege escalation.
 */
export function isOwner(roleCode: string): boolean {
  if (!roleCode) return false
  return roleCode === 'owner'
}
```

**Status:** REFACTOR NEEDED for 01.6

---

### 3. Dash ('-') Handling - PASS

**Design:** Dash ('-') represents "no access" to a module

**Verification:**
- Line 143: `if (modulePermissions === '-') return false` ✅
- Correctly handles single dash value
- No bypass possible with empty string (would not equal '-')

**Test Case:**
```typescript
hasPermission('settings', 'C', {settings: '-'}) // false - correct
hasPermission('settings', 'C', {settings: ''}) // false - correct (empty != '-')
```

**No Issues Found:** PASS

---

### 4. Hardcoded Permissions - PASS

**Search Results:** No hardcoded permissions found in permission-service.ts

**Design Validation:**
- All permissions are passed as function parameters
- Permissions come from database (via org-context-service)
- No magic strings embedded in logic
- Source of truth: `roles` table in database

**Issues Found:** None - PASS

---

### 5. Frontend vs Backend Permission Checks - DESIGN NOTE

**Current Split:**
- **Backend (DB Level):** RLS policies + hasPermission() in services
- **Frontend (UI Level):** Will use hasPermission() + usePermissions() hook
- **API Level:** Permission middleware will enforce checks

**Verification:**
```typescript
// Current flow:
1. API route receives request
2. deriveUserIdFromSession() extracts user
3. getOrgContext(userId) fetches permissions
4. hasPermission() checks before operation
5. RLS policy ensures second-layer protection
```

**No Issues Found:** PASS

---

### 6. Permission Matrix Correctness - PASS

**Verification Against ADR-012:**
- ✅ Owner: CRUD on all 12 modules
- ✅ Admin: CRU on settings (no delete), CRUD on others
- ✅ Production Manager: Full Production/Planning/Quality (CRUD), Read-only Settings
- ✅ Quality Manager: Full Quality (CRUD), read-only Production
- ✅ Warehouse Manager: Full Warehouse/Shipping (CRUD), limited others
- ✅ Production Operator: RU on Production, CR on Quality (no delete)
- ✅ Quality Inspector: CRU on Quality (no delete quality)
- ✅ Warehouse Operator: CRU on Warehouse/Shipping
- ✅ Planner: Full Planning (CRUD), read-only others except Integrations (no access)
- ✅ Viewer: Read-only all modules (R on 12, but can see integrations if R granted)

**Note:** Planner has "-" (no access) to Integrations. Viewer has "R" to Integrations. This appears intentional (integrations are premium).

**Matrix is Correct:** PASS

---

## Identified Code Smells for Refactoring

### Code Smell 1: Owner Role Not Explicitly Named

**Location:** `permission-service.ts`, line 33

**Issue:**
- `ADMIN_ROLES.includes(roleCode)` includes owner but doesn't name it
- Creates confusion when owner-only operations needed in 01.6

**Severity:** Medium (Security clarity)

**Refactoring:**
Extract `isOwner()` function, add security documentation

---

### Code Smell 2: Owner Role Restriction Logic Needs Addition

**Location:** Need new function for 01.6

**Issue:**
- Story 01.6 needs to prevent non-owner from assigning owner role
- Current code doesn't explicitly check for this
- Could lead to privilege escalation

**Severity:** High (Security)

**Refactoring:**
```typescript
/**
 * SECURITY: Only owner can assign owner role.
 * Admins cannot assign owner role (prevents privilege escalation).
 */
export function canAssignRole(
  assignerRoleCode: string,
  targetRoleCode: string
): boolean {
  // Only owner can assign owner
  if (targetRoleCode === 'owner' && !isOwner(assignerRoleCode)) {
    return false
  }

  // Admins can assign any role except owner
  // Regular users cannot assign any role
  return hasAdminAccess(assignerRoleCode)
}
```

---

### Code Smell 3: Permission Falsy Handling Clarity

**Location:** `permission-service.ts`, line 142

**Issue:**
```typescript
const modulePermissions = permissions[module]
if (!modulePermissions) return false
```

This correctly handles null/undefined/empty, but could be more explicit that we're treating falsy as "no permission". Comment would improve clarity.

**Severity:** Low (Code clarity)

**Refactoring:**
```typescript
const modulePermissions = permissions[module]
// Missing module or null/undefined permissions = no access (deny by default)
if (!modulePermissions) return false
```

---

### Code Smell 4: Type Safety - 'as any' Cast

**Location:** `permission-service.ts`, line 33

**Code:**
```typescript
return ADMIN_ROLES.includes(roleCode as any)
```

**Issue:**
- Casting to `any` bypasses TypeScript type checking
- While safe here (roleCode is string), reduces type safety
- Parameter is typed correctly, but cast is unnecessary

**Severity:** Low (Type safety)

**Refactoring:**
```typescript
// Better: Change parameter type or add explicit type guard
export function hasAdminAccess(roleCode: string): boolean {
  if (!roleCode) return false
  return (ADMIN_ROLES as readonly string[]).includes(roleCode)
}
```

---

## Refactoring Plan for Story 01.6

### Phase 1: Security Enhancements (Before Frontend Implementation)

**Refactoring 1: Add Owner Role Distinction**
- Extract `isOwner(roleCode)` function
- Add security documentation
- File: `lib/services/permission-service.ts`
- Lines: Add after line 34

**Refactoring 2: Add Role Assignment Validation**
- Extract `canAssignRole(assignerRole, targetRole)` function
- Document owner role restriction
- Prevent privilege escalation
- File: `lib/services/permission-service.ts`
- Lines: Add after line 56

**Refactoring 3: Improve Type Safety**
- Remove `as any` cast on line 33
- Use proper type guards
- File: `lib/services/permission-service.ts`
- Lines: 33

**Refactoring 4: Clarify Permission Logic**
- Add explanatory comments for falsy handling
- Document deny-by-default principle
- File: `lib/services/permission-service.ts`
- Lines: 142-144

### Phase 2: Frontend Components (01.6 Implementation)

**New Files to Create:**
1. `lib/hooks/usePermissions.ts` - React hook for permission checks
2. `lib/types/permission.ts` - Permission type definitions
3. `components/settings/RoleSelector.tsx` - Role dropdown component
4. `components/shared/PermissionGuard.tsx` - Conditional rendering wrapper
5. `lib/constants/modules.ts` - Module code constants
6. API endpoints (GET /api/settings/roles, GET /api/settings/roles/:id)

### Phase 3: Testing & Validation

**Test Cases for Refactorings:**
1. `isOwner()` function tests
2. `canAssignRole()` security tests
3. Permission matrix validation tests
4. Edge case tests (null, undefined, empty)

---

## Security Best Practices Verified

### 1. Defense in Depth - PASS
- Layer 1: Database RLS policies (ADR-013)
- Layer 2: Application permission checks (hasPermission)
- Layer 3: API middleware (requirePermission)
- Layer 4: Frontend permission guards (usePermissions hook)

### 2. Deny by Default - PASS
- Missing permissions = no access
- Dash ('-') = explicit no access
- Missing module returns false
- No positive assumption of access

### 3. Principle of Least Privilege - PASS
- Owner: Full access (necessary)
- Admin: No delete on settings (prevents org deletion)
- Regular users: Limited to module-specific access
- Viewer: Read-only everything

### 4. Error Messages Don't Leak Information - PASS
- NotFoundError (404) for cross-tenant access
- ForbiddenError (403) for permission denials
- No disclosure of what permissions user lacks

### 5. Session Validation - PASS
- Session existence checked
- Session expiration checked
- UUID validation prevents injection
- No direct use of JWT claims

---

## Files Status Summary

| File | Status | Changes Needed |
|------|--------|---|
| `lib/services/permission-service.ts` | GOOD | Add isOwner(), canAssignRole(), improve comments |
| `lib/constants/roles.ts` | EXCELLENT | No changes needed |
| `lib/types/organization.ts` | EXCELLENT | No changes needed |
| `lib/services/org-context-service.ts` | EXCELLENT | No changes needed |
| `lib/utils/validation.ts` | EXCELLENT | (From 01.1 refactor) |
| `lib/errors/*.ts` | EXCELLENT | (From 01.1 refactor) |

---

## Implementation Readiness

### Prerequisites Met
- ✅ Story 01.1 foundation complete
- ✅ RLS policies implemented
- ✅ Permission storage in JSONB
- ✅ 10 system roles seeded
- ✅ Org context service working
- ✅ Permission check logic functional

### Ready for Frontend Implementation
- ✅ Database schema complete
- ✅ API endpoints documented
- ✅ Permission matrix defined
- ✅ Security model verified
- ✅ Types available

### Refactoring Complete When
- ✅ isOwner() function added and tested
- ✅ canAssignRole() function added and tested
- ✅ Type safety improved (remove 'as any')
- ✅ Comments enhanced for clarity
- ✅ All tests still pass
- ✅ No behavior changes

---

## Conclusion

The permissions implementation from Story 01.1 provides an excellent foundation. No critical security issues found. Four minor refactorings recommended to improve clarity and add owner role protection before proceeding with Story 01.6 frontend implementation.

**Security Assessment Result:** PASS - No critical issues, ready for refactoring and implementation

**Recommendation:** Proceed with identified refactorings in order before handing off to FRONTEND-DEV for component implementation.

---

## Next Steps

1. **Apply Refactoring 1** - Add isOwner() function
2. **Test after each change** - Ensure all tests still pass
3. **Apply Refactoring 2** - Add canAssignRole() function
4. **Apply Refactoring 3** - Remove 'as any' cast
5. **Apply Refactoring 4** - Enhance comments
6. **Commit changes** - One refactoring per commit
7. **Handoff to CODE-REVIEWER** - For review
8. **Then FRONTEND-DEV** - For component implementation

**Timeline:** 1-2 hours for refactoring, 3 days for full frontend implementation

