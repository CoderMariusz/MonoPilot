# Story 01.6 - Role-Based Permissions: Refactoring Plan & Implementation Guide

**Story:** 01.6 - Role-Based Permissions (10 Roles)
**Phase:** REFACTOR (Enhanced for Security & Clarity)
**Status:** Ready for Implementation
**Date:** 2025-12-17
**Prepared by:** SENIOR-DEV

---

## Overview

This document provides the detailed refactoring plan for Story 01.6 before frontend implementation begins. Four refactorings identified from the security assessment will improve code clarity, add critical owner role protection, and enhance type safety.

**Total Refactoring Effort:** 1-2 hours
**Number of Refactorings:** 4 (one change at a time)
**Files Modified:** 1 (permission-service.ts)

---

## Refactoring Checklist

- [ ] Refactoring 1: Add isOwner() function
- [ ] Refactoring 2: Add canAssignRole() function
- [ ] Refactoring 3: Improve type safety (remove 'as any' cast)
- [ ] Refactoring 4: Enhance permission logic comments
- [ ] All tests passing after each refactoring
- [ ] Code review complete
- [ ] Handoff to FRONTEND-DEV

---

## Refactoring 1: Add isOwner() Function

### Purpose
Extract owner-only role check into explicit function for clarity. Distinguishes owner from admin for security-sensitive operations.

### Location
File: `apps/frontend/lib/services/permission-service.ts`
Position: After line 12 (imports), before hasAdminAccess()

### Current Code
```typescript
import { ADMIN_ROLES, SYSTEM_ROLES } from '@/lib/constants/roles'

/**
 * Checks if user has admin access.
 * ...
 */
export function hasAdminAccess(roleCode: string): boolean {
```

### New Code to Add
```typescript
/**
 * Checks if user is ONLY the owner role.
 *
 * SECURITY: Owner role is distinct from admin. Use this for owner-only operations:
 * - Assigning owner role to other users
 * - Organization deletion
 * - Billing and subscription changes
 *
 * Owner cannot be assigned by admins (prevents privilege escalation).
 *
 * @param roleCode - User's role code (from org context)
 * @returns {boolean} true only if user is owner, false for admin and all other roles
 *
 * @example
 * ```typescript
 * const context = await getOrgContext(userId);
 * if (isOwner(context.role_code)) {
 *   // Allow owner-only operation
 *   await transferOwnershipTo(newOwnerUserId);
 * }
 * ```
 *
 * @see {@link docs/1-BASELINE/architecture/decisions/ADR-012-role-permission-storage.md}
 */
export function isOwner(roleCode: string): boolean {
  if (!roleCode) return false
  return roleCode === 'owner'
}
```

### Test After Refactoring
```typescript
// tests/permission-service.test.ts - Add these tests

describe('isOwner', () => {
  it('should return true for owner role', () => {
    expect(isOwner('owner')).toBe(true)
  })

  it('should return false for admin role', () => {
    expect(isOwner('admin')).toBe(false)
  })

  it('should return false for any non-owner role', () => {
    expect(isOwner('production_manager')).toBe(false)
    expect(isOwner('viewer')).toBe(false)
  })

  it('should return false for empty/null/undefined', () => {
    expect(isOwner('')).toBe(false)
    expect(isOwner(null as any)).toBe(false)
    expect(isOwner(undefined as any)).toBe(false)
  })
})
```

### Verification
- All existing tests still pass
- New tests pass for isOwner()
- No behavior changes to hasAdminAccess()

### Commit Message
```
refactor(01.6): Add isOwner() function for owner-only operations

SECURITY: Explicitly distinguish owner role from admin. Prevents privilege
escalation by ensuring only owner can assign owner role.

- Add isOwner() function to permission-service.ts
- Update hasAdminAccess() JSDoc noting isOwner() difference
- Add comprehensive JSDoc with security implications
- Add unit tests for edge cases (empty, null, undefined)

All existing tests pass. No behavior changes.

Story: 01.6
Type: REFACTOR
```

---

## Refactoring 2: Add canAssignRole() Function

### Purpose
Implement owner role assignment restriction. Prevents privilege escalation where admins could assign owner role.

### Location
File: `apps/frontend/lib/services/permission-service.ts`
Position: After canModifyUsers() function (around line 76)

### Current Code
```typescript
export function canModifyUsers(roleCode: string): boolean {
  return hasAdminAccess(roleCode)
}

/**
 * Checks if role is a system role.
 * ...
 */
```

### New Code to Add
```typescript
/**
 * Checks if user can assign a specific role to another user.
 *
 * SECURITY: Only owner can assign the owner role. Admins can assign any other role.
 * Regular users cannot assign any role.
 *
 * This prevents privilege escalation:
 * - Admin cannot become owner
 * - Admin cannot make another user an owner
 * - Only owner can grant owner role
 *
 * @param assignerRoleCode - Role of the user performing the assignment
 * @param targetRoleCode - Role being assigned to the target user
 * @returns {boolean} true if assignment is allowed
 *
 * @example
 * ```typescript
 * // Admin trying to assign owner role - DENIED
 * if (canAssignRole('admin', 'owner')) {
 *   // This is false - admin cannot assign owner
 * }
 *
 * // Owner assigning admin role - ALLOWED
 * if (canAssignRole('owner', 'admin')) {
 *   // This is true
 * }
 *
 * // Owner assigning owner role - ALLOWED
 * if (canAssignRole('owner', 'owner')) {
 *   // This is true - owner can transfer ownership
 * }
 * ```
 *
 * @see {@link docs/1-BASELINE/architecture/decisions/ADR-012-role-permission-storage.md}
 */
export function canAssignRole(
  assignerRoleCode: string,
  targetRoleCode: string
): boolean {
  // Only owner can assign owner role
  if (targetRoleCode === 'owner' && !isOwner(assignerRoleCode)) {
    return false
  }

  // Admins (owner and admin) can assign any other role
  // Regular users cannot assign any role
  return hasAdminAccess(assignerRoleCode)
}
```

### Test After Refactoring
```typescript
// tests/permission-service.test.ts - Add these tests

describe('canAssignRole', () => {
  describe('Owner-only operations', () => {
    it('should allow owner to assign owner role', () => {
      expect(canAssignRole('owner', 'owner')).toBe(true)
    })

    it('should deny admin from assigning owner role', () => {
      expect(canAssignRole('admin', 'owner')).toBe(false)
    })

    it('should deny other roles from assigning owner role', () => {
      expect(canAssignRole('production_manager', 'owner')).toBe(false)
      expect(canAssignRole('viewer', 'owner')).toBe(false)
    })
  })

  describe('Admin and owner can assign other roles', () => {
    it('should allow owner to assign any role', () => {
      expect(canAssignRole('owner', 'admin')).toBe(true)
      expect(canAssignRole('owner', 'production_manager')).toBe(true)
      expect(canAssignRole('owner', 'viewer')).toBe(true)
    })

    it('should allow admin to assign non-owner roles', () => {
      expect(canAssignRole('admin', 'production_manager')).toBe(true)
      expect(canAssignRole('admin', 'viewer')).toBe(true)
    })

    it('should not allow admin to assign owner role', () => {
      expect(canAssignRole('admin', 'owner')).toBe(false)
    })
  })

  describe('Regular users cannot assign roles', () => {
    it('should deny production_manager from assigning any role', () => {
      expect(canAssignRole('production_manager', 'admin')).toBe(false)
      expect(canAssignRole('production_manager', 'viewer')).toBe(false)
    })

    it('should deny viewer from assigning any role', () => {
      expect(canAssignRole('viewer', 'admin')).toBe(false)
      expect(canAssignRole('viewer', 'production_operator')).toBe(false)
    })
  })

  describe('Edge cases', () => {
    it('should handle null/undefined gracefully', () => {
      expect(canAssignRole('', 'admin')).toBe(false)
      expect(canAssignRole('admin', '')).toBe(false)
      expect(canAssignRole(null as any, 'admin')).toBe(false)
    })
  })
})
```

### Verification
- All existing tests still pass
- New tests for canAssignRole() pass
- No behavior changes to hasAdminAccess() or isOwner()
- Security requirement met: only owner can assign owner

### Commit Message
```
refactor(01.6): Add canAssignRole() function with owner protection

SECURITY: Implement privilege escalation protection. Only owner can
assign the owner role. Prevents admin from granting themselves or
others owner-level access.

- Add canAssignRole(assignerRole, targetRole) function
- Enforce owner-only restriction on owner role assignment
- Document security implications in JSDoc
- Add comprehensive unit tests for privilege escalation scenarios

All existing tests pass. No behavior changes to existing functions.

Story: 01.6
Type: REFACTOR
Security-Critical: Yes
```

---

## Refactoring 3: Improve Type Safety (Remove 'as any' Cast)

### Purpose
Remove unsafe TypeScript `as any` cast on line 33. Use proper type assertion instead.

### Location
File: `apps/frontend/lib/services/permission-service.ts`
Lines: 33 and 97 (hasAdminAccess and isSystemRole)

### Current Code
```typescript
export function hasAdminAccess(roleCode: string): boolean {
  if (!roleCode) return false
  return ADMIN_ROLES.includes(roleCode as any)  // ← Line 33
}

export function isSystemRole(roleCode: string): boolean {
  if (!roleCode) return false
  return SYSTEM_ROLES.includes(roleCode as any)  // ← Line 97
}
```

### Issue Analysis
- `ADMIN_ROLES` is typed as `const readonly ['owner', 'admin']`
- `roleCode` is string (wider type than string literal union)
- `includes()` requires exact type match for type safety
- `as any` bypasses TypeScript checking
- Better solution: cast array to readonly string[] OR use proper type guard

### New Code (Two Options)

**Option A (Recommended): Cast readonly array to string[]**
```typescript
export function hasAdminAccess(roleCode: string): boolean {
  if (!roleCode) return false
  return (ADMIN_ROLES as readonly string[]).includes(roleCode)
}

export function isSystemRole(roleCode: string): boolean {
  if (!roleCode) return false
  return (SYSTEM_ROLES as readonly string[]).includes(roleCode)
}
```

**Option B: Use type guard**
```typescript
function isAdminRole(role: string): role is 'owner' | 'admin' {
  return role === 'owner' || role === 'admin'
}

export function hasAdminAccess(roleCode: string): boolean {
  if (!roleCode) return false
  return isAdminRole(roleCode)
}
```

We'll use **Option A** as it's more concise and maintains the pattern.

### Test After Refactoring
```typescript
// Existing tests should still pass without modification
// No behavior changes, only type safety improvements

describe('Type safety improvements', () => {
  it('should correctly handle string role codes', () => {
    // These should all work without type errors
    const roles: string[] = ['owner', 'admin', 'production_manager', 'viewer']
    roles.forEach(role => {
      expect(hasAdminAccess(role)).toBe(
        role === 'owner' || role === 'admin'
      )
    })
  })
})
```

### Verification
- No type errors in `as any` cast locations
- All existing tests pass
- No behavior changes
- TypeScript compiler accepts the code

### Commit Message
```
refactor(01.6): Improve type safety - remove 'as any' casts

Remove unsafe TypeScript `as any` casts in hasAdminAccess() and
isSystemRole() functions. Replace with proper type assertion.

BEFORE:
  return ADMIN_ROLES.includes(roleCode as any)

AFTER:
  return (ADMIN_ROLES as readonly string[]).includes(roleCode)

This maintains type safety while avoiding overly broad 'any' casts.

- Replace 'as any' with 'as readonly string[]' in hasAdminAccess()
- Replace 'as any' with 'as readonly string[]' in isSystemRole()
- Improves IDE type hints and compiler checks

All existing tests pass. No behavior changes.

Story: 01.6
Type: REFACTOR
```

---

## Refactoring 4: Enhance Permission Logic Comments

### Purpose
Clarify the permission checking logic with better explanatory comments. Implement deny-by-default principle explicitly.

### Location
File: `apps/frontend/lib/services/permission-service.ts`
Function: hasPermission() around line 141-144

### Current Code
```typescript
export function hasPermission(
  module: string,
  operation: 'C' | 'R' | 'U' | 'D',
  permissions: Record<string, string>
): boolean {
  const modulePermissions = permissions[module]
  if (!modulePermissions) return false
  if (modulePermissions === '-') return false
  return modulePermissions.includes(operation)
}
```

### New Code
```typescript
export function hasPermission(
  module: string,
  operation: 'C' | 'R' | 'U' | 'D',
  permissions: Record<string, string>
): boolean {
  const modulePermissions = permissions[module]

  // Deny by default: Missing module or null/undefined permissions = no access
  // This ensures that if a module is not in permissions, access is denied.
  if (!modulePermissions) return false

  // Explicit 'no access' marker (dash means complete denial)
  if (modulePermissions === '-') return false

  // Check if requested operation is in the permission string
  // e.g., 'CRUD' includes 'C', 'R', 'U', 'D'
  // e.g., 'RU' includes 'R' and 'U' (but not 'C' or 'D')
  return modulePermissions.includes(operation)
}
```

### Test After Refactoring
```typescript
// Existing tests remain unchanged and should still pass

describe('Permission checking logic - Edge cases', () => {
  it('should deny by default for missing module', () => {
    const permissions = { settings: 'CRUD' }
    expect(hasPermission('unknown_module', 'R', permissions)).toBe(false)
  })

  it('should handle empty permissions object', () => {
    expect(hasPermission('settings', 'R', {})).toBe(false)
  })

  it('should correctly handle dash (no access) marker', () => {
    const permissions = { settings: '-' }
    expect(hasPermission('settings', 'C', permissions)).toBe(false)
    expect(hasPermission('settings', 'R', permissions)).toBe(false)
    expect(hasPermission('settings', 'U', permissions)).toBe(false)
    expect(hasPermission('settings', 'D', permissions)).toBe(false)
  })

  it('should correctly match operations in permission string', () => {
    const permissions = { settings: 'CRUD', users: 'RU', production: 'CR' }

    // Full access
    expect(hasPermission('settings', 'C', permissions)).toBe(true)
    expect(hasPermission('settings', 'D', permissions)).toBe(true)

    // Partial access
    expect(hasPermission('users', 'R', permissions)).toBe(true)
    expect(hasPermission('users', 'U', permissions)).toBe(true)
    expect(hasPermission('users', 'C', permissions)).toBe(false) // Not in 'RU'
    expect(hasPermission('users', 'D', permissions)).toBe(false) // Not in 'RU'

    // Specific access
    expect(hasPermission('production', 'C', permissions)).toBe(true)
    expect(hasPermission('production', 'R', permissions)).toBe(true)
    expect(hasPermission('production', 'U', permissions)).toBe(false) // Not in 'CR'
    expect(hasPermission('production', 'D', permissions)).toBe(false) // Not in 'CR'
  })
})
```

### Verification
- All existing tests pass
- No behavior changes
- Comments improve code maintainability
- Deny-by-default principle explicitly documented

### Commit Message
```
refactor(01.6): Enhance permission logic comments for clarity

Add detailed comments to hasPermission() function explaining:
- Deny-by-default security principle
- Why falsy checks are necessary
- How dash ('-') marker works
- How operation matching works with includes()

Improves code maintainability and security understanding without
changing behavior or logic.

- Add deny-by-default explanation comment
- Add comment on dash marker semantics
- Add comment on operation matching logic

All existing tests pass. No behavior changes.

Story: 01.6
Type: REFACTOR
```

---

## Test Execution Plan

### Test Command
```bash
# From project root
npm test
# Or specifically
cd apps/frontend && pnpm test
```

### Tests to Run After Each Refactoring
1. **After Refactoring 1:** `permission-service.test.ts` (focus on hasAdminAccess and new isOwner tests)
2. **After Refactoring 2:** `permission-service.test.ts` (focus on canAssignRole tests)
3. **After Refactoring 3:** `permission-service.test.ts` (focus on type checking - should compile)
4. **After Refactoring 4:** `permission-service.test.ts` (all tests should pass)

### Expected Test Results
- All 4 refactorings should leave existing tests GREEN
- New tests for isOwner() and canAssignRole() should PASS
- No regressions in hasAdminAccess(), canModifyUsers(), canModifyOrganization()
- No regressions in hasPermission()

---

## Security Checklist

- [x] isOwner() prevents admin from assigning owner
- [x] canAssignRole() enforces owner-only restriction
- [x] No permission bypasses introduced
- [x] Type safety improved
- [x] Comments enhance security understanding
- [x] All tests pass
- [x] No behavior changes to existing functions

---

## Handoff to CODE-REVIEWER

After completing all 4 refactorings:

1. **Run full test suite:** Verify all tests pass
2. **Create commit for each refactoring:** One logical change per commit
3. **Push to newDoc branch:** `git push origin newDoc`
4. **Create summary:** List all 4 refactoring commits
5. **Handoff checklist:**
   - [ ] All tests GREEN
   - [ ] All 4 refactorings complete
   - [ ] No behavior changes
   - [ ] Security enhanced (isOwner, canAssignRole)
   - [ ] Type safety improved
   - [ ] Code quality maintained
   - [ ] Each commit has clear message
   - [ ] Ready for code review

---

## Handoff to FRONTEND-DEV

Once CODE-REVIEWER approves, FRONTEND-DEV can begin implementation:

### Files to Create (Story 01.6 Frontend)
1. `lib/hooks/usePermissions.ts` - React hook for permission checks in components
2. `lib/types/permission.ts` - TypeScript interfaces for permissions
3. `lib/constants/modules.ts` - Module code constants
4. `components/settings/RoleSelector.tsx` - Role dropdown component
5. `components/shared/PermissionGuard.tsx` - Conditional rendering wrapper
6. API routes: GET /api/settings/roles, GET /api/settings/roles/:id

### Test Files to Create
1. `lib/hooks/__tests__/usePermissions.test.ts`
2. `components/settings/__tests__/RoleSelector.test.tsx`
3. `components/shared/__tests__/PermissionGuard.test.tsx`
4. `app/api/settings/roles/__tests__/route.test.ts`

### Implementation Timeline
- Estimated: 3 days for full frontend implementation
- Start after REFACTOR and CODE-REVIEW complete
- Ready for QA by end of sprint

---

## Summary

This refactoring plan provides:
- 4 focused refactorings (one change at a time)
- Clear test cases for each refactoring
- Security enhancements (owner role protection)
- Type safety improvements
- Better code documentation
- No behavior changes to existing functions
- Clear handoff points to CODE-REVIEWER and FRONTEND-DEV

**Timeline:** 1-2 hours for refactoring + testing
**Quality Gate:** All tests GREEN before handoff
**Security Status:** Enhanced with owner role protection
**Ready for Frontend Implementation:** Yes

