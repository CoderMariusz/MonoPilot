# 09.15 - Yield & Scrap Variance

**Priority**: P0 (Phase 2)
**Story Points**: M (Medium)
**Type**: backend
**Phase**: 2 (Advanced Costing)
**Model**: OPUS

**State:** ready
**Estimate:** M (3-4 days)
**Primary PRD:** `docs/1-BASELINE/product/modules/finance.md` (FR-9.4.6, FR-9.3.8, FR-9.2.5)
**Architecture:** `docs/1-BASELINE/architecture/modules/finance.md` (cost_variances)

---

## Goal

Implement yield variance calculation to track cost impact of actual yield vs planned yield, and scrap cost tracking to quantify waste. Enable identification of production efficiency issues, quality problems, and process optimization opportunities through cost-based yield analysis.

---

## User Story

As a **Finance Manager**, I want to **calculate yield variance showing the cost impact of producing more or less than planned** so that **I can quantify production efficiency and yield losses**.

As a **Production Manager**, I want to **track scrap costs by reason code** so that **I can identify root causes of waste and prioritize improvement initiatives**.

---

## MVP Scope

**MVP Includes**:
- Yield variance calculation
- Scrap cost tracking
- Scrap reason code tracking
- Yield cost adjustment
- Integration with 04.4 WO outputs
- Integration with 04.5 scrap tracking
- Yield variance API
- Scrap cost report

**Deferred to Phase 3**:
- Yield variance trend analysis
- Scrap cost reduction targets
- Automated yield alerts
- Root cause categorization for scrap

---

## Dependencies

| Dependency | Story/Epic | Type | Status |
|------------|------------|------|--------|
| 01.1 | Org Context | HARD | Ready |
| 03.10 | Work Orders | HARD | Ready |
| 04.4 | WO Outputs | HARD | Ready |
| 04.5 | Scrap Tracking | HARD | Ready |
| 09.2 | Standard Costs | HARD | Ready |
| 09.6 | WO Cost Summary | HARD | Ready |

---

## Database Migration

```sql
-- Migration: create_yield_scrap_variance.sql

-- Scrap costs tracking
CREATE TABLE scrap_costs (
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id              UUID NOT NULL REFERENCES organizations(id),
    work_order_id       UUID NOT NULL REFERENCES work_orders(id),
    scrap_id            UUID NOT NULL REFERENCES scrap(id),

    product_id          UUID NOT NULL REFERENCES products(id),
    quantity            NUMERIC(15,4) NOT NULL CHECK (quantity >= 0),
    uom                 TEXT NOT NULL,

    unit_cost           NUMERIC(15,4) NOT NULL CHECK (unit_cost >= 0),
    total_cost          NUMERIC(15,2) NOT NULL CHECK (total_cost >= 0),

    scrap_reason        TEXT,
    scrap_category      TEXT,

    currency_id         UUID NOT NULL REFERENCES currencies(id),
    transaction_date    DATE NOT NULL DEFAULT CURRENT_DATE,

    created_at          TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT chk_scrap_total CHECK (total_cost = quantity * unit_cost)
);

CREATE INDEX idx_scrap_costs_org ON scrap_costs(org_id);
CREATE INDEX idx_scrap_costs_wo ON scrap_costs(work_order_id);
CREATE INDEX idx_scrap_costs_product ON scrap_costs(product_id);
CREATE INDEX idx_scrap_costs_reason ON scrap_costs(org_id, scrap_reason);
CREATE INDEX idx_scrap_costs_date ON scrap_costs(transaction_date);

ALTER TABLE scrap_costs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "scrap_costs_select" ON scrap_costs
    FOR SELECT USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

CREATE POLICY "scrap_costs_insert" ON scrap_costs
    FOR INSERT WITH CHECK (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- Extend cost_variances for yield variance
ALTER TABLE cost_variances
ADD COLUMN IF NOT EXISTS planned_yield NUMERIC(15,4),
ADD COLUMN IF NOT EXISTS actual_yield NUMERIC(15,4),
ADD COLUMN IF NOT EXISTS yield_percent NUMERIC(5,2),
ADD COLUMN IF NOT EXISTS scrap_quantity NUMERIC(15,4),
ADD COLUMN IF NOT EXISTS scrap_cost NUMERIC(15,2);

CREATE INDEX idx_cost_variances_yield ON cost_variances(org_id, variance_type) WHERE variance_type = 'yield';

-- Function: Calculate yield variance
CREATE OR REPLACE FUNCTION calculate_yield_variance(
    p_org_id UUID,
    p_work_order_id UUID,
    p_actual_yield NUMERIC,
    p_planned_yield NUMERIC,
    p_standard_unit_cost NUMERIC
)
RETURNS NUMERIC AS $$
BEGIN
    -- Yield Variance = (Actual Yield - Planned Yield) × Standard Unit Cost
    RETURN (p_actual_yield - p_planned_yield) * p_standard_unit_cost;
END;
$$ LANGUAGE plpgsql;

-- Function: Calculate scrap cost for work order
CREATE OR REPLACE FUNCTION calculate_work_order_scrap_cost(
    p_org_id UUID,
    p_work_order_id UUID
)
RETURNS TABLE (
    product_id UUID,
    product_name TEXT,
    scrap_quantity NUMERIC,
    unit_cost NUMERIC,
    total_scrap_cost NUMERIC,
    scrap_reason TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        s.product_id,
        p.name AS product_name,
        s.quantity AS scrap_quantity,
        sc.total_cost AS unit_cost,
        s.quantity * sc.total_cost AS total_scrap_cost,
        s.reason AS scrap_reason
    FROM scrap s
    JOIN products p ON p.id = s.product_id
    LEFT JOIN standard_costs sc ON sc.item_id = s.product_id
        AND sc.org_id = p_org_id
        AND sc.status = 'active'
    WHERE s.work_order_id = p_work_order_id
    AND s.org_id = p_org_id
    ORDER BY s.created_at;
END;
$$ LANGUAGE plpgsql;

-- Function: Calculate yield variance for work order
CREATE OR REPLACE FUNCTION calculate_work_order_yield_variance(
    p_org_id UUID,
    p_work_order_id UUID
)
RETURNS TABLE (
    planned_yield NUMERIC,
    actual_yield NUMERIC,
    yield_percent NUMERIC,
    scrap_quantity NUMERIC,
    standard_unit_cost NUMERIC,
    yield_variance NUMERIC,
    scrap_cost NUMERIC,
    total_variance NUMERIC
) AS $$
DECLARE
    v_wo RECORD;
    v_planned_yield NUMERIC;
    v_actual_yield NUMERIC;
    v_scrap_qty NUMERIC;
    v_yield_percent NUMERIC;
    v_standard_cost NUMERIC;
    v_yield_variance NUMERIC;
    v_scrap_cost NUMERIC;
BEGIN
    -- Get work order details
    SELECT
        wo.qty_planned,
        wo.qty_good,
        wo.product_id
    INTO v_wo
    FROM work_orders wo
    WHERE wo.id = p_work_order_id
    AND wo.org_id = p_org_id;

    IF v_wo IS NULL THEN
        RAISE EXCEPTION 'Work order not found';
    END IF;

    v_planned_yield := v_wo.qty_planned;
    v_actual_yield := COALESCE(v_wo.qty_good, 0);

    -- Calculate yield percentage
    IF v_planned_yield > 0 THEN
        v_yield_percent := (v_actual_yield / v_planned_yield) * 100;
    ELSE
        v_yield_percent := 0;
    END IF;

    -- Get scrap quantity
    SELECT COALESCE(SUM(quantity), 0) INTO v_scrap_qty
    FROM scrap
    WHERE work_order_id = p_work_order_id
    AND org_id = p_org_id;

    -- Get standard unit cost
    SELECT COALESCE(sc.total_cost, 0) INTO v_standard_cost
    FROM standard_costs sc
    WHERE sc.item_id = v_wo.product_id
    AND sc.org_id = p_org_id
    AND sc.status = 'active'
    ORDER BY sc.effective_from DESC
    LIMIT 1;

    -- Calculate yield variance
    v_yield_variance := calculate_yield_variance(
        p_org_id,
        p_work_order_id,
        v_actual_yield,
        v_planned_yield,
        v_standard_cost
    );

    -- Calculate scrap cost
    SELECT COALESCE(SUM(total_scrap_cost), 0) INTO v_scrap_cost
    FROM calculate_work_order_scrap_cost(p_org_id, p_work_order_id);

    RETURN QUERY SELECT
        v_planned_yield,
        v_actual_yield,
        v_yield_percent,
        v_scrap_qty,
        v_standard_cost,
        v_yield_variance,
        v_scrap_cost,
        (v_yield_variance + v_scrap_cost) AS total_variance;
END;
$$ LANGUAGE plpgsql;

-- Trigger: Auto-create yield variance on WO completion
CREATE OR REPLACE FUNCTION trigger_create_yield_variance()
RETURNS TRIGGER AS $$
DECLARE
    v_variance RECORD;
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        SELECT * INTO v_variance
        FROM calculate_work_order_yield_variance(NEW.org_id, NEW.id);

        -- Insert yield variance if significant (> 1%)
        IF ABS(v_variance.yield_variance) > 0.01 THEN
            INSERT INTO cost_variances (
                org_id, work_order_id, variance_type,
                planned_yield, actual_yield, yield_percent,
                scrap_quantity, scrap_cost,
                variance_amount,
                currency_id, status
            )
            VALUES (
                NEW.org_id, NEW.id, 'yield',
                v_variance.planned_yield, v_variance.actual_yield,
                v_variance.yield_percent,
                v_variance.scrap_quantity, v_variance.scrap_cost,
                v_variance.total_variance,
                (SELECT id FROM currencies WHERE org_id = NEW.org_id AND is_base = true LIMIT 1),
                'identified'
            );
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER wo_yield_variance
    AFTER UPDATE ON work_orders
    FOR EACH ROW
    EXECUTE FUNCTION trigger_create_yield_variance();

-- Trigger: Auto-create scrap cost on scrap transaction
CREATE OR REPLACE FUNCTION trigger_create_scrap_cost()
RETURNS TRIGGER AS $$
DECLARE
    v_unit_cost NUMERIC;
BEGIN
    -- Get standard cost for scrapped product
    SELECT COALESCE(sc.total_cost, 0) INTO v_unit_cost
    FROM standard_costs sc
    WHERE sc.item_id = NEW.product_id
    AND sc.org_id = NEW.org_id
    AND sc.status = 'active'
    ORDER BY sc.effective_from DESC
    LIMIT 1;

    -- Create scrap cost record
    INSERT INTO scrap_costs (
        org_id, work_order_id, scrap_id,
        product_id, quantity, uom,
        unit_cost, total_cost,
        scrap_reason, scrap_category,
        currency_id, transaction_date
    )
    VALUES (
        NEW.org_id, NEW.work_order_id, NEW.id,
        NEW.product_id, NEW.quantity, NEW.uom,
        v_unit_cost, NEW.quantity * v_unit_cost,
        NEW.reason, NEW.category,
        (SELECT id FROM currencies WHERE org_id = NEW.org_id AND is_base = true LIMIT 1),
        CURRENT_DATE
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER scrap_cost_tracking
    AFTER INSERT ON scrap
    FOR EACH ROW
    EXECUTE FUNCTION trigger_create_scrap_cost();
```

---

## API Endpoints

### GET /api/finance/work-order-costs/:workOrderId/yield-variance
Get yield and scrap variance for work order.

**Response:**
```json
{
  "work_order_id": "uuid",
  "work_order_number": "WO-2026-001",
  "product_name": "Chocolate Bar 100g",
  "planned_yield": 1000,
  "actual_yield": 980,
  "yield_percent": 98.0,
  "scrap_quantity": 20,
  "standard_unit_cost": 9.25,
  "yield_variance": {
    "amount": -185.00,
    "percent": -2.0,
    "status": "unfavorable"
  },
  "scrap_cost": {
    "amount": 185.00,
    "by_reason": [
      {
        "reason": "Quality Defect",
        "quantity": 15,
        "cost": 138.75
      },
      {
        "reason": "Equipment Malfunction",
        "quantity": 5,
        "cost": 46.25
      }
    ]
  },
  "total_variance": {
    "amount": -185.00,
    "status": "unfavorable"
  }
}
```

### GET /api/finance/scrap-costs
List scrap costs with filters.

**Query Params:**
- `work_order_id` (optional)
- `product_id` (optional)
- `scrap_reason` (optional)
- `from_date`, `to_date`

**Response:**
```json
{
  "data": [
    {
      "id": "uuid",
      "work_order_id": "uuid",
      "work_order_number": "WO-2026-001",
      "product_name": "Chocolate Bar 100g",
      "scrap_quantity": 15,
      "unit_cost": 9.25,
      "total_cost": 138.75,
      "scrap_reason": "Quality Defect",
      "transaction_date": "2026-01-15"
    }
  ],
  "pagination": {...}
}
```

### GET /api/finance/reports/yield-variance
Yield variance report.

**Query Params:**
- `from_date`, `to_date`
- `group_by` (optional: product, work_order)

**Response:**
```json
{
  "summary": {
    "total_planned_yield": 50000,
    "total_actual_yield": 48500,
    "average_yield_percent": 97.0,
    "total_scrap_quantity": 1500,
    "total_yield_variance": -13875.00,
    "total_scrap_cost": 13875.00
  },
  "by_product": [
    {
      "product_id": "uuid",
      "product_name": "Chocolate Bar 100g",
      "planned_yield": 10000,
      "actual_yield": 9800,
      "yield_percent": 98.0,
      "scrap_quantity": 200,
      "yield_variance": -1850.00,
      "scrap_cost": 1850.00
    }
  ]
}
```

### GET /api/finance/reports/scrap-cost-by-reason
Scrap cost analysis by reason code.

**Query Params:**
- `from_date`, `to_date`

**Response:**
```json
{
  "summary": {
    "total_scrap_cost": 13875.00,
    "total_scrap_quantity": 1500,
    "reason_count": 5
  },
  "by_reason": [
    {
      "scrap_reason": "Quality Defect",
      "scrap_quantity": 750,
      "total_cost": 6937.50,
      "percent_of_total": 50.0,
      "work_order_count": 25
    },
    {
      "scrap_reason": "Equipment Malfunction",
      "scrap_quantity": 400,
      "total_cost": 3700.00,
      "percent_of_total": 26.7,
      "work_order_count": 12
    }
  ]
}
```

---

## Service Layer

### YieldVarianceService

```typescript
export class YieldVarianceService {
  static async getYieldVariance(workOrderId: string) {
    const response = await fetch(
      `/api/finance/work-order-costs/${workOrderId}/yield-variance`
    );
    if (!response.ok) throw new Error('Failed to fetch yield variance');
    return response.json();
  }

  static async getScrapCosts(filters?: {
    workOrderId?: string;
    productId?: string;
    scrapReason?: string;
    fromDate?: Date;
    toDate?: Date;
  }) {
    const params = new URLSearchParams();
    if (filters?.workOrderId) params.set('work_order_id', filters.workOrderId);
    if (filters?.productId) params.set('product_id', filters.productId);
    if (filters?.scrapReason) params.set('scrap_reason', filters.scrapReason);
    if (filters?.fromDate) params.set('from_date', filters.fromDate.toISOString());
    if (filters?.toDate) params.set('to_date', filters.toDate.toISOString());

    const response = await fetch(`/api/finance/scrap-costs?${params}`);
    if (!response.ok) throw new Error('Failed to fetch scrap costs');
    return response.json();
  }

  static async getYieldVarianceReport(filters: {
    fromDate: Date;
    toDate: Date;
    groupBy?: 'product' | 'work_order';
  }) {
    const params = new URLSearchParams({
      from_date: filters.fromDate.toISOString(),
      to_date: filters.toDate.toISOString(),
      group_by: filters.groupBy || 'product'
    });

    const response = await fetch(`/api/finance/reports/yield-variance?${params}`);
    if (!response.ok) throw new Error('Failed to fetch yield report');
    return response.json();
  }

  static async getScrapCostByReason(filters: {
    fromDate: Date;
    toDate: Date;
  }) {
    const params = new URLSearchParams({
      from_date: filters.fromDate.toISOString(),
      to_date: filters.toDate.toISOString()
    });

    const response = await fetch(`/api/finance/reports/scrap-cost-by-reason?${params}`);
    if (!response.ok) throw new Error('Failed to fetch scrap analysis');
    return response.json();
  }

  static async calculateYieldVarianceForWorkOrder(workOrderId: string) {
    const { data, error } = await supabase.rpc(
      'calculate_work_order_yield_variance',
      {
        p_org_id: getOrgId(),
        p_work_order_id: workOrderId
      }
    );

    if (error) throw error;
    return data;
  }
}
```

---

## Acceptance Criteria

### AC-1: Yield Variance Calculation
```gherkin
Given planned yield = 1000 units
And actual yield = 980 units
And standard unit cost = 9.25 PLN
When calculating yield variance
Then yield_variance = (980 - 1000) × 9.25 = -185.00 PLN (unfavorable)
And yield_percent = (980 / 1000) × 100 = 98.0%
```

### AC-2: Scrap Cost Tracking
```gherkin
Given scrap transaction created:
  | Product | Quantity | Reason | Standard Cost |
  | Chocolate Bar | 20 | Quality Defect | 9.25 |
When scrap recorded
Then scrap_costs record created:
  | total_cost | 185.00 |
  | scrap_reason | Quality Defect |
```

### AC-3: Auto-Create Yield Variance
```gherkin
Given work order status changes to "completed"
And yield_variance = -185.00 (> 1%)
When WO completion triggered
Then cost_variances record created:
  | variance_type | yield |
  | variance_amount | -185.00 |
  | status | identified |
```

### AC-4: Scrap Cost by Reason Report
```gherkin
Given GET /api/finance/reports/scrap-cost-by-reason
When requesting scrap analysis
Then response includes:
  - Summary (total scrap cost and quantity)
  - Breakdown by reason code
  - Percentage of total per reason
  - Work order count per reason
```

---

## Performance Requirements

- Yield variance calculation: < 200ms
- Scrap cost calculation: < 200ms
- Yield variance report (1 month): < 2s
- Scrap by reason report (1 month): < 2s
- Auto-variance trigger: < 300ms

---

## Testing

### Unit Tests
- Yield variance formula
- Scrap cost calculation
- Yield percentage calculation
- Zero yield handling

### Integration Tests
- Auto-create yield variance
- Auto-create scrap cost
- Yield variance report
- Scrap by reason report

### Edge Cases
- Zero planned yield (should error)
- Zero actual yield (should handle)
- No scrap (should return zero cost)
- 100% yield (no variance)

---

## Deliverables

- [ ] `scrap_costs` table
- [ ] Extended `cost_variances` table (yield columns)
- [ ] `calculate_yield_variance()` function
- [ ] `calculate_work_order_scrap_cost()` function
- [ ] `calculate_work_order_yield_variance()` function
- [ ] Auto-create yield variance trigger
- [ ] Auto-create scrap cost trigger
- [ ] API: Yield variance endpoint
- [ ] API: Scrap costs list
- [ ] API: Yield variance report
- [ ] API: Scrap cost by reason
- [ ] YieldVarianceService with 5 methods
- [ ] Tests: Unit, integration, edge cases

---

## Definition of Done

- [ ] Yield variance calculated correctly
- [ ] Scrap costs tracked per transaction
- [ ] Auto-create variance on WO completion
- [ ] Auto-create scrap cost on scrap transaction
- [ ] Yield variance report generates < 2s
- [ ] Scrap by reason report generates < 2s
- [ ] Tests pass (unit, integration, edge cases)
- [ ] Performance benchmarks met
- [ ] Documentation updated

---

**Created**: 2026-01-15 | **Complexity**: M (3-4 days) | **Phase**: 2
