# Story 03.12 - Database Schema
# Purpose: Tables, RLS policies, indexes, functions, triggers
# Agent: BACKEND-DEV (database focus)

migrations:
  - path: "supabase/migrations/XXX_create_wo_operations_table.sql"
    type: "migration"
    description: "WO Operations table with RLS, indexes, functions, triggers"
    includes:
      - "wo_operations table"
      - "copy_routing_to_wo() function"
      - "update_wo_ops_timestamp trigger"
      - "calculate_wo_ops_duration trigger"
      - "RLS policies"
      - "Indexes"

tables:
  - name: "wo_operations"
    description: "WO Operations - immutable snapshot of routing operations"
    columns:
      - { name: "id", type: "UUID", constraints: "PRIMARY KEY DEFAULT gen_random_uuid()" }
      - { name: "wo_id", type: "UUID", constraints: "NOT NULL REFERENCES work_orders(id) ON DELETE CASCADE" }
      - { name: "organization_id", type: "UUID", constraints: "NOT NULL REFERENCES organizations(id) ON DELETE CASCADE" }
      - { name: "sequence", type: "INTEGER", constraints: "NOT NULL" }
      - { name: "operation_name", type: "TEXT", constraints: "NOT NULL" }
      - { name: "description", type: "TEXT", constraints: "" }
      - { name: "instructions", type: "TEXT", constraints: "" }
      - { name: "machine_id", type: "UUID", constraints: "REFERENCES machines(id)" }
      - { name: "line_id", type: "UUID", constraints: "REFERENCES production_lines(id)" }
      - { name: "expected_duration_minutes", type: "INTEGER", constraints: "" }
      - { name: "expected_yield_percent", type: "DECIMAL(5,2)", constraints: "" }
      - { name: "actual_duration_minutes", type: "INTEGER", constraints: "" }
      - { name: "actual_yield_percent", type: "DECIMAL(5,2)", constraints: "" }
      - { name: "status", type: "TEXT", constraints: "DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'skipped'))" }
      - { name: "started_at", type: "TIMESTAMPTZ", constraints: "" }
      - { name: "completed_at", type: "TIMESTAMPTZ", constraints: "" }
      - { name: "started_by", type: "UUID", constraints: "REFERENCES users(id)" }
      - { name: "completed_by", type: "UUID", constraints: "REFERENCES users(id)" }
      - { name: "skip_reason", type: "TEXT", constraints: "" }
      - { name: "notes", type: "TEXT", constraints: "" }
      - { name: "created_at", type: "TIMESTAMPTZ", constraints: "DEFAULT NOW()" }
      - { name: "updated_at", type: "TIMESTAMPTZ", constraints: "DEFAULT NOW()" }
    rls: true
    rls_pattern: "organization_id = (SELECT org_id FROM users WHERE id = auth.uid())"
    indexes:
      - "idx_wo_ops_wo_id ON wo_operations(wo_id)"
      - "idx_wo_ops_org_id ON wo_operations(organization_id)"
      - "idx_wo_ops_status ON wo_operations(status)"
      - "idx_wo_ops_machine ON wo_operations(machine_id)"
      - "idx_wo_ops_line ON wo_operations(line_id)"
      - "idx_wo_ops_sequence ON wo_operations(wo_id, sequence)"
    constraints:
      - "UNIQUE(wo_id, sequence)"
      - "CHECK (expected_duration_minutes IS NULL OR expected_duration_minutes > 0)"
      - "CHECK (actual_duration_minutes IS NULL OR actual_duration_minutes >= 0)"
      - "CHECK (expected_yield_percent IS NULL OR (expected_yield_percent >= 0 AND expected_yield_percent <= 100))"
      - "CHECK (actual_yield_percent IS NULL OR (actual_yield_percent >= 0 AND actual_yield_percent <= 100))"

# Database Functions
functions:
  - name: "copy_routing_to_wo"
    description: "Copy routing operations to WO operations on release"
    params:
      - { name: "p_wo_id", type: "UUID" }
      - { name: "p_org_id", type: "UUID" }
    returns: "INTEGER"
    logic: |
      1. Get WO routing_id
      2. Check wo_copy_routing setting
      3. Exit early if setting disabled or no routing
      4. Check idempotency (existing operations)
      5. Copy routing_operations to wo_operations
      6. Calculate expected_duration = duration + setup_time + cleanup_time
      7. Return operation count

  - name: "update_wo_ops_timestamp"
    description: "Update timestamp on modification"
    trigger: "BEFORE UPDATE ON wo_operations"
    logic: "NEW.updated_at := NOW()"

  - name: "calculate_wo_ops_duration"
    description: "Calculate actual duration on completion"
    trigger: "BEFORE UPDATE OF status, completed_at ON wo_operations"
    logic: |
      IF NEW.status = 'completed' AND NEW.started_at IS NOT NULL AND NEW.completed_at IS NOT NULL
      THEN NEW.actual_duration_minutes := EXTRACT(EPOCH FROM (NEW.completed_at - NEW.started_at)) / 60

# RLS Policies (ADR-013)
rls_policies:
  pattern: "Users Table Lookup + Role Check"
  pattern_sql: "(SELECT org_id FROM users WHERE id = auth.uid())"

  policies:
    - table: "wo_operations"
      name: "wo_ops_select"
      operation: "SELECT"
      using: "organization_id = (SELECT org_id FROM users WHERE id = auth.uid())"

    - table: "wo_operations"
      name: "wo_ops_insert"
      operation: "INSERT"
      with_check: |
        organization_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND (
          (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid())
          IN ('SUPER_ADMIN', 'ADMIN', 'PLANNER', 'PROD_MANAGER')
        )

    - table: "wo_operations"
      name: "wo_ops_update"
      operation: "UPDATE"
      using: |
        organization_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND (
          (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid())
          IN ('SUPER_ADMIN', 'ADMIN', 'PLANNER', 'PROD_MANAGER', 'OPERATOR')
        )

    - table: "wo_operations"
      name: "wo_ops_delete"
      operation: "DELETE"
      using: |
        organization_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND (
          (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid())
          IN ('SUPER_ADMIN', 'ADMIN')
        )

# Source Table Reference (routing_operations)
source_table:
  name: "routing_operations"
  description: "Source of operations to copy from"
  fields_mapped:
    - { source: "sequence", target: "sequence" }
    - { source: "name", target: "operation_name" }
    - { source: "description", target: "description" }
    - { source: "instructions", target: "instructions" }
    - { source: "machine_id", target: "machine_id" }
    - { source: "line_id", target: "line_id" }
    - { source: "duration + setup_time + cleanup_time", target: "expected_duration_minutes" }
  fields_not_mapped:
    - { source: "labor_cost_per_hour", reason: "Finance module scope" }
    - { source: "expected_yield_percent", reason: "Not in routing_operations (null)" }

# Migration SQL Template
migration_template: |
  -- Migration: XXX_create_wo_operations_table.sql
  -- Description: WO Operations table (routing snapshot)
  -- Story: 03.12 - WO Operations (Routing Copy)

  BEGIN;

  -- =============================================================================
  -- TABLE: wo_operations
  -- =============================================================================
  CREATE TABLE wo_operations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    wo_id UUID NOT NULL REFERENCES work_orders(id) ON DELETE CASCADE,
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

    -- Operation identity
    sequence INTEGER NOT NULL,
    operation_name TEXT NOT NULL,
    description TEXT,
    instructions TEXT,

    -- Resource assignment (copied from routing_operations)
    machine_id UUID REFERENCES machines(id),
    line_id UUID REFERENCES production_lines(id),

    -- Expected performance (from routing)
    expected_duration_minutes INTEGER,
    expected_yield_percent DECIMAL(5,2),

    -- Actual performance (filled during production in Epic 04)
    actual_duration_minutes INTEGER,
    actual_yield_percent DECIMAL(5,2),

    -- Status tracking
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'skipped')),
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    started_by UUID REFERENCES users(id),
    completed_by UUID REFERENCES users(id),

    -- Skipped operations
    skip_reason TEXT,

    -- Notes
    notes TEXT,

    -- Audit
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT wo_ops_unique_sequence UNIQUE(wo_id, sequence),
    CONSTRAINT wo_ops_expected_duration_positive CHECK (expected_duration_minutes IS NULL OR expected_duration_minutes > 0),
    CONSTRAINT wo_ops_actual_duration_positive CHECK (actual_duration_minutes IS NULL OR actual_duration_minutes >= 0),
    CONSTRAINT wo_ops_expected_yield_range CHECK (expected_yield_percent IS NULL OR (expected_yield_percent >= 0 AND expected_yield_percent <= 100)),
    CONSTRAINT wo_ops_actual_yield_range CHECK (actual_yield_percent IS NULL OR (actual_yield_percent >= 0 AND actual_yield_percent <= 100))
  );

  -- =============================================================================
  -- INDEXES
  -- =============================================================================
  CREATE INDEX idx_wo_ops_wo_id ON wo_operations(wo_id);
  CREATE INDEX idx_wo_ops_org_id ON wo_operations(organization_id);
  CREATE INDEX idx_wo_ops_status ON wo_operations(status);
  CREATE INDEX idx_wo_ops_machine ON wo_operations(machine_id);
  CREATE INDEX idx_wo_ops_line ON wo_operations(line_id);
  CREATE INDEX idx_wo_ops_sequence ON wo_operations(wo_id, sequence);

  -- =============================================================================
  -- FUNCTION: copy_routing_to_wo
  -- =============================================================================
  CREATE OR REPLACE FUNCTION copy_routing_to_wo(
    p_wo_id UUID,
    p_org_id UUID
  )
  RETURNS INTEGER AS $$
  DECLARE
    v_routing_id UUID;
    v_wo_copy_routing BOOLEAN;
    v_operation_count INTEGER := 0;
  BEGIN
    -- Get WO routing_id
    SELECT routing_id INTO v_routing_id
    FROM work_orders
    WHERE id = p_wo_id AND org_id = p_org_id;

    -- Check if WO exists
    IF NOT FOUND THEN
      RAISE EXCEPTION 'Work order not found';
    END IF;

    -- Check setting (default to TRUE if not set)
    SELECT COALESCE(wo_copy_routing, TRUE) INTO v_wo_copy_routing
    FROM planning_settings
    WHERE org_id = p_org_id;

    -- Default to TRUE if no settings row exists
    IF v_wo_copy_routing IS NULL THEN
      v_wo_copy_routing := TRUE;
    END IF;

    -- Exit if setting disabled or no routing
    IF v_wo_copy_routing = FALSE OR v_routing_id IS NULL THEN
      RETURN 0;
    END IF;

    -- Check if operations already exist (idempotency)
    SELECT COUNT(*) INTO v_operation_count
    FROM wo_operations
    WHERE wo_id = p_wo_id;

    IF v_operation_count > 0 THEN
      -- Operations already copied, return existing count
      RETURN v_operation_count;
    END IF;

    -- Copy routing operations to wo_operations
    INSERT INTO wo_operations (
      wo_id,
      organization_id,
      sequence,
      operation_name,
      description,
      instructions,
      machine_id,
      line_id,
      expected_duration_minutes,
      expected_yield_percent,
      status
    )
    SELECT
      p_wo_id,
      p_org_id,
      ro.sequence,
      ro.name,
      ro.description,
      ro.instructions,
      ro.machine_id,
      ro.line_id,
      COALESCE(ro.duration, 0) + COALESCE(ro.setup_time, 0) + COALESCE(ro.cleanup_time, 0),
      NULL,  -- expected_yield_percent not in routing_operations
      'pending'
    FROM routing_operations ro
    WHERE ro.routing_id = v_routing_id
    ORDER BY ro.sequence;

    GET DIAGNOSTICS v_operation_count = ROW_COUNT;

    RETURN v_operation_count;
  END;
  $$ LANGUAGE plpgsql;

  -- =============================================================================
  -- TRIGGER: update_wo_ops_timestamp
  -- =============================================================================
  CREATE OR REPLACE FUNCTION update_wo_ops_timestamp()
  RETURNS TRIGGER AS $$
  BEGIN
    NEW.updated_at := NOW();
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER tr_wo_ops_update_timestamp
  BEFORE UPDATE ON wo_operations
  FOR EACH ROW
  EXECUTE FUNCTION update_wo_ops_timestamp();

  -- =============================================================================
  -- TRIGGER: calculate_wo_ops_duration
  -- =============================================================================
  CREATE OR REPLACE FUNCTION calculate_wo_ops_duration()
  RETURNS TRIGGER AS $$
  BEGIN
    IF NEW.status = 'completed' AND NEW.started_at IS NOT NULL AND NEW.completed_at IS NOT NULL THEN
      NEW.actual_duration_minutes := EXTRACT(EPOCH FROM (NEW.completed_at - NEW.started_at)) / 60;
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER tr_wo_ops_calculate_duration
  BEFORE UPDATE OF status, completed_at ON wo_operations
  FOR EACH ROW
  EXECUTE FUNCTION calculate_wo_ops_duration();

  -- =============================================================================
  -- RLS POLICIES
  -- =============================================================================
  ALTER TABLE wo_operations ENABLE ROW LEVEL SECURITY;

  CREATE POLICY "wo_ops_select" ON wo_operations
  FOR SELECT TO authenticated
  USING (
    organization_id = (SELECT org_id FROM users WHERE id = auth.uid())
  );

  CREATE POLICY "wo_ops_insert" ON wo_operations
  FOR INSERT TO authenticated
  WITH CHECK (
    organization_id = (SELECT org_id FROM users WHERE id = auth.uid())
    AND (
      (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid())
      IN ('SUPER_ADMIN', 'ADMIN', 'PLANNER', 'PROD_MANAGER')
    )
  );

  CREATE POLICY "wo_ops_update" ON wo_operations
  FOR UPDATE TO authenticated
  USING (
    organization_id = (SELECT org_id FROM users WHERE id = auth.uid())
    AND (
      (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid())
      IN ('SUPER_ADMIN', 'ADMIN', 'PLANNER', 'PROD_MANAGER', 'OPERATOR')
    )
  );

  CREATE POLICY "wo_ops_delete" ON wo_operations
  FOR DELETE TO authenticated
  USING (
    organization_id = (SELECT org_id FROM users WHERE id = auth.uid())
    AND (
      (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid())
      IN ('SUPER_ADMIN', 'ADMIN')
    )
  );

  COMMIT;
