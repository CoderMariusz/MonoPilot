# 03.14 - WO Advanced Scheduling (APS Lite)

| Field | Value |
|-------|-------|
| **Story ID** | 03.14 |
| **Epic** | 03 - Planning |
| **Status** | Ready |
| **Phase** | P2 (Phase 2) - **DEFERRED** |
| **Complexity** | L (Large) |
| **Estimate** | 7-10 days |
| **Type** | Full-stack |

---

## DEFERRED STATUS

**DEFERRED - Requires Epic 04 (Production) + Epic 05 (Warehouse/Inventory)**

This story implements Advanced Planning and Scheduling (APS) lite functionality that requires:

1. **Epic 04 (Production)** - Line capacity definitions, shift schedules, machine availability
2. **Epic 05 (Warehouse/Inventory)** - License Plate (LP) inventory for material availability calculations
3. **Story 03.10** - Work Order CRUD (foundation)
4. **Story 03.13** - Material Availability Check (real-time inventory queries)
5. **Story 03.15** - WO Gantt Chart View (visualization base)

**Reason for Deferral:** Auto-scheduling requires real inventory data (LPs) to calculate material availability and production line capacity data to validate scheduling constraints. Without these foundations, the scheduling algorithm cannot make informed decisions.

**Target Phase:** Phase 2 (post-Epic 05 completion)

---

## PRD References

| FR ID | Requirement | Priority | Covered |
|-------|-------------|----------|---------|
| FR-PLAN-061 | Finite Capacity Scheduling | Could Have (Phase 3) | PARTIAL - Core scheduling |
| FR-PLAN-062 | Capacity Analytics | Could Have (Phase 3) | PARTIAL - Utilization only |
| FR-PLAN-060 | Resource Capacity Definition | Could Have (Phase 3) | YES - Line/machine capacity |
| FR-PLAN-024 | WO Gantt Chart View | Could Have | EXTENDS - Auto-scheduling |

**Primary PRD:** `docs/1-BASELINE/product/modules/planning.md` (Section 14)
**Architecture:** `docs/1-BASELINE/architecture/modules/planning.md`
**UX Wireframes:** PLAN-017 (Schedule Optimizer Modal), PLAN-018 (Capacity Chart)

---

## MVP Scope

This story implements APS Lite (Advanced Planning and Scheduling - Lightweight Version) for work order scheduling optimization. Unlike full APS systems that cost $50K+, this provides 80% of the value with constraint-based scheduling suitable for SMB food manufacturers.

**MVP Includes**:
- Scheduling algorithm engine (constraint-based, considers multiple factors)
- Auto-scheduling API endpoint to optimize WO schedule for date range
- Conflict detection for overlapping WOs on same production line
- Capacity utilization calculation per line/machine/day
- Manual schedule override with conflict warnings
- Schedule optimizer modal UI (trigger batch reschedule)
- Capacity utilization chart (visual heatmap)
- Service layer (scheduling engine, constraint validation)
- Validation schemas for scheduling inputs
- Comprehensive tests (constraint scenarios, optimization, edge cases)

**Deferred to Phase 3+**: See "Future Phases" section below.

---

## Goal

Provide production planners with intelligent scheduling capabilities that automatically optimize work order schedules based on line capacity, material availability, and production constraints, reducing manual scheduling effort by 70% while preventing scheduling conflicts.

---

## User Story

As a **Production Planner**, I want to **automatically optimize my work order schedule based on line capacity and material availability** so that **I can ensure efficient production without overloading lines, minimize changeovers, and guarantee materials are available when production starts**.

---

## Dependencies

| Dependency | Story/Epic | Type | Reason |
|------------|------------|------|--------|
| 01.1 | Org Context + Base RLS | HARD | Requires org_id context and RLS patterns |
| 01.9 | Production Lines CRUD | HARD | Line capacity definitions required |
| 01.10 | Machines CRUD | HARD | Machine capacity and availability |
| 02.1 | Products CRUD | HARD | Product information for scheduling |
| 02.4 | BOMs CRUD | HARD | BOM for material calculations |
| 03.10 | WO CRUD + BOM Auto-Select | HARD | Work orders to schedule |
| 03.11a | WO Materials (BOM Snapshot) | HARD | Material requirements per WO |
| 03.13 | WO Material Availability Check | HARD | Real-time inventory checks |
| 03.15 | WO Gantt Chart View | HARD | Visualization foundation |
| **Epic 04** | Production Module | **BLOCKER** | Line capacity, shift schedules, efficiency factors |
| **Epic 05** | Warehouse/Inventory | **BLOCKER** | LP inventory for material availability |

**Dependents:**
- MRP/MPS Integration (Phase 3) - Uses scheduling engine for planned orders
- Capacity Planning Analytics (Phase 3) - Extends utilization calculations

---

## Acceptance Criteria (Gherkin)

### AC-1: Schedule Optimizer Modal

```gherkin
Scenario: Open schedule optimizer from Gantt view
  Given planner views Gantt chart at `/planning/work-orders/gantt`
  When planner clicks "Optimize Schedule" button
  Then Schedule Optimizer modal opens
  And displays date range selector (default: next 7 days)
  And displays production line multi-select (default: all lines)
  And displays constraint toggles (capacity, materials, priority, changeover)
  And shows "Preview Optimization" and "Cancel" buttons

Scenario: Configure optimization parameters
  Given Schedule Optimizer modal is open
  When planner sets date range to "Dec 18 - Dec 25"
  And selects lines "Packing Line #1" and "Baking Line #2"
  And enables "Respect material availability" constraint
  And disables "Minimize changeovers" constraint
  Then optimization parameters are captured
  And "Preview Optimization" button is enabled

Scenario: Preview optimization results
  Given planner has configured optimization parameters
  When planner clicks "Preview Optimization"
  Then API POST /api/planning/work-orders/schedule/optimize called
  And loading spinner displays (max 10 seconds)
  And preview panel shows:
    - WOs to reschedule: 12
    - Conflicts resolved: 3
    - Utilization improvement: 15% -> 72%
    - Material warnings: 2
  And table lists each WO with old/new schedule
  And "Apply Changes" and "Modify" buttons appear

Scenario: Apply optimized schedule
  Given optimization preview displays 12 WOs to reschedule
  When planner clicks "Apply Changes"
  Then confirmation dialog shows "Reschedule 12 work orders?"
  And upon confirm, API POST /api/planning/work-orders/schedule/apply called
  And progress indicator shows "Applying changes... 4/12"
  And success toast "Schedule optimized: 12 WOs rescheduled" displays
  And Gantt chart refreshes with new schedule
  And modal closes

Scenario: Cancel optimization
  Given optimization preview is displayed
  When planner clicks "Cancel" or closes modal
  Then modal closes
  And no changes are applied
  And Gantt chart remains unchanged
```

### AC-2: Scheduling Algorithm - Constraint-Based

```gherkin
Scenario: Schedule respects line capacity
  Given Packing Line #1 has capacity of 8 hours/day
  And 3 WOs scheduled for Dec 18:
    - WO-001: 4 hours
    - WO-002: 3 hours
    - WO-003: 5 hours (total = 12 hours, exceeds capacity)
  When auto-schedule runs
  Then WO-003 is moved to Dec 19 (next available slot)
  And Dec 18 total = 7 hours (within capacity)
  And warning "WO-003 moved due to capacity constraint" logged

Scenario: Schedule respects material availability
  Given WO-004 requires 500kg Sugar Fine
  And Sugar Fine available: 400kg today, 600kg on Dec 20 (PO arriving)
  When auto-schedule runs with material constraint enabled
  Then WO-004 scheduled on or after Dec 20
  And warning "WO-004 delayed to Dec 20 awaiting material: Sugar Fine" logged

Scenario: Schedule respects WO priority
  Given 3 WOs for same line on Dec 18:
    - WO-005: Priority = High
    - WO-006: Priority = Normal
    - WO-007: Priority = Critical
  When auto-schedule runs
  Then WOs scheduled in priority order: WO-007, WO-005, WO-006
  And critical WOs get earliest time slots

Scenario: Schedule considers WO dependencies
  Given WO-008 depends on WO-007 (finish-to-start)
  And WO-007 scheduled to complete Dec 18, 16:00
  When auto-schedule runs
  Then WO-008 scheduled to start Dec 18, 16:00 or later
  And WO-008 cannot start before WO-007 completes

Scenario: Minimize changeovers (when enabled)
  Given 4 WOs for Packing Line #1:
    - WO-010: Product A (Chocolate)
    - WO-011: Product B (Vanilla)
    - WO-012: Product A (Chocolate)
    - WO-013: Product B (Vanilla)
  When auto-schedule runs with "Minimize changeovers" enabled
  Then WOs grouped by product: WO-010, WO-012 (Chocolate), then WO-011, WO-013 (Vanilla)
  And changeovers reduced from 3 to 1
```

### AC-3: Conflict Detection

```gherkin
Scenario: Detect overlapping WOs on same line
  Given Packing Line #1 has:
    - WO-020: Dec 18, 08:00-12:00
    - WO-021: Dec 18, 10:00-14:00 (overlaps with WO-020)
  When conflict detection runs
  Then conflict identified: "WO-020 and WO-021 overlap on Packing Line #1 (10:00-12:00)"
  And conflict severity = "High"
  And suggested resolution: "Move WO-021 to start at 12:00"

Scenario: Detect machine availability conflict
  Given Mixer #1 has downtime Dec 18, 10:00-14:00 (maintenance)
  And WO-022 scheduled for Dec 18, 11:00-15:00 on Mixer #1
  When conflict detection runs
  Then conflict identified: "WO-022 conflicts with Mixer #1 maintenance window"
  And suggested resolution: "Move WO-022 to 14:00 or reassign to Mixer #2"

Scenario: Detect capacity overload
  Given Baking Line #2 capacity = 8 hours/day
  And Dec 19 has WOs totaling 10.5 hours scheduled
  When conflict detection runs
  Then conflict identified: "Baking Line #2 over-capacity on Dec 19 by 2.5 hours"
  And suggested resolution: "Move 2.5 hours of work to Dec 20"

Scenario: Real-time conflict check on drag-drop
  Given planner drags WO-023 to Dec 18, 14:00 on Packing Line #1
  When drag position reaches new slot
  Then API POST /api/planning/work-orders/check-scheduling-conflicts called
  And response returns within 200ms
  And if conflict exists:
    - Ghost bar shows red border
    - Tooltip shows "Conflicts with WO-024 (13:00-15:30)"
  And if no conflict:
    - Ghost bar shows green border
    - Tooltip shows "Available slot"
```

### AC-4: Capacity Utilization Calculation

```gherkin
Scenario: Calculate daily capacity utilization per line
  Given Packing Line #1 has:
    - Capacity: 8 hours/day (480 minutes)
    - Efficiency factor: 0.85
    - Effective capacity: 408 minutes
  And WOs scheduled for Dec 18: 6 hours (360 minutes)
  When capacity utilization calculated
  Then utilization = 360 / 408 = 88.2%
  And utilization categorized as "High" (>80%)

Scenario: Calculate weekly capacity summary
  Given planner views capacity chart for week Dec 16-22
  When capacity API called
  Then response includes per-day utilization:
    | Date   | Line           | Capacity | Scheduled | Utilization | Status   |
    | Dec 16 | Packing Line 1 | 408 min  | 200 min   | 49%         | Low      |
    | Dec 17 | Packing Line 1 | 408 min  | 380 min   | 93%         | Critical |
    | Dec 18 | Packing Line 1 | 408 min  | 320 min   | 78%         | Medium   |
    | Dec 19 | Packing Line 1 | 408 min  | 450 min   | 110%        | Overload |

Scenario: Display capacity heatmap
  Given planner views capacity utilization chart
  When chart renders
  Then cells color-coded by utilization:
    - 0-50%: Green (#D1FAE5)
    - 50-80%: Yellow (#FEF3C7)
    - 80-100%: Orange (#FED7AA)
    - >100%: Red (#FEE2E2)
  And tooltip shows "Dec 18: 78% (320/408 min)"
```

### AC-5: Auto-Scheduling API Endpoint

```gherkin
Scenario: Call schedule optimization API
  Given planner triggers optimization via modal
  When API POST /api/planning/work-orders/schedule/optimize called with:
    {
      "date_from": "2024-12-18",
      "date_to": "2024-12-25",
      "line_ids": ["uuid-line-1", "uuid-line-2"],
      "constraints": {
        "respect_capacity": true,
        "respect_materials": true,
        "respect_priority": true,
        "minimize_changeovers": false
      },
      "dry_run": true
    }
  Then API returns optimization preview:
    {
      "success": true,
      "data": {
        "optimization_id": "uuid-opt-1",
        "summary": {
          "wos_analyzed": 25,
          "wos_to_reschedule": 12,
          "conflicts_resolved": 3,
          "utilization_before": 0.45,
          "utilization_after": 0.72,
          "material_warnings": 2
        },
        "changes": [
          {
            "wo_id": "uuid-wo-1",
            "wo_number": "WO-001",
            "product_name": "Chocolate Bar",
            "current": {
              "date": "2024-12-18",
              "start_time": "08:00",
              "end_time": "12:00",
              "line_id": "uuid-line-1"
            },
            "proposed": {
              "date": "2024-12-19",
              "start_time": "08:00",
              "end_time": "12:00",
              "line_id": "uuid-line-1"
            },
            "reason": "Capacity constraint - Dec 18 overloaded"
          }
        ],
        "warnings": [
          {
            "wo_id": "uuid-wo-3",
            "type": "material_availability",
            "message": "Sugar Fine will have 400kg available, 500kg required"
          }
        ]
      }
    }

Scenario: Apply optimization changes
  Given optimization preview generated (dry_run: true)
  When API POST /api/planning/work-orders/schedule/apply called with:
    {
      "optimization_id": "uuid-opt-1",
      "apply_changes": true
    }
  Then WOs are updated in database
  And status history records transition (source: "auto_scheduler")
  And response returns updated WO list
  And event "wo.batch_rescheduled" published

Scenario: Optimization timeout handling
  Given complex schedule with 100+ WOs
  When optimization runs longer than 30 seconds
  Then API returns partial results:
    {
      "success": false,
      "error": "OPTIMIZATION_TIMEOUT",
      "partial_results": { ... },
      "message": "Optimization timed out. Try reducing date range or line selection."
    }
```

### AC-6: Manual Schedule Override

```gherkin
Scenario: Manual reschedule with conflict warning
  Given WO-030 scheduled on Packing Line #1, Dec 18, 08:00-12:00
  And Packing Line #1 already has WO-031 at Dec 18, 10:00-14:00
  When planner manually drags WO-030 to overlap
  Then warning dialog appears:
    "This creates a conflict with WO-031 (10:00-14:00). Proceed anyway?"
  And options: "Override and Save" / "Cancel"

Scenario: Override conflict and save
  Given conflict warning dialog displayed
  When planner clicks "Override and Save"
  Then WO-030 saved to conflicting position
  And conflict flag set on both WOs: `has_scheduling_conflict: true`
  And conflict indicator shows on Gantt bars (red border)
  And audit log records: "Manual override by [user] - scheduling conflict accepted"

Scenario: Resolve conflict by moving other WO
  Given WO-030 and WO-031 have scheduling conflict
  When planner clicks "Resolve Conflicts" button
  Then conflict resolution dialog opens
  And shows options:
    - Move WO-030 to Dec 18, 14:00 (after WO-031)
    - Move WO-031 to Dec 18, 12:00 (after WO-030)
    - Move WO-030 to Baking Line #2
  And planner selects resolution
  And conflict flags cleared on both WOs
```

### AC-7: Capacity Chart UI

```gherkin
Scenario: View capacity utilization chart
  Given planner navigates to `/planning/capacity` or Gantt sidebar
  When capacity chart loads
  Then heatmap displays:
    - X-axis: Dates (next 30 days)
    - Y-axis: Production lines
    - Cells: Color-coded by utilization percentage
  And legend shows: Low (green), Medium (yellow), High (orange), Overload (red)

Scenario: Drill-down on capacity cell
  Given capacity chart displayed
  When planner clicks cell for "Packing Line #1, Dec 18"
  Then popover shows:
    - Line: Packing Line #1
    - Date: Dec 18, 2024
    - Capacity: 8 hours (480 min)
    - Scheduled: 10.5 hours (630 min)
    - Utilization: 131% (OVERLOAD)
    - WOs: [WO-001 (4h), WO-002 (3h), WO-003 (3.5h)]
  And "View in Gantt" button navigates to filtered Gantt view

Scenario: Filter capacity by date range
  Given capacity chart displayed
  When planner changes date range to "This Week"
  Then chart refreshes to show only Mon-Sun current week
  And utilization recalculated for visible dates

Scenario: Export capacity report
  Given capacity chart displayed
  When planner clicks "Export" button
  Then options shown: CSV, PDF
  And export includes: Line, Date, Capacity, Scheduled, Utilization, WO List
```

### AC-8: Service Layer - Scheduling Engine

```gherkin
Scenario: Scheduling engine processes constraints in order
  Given scheduling engine receives optimization request
  When engine processes constraints
  Then constraints applied in priority order:
    1. Hard constraints (capacity limits, machine availability)
    2. Soft constraints (material availability)
    3. Preference constraints (minimize changeovers, priority grouping)
  And each constraint logged for traceability

Scenario: Scheduling engine handles infeasible schedule
  Given constraints cannot all be satisfied
  When scheduling engine runs
  Then best-effort schedule generated
  And violations reported in warnings array
  And violation severity categorized (critical, warning, info)
  And suggestion provided for each violation

Scenario: Scheduling engine performance
  Given 100 WOs across 5 lines over 14 days
  When optimization requested
  Then scheduling completes within 10 seconds
  And memory usage stays below 512MB
  And no database locks held for >1 second
```

### AC-9: Validation Schemas

```gherkin
Scenario: Validate optimization request
  Given API receives optimization request
  When request validated against schema
  Then required fields checked:
    - date_from: ISO date string (required)
    - date_to: ISO date string (required, >= date_from)
    - line_ids: array of UUIDs (optional, empty = all lines)
    - constraints: object (optional, defaults applied)
    - dry_run: boolean (default: true)
  And invalid requests return 400 with field-level errors

Scenario: Validate scheduling constraint values
  Given constraints object in request
  When validated
  Then constraint flags must be boolean
  And unknown constraint keys rejected
  And date range limited to 60 days maximum
  And line_ids validated against existing lines
```

### AC-10: Complex Test Scenarios

```gherkin
Scenario: Multi-constraint optimization
  Given complex schedule:
    - 20 WOs across 3 lines
    - Mixed priorities (2 critical, 5 high, 13 normal)
    - 3 WOs have material shortages
    - 5 WOs have same product (changeover opportunity)
    - 2 WOs have dependencies
  When optimization runs with all constraints enabled
  Then critical WOs scheduled first
  And WOs with material shortages delayed to availability date
  And same-product WOs grouped to minimize changeovers
  And dependent WOs sequenced correctly
  And no capacity violations in final schedule

Scenario: Edge case - all WOs already optimal
  Given schedule has no conflicts
  And capacity utilization balanced
  When optimization runs
  Then response: "wos_to_reschedule: 0"
  And message: "Schedule is already optimized"

Scenario: Edge case - impossible schedule
  Given 10 WOs requiring 80 hours
  And 1 line with 40 hours capacity (5 days)
  And due date for all WOs is within 5 days
  When optimization runs
  Then best-effort schedule created
  And 5 WOs marked as "cannot meet due date"
  And warning: "40 hours of work cannot be scheduled within constraints"
```

### AC-11: Permission Enforcement

```gherkin
Scenario: Planner can optimize schedule
  Given user has PLANNER role
  When accessing schedule optimization
  Then full access to optimize, preview, apply

Scenario: Production Manager can view and apply
  Given user has PROD_MANAGER role
  When accessing schedule optimization
  Then can preview and apply optimization
  But cannot modify optimization algorithm parameters

Scenario: Operator view only
  Given user has OPERATOR role
  When accessing schedule optimization
  Then "Optimize Schedule" button hidden
  And capacity chart visible (read-only)
```

### AC-12: Multi-tenancy

```gherkin
Scenario: Org isolation on optimization
  Given User A from Org A triggers optimization
  When API processes request
  Then only Org A WOs, lines, materials considered
  And cross-org data never accessed

Scenario: Optimization results scoped to org
  Given optimization completes for Org A
  When results stored temporarily
  Then optimization_id scoped to Org A
  And cannot be accessed by Org B users
```

---

## Technical Specification

### Database Schema

```sql
-- Scheduling optimization runs (audit trail)
CREATE TABLE scheduling_optimizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

  -- Request parameters
  date_from DATE NOT NULL,
  date_to DATE NOT NULL,
  line_ids UUID[], -- NULL = all lines
  constraints JSONB NOT NULL,

  -- Results
  status VARCHAR(20) NOT NULL DEFAULT 'pending', -- pending, running, completed, failed, expired
  wos_analyzed INTEGER,
  wos_rescheduled INTEGER,
  conflicts_resolved INTEGER,
  utilization_before DECIMAL(5,2),
  utilization_after DECIMAL(5,2),

  -- Proposed changes (JSON for preview)
  proposed_changes JSONB,
  warnings JSONB,

  -- Timing
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  applied_at TIMESTAMPTZ,
  expires_at TIMESTAMPTZ, -- Optimization expires after 1 hour

  -- Audit
  created_by UUID REFERENCES users(id),
  applied_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT so_status_check CHECK (status IN ('pending', 'running', 'completed', 'failed', 'expired', 'applied'))
);

-- Scheduling conflicts (detected or manual override)
CREATE TABLE wo_scheduling_conflicts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

  wo_id UUID NOT NULL REFERENCES work_orders(id) ON DELETE CASCADE,
  conflicting_wo_id UUID REFERENCES work_orders(id) ON DELETE SET NULL,

  conflict_type VARCHAR(30) NOT NULL, -- overlap, capacity, material, machine_unavailable
  severity VARCHAR(20) NOT NULL, -- critical, warning, info
  description TEXT NOT NULL,
  suggested_resolution TEXT,

  -- Status
  status VARCHAR(20) NOT NULL DEFAULT 'active', -- active, resolved, ignored
  resolved_at TIMESTAMPTZ,
  resolved_by UUID REFERENCES users(id),
  resolution_notes TEXT,

  -- Audit
  detected_at TIMESTAMPTZ DEFAULT NOW(),
  detected_by VARCHAR(30), -- 'system', 'manual_override', 'optimization'

  CONSTRAINT wsc_type_check CHECK (conflict_type IN ('overlap', 'capacity', 'material', 'machine_unavailable', 'dependency')),
  CONSTRAINT wsc_severity_check CHECK (severity IN ('critical', 'warning', 'info')),
  CONSTRAINT wsc_status_check CHECK (status IN ('active', 'resolved', 'ignored'))
);

-- Capacity calendar (pre-calculated or cached)
CREATE TABLE line_capacity_calendar (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

  line_id UUID NOT NULL REFERENCES production_lines(id) ON DELETE CASCADE,
  capacity_date DATE NOT NULL,

  -- Capacity in minutes
  available_minutes INTEGER NOT NULL, -- From shift definitions
  efficiency_factor DECIMAL(5,4) DEFAULT 1.0, -- 0.85 = 85% efficiency
  effective_minutes INTEGER GENERATED ALWAYS AS (available_minutes * efficiency_factor) STORED,

  -- Scheduled work
  scheduled_minutes INTEGER DEFAULT 0,
  utilization_percent DECIMAL(5,2) GENERATED ALWAYS AS (
    CASE WHEN available_minutes * efficiency_factor > 0
      THEN (scheduled_minutes::DECIMAL / (available_minutes * efficiency_factor)) * 100
      ELSE 0
    END
  ) STORED,

  -- WO count
  wo_count INTEGER DEFAULT 0,

  -- Audit
  last_calculated_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT lcc_unique UNIQUE(org_id, line_id, capacity_date)
);

-- Indexes
CREATE INDEX idx_so_org_status ON scheduling_optimizations(org_id, status);
CREATE INDEX idx_so_created_at ON scheduling_optimizations(created_at DESC);
CREATE INDEX idx_wsc_org_wo ON wo_scheduling_conflicts(org_id, wo_id);
CREATE INDEX idx_wsc_status ON wo_scheduling_conflicts(status);
CREATE INDEX idx_lcc_org_line_date ON line_capacity_calendar(org_id, line_id, capacity_date);
CREATE INDEX idx_lcc_utilization ON line_capacity_calendar(org_id, capacity_date, utilization_percent);

-- Function: Calculate capacity utilization for date range
CREATE OR REPLACE FUNCTION calculate_capacity_utilization(
  p_org_id UUID,
  p_line_id UUID,
  p_date_from DATE,
  p_date_to DATE
)
RETURNS TABLE (
  capacity_date DATE,
  available_minutes INTEGER,
  scheduled_minutes INTEGER,
  utilization_percent DECIMAL,
  wo_count INTEGER,
  status VARCHAR
) AS $$
BEGIN
  RETURN QUERY
  WITH wo_durations AS (
    SELECT
      wo.planned_start_date AS wo_date,
      EXTRACT(EPOCH FROM (
        (wo.planned_start_date || ' ' || COALESCE(wo.scheduled_end_time, '17:00'))::TIMESTAMP -
        (wo.planned_start_date || ' ' || COALESCE(wo.scheduled_start_time, '08:00'))::TIMESTAMP
      )) / 60 AS duration_minutes
    FROM work_orders wo
    WHERE wo.org_id = p_org_id
      AND wo.production_line_id = p_line_id
      AND wo.planned_start_date BETWEEN p_date_from AND p_date_to
      AND wo.status NOT IN ('cancelled', 'completed', 'closed')
  ),
  daily_totals AS (
    SELECT
      wo_date,
      SUM(duration_minutes)::INTEGER AS total_minutes,
      COUNT(*)::INTEGER AS wo_count
    FROM wo_durations
    GROUP BY wo_date
  ),
  date_series AS (
    SELECT generate_series(p_date_from, p_date_to, '1 day'::INTERVAL)::DATE AS d
  )
  SELECT
    ds.d AS capacity_date,
    COALESCE(lcc.available_minutes, 480) AS available_minutes, -- Default 8 hours
    COALESCE(dt.total_minutes, 0)::INTEGER AS scheduled_minutes,
    CASE
      WHEN COALESCE(lcc.available_minutes, 480) > 0
      THEN ROUND((COALESCE(dt.total_minutes, 0)::DECIMAL / COALESCE(lcc.available_minutes, 480)) * 100, 2)
      ELSE 0
    END AS utilization_percent,
    COALESCE(dt.wo_count, 0)::INTEGER AS wo_count,
    CASE
      WHEN COALESCE(dt.total_minutes, 0)::DECIMAL / COALESCE(lcc.available_minutes, 480) > 1.0 THEN 'overload'
      WHEN COALESCE(dt.total_minutes, 0)::DECIMAL / COALESCE(lcc.available_minutes, 480) > 0.8 THEN 'high'
      WHEN COALESCE(dt.total_minutes, 0)::DECIMAL / COALESCE(lcc.available_minutes, 480) > 0.5 THEN 'medium'
      ELSE 'low'
    END::VARCHAR AS status
  FROM date_series ds
  LEFT JOIN line_capacity_calendar lcc
    ON lcc.org_id = p_org_id
    AND lcc.line_id = p_line_id
    AND lcc.capacity_date = ds.d
  LEFT JOIN daily_totals dt ON dt.wo_date = ds.d
  ORDER BY ds.d;
END;
$$ LANGUAGE plpgsql;

-- Function: Detect scheduling conflicts for a WO
CREATE OR REPLACE FUNCTION detect_wo_conflicts(
  p_wo_id UUID
)
RETURNS TABLE (
  conflict_type VARCHAR,
  severity VARCHAR,
  conflicting_wo_id UUID,
  description TEXT,
  suggested_resolution TEXT
) AS $$
DECLARE
  v_wo RECORD;
BEGIN
  -- Get the WO details
  SELECT * INTO v_wo FROM work_orders WHERE id = p_wo_id;

  IF NOT FOUND THEN
    RETURN;
  END IF;

  -- Check for time overlaps on same line
  RETURN QUERY
  SELECT
    'overlap'::VARCHAR AS conflict_type,
    'critical'::VARCHAR AS severity,
    wo.id AS conflicting_wo_id,
    FORMAT('Overlaps with %s (%s - %s)',
      wo.wo_number,
      wo.scheduled_start_time,
      wo.scheduled_end_time
    ) AS description,
    FORMAT('Move to start at %s or reassign to different line',
      wo.scheduled_end_time
    ) AS suggested_resolution
  FROM work_orders wo
  WHERE wo.org_id = v_wo.org_id
    AND wo.id != p_wo_id
    AND wo.production_line_id = v_wo.production_line_id
    AND wo.planned_start_date = v_wo.planned_start_date
    AND wo.status NOT IN ('cancelled', 'completed', 'closed')
    AND (
      -- Time overlap detection
      (v_wo.scheduled_start_time, v_wo.scheduled_end_time)
      OVERLAPS
      (wo.scheduled_start_time, wo.scheduled_end_time)
    );

  -- Add more conflict checks as needed (capacity, materials, etc.)
END;
$$ LANGUAGE plpgsql;

-- Trigger: Auto-detect conflicts on WO schedule change
CREATE OR REPLACE FUNCTION check_wo_scheduling_conflicts()
RETURNS TRIGGER AS $$
BEGIN
  -- Clear existing conflicts for this WO
  DELETE FROM wo_scheduling_conflicts
  WHERE wo_id = NEW.id AND detected_by = 'system';

  -- Detect and insert new conflicts
  INSERT INTO wo_scheduling_conflicts (org_id, wo_id, conflicting_wo_id, conflict_type, severity, description, suggested_resolution, detected_by)
  SELECT
    NEW.org_id,
    NEW.id,
    c.conflicting_wo_id,
    c.conflict_type,
    c.severity,
    c.description,
    c.suggested_resolution,
    'system'
  FROM detect_wo_conflicts(NEW.id) c;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_wo_check_conflicts
AFTER INSERT OR UPDATE OF planned_start_date, scheduled_start_time, scheduled_end_time, production_line_id
ON work_orders
FOR EACH ROW
WHEN (NEW.status NOT IN ('cancelled', 'completed', 'closed'))
EXECUTE FUNCTION check_wo_scheduling_conflicts();
```

### RLS Policies

```sql
-- Enable RLS
ALTER TABLE scheduling_optimizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE wo_scheduling_conflicts ENABLE ROW LEVEL SECURITY;
ALTER TABLE line_capacity_calendar ENABLE ROW LEVEL SECURITY;

-- Scheduling Optimizations: Org isolation
CREATE POLICY "so_select" ON scheduling_optimizations
FOR SELECT TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

CREATE POLICY "so_insert" ON scheduling_optimizations
FOR INSERT TO authenticated
WITH CHECK (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND (
    (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid())
    IN ('SUPER_ADMIN', 'ADMIN', 'PLANNER', 'PROD_MANAGER')
  )
);

CREATE POLICY "so_update" ON scheduling_optimizations
FOR UPDATE TO authenticated
USING (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND (
    (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid())
    IN ('SUPER_ADMIN', 'ADMIN', 'PLANNER', 'PROD_MANAGER')
  )
);

-- Scheduling Conflicts: Org isolation
CREATE POLICY "wsc_select" ON wo_scheduling_conflicts
FOR SELECT TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

CREATE POLICY "wsc_all" ON wo_scheduling_conflicts
FOR ALL TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- Capacity Calendar: Org isolation
CREATE POLICY "lcc_select" ON line_capacity_calendar
FOR SELECT TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

CREATE POLICY "lcc_all" ON line_capacity_calendar
FOR ALL TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));
```

### API Endpoints

```
# Schedule Optimization
POST   /api/v1/planning/work-orders/schedule/optimize     - Run optimization (dry_run for preview)
POST   /api/v1/planning/work-orders/schedule/apply        - Apply optimization changes
GET    /api/v1/planning/work-orders/schedule/history      - List optimization runs

# Conflict Detection
POST   /api/v1/planning/work-orders/check-scheduling-conflicts  - Check conflicts for proposed schedule
GET    /api/v1/planning/work-orders/conflicts             - List active conflicts
POST   /api/v1/planning/work-orders/conflicts/:id/resolve - Resolve a conflict
POST   /api/v1/planning/work-orders/conflicts/:id/ignore  - Ignore a conflict

# Capacity Utilization
GET    /api/v1/planning/capacity                          - Get capacity utilization chart data
GET    /api/v1/planning/capacity/:lineId                  - Get capacity for specific line
GET    /api/v1/planning/capacity/export                   - Export capacity report (CSV/PDF)

# Manual Reschedule with Override
POST   /api/v1/planning/work-orders/:id/reschedule        - Reschedule with override option
```

**Optimization Request Parameters:**
```typescript
interface OptimizeScheduleRequest {
  date_from: string;          // ISO date (required)
  date_to: string;            // ISO date (required, max 60 days from date_from)
  line_ids?: string[];        // UUIDs (optional, empty = all lines)
  constraints: {
    respect_capacity: boolean;      // Default: true
    respect_materials: boolean;     // Default: true
    respect_priority: boolean;      // Default: true
    minimize_changeovers: boolean;  // Default: false
    respect_dependencies: boolean;  // Default: true
  };
  dry_run: boolean;           // Default: true (preview only)
}
```

**Capacity Query Parameters:**
```
- date_from: string (ISO date, default: today)
- date_to: string (ISO date, default: today + 30 days)
- line_id: string (UUID, optional)
- group_by: 'day' | 'week' (default: 'day')
```

### Service Layer

```typescript
// lib/services/scheduling-service.ts

export interface SchedulingService {
  // Optimization
  runOptimization(params: OptimizeScheduleRequest): Promise<OptimizationResult>;
  applyOptimization(optimizationId: string): Promise<ApplyResult>;
  getOptimizationHistory(params: PaginationParams): Promise<PaginatedResult<OptimizationRun>>;

  // Conflict Detection
  checkConflicts(woId: string, proposedSchedule: ProposedSchedule): Promise<ConflictCheckResult>;
  listActiveConflicts(params: ConflictListParams): Promise<SchedulingConflict[]>;
  resolveConflict(conflictId: string, resolution: ConflictResolution): Promise<void>;
  ignoreConflict(conflictId: string, reason: string): Promise<void>;

  // Capacity Calculation
  getCapacityUtilization(params: CapacityParams): Promise<CapacityUtilization[]>;
  getCapacityForLine(lineId: string, dateFrom: Date, dateTo: Date): Promise<LineCapacity[]>;
  exportCapacityReport(params: ExportParams): Promise<Buffer>;

  // Scheduling Algorithm
  calculateOptimalSchedule(wos: WorkOrder[], constraints: SchedulingConstraints): OptimizedSchedule;
  validateSchedule(schedule: ProposedSchedule[]): ValidationResult;
}

// lib/services/scheduling-engine.ts

export class SchedulingEngine {
  private constraints: SchedulingConstraints;
  private materialService: MaterialAvailabilityService;
  private capacityService: CapacityService;

  constructor(
    constraints: SchedulingConstraints,
    materialService: MaterialAvailabilityService,
    capacityService: CapacityService
  ) {
    this.constraints = constraints;
    this.materialService = materialService;
    this.capacityService = capacityService;
  }

  /**
   * Main optimization algorithm
   * Uses constraint satisfaction with priority-based ordering
   */
  async optimize(wos: WorkOrder[], dateRange: DateRange): Promise<OptimizedSchedule> {
    // Step 1: Sort WOs by priority (critical > high > normal > low)
    const sortedWOs = this.sortByPriority(wos);

    // Step 2: Build constraint graph
    const constraintGraph = await this.buildConstraintGraph(sortedWOs, dateRange);

    // Step 3: Apply hard constraints (capacity, machine availability)
    const hardConstrainedSchedule = this.applyHardConstraints(constraintGraph);

    // Step 4: Apply soft constraints (materials, preferences)
    const softConstrainedSchedule = await this.applySoftConstraints(hardConstrainedSchedule);

    // Step 5: Optimize for preferences (minimize changeovers if enabled)
    const optimizedSchedule = this.constraints.minimize_changeovers
      ? this.minimizeChangeovers(softConstrainedSchedule)
      : softConstrainedSchedule;

    // Step 6: Generate warnings for unresolved soft constraints
    const warnings = this.generateWarnings(optimizedSchedule);

    return {
      schedule: optimizedSchedule,
      warnings,
      metrics: this.calculateMetrics(wos, optimizedSchedule)
    };
  }

  private sortByPriority(wos: WorkOrder[]): WorkOrder[] {
    const priorityOrder = { critical: 0, high: 1, normal: 2, low: 3 };
    return [...wos].sort((a, b) =>
      priorityOrder[a.priority] - priorityOrder[b.priority]
    );
  }

  private async buildConstraintGraph(wos: WorkOrder[], dateRange: DateRange): Promise<ConstraintGraph> {
    // Get capacity for all lines in date range
    const lineCapacities = await this.capacityService.getCapacityForDateRange(dateRange);

    // Get material availability forecasts
    const materialAvailability = await this.materialService.getForecast(
      wos.flatMap(wo => wo.materials?.map(m => m.product_id) || []),
      dateRange
    );

    // Get WO dependencies
    const dependencies = this.extractDependencies(wos);

    return {
      wos,
      lineCapacities,
      materialAvailability,
      dependencies,
      dateRange
    };
  }

  private applyHardConstraints(graph: ConstraintGraph): ScheduleCandidate[] {
    const candidates: ScheduleCandidate[] = [];

    for (const wo of graph.wos) {
      // Find earliest valid slot respecting capacity
      const validSlot = this.findValidSlot(wo, graph.lineCapacities, candidates);

      if (validSlot) {
        candidates.push({
          woId: wo.id,
          proposedDate: validSlot.date,
          proposedStartTime: validSlot.startTime,
          proposedEndTime: validSlot.endTime,
          lineId: validSlot.lineId,
          constraintViolations: []
        });
      } else {
        // No valid slot found - record as violation
        candidates.push({
          woId: wo.id,
          proposedDate: wo.planned_start_date,
          proposedStartTime: wo.scheduled_start_time,
          proposedEndTime: wo.scheduled_end_time,
          lineId: wo.production_line_id,
          constraintViolations: [{
            type: 'capacity',
            severity: 'critical',
            message: 'No available capacity slot found'
          }]
        });
      }
    }

    return candidates;
  }

  private findValidSlot(
    wo: WorkOrder,
    lineCapacities: Map<string, LineCapacity[]>,
    existingSchedule: ScheduleCandidate[]
  ): TimeSlot | null {
    const duration = this.calculateDuration(wo);
    const preferredLine = wo.production_line_id;
    const preferredDate = new Date(wo.planned_start_date);

    // Try preferred line first, then alternatives
    const linesToTry = preferredLine
      ? [preferredLine, ...Array.from(lineCapacities.keys()).filter(l => l !== preferredLine)]
      : Array.from(lineCapacities.keys());

    for (const lineId of linesToTry) {
      const capacities = lineCapacities.get(lineId) || [];

      for (const cap of capacities) {
        if (new Date(cap.date) < preferredDate) continue;

        // Calculate available slots for this day
        const availableSlots = this.calculateAvailableSlots(
          lineId,
          cap.date,
          cap.effective_minutes,
          existingSchedule
        );

        for (const slot of availableSlots) {
          if (slot.durationMinutes >= duration) {
            return {
              lineId,
              date: cap.date,
              startTime: slot.startTime,
              endTime: this.addMinutes(slot.startTime, duration)
            };
          }
        }
      }
    }

    return null;
  }

  private async applySoftConstraints(schedule: ScheduleCandidate[]): Promise<ScheduleCandidate[]> {
    if (!this.constraints.respect_materials) {
      return schedule;
    }

    // Check material availability for each scheduled WO
    for (const candidate of schedule) {
      const materialCheck = await this.materialService.checkAvailability(
        candidate.woId,
        candidate.proposedDate
      );

      if (!materialCheck.allMaterialsAvailable) {
        // Find earliest date when materials available
        const earliestMaterialDate = materialCheck.earliestAvailableDate;

        if (earliestMaterialDate && earliestMaterialDate > new Date(candidate.proposedDate)) {
          candidate.proposedDate = earliestMaterialDate.toISOString().split('T')[0];
          candidate.constraintViolations.push({
            type: 'material',
            severity: 'warning',
            message: `Delayed to ${candidate.proposedDate} for material availability`
          });
        }
      }
    }

    return schedule;
  }

  private minimizeChangeovers(schedule: ScheduleCandidate[]): ScheduleCandidate[] {
    // Group WOs by line and date
    const byLineAndDate = new Map<string, ScheduleCandidate[]>();

    for (const candidate of schedule) {
      const key = `${candidate.lineId}:${candidate.proposedDate}`;
      if (!byLineAndDate.has(key)) {
        byLineAndDate.set(key, []);
      }
      byLineAndDate.get(key)!.push(candidate);
    }

    // For each line/date, reorder to group same products together
    for (const [key, daySchedule] of byLineAndDate) {
      // Sort by product to minimize changeovers
      daySchedule.sort((a, b) => {
        // Need to fetch product info - placeholder
        return 0; // Product-based sorting
      });

      // Reassign times based on new order
      let currentTime = '08:00';
      for (const candidate of daySchedule) {
        const duration = this.calculateDurationFromCandidate(candidate);
        candidate.proposedStartTime = currentTime;
        candidate.proposedEndTime = this.addMinutes(currentTime, duration);
        currentTime = candidate.proposedEndTime;
      }
    }

    return schedule;
  }
}

// Type definitions
export interface OptimizationResult {
  optimizationId: string;
  summary: OptimizationSummary;
  changes: ScheduleChange[];
  warnings: SchedulingWarning[];
}

export interface OptimizationSummary {
  wos_analyzed: number;
  wos_to_reschedule: number;
  conflicts_resolved: number;
  utilization_before: number;
  utilization_after: number;
  material_warnings: number;
}

export interface ScheduleChange {
  wo_id: string;
  wo_number: string;
  product_name: string;
  current: ScheduleSlot;
  proposed: ScheduleSlot;
  reason: string;
}

export interface ScheduleSlot {
  date: string;
  start_time: string;
  end_time: string;
  line_id: string;
}

export interface SchedulingWarning {
  wo_id: string;
  type: 'material_availability' | 'capacity' | 'dependency' | 'due_date';
  message: string;
}

export interface SchedulingConflict {
  id: string;
  wo_id: string;
  conflicting_wo_id: string | null;
  conflict_type: 'overlap' | 'capacity' | 'material' | 'machine_unavailable' | 'dependency';
  severity: 'critical' | 'warning' | 'info';
  description: string;
  suggested_resolution: string;
  status: 'active' | 'resolved' | 'ignored';
}

export interface CapacityUtilization {
  line_id: string;
  line_name: string;
  date: string;
  available_minutes: number;
  scheduled_minutes: number;
  utilization_percent: number;
  wo_count: number;
  status: 'low' | 'medium' | 'high' | 'overload';
}
```

### Validation Schema (Zod)

```typescript
// lib/validation/scheduling-schemas.ts
import { z } from 'zod';

export const optimizeScheduleSchema = z.object({
  date_from: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Invalid date format'),
  date_to: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Invalid date format'),
  line_ids: z.array(z.string().uuid()).optional(),
  constraints: z.object({
    respect_capacity: z.boolean().default(true),
    respect_materials: z.boolean().default(true),
    respect_priority: z.boolean().default(true),
    minimize_changeovers: z.boolean().default(false),
    respect_dependencies: z.boolean().default(true)
  }).default({}),
  dry_run: z.boolean().default(true)
}).refine(
  (data) => {
    const from = new Date(data.date_from);
    const to = new Date(data.date_to);
    return to >= from;
  },
  { message: 'date_to must be on or after date_from', path: ['date_to'] }
).refine(
  (data) => {
    const from = new Date(data.date_from);
    const to = new Date(data.date_to);
    const daysDiff = (to.getTime() - from.getTime()) / (1000 * 60 * 60 * 24);
    return daysDiff <= 60;
  },
  { message: 'Date range cannot exceed 60 days', path: ['date_to'] }
);

export const applyOptimizationSchema = z.object({
  optimization_id: z.string().uuid()
});

export const checkConflictsSchema = z.object({
  wo_id: z.string().uuid().optional(),
  line_id: z.string().uuid(),
  scheduled_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  scheduled_start_time: z.string().regex(/^\d{2}:\d{2}$/),
  scheduled_end_time: z.string().regex(/^\d{2}:\d{2}$/),
  exclude_wo_id: z.string().uuid().optional()
});

export const capacityQuerySchema = z.object({
  date_from: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  date_to: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  line_id: z.string().uuid().optional(),
  group_by: z.enum(['day', 'week']).default('day')
});

export const resolveConflictSchema = z.object({
  resolution_type: z.enum(['move_wo', 'move_conflicting', 'change_line', 'manual']),
  new_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  new_start_time: z.string().regex(/^\d{2}:\d{2}$/).optional(),
  new_end_time: z.string().regex(/^\d{2}:\d{2}$/).optional(),
  new_line_id: z.string().uuid().optional(),
  notes: z.string().max(500).optional()
});

export const rescheduleWithOverrideSchema = z.object({
  scheduled_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  scheduled_start_time: z.string().regex(/^\d{2}:\d{2}$/),
  scheduled_end_time: z.string().regex(/^\d{2}:\d{2}$/),
  production_line_id: z.string().uuid().optional(),
  force_override: z.boolean().default(false), // Skip conflict check
  override_reason: z.string().max(500).optional() // Required if force_override
}).refine(
  (data) => !data.force_override || (data.force_override && data.override_reason),
  { message: 'override_reason required when force_override is true', path: ['override_reason'] }
);

// Type exports
export type OptimizeScheduleInput = z.infer<typeof optimizeScheduleSchema>;
export type ApplyOptimizationInput = z.infer<typeof applyOptimizationSchema>;
export type CheckConflictsInput = z.infer<typeof checkConflictsSchema>;
export type CapacityQueryInput = z.infer<typeof capacityQuerySchema>;
export type ResolveConflictInput = z.infer<typeof resolveConflictSchema>;
export type RescheduleWithOverrideInput = z.infer<typeof rescheduleWithOverrideSchema>;
```

---

## UI Components

```
app/(authenticated)/planning/
  work-orders/
    gantt/
      components/
        ScheduleOptimizerModal.tsx        -- Main optimization modal
        ScheduleOptimizerForm.tsx         -- Configuration form
        ScheduleOptimizerPreview.tsx      -- Preview changes table
        ScheduleOptimizerProgress.tsx     -- Apply progress indicator

        ConflictList.tsx                  -- List of active conflicts
        ConflictCard.tsx                  -- Individual conflict display
        ConflictResolutionDialog.tsx      -- Resolve conflict modal

  capacity/
    page.tsx                              -- Capacity utilization page
    components/
      CapacityHeatmap.tsx                 -- Main heatmap chart
      CapacityLegend.tsx                  -- Utilization legend
      CapacityDrilldownPopover.tsx        -- Cell detail popover
      CapacityFilters.tsx                 -- Date/line filters
      CapacityExportButton.tsx            -- Export actions

components/planning/scheduling/
  SchedulingConstraintToggles.tsx         -- Constraint configuration
  SchedulingWarningsList.tsx              -- Warnings display
  SchedulingMetricsSummary.tsx            -- Before/after metrics
```

### Key Component Details

**ScheduleOptimizerModal:**
- Full-screen modal with three panels: Config, Preview, Apply
- Step 1: Configure date range, lines, constraints
- Step 2: Preview optimization results (table with old/new schedules)
- Step 3: Apply changes with progress indicator
- Close button reverts to Gantt without applying

**CapacityHeatmap:**
- Uses react-heatmap-grid or custom SVG rendering
- X-axis: dates, Y-axis: production lines
- Cell click opens drilldown popover
- Responsive: Collapses to scrollable on mobile
- Export: Screenshot or data export

---

## Out of Scope

| Feature | Reason | Future Story |
|---------|--------|--------------|
| WO Dependencies with Arrow Lines | Gantt visualization enhancement | Phase 3 |
| Multi-shift Support | Requires shift management system | Phase 3 |
| What-if Scenario Modeling | Advanced planning feature | Phase 3 |
| Real-time WebSocket Updates | Infrastructure enhancement | Phase 3 |
| Machine Learning Optimization | Requires historical data | Phase 4 |
| Batch Scheduling (multiple products) | Complex batching algorithm | Phase 3 |
| Customer Order Integration | Requires Shipping module | Phase 3 |

---

## Test Cases

### Unit Tests

**File:** `__tests__/unit/services/scheduling-service.test.ts`

| Test Case | Description |
|-----------|-------------|
| `sortByPriority()` orders correctly | Critical > High > Normal > Low |
| `findValidSlot()` respects capacity | Returns null when no capacity |
| `findValidSlot()` finds earliest slot | Returns earliest available |
| `applyHardConstraints()` blocks overlaps | Moves WOs to prevent overlap |
| `applySoftConstraints()` delays for materials | Respects material availability |
| `minimizeChangeovers()` groups products | Same products scheduled together |
| `calculateDuration()` handles edge cases | Overnight, missing times |
| `validateSchedule()` detects conflicts | Returns conflict list |
| `calculateMetrics()` correct before/after | Utilization calculation |

**File:** `__tests__/unit/services/scheduling-engine.test.ts`

| Test Case | Description |
|-----------|-------------|
| Engine handles empty WO list | Returns empty schedule |
| Engine handles single WO | Schedules correctly |
| Engine handles 100+ WOs | Completes within 10s |
| Engine respects all constraints | All constraints applied in order |
| Engine generates warnings | Soft constraint violations logged |
| Engine handles infeasible schedule | Best-effort with violations |

### Integration Tests

**File:** `__tests__/integration/api/planning/scheduling.test.ts`

| Test Case | Description |
|-----------|-------------|
| POST `/schedule/optimize` returns preview | Dry run returns changes |
| POST `/schedule/optimize` validates inputs | Invalid dates return 400 |
| POST `/schedule/apply` updates WOs | All WOs rescheduled |
| POST `/schedule/apply` invalid ID returns 404 | Expired optimization |
| GET `/conflicts` returns active only | Status filter works |
| POST `/conflicts/:id/resolve` clears flag | Conflict resolved |
| GET `/capacity` returns utilization | Calculation correct |
| Cross-org access returns 404 | Multi-tenancy enforced |
| Concurrent optimization blocked | Mutex prevents race |

### E2E Tests

**File:** `__tests__/e2e/planning/scheduling.spec.ts`

| Test Case | Description |
|-----------|-------------|
| Open optimizer modal from Gantt | Modal opens with defaults |
| Configure and preview optimization | Preview displays changes |
| Apply optimization updates Gantt | Bars move to new positions |
| Cancel optimization no changes | Gantt unchanged |
| View capacity heatmap | Chart renders correctly |
| Drill down capacity cell | Popover shows WO list |
| Export capacity report | CSV/PDF downloads |
| Resolve scheduling conflict | Conflict cleared |
| Manual override with warning | Override applied |

---

## Key Business Rules

1. **Constraint Priority Order:**
   - Hard constraints (capacity, machine availability) - Cannot be violated
   - Soft constraints (material availability) - Generates warnings if violated
   - Preferences (minimize changeovers) - Best-effort optimization

2. **Capacity Calculation:**
   ```
   Effective Capacity = Shift Hours * 60 * Efficiency Factor
   Utilization = Scheduled Minutes / Effective Capacity
   ```

3. **Conflict Detection:**
   - Overlap: Two WOs on same line with overlapping times
   - Capacity: Daily scheduled minutes > effective capacity
   - Material: Required materials not available on scheduled date
   - Dependency: WO scheduled before dependent WO completes

4. **Optimization Algorithm:**
   - Forward scheduling (earliest start from today)
   - Priority-based ordering (critical first)
   - First-fit slot allocation
   - Greedy changeover minimization (same products together)

5. **Manual Override:**
   - User can force schedule despite conflicts
   - Conflict flag set on WO
   - Audit trail records override reason
   - Conflict visible in Gantt (red border)

6. **Optimization Expiry:**
   - Preview results expire after 1 hour
   - Expired optimization cannot be applied
   - User must re-run optimization

7. **Performance Requirements:**
   - Optimization: < 10 seconds for 100 WOs
   - Conflict check: < 200ms response time
   - Capacity chart: < 500ms load time

---

## Performance Requirements

| Metric | Target |
|--------|--------|
| Optimization (100 WOs, 14 days, 5 lines) | < 10 seconds |
| Conflict check (single WO) | < 200ms |
| Capacity chart load | < 500ms |
| Apply changes (batch update) | < 5 seconds for 50 WOs |
| Memory usage during optimization | < 512MB |
| Concurrent optimizations | Blocked (mutex per org) |

---

## Definition of Done

- [ ] Database migration creates `scheduling_optimizations`, `wo_scheduling_conflicts`, `line_capacity_calendar` tables
- [ ] All constraints and indexes created
- [ ] Database functions for capacity calculation and conflict detection
- [ ] Conflict detection trigger on WO schedule changes
- [ ] RLS policies enforce org isolation
- [ ] All API endpoints implemented (optimize, apply, conflicts, capacity)
- [ ] Zod schemas validate all inputs
- [ ] `scheduling-service.ts` implements all methods
- [ ] `scheduling-engine.ts` implements optimization algorithm
- [ ] Constraint-based scheduling works (capacity, materials, priority, changeovers)
- [ ] Schedule Optimizer Modal with config, preview, apply flow
- [ ] Capacity Heatmap renders with drill-down
- [ ] Conflict detection and resolution UI
- [ ] Manual override with warning confirmation
- [ ] Permission matrix implemented (Planner, Prod Manager, Operator)
- [ ] Multi-tenancy: cross-org returns 404
- [ ] Unit tests >= 80% coverage
- [ ] Integration tests for all endpoints
- [ ] E2E tests for critical flows
- [ ] Complex scenarios tested (multi-constraint, infeasible)
- [ ] Performance targets met (< 10s optimization, < 200ms conflict check)
- [ ] Loading, empty, error states implemented
- [ ] Toast notifications on success/error
- [ ] Accessibility: keyboard nav, ARIA labels

---

## Future Phases (Not in MVP)

### Phase 3

- **WO Dependencies with Constraints** (FR-PLAN-061 extension)
  - Visual arrows showing dependencies in Gantt
  - Constraint types: FS, SS, FF, SF with lag times
  - Automatic dependency validation during scheduling
  - Critical path calculation

- **What-if Scenario Modeling**
  - Save and compare multiple schedule scenarios
  - "What if line X is down for 2 days?"
  - Side-by-side scenario comparison
  - Select best scenario to apply

- **Multi-shift Support**
  - Define shifts per line (1st, 2nd, 3rd)
  - Capacity varies by shift
  - WO bars colored by shift
  - Shift-aware scheduling algorithm

- **Batch Scheduling**
  - Group multiple products into single batch
  - Shared setup time
  - Batch size optimization
  - Clean-in-place (CIP) scheduling

### Phase 4

- **Machine Learning Optimization**
  - Learn from historical schedule performance
  - Predict actual vs planned duration
  - Recommend optimal product sequencing
  - Anomaly detection for schedule disruptions

- **Customer Order Integration**
  - Schedule WOs based on customer order due dates
  - Automatic priority adjustment for late orders
  - Customer-facing delivery date promise

**Implementation**: See Epic 03.0 "Future Feature Handling" section. Features marked as "Coming Soon" in UI.

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-12-16 | Initial story creation | Claude Opus 4.5 |
