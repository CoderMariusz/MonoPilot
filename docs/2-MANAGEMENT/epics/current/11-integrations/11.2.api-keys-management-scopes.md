# 11.2 - API Keys Management & Scopes

**Priority**: P0 (MVP)
**Story Points**: L (Large)
**Type**: fullstack
**Phase**: 1 (MVP)
**Model**: OPUS

**State:** ready
**Estimate:** L (4-5 days)
**Primary PRD:** `docs/1-BASELINE/product/modules/integrations.md` (FR-INT-002, FR-INT-003, FR-INT-004)
**Architecture:** `docs/1-BASELINE/architecture/modules/integrations.md` (API authentication patterns)

---

## Goal

Implement API Keys Management - allow admins to create, manage, and revoke API keys for external system authentication. Each key has granular scope permissions (read:products, write:orders, etc.), configurable rate limits, and optional expiration. Includes masked display, regeneration endpoint, and usage tracking.

---

## User Story

As a **System Administrator**, I want to **create and manage API keys with specific scopes** so that **I can grant external systems secure, limited access to MonoPilot data without sharing user credentials**.

As an **Integration Specialist**, I want to **configure rate limits per API key** so that **I can prevent abuse while allowing legitimate high-volume integrations**.

---

## Dependencies

### Cross-Epic Dependencies

| Dependency | Story/Epic | Type | What It Provides | Status |
|------------|------------|------|------------------|--------|
| 01.1 | Org Context + RLS | HARD | organizations, users, roles tables | Ready |
| 11.1 | Dashboard | HARD | integration_health table, nav shell | Ready |

### Provides To (Downstream)

| Story | What This Provides |
|-------|-------------------|
| 11.3 | API key tracking in logs |
| All | Secure API authentication for external systems |

---

## Database Migration

### Migration: Create integration_api_keys table

```sql
-- Migration: YYYYMMDDHHMMSS_create_integration_api_keys.sql

-- API Keys for external integrations
CREATE TABLE integration_api_keys (
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id              UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

    -- Key identification
    name                VARCHAR(255) NOT NULL,
    key_value_hash      VARCHAR(255) UNIQUE NOT NULL, -- bcrypt hash
    key_prefix          VARCHAR(20) NOT NULL, -- First 8 chars for display (e.g., "mp_live_abc123...")

    -- Permissions & limits
    scopes              JSONB NOT NULL DEFAULT '[]', -- ["read:products", "write:orders"]
    rate_limit_tier     VARCHAR(20) NOT NULL DEFAULT 'basic' CHECK (rate_limit_tier IN ('basic', 'standard', 'premium')),

    -- Status & expiry
    status              VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'suspended', 'revoked')),
    expires_at          TIMESTAMPTZ,

    -- Usage tracking
    last_used_at        TIMESTAMPTZ,
    request_count       INTEGER DEFAULT 0,

    -- Audit
    created_by          UUID REFERENCES users(id),
    created_at          TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at          TIMESTAMPTZ NOT NULL DEFAULT now(),
    revoked_at          TIMESTAMPTZ,
    revoked_by          UUID REFERENCES users(id),
    revocation_reason   TEXT,

    CONSTRAINT uq_api_key_name UNIQUE (org_id, name)
);

-- Indexes
CREATE INDEX idx_api_keys_org ON integration_api_keys(org_id);
CREATE INDEX idx_api_keys_status ON integration_api_keys(org_id, status);
CREATE INDEX idx_api_keys_hash ON integration_api_keys(key_value_hash);
CREATE INDEX idx_api_keys_active ON integration_api_keys(org_id) WHERE status = 'active' AND (expires_at IS NULL OR expires_at > now());

-- RLS Policies
ALTER TABLE integration_api_keys ENABLE ROW LEVEL SECURITY;

CREATE POLICY "api_keys_select" ON integration_api_keys
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid()) IN ('SUPER_ADMIN', 'ADMIN', 'IT_MANAGER')
    );

CREATE POLICY "api_keys_insert" ON integration_api_keys
    FOR INSERT WITH CHECK (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid()) IN ('SUPER_ADMIN', 'ADMIN')
    );

CREATE POLICY "api_keys_update" ON integration_api_keys
    FOR UPDATE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid()) IN ('SUPER_ADMIN', 'ADMIN')
    );

CREATE POLICY "api_keys_delete" ON integration_api_keys
    FOR DELETE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND (SELECT r.code FROM roles r JOIN users u ON u.role_id = r.id WHERE u.id = auth.uid()) IN ('SUPER_ADMIN', 'ADMIN')
    );

-- Trigger for updated_at
CREATE TRIGGER update_api_keys_updated_at
    BEFORE UPDATE ON integration_api_keys
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================================================
-- Rate Limit Tiers Configuration
-- =============================================================================

CREATE TABLE rate_limit_tiers (
    tier                VARCHAR(20) PRIMARY KEY,
    requests_per_minute INTEGER NOT NULL,
    requests_per_hour   INTEGER NOT NULL,
    burst_limit         INTEGER NOT NULL,
    description         TEXT
);

INSERT INTO rate_limit_tiers (tier, requests_per_minute, requests_per_hour, burst_limit, description) VALUES
    ('basic', 60, 1000, 10, 'Basic tier - 60 req/min, 1K req/hour'),
    ('standard', 300, 10000, 50, 'Standard tier - 300 req/min, 10K req/hour'),
    ('premium', 1000, 50000, 200, 'Premium tier - 1K req/min, 50K req/hour');
```

---

## Acceptance Criteria (Given/When/Then)

### AC-1: Create API Key

```gherkin
Scenario: Admin creates new API key
  Given user has ADMIN role
  When creating new API key with:
    | name | "Mobile App Production" |
    | scopes | ["read:products", "write:orders"] |
    | rate_limit_tier | "standard" |
    | expires_at | "2025-12-31" |
  Then API key generated with format "mp_live_XXXXXXXXXXXXXXXX"
  And key displayed ONCE (not retrievable again)
  And key_value_hash stored (bcrypt with cost 12)
  And key_prefix stored ("mp_live_XXXXXXXX")
  And success message shows "Copy this key now - it won't be shown again"

Scenario: Key generation format
  Given creating new API key
  Then key format is "mp_{env}_{random32}"
  Where env = "live" (production) or "test" (sandbox)
  And random32 = 32 cryptographically random chars (base62)

Scenario: Cannot create duplicate key name
  Given API key named "Mobile App" exists
  When creating new key with name "Mobile App"
  Then error "API key name already exists" displayed
  And key not created
```

### AC-2: View API Keys List

```gherkin
Scenario: Admin views API keys table
  Given organization has 3 API keys
  When navigating to /integrations/api-keys
  Then table displays:
    | Column | Content |
    | Name | "Mobile App Production" |
    | Key | "mp_live_abc123••••••••" (masked) |
    | Scopes | "read:products, write:orders" (2) |
    | Rate Limit | "Standard (300/min)" |
    | Status | Badge (active/suspended/revoked) |
    | Last Used | "2 hours ago" |
    | Created | "Dec 15, 2024" |
    | Actions | [Edit] [Suspend] [Revoke] |

Scenario: No API keys - empty state
  Given organization has 0 API keys
  When viewing API keys page
  Then empty state displays:
    | Message | "No API keys created yet" |
  And [Create API Key] button prominent
```

### AC-3: Scope Management

```gherkin
Scenario: Scope selector shows all available scopes
  Given creating/editing API key
  When scope selector displayed
  Then grouped scopes shown:
    | Group | Scopes |
    | Products | read:products, write:products |
    | Orders | read:orders, write:orders |
    | Inventory | read:inventory, write:inventory |
    | Production | read:production, write:production |
    | Shipping | read:shipping |
    | Webhooks | webhook:manage |
  And checkboxes for each scope

Scenario: Write scope auto-includes read
  Given selecting "write:products" scope
  When scope saved
  Then "read:products" automatically added
  And user notified "Write permissions include read access"

Scenario: At least one scope required
  Given creating API key
  When submitting with no scopes selected
  Then error "At least one scope is required" displayed
  And form submission prevented
```

### AC-4: Rate Limiting Configuration

```gherkin
Scenario: Rate limit tier selector
  Given creating/editing API key
  Then tier dropdown shows:
    | Tier | Limits |
    | Basic | 60/min, 1K/hour, burst 10 |
    | Standard | 300/min, 10K/hour, burst 50 |
    | Premium | 1K/min, 50K/hour, burst 200 |
  And default = "basic"

Scenario: Rate limit enforcement on API request
  Given API key with "basic" tier (60/min)
  And 60 requests made in current minute
  When 61st request arrives
  Then response is 429 Too Many Requests
  And headers include:
    | Header | Value |
    | X-RateLimit-Limit | 60 |
    | X-RateLimit-Remaining | 0 |
    | X-RateLimit-Reset | 1640000060 |
    | Retry-After | 30 |
  And error logged to integration_logs
```

### AC-5: Edit API Key

```gherkin
Scenario: Edit key metadata only
  Given existing API key
  When editing key
  Then can change:
    - name
    - scopes
    - rate_limit_tier
    - expires_at
  But CANNOT change:
    - key_value (use regenerate instead)
    - org_id

Scenario: Edit saves changes
  Given API key with name "Old Name"
  When changing name to "New Name"
  And adding scope "read:shipping"
  And saving
  Then key updated successfully
  And updated_at timestamp refreshed
  And success toast "API key updated" shown
```

### AC-6: Suspend & Reactivate

```gherkin
Scenario: Suspend active key
  Given API key with status = "active"
  When clicking [Suspend]
  And confirming action
  Then status changed to "suspended"
  And key no longer authenticates requests
  And suspension logged to audit trail

Scenario: Reactivate suspended key
  Given API key with status = "suspended"
  When clicking [Activate]
  Then status changed to "active"
  And key authenticates requests again
  And reactivation logged

Scenario: Suspended key authentication fails
  Given API key suspended
  When API request with suspended key
  Then 401 Unauthorized response
  And error message "API key has been suspended"
```

### AC-7: Revoke Key (Permanent)

```gherkin
Scenario: Revoke key permanently
  Given active API key
  When clicking [Revoke]
  And confirming with reason "Security incident"
  Then status changed to "revoked"
  And revoked_at = now()
  And revoked_by = current user
  And revocation_reason stored
  And key cannot be reactivated (permanent)
  And key no longer authenticates requests

Scenario: Revoked key cannot be reactivated
  Given revoked API key
  When viewing key details
  Then [Activate] button not shown
  And status badge shows "Revoked" (gray)
  And revocation details displayed:
    | Field | Value |
    | Revoked At | "Dec 15, 2024 10:30 AM" |
    | Revoked By | "John Admin" |
    | Reason | "Security incident" |
```

### AC-8: Regenerate Key

```gherkin
Scenario: Regenerate key creates new value
  Given existing API key
  When clicking [Regenerate]
  And confirming action
  Then new key_value generated
  And new key_value_hash stored
  And old key immediately invalid
  And new key displayed ONCE
  And warning shown "Update all systems using this key"

Scenario: Regenerate maintains metadata
  Given API key with:
    - name = "Mobile App"
    - scopes = ["read:products"]
    - rate_limit_tier = "standard"
  When regenerating key
  Then new key_value generated
  But name, scopes, tier unchanged
  And only key_value_hash updated
```

### AC-9: Expiration Handling

```gherkin
Scenario: Set expiration date
  Given creating API key
  When setting expires_at = "2025-12-31"
  And saving
  Then expiration stored
  And warning shown "Key will expire on Dec 31, 2025"

Scenario: Expired key authentication fails
  Given API key with expires_at = "2024-01-01"
  And current date = "2024-01-02"
  When API request with expired key
  Then 401 Unauthorized response
  And error message "API key has expired"

Scenario: Expiration warning near expiry
  Given API key expires in 7 days
  When admin views API keys list
  Then warning badge shown next to key
  And tooltip "Expires in 7 days"
```

### AC-10: Usage Tracking

```gherkin
Scenario: Track last used timestamp
  Given API key with last_used_at = "2024-12-01"
  When API request authenticated with key
  Then last_used_at updated to now()
  And request_count incremented

Scenario: Display usage statistics
  Given API key details page
  Then displays:
    | Metric | Value |
    | Total Requests | 1,247 |
    | Last Used | "2 hours ago" |
    | Avg Requests/Day | 83 |
    | Created | "30 days ago" |
```

### AC-11: API Authentication Flow

```gherkin
Scenario: Successful API authentication
  Given valid API key "mp_live_abc123..."
  And key has scope "read:products"
  When GET /api/technical/products with header:
    Authorization: Bearer mp_live_abc123...
  Then request authenticated
  And org_id extracted from key
  And response filtered by org_id (RLS)
  And last_used_at updated
  And request logged to integration_logs

Scenario: Invalid API key
  Given non-existent key "mp_live_invalid"
  When API request with invalid key
  Then 401 Unauthorized response
  And error "Invalid API key"
  And failed attempt logged

Scenario: Insufficient scope
  Given API key with scope "read:products"
  When POST /api/planning/orders (requires "write:orders")
  Then 403 Forbidden response
  And error "Insufficient scope: write:orders required"
```

### AC-12: Admin-Only Access

```gherkin
Scenario: Admin can manage all keys
  Given user with ADMIN role
  Then can create, edit, suspend, revoke API keys
  And can view all org API keys

Scenario: IT Manager has read-only access
  Given user with IT_MANAGER role
  Then can view API keys
  But cannot create, edit, or revoke
  And action buttons hidden

Scenario: Regular user cannot access
  Given user with USER role
  When attempting to access /integrations/api-keys
  Then 403 Forbidden
  And redirected to home
```

---

## Implementation Notes

### API Endpoints

```typescript
// =============================================================================
// API Keys Endpoints
// =============================================================================

// GET /api/integrations/api-keys - List all API keys (masked)
interface ApiKeyListResponse {
  api_keys: ApiKey[];
  total: number;
}

// POST /api/integrations/api-keys - Create new key
interface CreateApiKeyRequest {
  name: string;
  scopes: string[];
  rate_limit_tier: 'basic' | 'standard' | 'premium';
  expires_at?: string; // ISO date
}

interface CreateApiKeyResponse {
  id: string;
  name: string;
  key_value: string; // Plain text - ONLY returned on creation
  key_prefix: string;
  scopes: string[];
  rate_limit_tier: string;
  expires_at?: string;
  created_at: string;
}

// PUT /api/integrations/api-keys/:id - Update key metadata
interface UpdateApiKeyRequest {
  name?: string;
  scopes?: string[];
  rate_limit_tier?: string;
  expires_at?: string | null;
}

// POST /api/integrations/api-keys/:id/regenerate - Regenerate key value
interface RegenerateApiKeyResponse {
  key_value: string; // New plain text key
  key_prefix: string;
}

// POST /api/integrations/api-keys/:id/suspend - Suspend key
// POST /api/integrations/api-keys/:id/activate - Reactivate key
// DELETE /api/integrations/api-keys/:id - Revoke key (soft delete)

interface RevokeApiKeyRequest {
  reason?: string;
}
```

### Validation Schemas (Zod)

```typescript
import { z } from 'zod';

export const apiKeyScopes = [
  'read:products', 'write:products',
  'read:orders', 'write:orders',
  'read:inventory', 'write:inventory',
  'read:production', 'write:production',
  'read:shipping',
  'webhook:manage',
] as const;

export const createApiKeySchema = z.object({
  name: z.string().min(3).max(255),
  scopes: z.array(z.enum(apiKeyScopes)).min(1, 'At least one scope required'),
  rate_limit_tier: z.enum(['basic', 'standard', 'premium']).default('basic'),
  expires_at: z.string().datetime().optional(),
}).refine(
  (data) => {
    // Auto-add read scopes for write scopes
    const writeScopes = data.scopes.filter(s => s.startsWith('write:'));
    writeScopes.forEach(ws => {
      const readScope = ws.replace('write:', 'read:') as typeof apiKeyScopes[number];
      if (!data.scopes.includes(readScope)) {
        data.scopes.push(readScope);
      }
    });
    return true;
  }
);

export const updateApiKeySchema = createApiKeySchema.partial();

export const revokeApiKeySchema = z.object({
  reason: z.string().max(500).optional(),
});
```

### Service Layer

```typescript
// lib/services/api-key-service.ts

export class ApiKeyService {
  /**
   * Generate cryptographically secure API key
   */
  static async generateKey(env: 'live' | 'test'): Promise<string>;

  /**
   * Hash API key for storage
   */
  static async hashKey(key: string): Promise<string>;

  /**
   * Verify API key against hash
   */
  static async verifyKey(key: string, hash: string): Promise<boolean>;

  /**
   * Create new API key
   */
  static async create(orgId: string, data: CreateApiKeyRequest, userId: string): Promise<CreateApiKeyResponse>;

  /**
   * List API keys (with masked values)
   */
  static async list(orgId: string): Promise<ApiKey[]>;

  /**
   * Update API key metadata
   */
  static async update(id: string, data: UpdateApiKeyRequest): Promise<ApiKey>;

  /**
   * Regenerate key value
   */
  static async regenerate(id: string): Promise<{ key_value: string }>;

  /**
   * Suspend/activate key
   */
  static async suspend(id: string): Promise<void>;
  static async activate(id: string): Promise<void>;

  /**
   * Revoke key permanently
   */
  static async revoke(id: string, reason?: string, userId?: string): Promise<void>;

  /**
   * Authenticate API request with key
   */
  static async authenticate(keyValue: string): Promise<AuthResult>;

  /**
   * Check scope permission
   */
  static async checkScope(keyId: string, requiredScope: string): Promise<boolean>;

  /**
   * Check rate limit
   */
  static async checkRateLimit(keyId: string): Promise<RateLimitResult>;

  /**
   * Update usage statistics
   */
  static async updateUsage(keyId: string): Promise<void>;
}

interface AuthResult {
  valid: boolean;
  key?: ApiKey;
  org_id?: string;
  error?: string;
}

interface RateLimitResult {
  allowed: boolean;
  limit: number;
  remaining: number;
  reset_at: number;
}
```

### Frontend Components

```
apps/frontend/app/(authenticated)/integrations/
  api-keys/
    page.tsx                    -- API keys list page
    [id]/
      page.tsx                  -- API key detail/edit page

components/integrations/api-keys/
  ApiKeysTable.tsx              -- DataTable for API keys
  CreateApiKeyModal.tsx         -- Create key form (shows key ONCE)
  EditApiKeyModal.tsx           -- Edit metadata
  ScopeSelector.tsx             -- Grouped scope checkboxes
  RateLimitTierSelector.tsx     -- Tier dropdown with info
  RegenerateKeyDialog.tsx       -- Confirm + show new key
  RevokeKeyDialog.tsx           -- Confirm with reason input
  ApiKeyUsageStats.tsx          -- Usage statistics widget
  ApiKeyStatusBadge.tsx         -- Status badge component
```

---

## Key Business Rules

1. **One-Time Key Display**: Plain key shown ONLY at creation/regeneration, never retrievable
2. **Scope Hierarchy**: Write scopes automatically include read scopes
3. **Rate Limiting**: Enforced at middleware level before RLS
4. **Revocation Permanent**: Revoked keys cannot be reactivated (create new instead)
5. **Admin-Only**: Only ADMIN/SUPER_ADMIN can create/edit/revoke keys
6. **Key Format**: `mp_{env}_{random32}` where env=live/test
7. **Bcrypt Hashing**: Keys hashed with cost factor 12
8. **Expiration Check**: Checked on every authentication
9. **Usage Tracking**: last_used_at updated on every valid request
10. **Audit Trail**: All key actions logged with actor and timestamp

---

## Deliverables

### Database
- [ ] `integration_api_keys` table with RLS
- [ ] `rate_limit_tiers` table (seed data)
- [ ] Indexes for performance

### API Routes
- [ ] GET /api/integrations/api-keys
- [ ] POST /api/integrations/api-keys
- [ ] GET /api/integrations/api-keys/:id
- [ ] PUT /api/integrations/api-keys/:id
- [ ] POST /api/integrations/api-keys/:id/regenerate
- [ ] POST /api/integrations/api-keys/:id/suspend
- [ ] POST /api/integrations/api-keys/:id/activate
- [ ] DELETE /api/integrations/api-keys/:id (revoke)

### Service Layer
- [ ] ApiKeyService with all methods
- [ ] Key generation (crypto random)
- [ ] Bcrypt hashing/verification
- [ ] Rate limit checking (Redis)
- [ ] Scope validation

### Validation
- [ ] createApiKeySchema
- [ ] updateApiKeySchema
- [ ] revokeApiKeySchema

### Frontend
- [ ] API keys list page
- [ ] Create API key modal
- [ ] Edit API key modal
- [ ] Scope selector component
- [ ] Rate limit tier selector
- [ ] Regenerate key dialog
- [ ] Revoke key dialog
- [ ] Usage statistics widget
- [ ] Status badges

### Tests
- [ ] Unit tests: ApiKeyService methods (>80% coverage)
- [ ] Integration tests: All API endpoints
- [ ] Rate limiting tests
- [ ] Scope validation tests
- [ ] RLS tests: Multi-tenancy
- [ ] E2E: Create, edit, revoke key flow

---

## Definition of Done

### Database
- [ ] Tables created with all constraints
- [ ] RLS policies enforce org isolation
- [ ] Indexes created
- [ ] Seed data for rate limit tiers

### API
- [ ] All endpoints functional
- [ ] Key creation returns plain key ONCE
- [ ] Rate limiting enforced (429 responses)
- [ ] Scope validation works
- [ ] Response times < 500ms
- [ ] RLS enforced

### Service
- [ ] Key generation cryptographically secure
- [ ] Bcrypt hashing with cost 12
- [ ] Rate limit checking with Redis
- [ ] Scope hierarchy (write includes read)
- [ ] Usage tracking updates

### Frontend
- [ ] Create key flow works (shows key once)
- [ ] Keys list displays masked values
- [ ] Edit metadata works
- [ ] Regenerate shows new key once
- [ ] Revoke with reason works
- [ ] Status badges display correctly
- [ ] Usage stats accurate

### Testing
- [ ] Unit tests: >80% coverage
- [ ] Integration tests: All endpoints
- [ ] Rate limit tests passing
- [ ] RLS tests: Multi-tenancy verified
- [ ] E2E tests: Full workflow passing

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Key exposure in logs | CRITICAL | LOW | Never log plain keys, only prefixes |
| Rate limit bypass | MEDIUM | LOW | Redis-based enforcement at middleware |
| Scope creep on permissions | MEDIUM | MEDIUM | Strict enum validation, write includes read |
| Key regeneration breaks integrations | HIGH | MEDIUM | Clear warnings, email notifications |

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2026-01-15 | Initial story for Epic 11 Phase 1 | ARCHITECT-AGENT |

---

**Document Status**: Ready for Implementation
**Created**: 2026-01-15
**Lines**: ~600
**Complexity**: L (Large)
**Phase**: 1 (MVP)
