# Story 06.6 - Test Results Recording

**Epic:** 06 Quality Module
**Status:** TO IMPLEMENT
**Phase:** 1A - Core Quality
**Story Type:** Feature Implementation
**Complexity:** M (Medium)
**Estimated Days:** 2-3 days

---

## Story Overview

Enable inspectors to record test results for quality inspections by capturing measured values against specification parameters. The system validates each test result against acceptance criteria (numeric/text/boolean/range), determines pass/fail status, and detects marginal results (within 5% of limits).

**User Story:**
As a QA Inspector, I want to record test results during inspections so that I can validate product quality against specifications and identify pass/fail/marginal conditions.

---

## PRD Reference

**Primary FR:** FR-QA-004 (Test Templates & Recording)

**Key PRD Sections:**
- Section 4.1: quality_test_results table
- Section 5: Test Results API endpoints
- Section 9: Inspection Types
- Section 15: KPIs & Metrics

---

## Dependencies

### Required (Must Exist)

| Dependency | Provides | Status |
|------------|----------|--------|
| **Epic 01.1** | organizations, users (tested_by) | REQUIRED |
| **Epic 02.1** | products table | REQUIRED |
| **Story 06.3** | quality_specifications table | REQUIRED |
| **Story 06.4** | quality_spec_parameters table | REQUIRED |
| **Story 06.5** | quality_inspections table | REQUIRED |

### Optional (Enhances)

| Dependency | Provides | Impact if Missing |
|------------|----------|-------------------|
| **Epic 01.10** | machines table (equipment_id) | Equipment tracking disabled |

---

## Technical Implementation

### 1. Database Migration

**File:** `supabase/migrations/20XX_create_quality_test_results.sql`

```sql
-- quality_test_results table
CREATE TABLE quality_test_results (
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id              UUID NOT NULL REFERENCES organizations(id),
    inspection_id       UUID NOT NULL REFERENCES quality_inspections(id) ON DELETE CASCADE,
    parameter_id        UUID NOT NULL REFERENCES quality_spec_parameters(id),

    -- Test Values
    measured_value      TEXT,                    -- String to support various types
    numeric_value       DECIMAL(15,6),           -- For numeric parameters

    -- Result Determination
    result_status       TEXT NOT NULL,           -- pass, fail, marginal
    deviation_pct       DECIMAL(5,2),            -- % deviation from limit (for marginal detection)

    -- Test Metadata
    tested_by           UUID NOT NULL REFERENCES users(id),
    tested_at           TIMESTAMPTZ NOT NULL DEFAULT now(),

    -- Equipment (Optional - Epic 01.10)
    equipment_id        UUID REFERENCES machines(id),
    calibration_date    DATE,                    -- Equipment calibration date

    -- Additional Info
    notes               TEXT,
    attachment_url      TEXT,                    -- Photo/document evidence

    -- Audit Fields
    created_at          TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by          UUID REFERENCES users(id),
    updated_at          TIMESTAMPTZ,

    -- Constraints
    CHECK (result_status IN ('pass', 'fail', 'marginal')),
    CHECK (numeric_value IS NULL OR measured_value IS NOT NULL)
);

-- Indexes
CREATE INDEX idx_test_results_inspection ON quality_test_results(inspection_id);
CREATE INDEX idx_test_results_parameter ON quality_test_results(parameter_id);
CREATE INDEX idx_test_results_org_status ON quality_test_results(org_id, result_status);
CREATE INDEX idx_test_results_tested_at ON quality_test_results(tested_at DESC);

-- RLS Policies
ALTER TABLE quality_test_results ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Quality test results org isolation"
ON quality_test_results FOR ALL
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- Comments
COMMENT ON TABLE quality_test_results IS 'Test result records for quality inspections';
COMMENT ON COLUMN quality_test_results.measured_value IS 'String value supporting all parameter types';
COMMENT ON COLUMN quality_test_results.numeric_value IS 'Numeric value for calculations and trending';
COMMENT ON COLUMN quality_test_results.result_status IS 'Pass/fail/marginal based on acceptance criteria';
COMMENT ON COLUMN quality_test_results.deviation_pct IS 'Percentage deviation from limit (marginal detection)';
```

---

### 2. Zod Validation Schema

**File:** `apps/frontend/lib/validation/quality-test-results-schema.ts`

```typescript
import { z } from 'zod';

export const testResultCreateSchema = z.object({
  inspection_id: z.string().uuid('Invalid inspection ID'),
  parameter_id: z.string().uuid('Invalid parameter ID'),
  measured_value: z.string().min(1, 'Measured value required'),
  numeric_value: z.number().optional(),
  equipment_id: z.string().uuid().optional(),
  calibration_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  notes: z.string().max(1000, 'Notes too long (max 1000 chars)').optional(),
  attachment_url: z.string().url().optional(),
});

export const testResultBatchCreateSchema = z.object({
  inspection_id: z.string().uuid(),
  results: z.array(testResultCreateSchema.omit({ inspection_id: true }))
    .min(1, 'At least one result required')
    .max(100, 'Max 100 results per batch'),
});

export const testResultUpdateSchema = testResultCreateSchema.partial().extend({
  id: z.string().uuid(),
});

export const testResultQuerySchema = z.object({
  inspection_id: z.string().uuid().optional(),
  parameter_id: z.string().uuid().optional(),
  result_status: z.enum(['pass', 'fail', 'marginal']).optional(),
  tested_by: z.string().uuid().optional(),
  from_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  to_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  page: z.number().int().positive().default(1),
  limit: z.number().int().positive().max(100).default(20),
});

// Type exports
export type TestResultCreate = z.infer<typeof testResultCreateSchema>;
export type TestResultBatchCreate = z.infer<typeof testResultBatchCreateSchema>;
export type TestResultUpdate = z.infer<typeof testResultUpdateSchema>;
export type TestResultQuery = z.infer<typeof testResultQuerySchema>;
```

---

### 3. Service Layer

**File:** `apps/frontend/lib/services/test-results-service.ts`

```typescript
import { createClient } from '@/lib/supabase/server';
import {
  TestResultCreate,
  TestResultBatchCreate,
  TestResultUpdate,
  TestResultQuery
} from '@/lib/validation/quality-test-results-schema';

export interface TestResult {
  id: string;
  org_id: string;
  inspection_id: string;
  parameter_id: string;
  measured_value: string;
  numeric_value?: number;
  result_status: 'pass' | 'fail' | 'marginal';
  deviation_pct?: number;
  tested_by: string;
  tested_at: string;
  equipment_id?: string;
  calibration_date?: string;
  notes?: string;
  attachment_url?: string;
  created_at: string;
  created_by?: string;
  updated_at?: string;
  // Relations
  parameter?: any;
  tester?: any;
  equipment?: any;
}

export interface ParameterValidationResult {
  result_status: 'pass' | 'fail' | 'marginal';
  deviation_pct?: number;
  numeric_value?: number;
}

export class TestResultsService {
  /**
   * Validate test result against parameter criteria
   */
  static validateResult(
    measuredValue: string,
    parameter: any
  ): ParameterValidationResult {
    const paramType = parameter.parameter_type;

    // Boolean type
    if (paramType === 'boolean') {
      const boolValue = measuredValue.toLowerCase();
      const targetValue = parameter.target_value?.toLowerCase();
      const passes = boolValue === targetValue || boolValue === 'true' || boolValue === 'yes';
      return {
        result_status: passes ? 'pass' : 'fail',
      };
    }

    // Text type (exact match)
    if (paramType === 'text') {
      const passes = measuredValue.toLowerCase() === parameter.target_value?.toLowerCase();
      return {
        result_status: passes ? 'pass' : 'fail',
      };
    }

    // Numeric and Range types
    if (paramType === 'numeric' || paramType === 'range') {
      const numValue = parseFloat(measuredValue);

      if (isNaN(numValue)) {
        return { result_status: 'fail' };
      }

      const min = parameter.min_value;
      const max = parameter.max_value;

      // Both limits defined
      if (min !== null && max !== null) {
        const range = max - min;
        const marginThreshold = range * 0.05; // 5% of range

        // Calculate deviation from nearest limit
        let deviationPct = 0;
        let isMarginal = false;

        if (numValue < min) {
          deviationPct = ((min - numValue) / range) * 100;
          return { result_status: 'fail', deviation_pct: deviationPct, numeric_value: numValue };
        }

        if (numValue > max) {
          deviationPct = ((numValue - max) / range) * 100;
          return { result_status: 'fail', deviation_pct: deviationPct, numeric_value: numValue };
        }

        // Within limits - check if marginal
        if (numValue < min + marginThreshold) {
          deviationPct = ((min + marginThreshold - numValue) / range) * 100;
          isMarginal = true;
        } else if (numValue > max - marginThreshold) {
          deviationPct = ((numValue - (max - marginThreshold)) / range) * 100;
          isMarginal = true;
        }

        return {
          result_status: isMarginal ? 'marginal' : 'pass',
          deviation_pct: isMarginal ? deviationPct : undefined,
          numeric_value: numValue,
        };
      }

      // Only min limit
      if (min !== null && numValue < min) {
        const deviationPct = ((min - numValue) / min) * 100;
        return { result_status: 'fail', deviation_pct: deviationPct, numeric_value: numValue };
      }

      // Only max limit
      if (max !== null && numValue > max) {
        const deviationPct = ((numValue - max) / max) * 100;
        return { result_status: 'fail', deviation_pct: deviationPct, numeric_value: numValue };
      }

      // Check marginal for single limit (within 5%)
      if (min !== null) {
        const marginThreshold = min * 0.05;
        if (numValue < min + marginThreshold) {
          const deviationPct = ((min + marginThreshold - numValue) / min) * 100;
          return { result_status: 'marginal', deviation_pct: deviationPct, numeric_value: numValue };
        }
      }

      if (max !== null) {
        const marginThreshold = max * 0.05;
        if (numValue > max - marginThreshold) {
          const deviationPct = ((numValue - (max - marginThreshold)) / max) * 100;
          return { result_status: 'marginal', deviation_pct: deviationPct, numeric_value: numValue };
        }
      }

      // Pass
      return { result_status: 'pass', numeric_value: numValue };
    }

    // Unknown type - default fail
    return { result_status: 'fail' };
  }

  /**
   * Create a single test result
   */
  static async create(data: TestResultCreate, userId: string): Promise<TestResult> {
    const supabase = await createClient();

    // Get user org_id
    const { data: user } = await supabase
      .from('users')
      .select('org_id')
      .eq('id', userId)
      .single();

    if (!user) throw new Error('User not found');

    // Get parameter details for validation
    const { data: parameter } = await supabase
      .from('quality_spec_parameters')
      .select('*')
      .eq('id', data.parameter_id)
      .single();

    if (!parameter) throw new Error('Parameter not found');

    // Validate result
    const validation = this.validateResult(data.measured_value, parameter);

    // Insert test result
    const { data: result, error } = await supabase
      .from('quality_test_results')
      .insert({
        org_id: user.org_id,
        inspection_id: data.inspection_id,
        parameter_id: data.parameter_id,
        measured_value: data.measured_value,
        numeric_value: validation.numeric_value,
        result_status: validation.result_status,
        deviation_pct: validation.deviation_pct,
        tested_by: userId,
        tested_at: new Date().toISOString(),
        equipment_id: data.equipment_id,
        calibration_date: data.calibration_date,
        notes: data.notes,
        attachment_url: data.attachment_url,
        created_by: userId,
      })
      .select()
      .single();

    if (error) throw error;
    return result;
  }

  /**
   * Create multiple test results (batch)
   */
  static async createBatch(
    data: TestResultBatchCreate,
    userId: string
  ): Promise<TestResult[]> {
    const supabase = await createClient();

    // Get user org_id
    const { data: user } = await supabase
      .from('users')
      .select('org_id')
      .eq('id', userId)
      .single();

    if (!user) throw new Error('User not found');

    // Get all parameters for validation
    const parameterIds = data.results.map(r => r.parameter_id);
    const { data: parameters } = await supabase
      .from('quality_spec_parameters')
      .select('*')
      .in('id', parameterIds);

    if (!parameters) throw new Error('Parameters not found');

    const parameterMap = new Map(parameters.map(p => [p.id, p]));

    // Validate and prepare inserts
    const inserts = data.results.map(result => {
      const parameter = parameterMap.get(result.parameter_id);
      if (!parameter) throw new Error(`Parameter ${result.parameter_id} not found`);

      const validation = this.validateResult(result.measured_value, parameter);

      return {
        org_id: user.org_id,
        inspection_id: data.inspection_id,
        parameter_id: result.parameter_id,
        measured_value: result.measured_value,
        numeric_value: validation.numeric_value,
        result_status: validation.result_status,
        deviation_pct: validation.deviation_pct,
        tested_by: userId,
        tested_at: new Date().toISOString(),
        equipment_id: result.equipment_id,
        calibration_date: result.calibration_date,
        notes: result.notes,
        attachment_url: result.attachment_url,
        created_by: userId,
      };
    });

    // Batch insert
    const { data: results, error } = await supabase
      .from('quality_test_results')
      .insert(inserts)
      .select();

    if (error) throw error;
    return results;
  }

  /**
   * Get test results for an inspection
   */
  static async getByInspection(inspectionId: string): Promise<TestResult[]> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('quality_test_results')
      .select(`
        *,
        parameter:quality_spec_parameters(*),
        tester:users(id, name, email),
        equipment:machines(id, name, code)
      `)
      .eq('inspection_id', inspectionId)
      .order('created_at', { ascending: true });

    if (error) throw error;
    return data || [];
  }

  /**
   * Query test results with filters
   */
  static async query(filters: TestResultQuery): Promise<{
    results: TestResult[];
    total: number;
    page: number;
    limit: number;
  }> {
    const supabase = await createClient();

    let query = supabase
      .from('quality_test_results')
      .select(`
        *,
        parameter:quality_spec_parameters(*),
        tester:users(id, name, email),
        equipment:machines(id, name, code)
      `, { count: 'exact' });

    // Apply filters
    if (filters.inspection_id) {
      query = query.eq('inspection_id', filters.inspection_id);
    }
    if (filters.parameter_id) {
      query = query.eq('parameter_id', filters.parameter_id);
    }
    if (filters.result_status) {
      query = query.eq('result_status', filters.result_status);
    }
    if (filters.tested_by) {
      query = query.eq('tested_by', filters.tested_by);
    }
    if (filters.from_date) {
      query = query.gte('tested_at', filters.from_date);
    }
    if (filters.to_date) {
      query = query.lte('tested_at', filters.to_date);
    }

    // Pagination
    const offset = (filters.page - 1) * filters.limit;
    query = query.range(offset, offset + filters.limit - 1);
    query = query.order('tested_at', { ascending: false });

    const { data, error, count } = await query;

    if (error) throw error;

    return {
      results: data || [],
      total: count || 0,
      page: filters.page,
      limit: filters.limit,
    };
  }

  /**
   * Get test result summary for inspection (pass/fail/marginal counts)
   */
  static async getInspectionSummary(inspectionId: string): Promise<{
    total: number;
    pass: number;
    fail: number;
    marginal: number;
    pass_rate: number;
  }> {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('quality_test_results')
      .select('result_status')
      .eq('inspection_id', inspectionId);

    if (error) throw error;

    const total = data?.length || 0;
    const pass = data?.filter(r => r.result_status === 'pass').length || 0;
    const fail = data?.filter(r => r.result_status === 'fail').length || 0;
    const marginal = data?.filter(r => r.result_status === 'marginal').length || 0;

    return {
      total,
      pass,
      fail,
      marginal,
      pass_rate: total > 0 ? (pass / total) * 100 : 0,
    };
  }

  /**
   * Update test result (limited fields)
   */
  static async update(
    id: string,
    data: Partial<TestResultUpdate>
  ): Promise<TestResult> {
    const supabase = await createClient();

    // If measured_value changed, re-validate
    let updateData: any = {
      ...data,
      updated_at: new Date().toISOString(),
    };

    if (data.measured_value) {
      // Get parameter for re-validation
      const { data: result } = await supabase
        .from('quality_test_results')
        .select('parameter_id')
        .eq('id', id)
        .single();

      if (result) {
        const { data: parameter } = await supabase
          .from('quality_spec_parameters')
          .select('*')
          .eq('id', result.parameter_id)
          .single();

        if (parameter) {
          const validation = this.validateResult(data.measured_value, parameter);
          updateData = {
            ...updateData,
            numeric_value: validation.numeric_value,
            result_status: validation.result_status,
            deviation_pct: validation.deviation_pct,
          };
        }
      }
    }

    const { data: updated, error } = await supabase
      .from('quality_test_results')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;
    return updated;
  }

  /**
   * Delete test result
   */
  static async delete(id: string): Promise<void> {
    const supabase = await createClient();

    const { error } = await supabase
      .from('quality_test_results')
      .delete()
      .eq('id', id);

    if (error) throw error;
  }
}
```

---

### 4. API Routes

**File:** `apps/frontend/app/api/quality/test-results/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { TestResultsService } from '@/lib/services/test-results-service';
import {
  testResultCreateSchema,
  testResultBatchCreateSchema,
  testResultQuerySchema
} from '@/lib/validation/quality-test-results-schema';
import { getCurrentUser } from '@/lib/auth-utils';

// POST /api/quality/test-results - Create test result(s)
export async function POST(req: NextRequest) {
  try {
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();

    // Check if batch or single
    if (body.results && Array.isArray(body.results)) {
      // Batch create
      const validated = testResultBatchCreateSchema.parse(body);
      const results = await TestResultsService.createBatch(validated, user.id);
      return NextResponse.json({ results }, { status: 201 });
    } else {
      // Single create
      const validated = testResultCreateSchema.parse(body);
      const result = await TestResultsService.create(validated, user.id);
      return NextResponse.json({ result }, { status: 201 });
    }
  } catch (error: any) {
    console.error('Error creating test result:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create test result' },
      { status: 400 }
    );
  }
}

// GET /api/quality/test-results - Query test results
export async function GET(req: NextRequest) {
  try {
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const searchParams = req.nextUrl.searchParams;
    const filters = testResultQuerySchema.parse({
      inspection_id: searchParams.get('inspection_id') || undefined,
      parameter_id: searchParams.get('parameter_id') || undefined,
      result_status: searchParams.get('result_status') || undefined,
      tested_by: searchParams.get('tested_by') || undefined,
      from_date: searchParams.get('from_date') || undefined,
      to_date: searchParams.get('to_date') || undefined,
      page: parseInt(searchParams.get('page') || '1'),
      limit: parseInt(searchParams.get('limit') || '20'),
    });

    const data = await TestResultsService.query(filters);
    return NextResponse.json(data);
  } catch (error: any) {
    console.error('Error querying test results:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to query test results' },
      { status: 400 }
    );
  }
}
```

**File:** `apps/frontend/app/api/quality/test-results/inspection/[id]/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { TestResultsService } from '@/lib/services/test-results-service';
import { getCurrentUser } from '@/lib/auth-utils';

// GET /api/quality/test-results/inspection/:id - Get results for inspection
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const results = await TestResultsService.getByInspection(params.id);
    return NextResponse.json({ results });
  } catch (error: any) {
    console.error('Error fetching test results:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to fetch test results' },
      { status: 400 }
    );
  }
}
```

**File:** `apps/frontend/app/api/quality/test-results/inspection/[id]/summary/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { TestResultsService } from '@/lib/services/test-results-service';
import { getCurrentUser } from '@/lib/auth-utils';

// GET /api/quality/test-results/inspection/:id/summary - Get summary
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const summary = await TestResultsService.getInspectionSummary(params.id);
    return NextResponse.json({ summary });
  } catch (error: any) {
    console.error('Error fetching test result summary:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to fetch summary' },
      { status: 400 }
    );
  }
}
```

**File:** `apps/frontend/app/api/quality/test-results/[id]/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { TestResultsService } from '@/lib/services/test-results-service';
import { testResultUpdateSchema } from '@/lib/validation/quality-test-results-schema';
import { getCurrentUser } from '@/lib/auth-utils';

// PUT /api/quality/test-results/:id - Update test result
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();
    const validated = testResultUpdateSchema.parse({ ...body, id: params.id });

    const result = await TestResultsService.update(params.id, validated);
    return NextResponse.json({ result });
  } catch (error: any) {
    console.error('Error updating test result:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to update test result' },
      { status: 400 }
    );
  }
}

// DELETE /api/quality/test-results/:id - Delete test result
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    await TestResultsService.delete(params.id);
    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('Error deleting test result:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to delete test result' },
      { status: 400 }
    );
  }
}
```

---

### 5. React Components

**File:** `apps/frontend/components/quality/test-results/TestResultsForm.tsx`

```typescript
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { testResultCreateSchema } from '@/lib/validation/quality-test-results-schema';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';

interface TestResultsFormProps {
  inspectionId: string;
  parameters: any[];
  onSubmit: (data: any) => Promise<void>;
  onCancel?: () => void;
}

export function TestResultsForm({
  inspectionId,
  parameters,
  onSubmit,
  onCancel,
}: TestResultsFormProps) {
  const [submitting, setSubmitting] = useState(false);
  const [selectedParam, setSelectedParam] = useState<any>(null);

  const form = useForm({
    resolver: zodResolver(testResultCreateSchema),
    defaultValues: {
      inspection_id: inspectionId,
      parameter_id: '',
      measured_value: '',
      notes: '',
    },
  });

  const handleSubmit = async (data: any) => {
    setSubmitting(true);
    try {
      await onSubmit(data);
      form.reset();
      setSelectedParam(null);
    } catch (error) {
      console.error('Submit error:', error);
    } finally {
      setSubmitting(false);
    }
  };

  const handleParameterChange = (paramId: string) => {
    const param = parameters.find(p => p.id === paramId);
    setSelectedParam(param);
    form.setValue('parameter_id', paramId);
  };

  return (
    <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-4">
      <Card>
        <CardHeader>
          <CardTitle>Record Test Result</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* Parameter Selection */}
          <div>
            <Label>Parameter</Label>
            <Select
              value={form.watch('parameter_id')}
              onValueChange={handleParameterChange}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select parameter" />
              </SelectTrigger>
              <SelectContent>
                {parameters.map(param => (
                  <SelectItem key={param.id} value={param.id}>
                    {param.parameter_name}
                    {param.is_critical && (
                      <Badge variant="destructive" className="ml-2">Critical</Badge>
                    )}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            {form.formState.errors.parameter_id && (
              <p className="text-sm text-red-600">
                {form.formState.errors.parameter_id.message}
              </p>
            )}
          </div>

          {/* Parameter Details */}
          {selectedParam && (
            <div className="p-3 bg-slate-50 rounded-md space-y-1 text-sm">
              <p><strong>Type:</strong> {selectedParam.parameter_type}</p>
              {selectedParam.target_value && (
                <p><strong>Target:</strong> {selectedParam.target_value}</p>
              )}
              {selectedParam.min_value !== null && (
                <p><strong>Min:</strong> {selectedParam.min_value} {selectedParam.unit}</p>
              )}
              {selectedParam.max_value !== null && (
                <p><strong>Max:</strong> {selectedParam.max_value} {selectedParam.unit}</p>
              )}
              {selectedParam.test_method && (
                <p><strong>Method:</strong> {selectedParam.test_method}</p>
              )}
            </div>
          )}

          {/* Measured Value */}
          <div>
            <Label>Measured Value</Label>
            <Input
              type={selectedParam?.parameter_type === 'numeric' ? 'number' : 'text'}
              step={selectedParam?.parameter_type === 'numeric' ? 'any' : undefined}
              placeholder={
                selectedParam?.parameter_type === 'boolean'
                  ? 'true/false or yes/no'
                  : 'Enter measured value'
              }
              {...form.register('measured_value')}
            />
            {form.formState.errors.measured_value && (
              <p className="text-sm text-red-600">
                {form.formState.errors.measured_value.message}
              </p>
            )}
          </div>

          {/* Equipment (Optional) */}
          <div>
            <Label>Equipment (Optional)</Label>
            <Input
              placeholder="Equipment ID"
              {...form.register('equipment_id')}
            />
          </div>

          {/* Calibration Date (Optional) */}
          <div>
            <Label>Calibration Date (Optional)</Label>
            <Input
              type="date"
              {...form.register('calibration_date')}
            />
          </div>

          {/* Notes */}
          <div>
            <Label>Notes (Optional)</Label>
            <Textarea
              rows={3}
              placeholder="Additional notes..."
              {...form.register('notes')}
            />
          </div>

          {/* Actions */}
          <div className="flex gap-2 justify-end">
            {onCancel && (
              <Button type="button" variant="outline" onClick={onCancel}>
                Cancel
              </Button>
            )}
            <Button type="submit" disabled={submitting}>
              {submitting ? 'Saving...' : 'Save Result'}
            </Button>
          </div>
        </CardContent>
      </Card>
    </form>
  );
}
```

**File:** `apps/frontend/components/quality/test-results/TestResultsTable.tsx`

```typescript
'use client';

import { Badge } from '@/components/ui/badge';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { formatDate } from '@/lib/utils';

interface TestResultsTableProps {
  results: any[];
  showInspection?: boolean;
}

export function TestResultsTable({
  results,
  showInspection = false
}: TestResultsTableProps) {
  const getStatusBadge = (status: string) => {
    switch (status) {
      case 'pass':
        return <Badge variant="success">Pass</Badge>;
      case 'fail':
        return <Badge variant="destructive">Fail</Badge>;
      case 'marginal':
        return <Badge variant="warning">Marginal</Badge>;
      default:
        return <Badge variant="secondary">{status}</Badge>;
    }
  };

  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Parameter</TableHead>
          <TableHead>Measured Value</TableHead>
          <TableHead>Specification</TableHead>
          <TableHead>Result</TableHead>
          <TableHead>Tested By</TableHead>
          <TableHead>Tested At</TableHead>
          {showInspection && <TableHead>Inspection</TableHead>}
        </TableRow>
      </TableHeader>
      <TableBody>
        {results.length === 0 ? (
          <TableRow>
            <TableCell colSpan={showInspection ? 7 : 6} className="text-center text-muted-foreground">
              No test results found
            </TableCell>
          </TableRow>
        ) : (
          results.map((result) => (
            <TableRow key={result.id}>
              <TableCell>
                <div className="font-medium">{result.parameter?.parameter_name}</div>
                {result.parameter?.is_critical && (
                  <Badge variant="destructive" className="mt-1">Critical</Badge>
                )}
              </TableCell>
              <TableCell>
                {result.measured_value}
                {result.parameter?.unit && ` ${result.parameter.unit}`}
              </TableCell>
              <TableCell className="text-sm text-muted-foreground">
                {result.parameter?.min_value !== null && result.parameter?.max_value !== null ? (
                  <span>{result.parameter.min_value} - {result.parameter.max_value}</span>
                ) : result.parameter?.min_value !== null ? (
                  <span>Min: {result.parameter.min_value}</span>
                ) : result.parameter?.max_value !== null ? (
                  <span>Max: {result.parameter.max_value}</span>
                ) : result.parameter?.target_value ? (
                  <span>Target: {result.parameter.target_value}</span>
                ) : (
                  <span>-</span>
                )}
              </TableCell>
              <TableCell>
                {getStatusBadge(result.result_status)}
                {result.deviation_pct && (
                  <div className="text-xs text-muted-foreground mt-1">
                    {result.deviation_pct.toFixed(1)}% from limit
                  </div>
                )}
              </TableCell>
              <TableCell>{result.tester?.name || 'Unknown'}</TableCell>
              <TableCell>{formatDate(result.tested_at)}</TableCell>
              {showInspection && (
                <TableCell>{result.inspection?.inspection_number}</TableCell>
              )}
            </TableRow>
          ))
        )}
      </TableBody>
    </Table>
  );
}
```

**File:** `apps/frontend/components/quality/test-results/TestResultsSummary.tsx`

```typescript
'use client';

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Progress } from '@/components/ui/progress';

interface TestResultsSummaryProps {
  summary: {
    total: number;
    pass: number;
    fail: number;
    marginal: number;
    pass_rate: number;
  };
}

export function TestResultsSummary({ summary }: TestResultsSummaryProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Test Results Summary</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="grid grid-cols-4 gap-4">
          <div className="text-center">
            <div className="text-2xl font-bold">{summary.total}</div>
            <div className="text-sm text-muted-foreground">Total Tests</div>
          </div>
          <div className="text-center">
            <div className="text-2xl font-bold text-green-600">{summary.pass}</div>
            <div className="text-sm text-muted-foreground">Passed</div>
          </div>
          <div className="text-center">
            <div className="text-2xl font-bold text-red-600">{summary.fail}</div>
            <div className="text-sm text-muted-foreground">Failed</div>
          </div>
          <div className="text-center">
            <div className="text-2xl font-bold text-yellow-600">{summary.marginal}</div>
            <div className="text-sm text-muted-foreground">Marginal</div>
          </div>
        </div>

        <div>
          <div className="flex justify-between text-sm mb-2">
            <span>Pass Rate</span>
            <span className="font-medium">{summary.pass_rate.toFixed(1)}%</span>
          </div>
          <Progress value={summary.pass_rate} className="h-2" />
        </div>
      </CardContent>
    </Card>
  );
}
```

---

## Business Rules

### Result Validation Logic

1. **Boolean Parameters**:
   - `true`, `yes`, `1` → Pass if target is `true`
   - `false`, `no`, `0` → Fail if target is `true`

2. **Text Parameters**:
   - Case-insensitive exact match against target value
   - Pass only on exact match

3. **Numeric/Range Parameters**:
   - **Pass**: Within min/max limits and NOT marginal
   - **Marginal**: Within 5% of either limit (inside valid range)
   - **Fail**: Outside min/max limits
   - Deviation % calculated for marginal/fail results

4. **Marginal Detection (5% Rule)**:
   - If value is within 5% of upper or lower limit, mark as marginal
   - Example: Range 10-20, marginal zone: 10-10.5 and 19.5-20
   - Single limit: 5% of the limit value itself

### Equipment Calibration Tracking

- `equipment_id` links to `machines` table (Epic 01.10)
- `calibration_date` optional field
- If equipment requires calibration, warn if date is old (>90 days)
- Enforce calibration date for critical parameters (configurable)

### Photo Attachments

- `attachment_url` field stores URL to uploaded photo
- Use Supabase Storage for uploads
- Allowed types: JPG, PNG, PDF
- Max size: 10 MB per file
- Multiple attachments: Use JSON array in `attachment_url` (future enhancement)

---

## Testing Requirements

### Unit Tests

**File:** `apps/frontend/lib/services/__tests__/test-results-service.test.ts`

```typescript
describe('TestResultsService', () => {
  describe('validateResult', () => {
    it('should pass boolean parameter with true value', () => {
      const param = { parameter_type: 'boolean', target_value: 'true' };
      const result = TestResultsService.validateResult('true', param);
      expect(result.result_status).toBe('pass');
    });

    it('should fail text parameter with wrong value', () => {
      const param = { parameter_type: 'text', target_value: 'Red' };
      const result = TestResultsService.validateResult('Blue', param);
      expect(result.result_status).toBe('fail');
    });

    it('should pass numeric parameter within range', () => {
      const param = { parameter_type: 'numeric', min_value: 10, max_value: 20 };
      const result = TestResultsService.validateResult('15', param);
      expect(result.result_status).toBe('pass');
    });

    it('should mark numeric parameter as marginal near lower limit', () => {
      const param = { parameter_type: 'numeric', min_value: 10, max_value: 20 };
      const result = TestResultsService.validateResult('10.3', param);
      expect(result.result_status).toBe('marginal');
    });

    it('should fail numeric parameter below min', () => {
      const param = { parameter_type: 'numeric', min_value: 10, max_value: 20 };
      const result = TestResultsService.validateResult('8', param);
      expect(result.result_status).toBe('fail');
    });

    it('should calculate deviation percentage for failed result', () => {
      const param = { parameter_type: 'numeric', min_value: 10, max_value: 20 };
      const result = TestResultsService.validateResult('8', param);
      expect(result.deviation_pct).toBeGreaterThan(0);
    });
  });

  describe('create', () => {
    it('should create test result with auto-validation', async () => {
      // Mock implementation
    });
  });

  describe('getInspectionSummary', () => {
    it('should return correct pass/fail/marginal counts', async () => {
      // Mock implementation
    });
  });
});
```

### Integration Tests

**File:** `apps/frontend/app/api/quality/test-results/__tests__/route.test.ts`

```typescript
describe('POST /api/quality/test-results', () => {
  it('should create test result and return pass status', async () => {
    // Test implementation
  });

  it('should create batch test results', async () => {
    // Test implementation
  });

  it('should return 400 for invalid data', async () => {
    // Test implementation
  });

  it('should enforce RLS (org isolation)', async () => {
    // Test implementation
  });
});

describe('GET /api/quality/test-results/inspection/:id', () => {
  it('should return all results for inspection', async () => {
    // Test implementation
  });
});
```

### E2E Tests

**File:** `apps/frontend/__tests__/e2e/quality/test-results.spec.ts`

```typescript
test.describe('Test Results Recording', () => {
  test('should record test result with pass status', async ({ page }) => {
    // Navigate to inspection detail
    // Select parameter
    // Enter measured value
    // Submit form
    // Verify pass badge displayed
  });

  test('should detect marginal result', async ({ page }) => {
    // Enter value near limit
    // Verify marginal badge and deviation percentage
  });

  test('should show validation error for out-of-spec value', async ({ page }) => {
    // Enter value outside limits
    // Verify fail status
  });
});
```

---

## Acceptance Criteria

- [ ] `quality_test_results` table created with RLS
- [ ] Test result validation logic implemented for all parameter types
- [ ] Marginal detection (5% rule) working correctly
- [ ] API endpoints functional:
  - `POST /api/quality/test-results` (single + batch)
  - `GET /api/quality/test-results/inspection/:id`
  - `GET /api/quality/test-results/inspection/:id/summary`
  - `PUT /api/quality/test-results/:id`
  - `DELETE /api/quality/test-results/:id`
- [ ] `TestResultsForm` component renders with parameter selection
- [ ] `TestResultsTable` displays results with pass/fail/marginal badges
- [ ] `TestResultsSummary` shows pass rate and counts
- [ ] Equipment ID and calibration date captured (if Epic 01.10 exists)
- [ ] Photo attachment support (URL stored)
- [ ] Unit tests >80% coverage
- [ ] Integration tests for all API routes
- [ ] E2E test for test result recording flow
- [ ] RLS policies enforce org isolation
- [ ] Documentation complete

---

## Open Questions

1. **Multi-photo support**: Should `attachment_url` support multiple photos? (Future enhancement)
2. **Calibration enforcement**: Should system block test results if equipment calibration expired?
3. **Test method validation**: Should system enforce specific test methods per parameter?
4. **Re-test workflow**: If result fails, should system allow immediate re-test or require investigation?
5. **Result locking**: Should test results be immutable once inspection is completed?

---

## Notes

- This story enables data capture; inspection completion logic is in Story 06.5
- Marginal results are warnings, not failures (inspection can still pass)
- Critical parameter failures should trigger alerts (Story 06.17)
- Test result trending and charting in Story 06.18
- Scanner integration for mobile test recording in Story 06.8

---

## Files Created

### Database
- `supabase/migrations/20XX_create_quality_test_results.sql`

### Backend
- `apps/frontend/lib/validation/quality-test-results-schema.ts`
- `apps/frontend/lib/services/test-results-service.ts`

### API Routes
- `apps/frontend/app/api/quality/test-results/route.ts`
- `apps/frontend/app/api/quality/test-results/inspection/[id]/route.ts`
- `apps/frontend/app/api/quality/test-results/inspection/[id]/summary/route.ts`
- `apps/frontend/app/api/quality/test-results/[id]/route.ts`

### Frontend Components
- `apps/frontend/components/quality/test-results/TestResultsForm.tsx`
- `apps/frontend/components/quality/test-results/TestResultsTable.tsx`
- `apps/frontend/components/quality/test-results/TestResultsSummary.tsx`

### Tests
- `apps/frontend/lib/services/__tests__/test-results-service.test.ts`
- `apps/frontend/app/api/quality/test-results/__tests__/route.test.ts`
- `apps/frontend/__tests__/e2e/quality/test-results.spec.ts`

---

**Story Status:** Ready for Implementation
**Last Updated:** 2025-12-16
**Story Points:** 5 (Medium)
**Estimated Hours:** 16-24 hours
