# 06.5 - Incoming Inspection

**Priority**: P0 (MVP)
**Story Points**: L (Large)
**Type**: backend + frontend
**Phase**: 1B (Core Quality)
**Model**: OPUS

**State:** ready
**Estimate:** L (5-7 days)
**Primary PRD:** `docs/1-BASELINE/product/modules/quality.md` (FR-QA-005, Section 9.1)
**Architecture:** `docs/1-BASELINE/architecture/modules/quality.md` (quality_inspections table)

---

## Goal

Implement the incoming inspection workflow for goods received via GRN. This enables QA teams to inspect raw materials, packaging, and ingredients upon receipt, determine pass/fail/conditional results, and update License Plate QA status accordingly. Incoming inspection is a critical quality gate that ensures only approved materials enter production.

---

## Food Safety Compliance

This story is **critical for food safety compliance**:

- [x] **HACCP Compliance** - Receiving temperature CCPs require inspection records
- [x] **FDA 21 CFR Part 11** - Audit trail for all inspection actions required
- [x] **Audit Trail Required** - Inspector ID, timestamp, result, all test values
- [x] **Traceability** - Inspection linked to PO, GRN, LP, and batch

**Regulatory Context:**
- FDA FSMA requires documented receiving inspections
- Temperature verification on arrival for perishables
- Visual inspection for damage, contamination, pest evidence
- CoA verification for critical ingredients
- All records retained for minimum 2 years (configurable)

---

## MVP Scope

This story implements Phase 1B (Core Quality) functionality. Incoming inspection is the first inspection type to implement, establishing patterns for in-process and final inspections.

**MVP Includes**:
- `quality_inspections` table with type='incoming' filter
- Auto-create inspection on GRN completion (if setting enabled)
- Manual inspection creation from pending queue
- Inspection workflow: scheduled -> in_progress -> completed
- Inspector assignment and reassignment
- Test results recording per specification parameter (via story 06.6)
- Result determination: pass/fail/conditional
- LP QA status update on inspection completion
- Inspection queue dashboard with filters
- Inspection detail page with test results grid
- Integration with Epic 03 (PO) and Epic 05 (LP)

**Deferred to Phase 1+ (Story 06.5b)**: See "Future Phases" section below.

---

## User Story

As a **QA Inspector**, I want to **receive and inspect goods from Purchase Orders, recording test results and determining pass/fail status** so that **only quality-approved materials enter our warehouse and production processes**.

As a **QA Manager**, I want to **view pending inspections, assign inspectors, and review completed inspection results** so that **I can ensure timely quality checks and maintain compliance records**.

---

## Scope

**In scope (this story)**
- `quality_inspections` table with incoming-specific logic
- Auto-create inspection on GRN completion (configurable)
- GET /api/quality/inspections (list with type='incoming' filter)
- GET /api/quality/inspections/:id (inspection detail)
- POST /api/quality/inspections (manual creation)
- POST /api/quality/inspections/:id/start (begin inspection)
- POST /api/quality/inspections/:id/assign (assign/reassign inspector)
- POST /api/quality/inspections/:id/complete (complete with result)
- GET /api/quality/inspections/pending (pending queue)
- GET /api/quality/inspections/incoming (incoming queue)
- LP QA status update on inspection completion
- Inspection queue page with filters and sorting
- Inspection detail page with test results
- Start/Complete inspection workflow UI
- Inspector assignment modal
- Result determination logic (pass/fail/conditional)

**Out of scope (this story)**
- Test results recording (story 06.6 - required dependency)
- In-process inspection (story 06.10)
- Final inspection (story 06.11)
- Sampling plans integration (story 06.7)
- Scanner QA workflow (story 06.8)
- NCR auto-creation on failure (story 06.9)
- CoA verification (Phase 2)
- Temperature logging integration (Phase 3 - HACCP)

---

## Future Phases (Not in MVP)

### Phase 1+ (Story 06.5b - Incoming Inspection Advanced)
- **Auto-create from GRN** - Automatic inspection creation on GRN completion
- **Sampling plan integration** - Use AQL-based sampling from story 06.7
- **Multi-sample inspections** - Multiple samples per LP
- **Inspection scheduling** - Scheduled date vs actual date
- **Inspection templates** - Pre-configured inspection types
- **Photo attachments** - Capture defect photos during inspection

### Phase 2
- **CoA verification workflow** - Verify supplier CoA against spec
- **Temperature logging** - IoT temperature data capture
- **Supplier quality scoring** - Update supplier rating on inspection results
- **Inspection SLAs** - Alert when inspection exceeds time limits
- **Inspection reports** - Printable inspection certificates

### Phase 3
- **CCP monitoring integration** - Receiving temperature as CCP
- **Auto-NCR on critical failure** - Automatic NCR creation for critical failures
- **E-signature for completion** - FDA 21 CFR Part 11 compliant signatures
- **Inspection analytics** - Pass rate trends, failure pareto

### Deferred to Other Stories
- **Test results recording** - Story 06.6 (Test Results Recording)
- **Sampling plans** - Story 06.7 (Sampling Plans AQL)
- **Scanner QA** - Story 06.8 (Scanner QA Pass/Fail)
- **NCR creation** - Story 06.9 (Basic NCR Creation)
- **Quality holds** - Story 06.2 (Quality Holds CRUD)

---

## Dependencies

### Cross-Epic Dependencies

| Dependency | Story/Epic | Type | What It Provides | Status |
|------------|------------|------|------------------|--------|
| 01.1 | Org Context + RLS | HARD | organizations, users, roles tables | Ready |
| 02.1 | Products CRUD | HARD | products table for product reference | Ready |
| 03.3 | Purchase Orders | HARD | purchase_orders, po_lines for PO reference | Ready |
| 05.1 | LP Table + CRUD | HARD | license_plates table, LP service | Ready |
| 05.11 | GRN from PO | HARD | grns, grn_items tables, GRN completion trigger | Ready |

### Within Epic Dependencies

| Dependency | Story | Type | What It Provides |
|------------|-------|------|------------------|
| 06.0 | Quality Settings | HARD | quality_settings for auto-create, defaults |
| 06.1 | Quality Status Types | HARD | QA status enum for LP updates |
| 06.3 | Product Specifications | HARD | quality_specifications for test parameters |
| 06.4 | Test Parameters | HARD | quality_spec_parameters for test criteria |

### Provides To (Downstream)

| Story | What This Provides |
|-------|-------------------|
| 06.6 | Test Results Recording - inspection_id reference |
| 06.7 | Sampling Plans - inspection linkage |
| 06.8 | Scanner QA - inspection workflow patterns |
| 06.9 | NCR Creation - source inspection reference |
| 06.10 | In-Process Inspection - shared inspection patterns |
| 06.11 | Final Inspection - shared inspection patterns |

---

## Database Migration

### Migration: Create quality_inspections table

```sql
-- Migration: YYYYMMDDHHMMSS_create_quality_inspections.sql

CREATE TABLE quality_inspections (
    -- Identity
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id                  UUID NOT NULL REFERENCES organizations(id),
    inspection_number       TEXT NOT NULL,

    -- Type and Classification
    inspection_type         TEXT NOT NULL
                            CHECK (inspection_type IN ('incoming', 'in_process', 'final')),

    -- Source Reference (polymorphic - one populated based on type)
    reference_type          TEXT NOT NULL
                            CHECK (reference_type IN ('po', 'grn', 'wo', 'lp', 'batch')),
    reference_id            UUID NOT NULL,

    -- Product and Specification
    product_id              UUID NOT NULL REFERENCES products(id),
    spec_id                 UUID REFERENCES quality_specifications(id),

    -- LP Reference (for incoming, the received LP)
    lp_id                   UUID REFERENCES license_plates(id),
    grn_id                  UUID REFERENCES grns(id),
    po_id                   UUID REFERENCES purchase_orders(id),

    -- Batch Tracking
    batch_number            TEXT,
    lot_size                INTEGER,
    sample_size             INTEGER,
    sampling_plan_id        UUID REFERENCES sampling_plans(id),

    -- Assignment
    inspector_id            UUID REFERENCES users(id),
    assigned_by             UUID REFERENCES users(id),
    assigned_at             TIMESTAMPTZ,

    -- Workflow Status
    status                  TEXT NOT NULL DEFAULT 'scheduled'
                            CHECK (status IN ('scheduled', 'in_progress', 'completed', 'cancelled')),

    -- Scheduling
    scheduled_date          DATE,
    priority                TEXT DEFAULT 'normal'
                            CHECK (priority IN ('low', 'normal', 'high', 'urgent')),

    -- Execution
    started_at              TIMESTAMPTZ,
    completed_at            TIMESTAMPTZ,
    completed_by            UUID REFERENCES users(id),

    -- Results
    result                  TEXT
                            CHECK (result IN ('pass', 'fail', 'conditional', NULL)),
    result_notes            TEXT,

    -- Defect Counts
    defects_found           INTEGER DEFAULT 0,
    major_defects           INTEGER DEFAULT 0,
    minor_defects           INTEGER DEFAULT 0,
    critical_defects        INTEGER DEFAULT 0,

    -- Conditional Approval
    conditional_reason      TEXT,
    conditional_restrictions TEXT,
    conditional_approved_by UUID REFERENCES users(id),
    conditional_expires_at  TIMESTAMPTZ,

    -- NCR Linkage (populated if inspection triggers NCR)
    ncr_id                  UUID REFERENCES ncr_reports(id),

    -- Audit
    created_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by              UUID REFERENCES users(id),
    updated_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by              UUID REFERENCES users(id),

    -- Constraints
    CONSTRAINT uq_inspection_number UNIQUE (org_id, inspection_number)
);

-- =============================================================================
-- Indexes for Performance
-- =============================================================================

CREATE INDEX idx_inspections_org_status ON quality_inspections(org_id, status);
CREATE INDEX idx_inspections_org_type ON quality_inspections(org_id, inspection_type);
CREATE INDEX idx_inspections_type_status ON quality_inspections(org_id, inspection_type, status);
CREATE INDEX idx_inspections_product ON quality_inspections(product_id);
CREATE INDEX idx_inspections_lp ON quality_inspections(lp_id) WHERE lp_id IS NOT NULL;
CREATE INDEX idx_inspections_grn ON quality_inspections(grn_id) WHERE grn_id IS NOT NULL;
CREATE INDEX idx_inspections_po ON quality_inspections(po_id) WHERE po_id IS NOT NULL;
CREATE INDEX idx_inspections_inspector ON quality_inspections(inspector_id) WHERE inspector_id IS NOT NULL;
CREATE INDEX idx_inspections_scheduled ON quality_inspections(org_id, scheduled_date)
    WHERE status = 'scheduled';
CREATE INDEX idx_inspections_pending ON quality_inspections(org_id, inspection_type, status)
    WHERE status IN ('scheduled', 'in_progress');
CREATE INDEX idx_inspections_created ON quality_inspections(org_id, created_at);

-- =============================================================================
-- Inspection Number Sequence
-- =============================================================================

CREATE TABLE inspection_number_sequences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    year INTEGER NOT NULL,
    inspection_type TEXT NOT NULL,
    current_value BIGINT NOT NULL DEFAULT 0,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    UNIQUE(org_id, year, inspection_type)
);

-- Function to generate inspection number (INS-INCOMING-YYYY-NNNNN)
CREATE OR REPLACE FUNCTION generate_inspection_number(p_org_id UUID, p_type TEXT)
RETURNS TEXT AS $$
DECLARE
    v_year INTEGER;
    v_next_val BIGINT;
    v_prefix TEXT;
    v_inspection_number TEXT;
BEGIN
    v_year := EXTRACT(YEAR FROM CURRENT_DATE);

    -- Determine prefix based on type
    CASE p_type
        WHEN 'incoming' THEN v_prefix := 'INC';
        WHEN 'in_process' THEN v_prefix := 'IPR';
        WHEN 'final' THEN v_prefix := 'FIN';
        ELSE v_prefix := 'INS';
    END CASE;

    -- Upsert sequence and get next value
    INSERT INTO inspection_number_sequences (org_id, year, inspection_type, current_value)
    VALUES (p_org_id, v_year, p_type, 1)
    ON CONFLICT (org_id, year, inspection_type)
    DO UPDATE SET
        current_value = inspection_number_sequences.current_value + 1,
        updated_at = NOW()
    RETURNING current_value INTO v_next_val;

    -- Format inspection number
    v_inspection_number := 'INS-' || v_prefix || '-' || v_year::TEXT || '-' || LPAD(v_next_val::TEXT, 5, '0');

    RETURN v_inspection_number;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- RLS Policies
-- =============================================================================

ALTER TABLE quality_inspections ENABLE ROW LEVEL SECURITY;

CREATE POLICY "inspections_select" ON quality_inspections
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "inspections_insert" ON quality_inspections
    FOR INSERT WITH CHECK (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "inspections_update" ON quality_inspections
    FOR UPDATE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

-- Only allow delete of scheduled inspections (not started)
CREATE POLICY "inspections_delete" ON quality_inspections
    FOR DELETE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND status = 'scheduled'
    );

ALTER TABLE inspection_number_sequences ENABLE ROW LEVEL SECURITY;

CREATE POLICY "insp_seq_org" ON inspection_number_sequences
    FOR ALL TO authenticated
    USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- =============================================================================
-- Trigger for updated_at
-- =============================================================================

CREATE TRIGGER update_quality_inspections_updated_at
    BEFORE UPDATE ON quality_inspections
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================================================
-- Function: Auto-create inspection on GRN completion
-- =============================================================================

CREATE OR REPLACE FUNCTION create_incoming_inspection_on_grn()
RETURNS TRIGGER AS $$
DECLARE
    v_settings RECORD;
    v_grn_item RECORD;
    v_spec_id UUID;
    v_inspection_number TEXT;
BEGIN
    -- Only trigger on GRN status change to 'completed'
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN

        -- Check if auto-create is enabled
        SELECT * INTO v_settings
        FROM quality_settings
        WHERE org_id = NEW.org_id;

        IF v_settings.auto_create_inspection_on_grn = true THEN

            -- Create inspection for each GRN item with an LP
            FOR v_grn_item IN
                SELECT gi.*, lp.id as lp_uuid
                FROM grn_items gi
                LEFT JOIN license_plates lp ON lp.id = gi.lp_id
                WHERE gi.grn_id = NEW.id
                  AND gi.lp_id IS NOT NULL
            LOOP
                -- Get active specification for product (if exists)
                SELECT id INTO v_spec_id
                FROM quality_specifications
                WHERE org_id = NEW.org_id
                  AND product_id = v_grn_item.product_id
                  AND status = 'active'
                ORDER BY effective_date DESC
                LIMIT 1;

                -- Generate inspection number
                v_inspection_number := generate_inspection_number(NEW.org_id, 'incoming');

                -- Create inspection record
                INSERT INTO quality_inspections (
                    org_id,
                    inspection_number,
                    inspection_type,
                    reference_type,
                    reference_id,
                    product_id,
                    spec_id,
                    lp_id,
                    grn_id,
                    po_id,
                    batch_number,
                    status,
                    scheduled_date,
                    priority,
                    created_by
                ) VALUES (
                    NEW.org_id,
                    v_inspection_number,
                    'incoming',
                    'grn',
                    NEW.id,
                    v_grn_item.product_id,
                    v_spec_id,
                    v_grn_item.lp_uuid,
                    NEW.id,
                    NEW.po_id,
                    v_grn_item.batch_number,
                    'scheduled',
                    CURRENT_DATE,
                    'normal',
                    NEW.received_by
                );

            END LOOP;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger on grns table (if grns table exists)
-- Note: This trigger should be added after grns table is created in Epic 05
-- CREATE TRIGGER trigger_create_incoming_inspection
--     AFTER UPDATE ON grns
--     FOR EACH ROW
--     EXECUTE FUNCTION create_incoming_inspection_on_grn();

-- =============================================================================
-- Function: Update LP QA status on inspection completion
-- =============================================================================

CREATE OR REPLACE FUNCTION update_lp_qa_status_on_inspection()
RETURNS TRIGGER AS $$
BEGIN
    -- Only trigger on inspection completion
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN

        -- Update LP QA status based on result
        IF NEW.lp_id IS NOT NULL THEN
            UPDATE license_plates
            SET qa_status = CASE NEW.result
                WHEN 'pass' THEN 'passed'
                WHEN 'fail' THEN 'failed'
                WHEN 'conditional' THEN 'conditional'
                ELSE 'pending'
            END,
            updated_at = NOW()
            WHERE id = NEW.lp_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_lp_qa_status
    AFTER UPDATE ON quality_inspections
    FOR EACH ROW
    EXECUTE FUNCTION update_lp_qa_status_on_inspection();
```

---

## Acceptance Criteria (Given/When/Then)

### AC-1: Inspection Table Creation

```gherkin
Scenario: quality_inspections table exists with all required columns
  Given database migration runs
  When schema is inspected
  Then quality_inspections table has all columns from schema
  And UNIQUE constraint exists on (org_id, inspection_number)
  And FK constraints exist for all references
  And RLS policies enforce org isolation
```

### AC-2: Inspection Number Auto-Generation

```gherkin
Scenario: Generate inspection number with type-specific format
  Given organization exists
  When incoming inspection created
  Then inspection_number format is 'INS-INC-2025-00001'
  And next incoming inspection gets 'INS-INC-2025-00002'
  And in_process type uses 'INS-IPR-YYYY-NNNNN'
  And final type uses 'INS-FIN-YYYY-NNNNN'
  And year resets sequence (first 2026 = 'INS-INC-2026-00001')

Scenario: Inspection number uniqueness
  Given inspection 'INS-INC-2025-00001' exists in org A
  When creating another with same number in org A
  Then system returns 409 Conflict error
```

### AC-3: Auto-Create Inspection on GRN Completion

```gherkin
Scenario: Auto-create when setting enabled
  Given quality_settings.auto_create_inspection_on_grn = true
  And GRN with 3 LP items completed
  When GRN status changes to 'completed'
  Then 3 inspection records created (one per LP)
  And each inspection has:
    | Field | Value |
    | inspection_type | incoming |
    | reference_type | grn |
    | reference_id | GRN uuid |
    | status | scheduled |
    | scheduled_date | today |
  And spec_id populated if active spec exists for product

Scenario: No auto-create when setting disabled
  Given quality_settings.auto_create_inspection_on_grn = false
  When GRN completed
  Then no inspection records created

Scenario: Auto-create respects product specification
  Given product has active quality_specification
  When inspection auto-created for product
  Then inspection.spec_id = active specification id

Scenario: Auto-create with no specification
  Given product has no active quality_specification
  When inspection auto-created
  Then inspection.spec_id = NULL
  And inspection still created (spec optional for MVP)
```

### AC-4: Manual Inspection Creation

```gherkin
Scenario: Create inspection manually
  Given user navigates to incoming inspection queue
  And clicks [+ New Inspection]
  When user selects:
    | Field | Value |
    | Product | Flour (SKU-001) |
    | LP | LP00000001 |
    | Specification | QS-202512-001 (optional) |
    | Priority | High |
  And clicks [Create]
  Then inspection created with status = 'scheduled'
  And inspection_number auto-generated
  And success toast "Inspection INS-INC-2025-00001 created"

Scenario: Create inspection from LP detail page
  Given user views LP detail page for LP00000001
  And LP.qa_status = 'pending'
  When user clicks [Create Inspection]
  Then form pre-filled with LP, product, GRN reference
  And user can adjust and submit

Scenario: Validation - LP already has active inspection
  Given LP00000001 has inspection with status = 'scheduled'
  When attempting to create another inspection for same LP
  Then warning "LP already has a pending inspection (INS-INC-2025-00001)"
  And user can choose to proceed or cancel
```

### AC-5: Inspection Queue Display

```gherkin
Scenario: Incoming inspection queue loads
  Given user navigates to Quality > Inspections > Incoming
  When page loads
  Then DataTable displays inspections with columns:
    | Column | Description |
    | Inspection # | Link to detail |
    | LP Number | Link to LP detail |
    | Product | Product name |
    | Batch | Batch number |
    | Status | Badge (scheduled/in_progress/completed) |
    | Priority | Badge with color (urgent=red, high=orange) |
    | Scheduled | Date |
    | Inspector | Assigned user name or "Unassigned" |
    | Actions | Start, Assign, View |
  And list loads within 500ms
  And pagination available (20 per page)

Scenario: Filter by status
  Given inspections exist with various statuses
  When user filters by status = 'scheduled'
  Then only scheduled inspections display
  And URL updates with filter state

Scenario: Filter by priority
  Given inspections with mixed priorities
  When user filters by priority = 'urgent'
  Then only urgent inspections display

Scenario: Search by LP number or product
  Given inspections exist
  When user searches "LP00000001" or "Flour"
  Then matching inspections display
  And search debounced (300ms)

Scenario: Sort by scheduled date
  Given inspections with various dates
  When user sorts by scheduled_date ascending
  Then oldest first displayed
```

### AC-6: Inspector Assignment

```gherkin
Scenario: Assign inspector to scheduled inspection
  Given inspection with status = 'scheduled' and inspector_id = NULL
  When QA Manager clicks [Assign]
  Then modal shows list of users with QA_INSPECTOR or QA_MANAGER role
  And user selects inspector
  And clicks [Assign]
  Then inspection.inspector_id updated
  And inspection.assigned_by = current user
  And inspection.assigned_at = now
  And notification sent to assigned inspector

Scenario: Reassign inspector
  Given inspection assigned to Inspector A
  When QA Manager clicks [Reassign]
  And selects Inspector B
  Then inspector_id updated to Inspector B
  And audit log records reassignment
  And notification sent to new inspector

Scenario: Self-assign
  Given user is QA Inspector viewing unassigned inspection
  When clicking [Assign to Me]
  Then inspector_id set to current user

Scenario: Cannot assign completed inspection
  Given inspection with status = 'completed'
  Then [Assign] button disabled
  And tooltip shows "Cannot reassign completed inspection"
```

### AC-7: Start Inspection Workflow

```gherkin
Scenario: Start inspection
  Given inspection with status = 'scheduled'
  And inspector_id = current user
  When user clicks [Start Inspection]
  Then status changes to 'in_progress'
  And started_at = now
  And user redirected to inspection detail page
  And test results form displayed

Scenario: Start inspection as different user
  Given inspection assigned to Inspector A
  And current user is Inspector B (QA Manager)
  When Inspector B clicks [Start Inspection]
  Then confirmation: "This inspection is assigned to Inspector A. Take over?"
  And if confirmed, inspector_id updated to Inspector B
  And status changes to 'in_progress'

Scenario: Cannot start without inspector
  Given inspection with inspector_id = NULL
  When viewing inspection
  Then [Start] disabled
  And message "Assign inspector before starting"

Scenario: Cannot start already in-progress
  Given inspection with status = 'in_progress'
  Then [Start] button not shown
  And [Continue Inspection] button shown instead
```

### AC-8: Inspection Detail Page

```gherkin
Scenario: View inspection detail
  Given inspection INS-INC-2025-00001 exists
  When user navigates to /quality/inspections/INS-INC-2025-00001
  Then page displays:
    | Section | Content |
    | Header | Inspection #, Status badge, Priority badge |
    | Source | GRN link, PO link, Supplier |
    | Product | Product name, code, LP number with link |
    | Specification | Spec name/version with link (or "No spec") |
    | Batch | Batch number, expiry date |
    | Assignment | Inspector name, assigned date |
    | Timing | Scheduled, Started, Completed dates |
    | Test Results | Grid of parameters and results (from 06.6) |
    | Actions | Based on status and permissions |

Scenario: Inspection without specification
  Given inspection with spec_id = NULL
  When viewing detail page
  Then "No specification linked" message shown
  And [Link Specification] button available
  And manual pass/fail still allowed

Scenario: View inspection with test results
  Given inspection with recorded test results
  When viewing detail page
  Then test results table shows:
    | Column | Content |
    | Parameter | Name from spec_parameters |
    | Spec Min/Max | From spec |
    | Result | Recorded value |
    | Status | Pass/Fail badge |
    | Tested By | User name |
    | Tested At | Timestamp |
```

### AC-9: Complete Inspection - Pass

```gherkin
Scenario: Complete inspection with pass result
  Given inspection in_progress with all tests recorded
  And all test results status = 'pass'
  When user clicks [Complete Inspection]
  Then result determination modal shows:
    | Field | Value |
    | Suggested Result | PASS (all tests passed) |
    | Result Dropdown | Pass / Fail / Conditional |
    | Notes | Optional text field |
  And user confirms with result = 'pass'
  Then inspection.status = 'completed'
  And inspection.result = 'pass'
  And inspection.completed_at = now
  And inspection.completed_by = current user
  And LP.qa_status updated to 'passed'
  And success toast "Inspection completed - PASS"

Scenario: LP status update on pass
  Given inspection.lp_id references LP00000001
  And LP00000001.qa_status = 'pending'
  When inspection completed with result = 'pass'
  Then LP00000001.qa_status = 'passed'
  And LP becomes available for consumption
```

### AC-10: Complete Inspection - Fail

```gherkin
Scenario: Complete inspection with fail result
  Given inspection in_progress
  And some test results status = 'fail'
  When user clicks [Complete Inspection]
  Then suggested result = 'FAIL'
  And user confirms with result = 'fail'
  Then inspection.result = 'fail'
  And LP.qa_status updated to 'failed'
  And prompt: "Create NCR for failed inspection?"
  And if yes, redirect to NCR creation (story 06.9)

Scenario: LP status update on fail
  Given inspection.lp_id references LP00000001
  When inspection completed with result = 'fail'
  Then LP00000001.qa_status = 'failed'
  And LP blocked from consumption
  And LP remains in location but flagged

Scenario: Override suggested result
  Given all test results passed
  But inspector observes defect not in spec
  When completing inspection
  And inspector selects result = 'fail' instead of suggested 'pass'
  And enters result_notes explaining override
  Then inspection.result = 'fail'
  And audit log records override with notes
```

### AC-11: Complete Inspection - Conditional

```gherkin
Scenario: Complete inspection with conditional result
  Given inspection in_progress
  And some tests marginal (near limit)
  When user clicks [Complete Inspection]
  And selects result = 'conditional'
  Then additional fields appear:
    | Field | Required |
    | Conditional Reason | Yes |
    | Usage Restrictions | Yes |
    | Expires At | Optional (date/time) |
    | Approved By | Auto-fill (requires QA Manager) |
  And user fills conditional details
  Then inspection.result = 'conditional'
  And LP.qa_status = 'conditional'
  And LP available with restrictions

Scenario: Conditional requires QA Manager
  Given current user is QA_INSPECTOR (not QA_MANAGER)
  When selecting result = 'conditional'
  Then warning: "Conditional approval requires QA Manager"
  And [Submit for Approval] button shown instead of [Complete]
  And inspection moves to 'pending_approval' status
  And QA Manager notified

Scenario: LP conditional status
  Given inspection completed as conditional
  And conditional_expires_at = 7 days from now
  When LP consumed within 7 days
  Then consumption allowed with warning flag
  When 7 days pass
  Then LP automatically moved to 'pending' for re-inspection
```

### AC-12: Defect Counting

```gherkin
Scenario: Record defect counts
  Given inspection in progress
  When inspector records test results
  And marks 2 major defects, 5 minor defects
  Then inspection.major_defects = 2
  And inspection.minor_defects = 5
  And inspection.defects_found = 7

Scenario: Critical defect auto-fail
  Given quality_settings.auto_fail_on_critical = true
  When inspector records critical_defects > 0
  Then suggested result = 'FAIL' regardless of other tests
  And warning: "Critical defect detected - auto-fail recommended"
```

### AC-13: Cancel Inspection

```gherkin
Scenario: Cancel scheduled inspection
  Given inspection with status = 'scheduled'
  When user clicks [Cancel Inspection]
  And provides cancellation reason
  Then inspection.status = 'cancelled'
  And audit log records cancellation with reason

Scenario: Cannot cancel in-progress inspection
  Given inspection with status = 'in_progress'
  When user attempts to cancel
  Then error: "Cannot cancel in-progress inspection. Complete or reset first."

Scenario: Cannot cancel completed inspection
  Given inspection with status = 'completed'
  Then [Cancel] button not shown
```

### AC-14: Permission Enforcement

```gherkin
Scenario: Viewer can view but not create
  Given user with VIEWER role
  When viewing inspection queue
  Then [+ New Inspection] button hidden
  And can click to view inspection detail
  And [Start], [Complete], [Assign] buttons hidden

Scenario: QA Inspector can inspect
  Given user with QA_INSPECTOR role
  When viewing inspection queue
  Then can create, start, record results, complete (pass/fail)
  And cannot approve conditional without QA_MANAGER

Scenario: QA Manager has full access
  Given user with QA_MANAGER role
  Then all actions available
  And can approve conditional results
  And can reassign inspections
  And can delete scheduled inspections
```

### AC-15: Audit Trail

```gherkin
Scenario: All inspection actions logged
  Given any inspection state change
  When action completes
  Then quality_audit_log entry created with:
    | Field | Value |
    | entity_type | inspection |
    | entity_id | inspection.id |
    | action | create/update/start/complete/cancel/assign |
    | user_id | current user |
    | timestamp | now |
    | old_value | previous state (for updates) |
    | new_value | new state |

Scenario: Result override logged
  Given inspector overrides suggested result
  Then audit log includes:
    | Field | Value |
    | action | result_override |
    | old_value | { suggested_result: 'pass' } |
    | new_value | { actual_result: 'fail', notes: '...' } |
```

### AC-16: RLS Policy Enforcement

```gherkin
Scenario: Org isolation on inspection list
  Given User A from Org A and User B from Org B
  And inspections exist in both orgs
  When User A requests GET /api/quality/inspections
  Then only Org A inspections returned

Scenario: Cannot view inspection from different org
  Given inspection belongs to Org B
  When User A (Org A) requests GET /api/quality/inspections/:id
  Then 404 Not Found returned

Scenario: Inspection inherits org_id from user
  Given User A from Org A creates inspection
  Then inspection.org_id = Org A (automatic)
```

### AC-17: Performance Requirements

```gherkin
Scenario: Inspection queue performance
  Given 1000 inspections in organization
  When listing incoming inspections with pagination
  Then response time < 500ms

Scenario: Inspection detail performance
  Given inspection with 50 test results
  When loading inspection detail page
  Then response time < 500ms

Scenario: Inspection creation performance
  Given valid inspection data
  When creating inspection
  Then operation completes < 300ms
```

---

## Implementation Notes

### API Endpoints

```typescript
// =============================================================================
// Inspection Endpoints
// =============================================================================

// GET /api/quality/inspections
// List inspections with filters
interface InspectionsListParams {
  inspection_type?: 'incoming' | 'in_process' | 'final';
  status?: 'scheduled' | 'in_progress' | 'completed' | 'cancelled';
  priority?: 'low' | 'normal' | 'high' | 'urgent';
  inspector_id?: string;
  product_id?: string;
  lp_id?: string;
  grn_id?: string;
  po_id?: string;
  date_from?: string;
  date_to?: string;
  search?: string;
  sort_by?: 'inspection_number' | 'scheduled_date' | 'created_at' | 'priority';
  sort_order?: 'asc' | 'desc';
  page?: number;
  limit?: number;
}

interface InspectionsListResponse {
  inspections: QualityInspection[];
  pagination: {
    total: number;
    page: number;
    limit: number;
    pages: number;
  };
}

interface QualityInspection {
  id: string;
  org_id: string;
  inspection_number: string;
  inspection_type: 'incoming' | 'in_process' | 'final';
  reference_type: string;
  reference_id: string;

  // Product info
  product_id: string;
  product_code: string;
  product_name: string;

  // Specification
  spec_id?: string;
  spec_number?: string;
  spec_name?: string;

  // LP info
  lp_id?: string;
  lp_number?: string;

  // GRN/PO info
  grn_id?: string;
  grn_number?: string;
  po_id?: string;
  po_number?: string;
  supplier_name?: string;

  // Batch
  batch_number?: string;
  lot_size?: number;
  sample_size?: number;

  // Assignment
  inspector_id?: string;
  inspector_name?: string;
  assigned_by?: string;
  assigned_at?: string;

  // Status
  status: 'scheduled' | 'in_progress' | 'completed' | 'cancelled';
  priority: 'low' | 'normal' | 'high' | 'urgent';

  // Timing
  scheduled_date?: string;
  started_at?: string;
  completed_at?: string;

  // Result
  result?: 'pass' | 'fail' | 'conditional';
  result_notes?: string;
  defects_found: number;
  major_defects: number;
  minor_defects: number;
  critical_defects: number;

  // Conditional
  conditional_reason?: string;
  conditional_restrictions?: string;
  conditional_expires_at?: string;

  // Audit
  created_at: string;
  created_by: string;
  updated_at: string;
}

// GET /api/quality/inspections/:id
interface InspectionDetailResponse {
  inspection: QualityInspection;
  test_results: TestResult[]; // From story 06.6
  test_result_summary: {
    total_parameters: number;
    tested_count: number;
    passed_count: number;
    failed_count: number;
    marginal_count: number;
    untested_count: number;
  };
  can_complete: boolean;
  suggested_result: 'pass' | 'fail' | 'conditional' | null;
}

// POST /api/quality/inspections
interface CreateInspectionRequest {
  product_id: string;
  lp_id?: string;
  grn_id?: string;
  po_id?: string;
  spec_id?: string;
  batch_number?: string;
  lot_size?: number;
  priority?: 'low' | 'normal' | 'high' | 'urgent';
  scheduled_date?: string;
  inspector_id?: string;
  notes?: string;
}

interface CreateInspectionResponse {
  inspection: QualityInspection;
}

// POST /api/quality/inspections/:id/assign
interface AssignInspectionRequest {
  inspector_id: string;
}

// POST /api/quality/inspections/:id/start
interface StartInspectionRequest {
  take_over?: boolean; // If assigned to different user
}

interface StartInspectionResponse {
  inspection: QualityInspection;
}

// POST /api/quality/inspections/:id/complete
interface CompleteInspectionRequest {
  result: 'pass' | 'fail' | 'conditional';
  result_notes?: string;
  defects_found?: number;
  major_defects?: number;
  minor_defects?: number;
  critical_defects?: number;

  // For conditional result
  conditional_reason?: string;
  conditional_restrictions?: string;
  conditional_expires_at?: string;

  // For failed result
  create_ncr?: boolean;
}

interface CompleteInspectionResponse {
  inspection: QualityInspection;
  lp_status_updated: boolean;
  ncr_id?: string; // If NCR created
}

// POST /api/quality/inspections/:id/cancel
interface CancelInspectionRequest {
  cancellation_reason: string;
}

// GET /api/quality/inspections/pending
// Shortcut for status IN ('scheduled', 'in_progress')
interface PendingInspectionsResponse {
  inspections: QualityInspection[];
  counts: {
    scheduled: number;
    in_progress: number;
    total: number;
  };
}

// GET /api/quality/inspections/incoming
// Shortcut for inspection_type = 'incoming'
// Same response format as list
```

### Validation Schemas (Zod)

```typescript
import { z } from 'zod';

export const inspectionTypeEnum = z.enum(['incoming', 'in_process', 'final']);
export const inspectionStatusEnum = z.enum(['scheduled', 'in_progress', 'completed', 'cancelled']);
export const inspectionPriorityEnum = z.enum(['low', 'normal', 'high', 'urgent']);
export const inspectionResultEnum = z.enum(['pass', 'fail', 'conditional']);

export const createInspectionSchema = z.object({
  product_id: z.string().uuid('Invalid product ID'),
  lp_id: z.string().uuid('Invalid LP ID').optional(),
  grn_id: z.string().uuid('Invalid GRN ID').optional(),
  po_id: z.string().uuid('Invalid PO ID').optional(),
  spec_id: z.string().uuid('Invalid specification ID').optional(),
  batch_number: z.string().max(100).optional(),
  lot_size: z.number().int().positive().optional(),
  priority: inspectionPriorityEnum.default('normal'),
  scheduled_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  inspector_id: z.string().uuid().optional(),
  notes: z.string().max(2000).optional(),
}).refine(
  (data) => data.lp_id || data.grn_id || data.po_id,
  { message: 'At least one reference (LP, GRN, or PO) is required' }
);

export const assignInspectionSchema = z.object({
  inspector_id: z.string().uuid('Invalid inspector ID'),
});

export const startInspectionSchema = z.object({
  take_over: z.boolean().default(false),
});

export const completeInspectionSchema = z.object({
  result: inspectionResultEnum,
  result_notes: z.string().max(2000).optional(),
  defects_found: z.number().int().min(0).default(0),
  major_defects: z.number().int().min(0).default(0),
  minor_defects: z.number().int().min(0).default(0),
  critical_defects: z.number().int().min(0).default(0),

  // Conditional fields
  conditional_reason: z.string().max(500).optional(),
  conditional_restrictions: z.string().max(1000).optional(),
  conditional_expires_at: z.string().datetime().optional(),

  // NCR creation
  create_ncr: z.boolean().default(false),
}).refine(
  (data) => {
    if (data.result === 'conditional') {
      return data.conditional_reason && data.conditional_restrictions;
    }
    return true;
  },
  {
    message: 'Conditional reason and restrictions required for conditional result',
    path: ['conditional_reason'],
  }
);

export const cancelInspectionSchema = z.object({
  cancellation_reason: z.string().min(10, 'Reason must be at least 10 characters').max(500),
});

export const inspectionListQuerySchema = z.object({
  inspection_type: inspectionTypeEnum.optional(),
  status: inspectionStatusEnum.optional(),
  priority: inspectionPriorityEnum.optional(),
  inspector_id: z.string().uuid().optional(),
  product_id: z.string().uuid().optional(),
  lp_id: z.string().uuid().optional(),
  grn_id: z.string().uuid().optional(),
  po_id: z.string().uuid().optional(),
  date_from: z.string().optional(),
  date_to: z.string().optional(),
  search: z.string().min(1).optional(),
  sort_by: z.enum(['inspection_number', 'scheduled_date', 'created_at', 'priority']).default('scheduled_date'),
  sort_order: z.enum(['asc', 'desc']).default('desc'),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
});
```

### Service Layer

```typescript
// lib/services/inspection-service.ts

export class InspectionService {
  // ==========================================================================
  // CRUD Operations
  // ==========================================================================

  /**
   * List inspections with filtering and pagination
   */
  static async list(params: InspectionListParams): Promise<PaginatedResult<QualityInspection>>;

  /**
   * Get inspection by ID with test results
   */
  static async getById(id: string): Promise<InspectionDetail | null>;

  /**
   * Get inspection by number
   */
  static async getByNumber(inspectionNumber: string): Promise<QualityInspection | null>;

  /**
   * Create new inspection
   */
  static async create(input: CreateInspectionInput): Promise<QualityInspection>;

  /**
   * Update inspection (draft/scheduled only)
   */
  static async update(id: string, input: UpdateInspectionInput): Promise<QualityInspection>;

  // ==========================================================================
  // Workflow Operations
  // ==========================================================================

  /**
   * Assign inspector to inspection
   */
  static async assign(
    id: string,
    inspectorId: string,
    assignedBy: string
  ): Promise<QualityInspection>;

  /**
   * Start inspection (scheduled -> in_progress)
   */
  static async start(id: string, userId: string, takeOver?: boolean): Promise<QualityInspection>;

  /**
   * Complete inspection with result
   * Updates LP QA status automatically
   */
  static async complete(
    id: string,
    input: CompleteInspectionInput,
    userId: string
  ): Promise<{ inspection: QualityInspection; ncrId?: string }>;

  /**
   * Cancel inspection (scheduled only)
   */
  static async cancel(id: string, reason: string, userId: string): Promise<QualityInspection>;

  // ==========================================================================
  // Result Determination
  // ==========================================================================

  /**
   * Calculate suggested result based on test results
   */
  static async getSuggestedResult(inspectionId: string): Promise<{
    suggested: 'pass' | 'fail' | 'conditional';
    reason: string;
    testSummary: TestResultSummary;
  }>;

  /**
   * Check if inspection can be completed
   * (all required tests recorded)
   */
  static async canComplete(inspectionId: string): Promise<{
    canComplete: boolean;
    missingTests: string[];
    untestedCritical: string[];
  }>;

  // ==========================================================================
  // LP Integration
  // ==========================================================================

  /**
   * Update LP QA status based on inspection result
   */
  static async updateLPStatus(
    lpId: string,
    result: 'pass' | 'fail' | 'conditional'
  ): Promise<void>;

  // ==========================================================================
  // Queue Operations
  // ==========================================================================

  /**
   * Get pending inspections (scheduled + in_progress)
   */
  static async getPendingInspections(type?: string): Promise<{
    inspections: QualityInspection[];
    counts: { scheduled: number; in_progress: number };
  }>;

  /**
   * Get inspections for inspector's work queue
   */
  static async getMyInspections(userId: string): Promise<QualityInspection[]>;

  // ==========================================================================
  // Auto-Creation
  // ==========================================================================

  /**
   * Create inspections for GRN completion
   * Called by GRN service or trigger
   */
  static async createForGRN(grnId: string, userId: string): Promise<QualityInspection[]>;

  // ==========================================================================
  // Utility
  // ==========================================================================

  /**
   * Generate next inspection number
   */
  static async generateInspectionNumber(type: string): Promise<string>;

  /**
   * Check if LP has pending inspection
   */
  static async hasActiveInspection(lpId: string): Promise<{
    has: boolean;
    inspectionId?: string;
    inspectionNumber?: string;
  }>;
}
```

### Frontend Components

```
apps/frontend/app/(authenticated)/quality/
  inspections/
    page.tsx                       -- Inspections list (all types)
    incoming/
      page.tsx                     -- Incoming inspection queue
    [id]/
      page.tsx                     -- Inspection detail
    new/
      page.tsx                     -- Create inspection form

components/quality/inspections/
  InspectionDataTable.tsx          -- DataTable with filters
  InspectionFilters.tsx            -- Filter panel (status, priority, date)
  InspectionStatusBadge.tsx        -- Status badge component
  InspectionPriorityBadge.tsx      -- Priority badge (color-coded)
  InspectionResultBadge.tsx        -- Result badge (pass/fail/conditional)
  InspectionDetail.tsx             -- Detail view container
  InspectionHeader.tsx             -- Header with status, actions
  InspectionSourceInfo.tsx         -- GRN, PO, Supplier info
  InspectionProductInfo.tsx        -- Product, LP, Batch info
  InspectionTestResults.tsx        -- Test results grid (uses 06.6 components)
  InspectionTimeline.tsx           -- Timeline of status changes
  InspectionActions.tsx            -- Action buttons based on status
  AssignInspectorModal.tsx         -- Inspector assignment modal
  StartInspectionDialog.tsx        -- Confirmation for starting
  CompleteInspectionModal.tsx      -- Complete with result selection
  ConditionalDetailsForm.tsx       -- Conditional approval fields
  CancelInspectionDialog.tsx       -- Cancellation with reason
  CreateInspectionForm.tsx         -- Manual creation form
  InspectionSummaryCard.tsx        -- Summary card for dashboard
  PendingInspectionsBadge.tsx      -- Badge showing pending count
```

### UI Component Details

**InspectionDataTable.tsx**
- ShadCN DataTable pattern
- Columns: Inspection #, LP, Product, Batch, Status, Priority, Scheduled, Inspector, Actions
- Row click navigates to detail
- Inline actions: Start, Assign, View
- Multi-select for bulk actions (future)
- Priority badge colors: urgent=red, high=orange, normal=blue, low=gray
- Status badge colors: scheduled=yellow, in_progress=blue, completed=green, cancelled=gray

**InspectionDetail.tsx**
- Three-column layout on desktop
- Left: Header, Status, Actions
- Center: Product info, Test Results grid
- Right: Source info, Timeline, Assignment
- Responsive: stacks on mobile

**CompleteInspectionModal.tsx**
- Shows test result summary at top
- Suggested result with explanation
- Result selector (pass/fail/conditional)
- Notes field (optional for pass, recommended for fail)
- Conditional fields appear when conditional selected
- Defect counts input
- Confirm button with loading state
- NCR creation checkbox for failures

---

## Key Business Rules

1. **Inspection Required for QA Release**: LP with qa_status='pending' cannot be consumed in production until inspection completed with pass/conditional
2. **One Active Inspection per LP**: Prevent duplicate inspections for same LP (warn but allow override)
3. **Inspector Assignment Required**: Cannot start inspection without assigned inspector
4. **Specification Optional in MVP**: Inspection can complete without linked specification (manual pass/fail)
5. **Auto-Fail on Critical Defect**: If quality_settings.auto_fail_on_critical=true, any critical defect = automatic fail suggestion
6. **Conditional Requires Manager**: Conditional approval requires QA_MANAGER role
7. **LP Status Update Automatic**: Completing inspection automatically updates LP.qa_status
8. **Audit Trail Required**: All status changes, assignments, and results logged
9. **Cancel Only Scheduled**: Only scheduled inspections can be cancelled; in_progress must complete or reset
10. **Priority Escalation**: Urgent inspections should be completed within 4 hours (configurable)

---

## Deliverables

### Database
- [ ] Migration: `quality_inspections` table with all columns
- [ ] Migration: `inspection_number_sequences` table
- [ ] Function: `generate_inspection_number(org_id, type)`
- [ ] Function: `create_incoming_inspection_on_grn()` trigger function
- [ ] Function: `update_lp_qa_status_on_inspection()` trigger
- [ ] RLS policies for quality_inspections
- [ ] All performance indexes

### API Routes
- [ ] `GET /api/quality/inspections` - List with filters
- [ ] `GET /api/quality/inspections/:id` - Get detail with test results
- [ ] `POST /api/quality/inspections` - Create inspection
- [ ] `PUT /api/quality/inspections/:id` - Update scheduled inspection
- [ ] `DELETE /api/quality/inspections/:id` - Delete scheduled inspection
- [ ] `POST /api/quality/inspections/:id/assign` - Assign inspector
- [ ] `POST /api/quality/inspections/:id/start` - Start inspection
- [ ] `POST /api/quality/inspections/:id/complete` - Complete with result
- [ ] `POST /api/quality/inspections/:id/cancel` - Cancel inspection
- [ ] `GET /api/quality/inspections/pending` - Pending queue
- [ ] `GET /api/quality/inspections/incoming` - Incoming queue

### Service Layer
- [ ] `InspectionService.list()` - List with pagination
- [ ] `InspectionService.getById()` - Get with test results
- [ ] `InspectionService.create()` - Create inspection
- [ ] `InspectionService.assign()` - Assign inspector
- [ ] `InspectionService.start()` - Start workflow
- [ ] `InspectionService.complete()` - Complete with LP update
- [ ] `InspectionService.cancel()` - Cancel inspection
- [ ] `InspectionService.getSuggestedResult()` - Result determination
- [ ] `InspectionService.canComplete()` - Completion validation
- [ ] `InspectionService.updateLPStatus()` - LP QA status update
- [ ] `InspectionService.createForGRN()` - Auto-creation
- [ ] `InspectionService.generateInspectionNumber()` - Number generation

### Validation
- [ ] `createInspectionSchema`
- [ ] `assignInspectionSchema`
- [ ] `startInspectionSchema`
- [ ] `completeInspectionSchema`
- [ ] `cancelInspectionSchema`
- [ ] `inspectionListQuerySchema`

### Frontend
- [ ] Incoming inspection queue page
- [ ] Inspection detail page
- [ ] Create inspection form
- [ ] Assign inspector modal
- [ ] Start inspection confirmation
- [ ] Complete inspection modal with result
- [ ] Conditional details form
- [ ] Cancel inspection dialog
- [ ] Status, priority, result badges
- [ ] Filter panel
- [ ] Search functionality

### Tests
- [ ] Unit tests: InspectionService methods (>80% coverage)
- [ ] Integration tests: All API endpoints
- [ ] LP status update tests
- [ ] Auto-creation trigger tests
- [ ] RLS tests: Multi-tenancy isolation
- [ ] E2E: Full inspection workflow (create -> assign -> start -> complete)

---

## Test Strategy

### Unit Tests

```typescript
describe('InspectionService', () => {
  describe('create', () => {
    it('creates inspection with correct fields', async () => {});
    it('generates inspection number', async () => {});
    it('validates LP exists', async () => {});
    it('warns if LP has active inspection', async () => {});
    it('links specification if found for product', async () => {});
  });

  describe('assign', () => {
    it('assigns inspector to scheduled inspection', async () => {});
    it('allows reassignment', async () => {});
    it('blocks assignment of completed inspection', async () => {});
    it('creates audit log entry', async () => {});
  });

  describe('start', () => {
    it('changes status to in_progress', async () => {});
    it('sets started_at timestamp', async () => {});
    it('requires inspector assignment', async () => {});
    it('allows take over by different user', async () => {});
  });

  describe('complete', () => {
    it('sets result and completed fields', async () => {});
    it('updates LP QA status on pass', async () => {});
    it('updates LP QA status on fail', async () => {});
    it('handles conditional result', async () => {});
    it('creates NCR if requested', async () => {});
    it('validates conditional fields', async () => {});
  });

  describe('getSuggestedResult', () => {
    it('suggests pass when all tests pass', async () => {});
    it('suggests fail when any test fails', async () => {});
    it('suggests fail on critical defect', async () => {});
    it('returns test summary', async () => {});
  });

  describe('updateLPStatus', () => {
    it('sets LP.qa_status to passed on pass', async () => {});
    it('sets LP.qa_status to failed on fail', async () => {});
    it('sets LP.qa_status to conditional on conditional', async () => {});
  });

  describe('generateInspectionNumber', () => {
    it('generates INS-INC-YYYY-NNNNN format', async () => {});
    it('increments sequence', async () => {});
    it('resets per year', async () => {});
    it('uses correct prefix per type', async () => {});
  });
});
```

### Integration Tests

```typescript
describe('Inspections API', () => {
  describe('POST /api/quality/inspections', () => {
    it('creates inspection with valid data', async () => {});
    it('returns 400 for missing reference', async () => {});
    it('returns 400 for invalid product', async () => {});
    it('enforces org_id from auth', async () => {});
  });

  describe('POST /api/quality/inspections/:id/complete', () => {
    it('completes with pass result', async () => {});
    it('updates LP QA status', async () => {});
    it('requires conditional fields for conditional', async () => {});
    it('creates NCR on request', async () => {});
    it('returns 403 for unauthorized user', async () => {});
  });

  describe('GET /api/quality/inspections/incoming', () => {
    it('returns only incoming type', async () => {});
    it('respects RLS for org isolation', async () => {});
    it('paginates correctly', async () => {});
    it('filters by status', async () => {});
  });
});
```

### E2E Tests

```typescript
describe('Incoming Inspection Workflow', () => {
  it('complete workflow: create -> assign -> start -> record results -> complete', async () => {
    // 1. Navigate to incoming queue
    // 2. Create new inspection for LP
    // 3. Verify inspection appears in queue
    // 4. Assign inspector
    // 5. Start inspection
    // 6. Record test results (story 06.6)
    // 7. Complete with pass result
    // 8. Verify LP QA status updated
    // 9. Verify inspection in completed list
  });

  it('fail inspection and verify LP blocked', async () => {
    // 1. Create and start inspection
    // 2. Record failing test result
    // 3. Complete with fail
    // 4. Verify LP.qa_status = failed
    // 5. Verify LP cannot be consumed
  });

  it('conditional approval workflow', async () => {
    // 1. Complete with conditional
    // 2. Verify requires QA Manager
    // 3. Fill conditional details
    // 4. Verify LP.qa_status = conditional
  });
});
```

---

## Definition of Done

### Database
- [ ] `quality_inspections` table created with all columns
- [ ] `inspection_number_sequences` table created
- [ ] All indexes created for performance
- [ ] RLS policies enforce org isolation
- [ ] Trigger for LP QA status update works
- [ ] Inspection number generation works correctly

### API
- [ ] All endpoints return correct HTTP status codes
- [ ] Validation errors return 400 with detailed messages
- [ ] Cross-tenant access returns 404
- [ ] Response times:
  - Inspection list: < 500ms
  - Inspection detail: < 500ms
  - Create/Update: < 300ms
  - Complete with LP update: < 500ms

### Service
- [ ] Complete workflow: create -> assign -> start -> complete
- [ ] LP QA status updated automatically on completion
- [ ] Result determination logic works correctly
- [ ] Audit trail created for all actions
- [ ] Permission checks enforced

### Frontend
- [ ] Incoming inspection queue displays correctly
- [ ] Inspection detail page shows all information
- [ ] Assignment modal works
- [ ] Start inspection confirmation works
- [ ] Complete inspection modal with result selection
- [ ] Conditional fields appear when needed
- [ ] Status/priority/result badges display correctly
- [ ] Filters and search work
- [ ] Pagination works

### Testing
- [ ] Unit tests: >80% coverage on service
- [ ] Integration tests: All endpoints covered
- [ ] LP status update tests passing
- [ ] RLS tests: Multi-tenancy verified
- [ ] E2E tests: Full workflow passing

### Integration
- [ ] Works with story 06.3 (Specifications)
- [ ] Works with story 06.4 (Test Parameters)
- [ ] Works with story 06.6 (Test Results Recording)
- [ ] Works with Epic 05 LP service

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| LP status update race condition | HIGH | LOW | Database transaction, optimistic locking |
| Auto-create trigger complexity | MEDIUM | MEDIUM | Thorough trigger testing, fallback to manual |
| Test results integration | HIGH | LOW | Clear interface with story 06.6 |
| Permission complexity | MEDIUM | MEDIUM | Clear role definitions, comprehensive tests |
| Performance with many inspections | MEDIUM | LOW | Proper indexes, pagination |
| Conditional approval workflow | MEDIUM | MEDIUM | Clear UX flow, role checks |

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-12-16 | Initial story creation with comprehensive inspection workflow | OPUS |

---

**Document Status**: Ready for Implementation
**Created**: 2025-12-16
**Lines**: ~1200
**Complexity**: L (Large)
**Phase**: 1B (Core Quality)
