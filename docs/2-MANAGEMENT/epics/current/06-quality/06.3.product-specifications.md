# 06.3 - Product Specifications

**Priority**: P0 (MVP)
**Story Points**: M (Medium)
**Type**: backend + frontend
**Phase**: 1A (Core Quality)

**State:** ready
**Estimate:** M (medium story)
**Primary PRD:** `docs/1-BASELINE/product/modules/quality.md` (FR-QA-003)
**Architecture:** `docs/1-BASELINE/architecture/modules/quality.md` (quality_specifications table)

## Goal

Implement versioned product quality specifications with approval workflow and active spec resolution. This enables QA teams to define test parameters and acceptance criteria per product, with proper version control and regulatory audit trail.

## MVP Scope

This story implements Phase 1A (Core Quality) functionality. Features listed in "Future Phases" are deferred.

**MVP Includes**:
- Quality specifications CRUD (create, read, update)
- Version control (effective_date, expiry_date)
- Status workflow (draft -> active -> expired/superseded)
- Approval workflow with approver tracking
- Active specification resolution logic
- Review frequency configuration
- Spec superseding when new version approved
- Basic spec cloning for new versions

**Deferred to Phase 2+**: See "Future Phases" section below.

## Scope

**In scope**
- `quality_specifications` table with RLS
- GET /api/quality/specifications (list with filters)
- GET /api/quality/specifications/:id (detail)
- POST /api/quality/specifications (create draft)
- PUT /api/quality/specifications/:id (update draft)
- POST /api/quality/specifications/:id/approve (approve and activate)
- POST /api/quality/specifications/:id/clone (create new version)
- GET /api/quality/specifications/product/:productId (specs for product)
- GET /api/quality/specifications/product/:productId/active (resolve active spec)
- Specifications list page with filters
- Specification detail/edit page
- Approval workflow UI
- Version history display
- Review date tracking and alerts

**Out of scope (this story)**
- Test parameters (story 06.4)
- Spec-parameter linking (story 06.4)
- Document attachments (Phase 2)
- Digital signatures (Phase 3)

## Future Phases (Not in MVP)

### Phase 2
- **Document attachments** - PDF/image attachments to specifications
- **Specification comparison** - Side-by-side version comparison
- **Specification templates** - Reusable spec templates by product category
- **Bulk specification updates** - Update multiple specs at once
- **Specification import/export** - CSV/Excel import/export

### Phase 3
- **Digital signatures** - E-signature for approvals (FDA 21 CFR Part 11)
- **Multi-level approval** - Sequential approval workflows
- **Change control** - Formal change request process
- **Specification audit reports** - Compliance reporting

### Deferred to Other Stories
- **Test parameters** - Story 06.4 (Test Parameters)
- **Inspection linkage** - Story 06.5 (Incoming Inspection)
- **Document control** - Story 06.40 (Document Control)

## Dependencies

### Cross-Epic Dependencies
- **01.1** - Org Context + Base RLS (organizations, users tables)
- **02.1** - Products CRUD (products table must exist)

### Within Epic Dependencies
- **06.0** - Quality Settings (quality_settings table for defaults)

### Provides To (Downstream)
- **06.4** - Test Parameters (spec_id reference)
- **06.5** - Incoming Inspection (spec_id for inspection)
- **06.6** - Test Results Recording (spec parameters)
- **06.10/06.11** - In-Process/Final Inspection (spec reference)
- **06.27** - CoA Templates (spec parameters)

## Database Migration

### Migration: Create quality_specifications table

```sql
-- Migration: YYYYMMDDHHMMSS_create_quality_specifications.sql

CREATE TABLE quality_specifications (
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id                  UUID NOT NULL REFERENCES organizations(id),
    product_id              UUID NOT NULL REFERENCES products(id),
    spec_number             TEXT NOT NULL,
    version                 INTEGER NOT NULL DEFAULT 1,
    name                    TEXT NOT NULL,
    description             TEXT,
    effective_date          DATE NOT NULL,
    expiry_date             DATE,
    status                  TEXT NOT NULL DEFAULT 'draft'
                            CHECK (status IN ('draft', 'active', 'expired', 'superseded')),
    approved_by             UUID REFERENCES users(id),
    approved_at             TIMESTAMPTZ,
    superseded_by           UUID REFERENCES quality_specifications(id),
    superseded_at           TIMESTAMPTZ,
    review_frequency_days   INTEGER DEFAULT 365,
    next_review_date        DATE,
    last_review_date        DATE,
    notes                   TEXT,
    created_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by              UUID REFERENCES users(id),
    updated_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by              UUID REFERENCES users(id),

    CONSTRAINT uq_spec_number_version UNIQUE (org_id, spec_number, version)
);

-- Indexes for performance
CREATE INDEX idx_quality_specs_org_id ON quality_specifications(org_id);
CREATE INDEX idx_quality_specs_product ON quality_specifications(product_id);
CREATE INDEX idx_quality_specs_status ON quality_specifications(org_id, status);
CREATE INDEX idx_quality_specs_effective ON quality_specifications(org_id, effective_date, expiry_date);
CREATE INDEX idx_quality_specs_review ON quality_specifications(org_id, next_review_date)
    WHERE status = 'active';
CREATE INDEX idx_quality_specs_number ON quality_specifications(org_id, spec_number);

-- RLS Policies
ALTER TABLE quality_specifications ENABLE ROW LEVEL SECURITY;

CREATE POLICY "quality_specifications_select" ON quality_specifications
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "quality_specifications_insert" ON quality_specifications
    FOR INSERT WITH CHECK (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "quality_specifications_update" ON quality_specifications
    FOR UPDATE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "quality_specifications_delete" ON quality_specifications
    FOR DELETE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
        AND status = 'draft'  -- Only draft specs can be deleted
    );

-- Trigger for updated_at
CREATE TRIGGER update_quality_specifications_updated_at
    BEFORE UPDATE ON quality_specifications
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Function to resolve active specification for a product
CREATE OR REPLACE FUNCTION get_active_specification(p_org_id UUID, p_product_id UUID, p_as_of_date DATE DEFAULT CURRENT_DATE)
RETURNS UUID AS $$
DECLARE
    v_spec_id UUID;
BEGIN
    SELECT id INTO v_spec_id
    FROM quality_specifications
    WHERE org_id = p_org_id
      AND product_id = p_product_id
      AND status = 'active'
      AND effective_date <= p_as_of_date
      AND (expiry_date IS NULL OR expiry_date >= p_as_of_date)
    ORDER BY effective_date DESC, version DESC
    LIMIT 1;

    RETURN v_spec_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to supersede specification when new version activated
CREATE OR REPLACE FUNCTION supersede_previous_spec()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status = 'active' AND (OLD.status IS NULL OR OLD.status != 'active') THEN
        -- Supersede any other active specs for this product
        UPDATE quality_specifications
        SET status = 'superseded',
            superseded_by = NEW.id,
            superseded_at = now(),
            updated_at = now()
        WHERE org_id = NEW.org_id
          AND product_id = NEW.product_id
          AND status = 'active'
          AND id != NEW.id;

        -- Calculate next review date
        IF NEW.review_frequency_days IS NOT NULL THEN
            NEW.next_review_date := NEW.effective_date + (NEW.review_frequency_days || ' days')::INTERVAL;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_supersede_spec
    BEFORE UPDATE ON quality_specifications
    FOR EACH ROW
    EXECUTE FUNCTION supersede_previous_spec();
```

## Acceptance Criteria (Given/When/Then)

### Specification List Display

- **GIVEN** user navigates to Quality > Specifications page
- **WHEN** page loads
- **THEN** specifications list displays within 500ms showing spec_number, name, product, version, status, effective_date, and next_review_date
- **AND** list is paginated (20 per page) and sortable by any column

- **GIVEN** user applies filter for status = 'active'
- **WHEN** filter applied
- **THEN** only active specifications display
- **AND** URL reflects filter state for bookmarking

- **GIVEN** user searches for spec by product name or spec number
- **WHEN** search term entered
- **THEN** results filter in real-time (debounced 300ms)

### Create Specification (Draft)

- **GIVEN** user clicks [+ New Specification]
- **WHEN** create form displays
- **THEN** form shows: Product (dropdown), Spec Number (auto-generated), Name, Description, Effective Date, Review Frequency

- **GIVEN** user fills required fields (Product, Name, Effective Date)
- **WHEN** [Save Draft] clicked
- **THEN** specification created with status='draft', version=1
- **AND** user redirected to specification detail page
- **AND** success toast "Specification QS-001 created as draft"

- **GIVEN** spec_number auto-generation
- **WHEN** new spec created for product
- **THEN** spec_number format is "QS-{YYYYMM}-{SEQ}" (e.g., QS-202512-001)
- **AND** sequence is org-scoped and increments

- **GIVEN** duplicate spec_number + version combination
- **WHEN** attempting to save
- **THEN** validation error "Specification number and version already exists"

### Edit Specification (Draft Only)

- **GIVEN** user opens draft specification
- **WHEN** detail page loads
- **THEN** all fields are editable
- **AND** [Edit], [Approve], [Delete] buttons visible

- **GIVEN** user opens active/expired/superseded specification
- **WHEN** detail page loads
- **THEN** all fields are read-only
- **AND** only [Clone as New Version] button visible

- **GIVEN** user edits draft spec and clicks [Save]
- **WHEN** save completes
- **THEN** updated_at and updated_by are set
- **AND** success toast "Specification updated"

### Approve Specification

- **GIVEN** user with QA_MANAGER role views draft specification
- **WHEN** [Approve] button clicked
- **THEN** confirmation modal displays: "Approving will activate this specification and supersede any existing active specs for {product_name}. Continue?"

- **GIVEN** user confirms approval
- **WHEN** approval processes
- **THEN** status changes to 'active'
- **AND** approved_by set to current user
- **AND** approved_at set to now()
- **AND** next_review_date calculated from effective_date + review_frequency_days
- **AND** any previous active specs for same product marked as 'superseded'

- **GIVEN** user without QA_MANAGER role
- **WHEN** viewing draft specification
- **THEN** [Approve] button is hidden
- **AND** API returns 403 if attempted

- **GIVEN** spec approved with effective_date in future
- **WHEN** approval completes
- **THEN** status is 'active' immediately (effective_date is informational)
- **AND** previous active spec superseded

### Version Control

- **GIVEN** user views active specification
- **WHEN** [Clone as New Version] clicked
- **THEN** new draft created with:
  - Same spec_number
  - version = previous_version + 1
  - status = 'draft'
  - Copy of name, description, review_frequency_days
  - effective_date = today
  - approved_by/approved_at cleared

- **GIVEN** specification has multiple versions
- **WHEN** version history section displays
- **THEN** all versions listed with version number, status, effective_date, approved_by
- **AND** user can click to view any version

- **GIVEN** spec version 1 is active, version 2 draft exists
- **WHEN** version 2 approved
- **THEN** version 1 status = 'superseded', superseded_by = version 2 id

### Active Specification Resolution

- **GIVEN** product has multiple specification versions (v1 superseded, v2 active, v3 draft)
- **WHEN** GET /api/quality/specifications/product/:productId/active called
- **THEN** returns v2 (the active spec)
- **AND** response includes version history summary

- **GIVEN** product has active spec with expiry_date in the past
- **WHEN** active spec resolution runs
- **THEN** spec with expired expiry_date is NOT returned
- **AND** status should be marked as 'expired' (via scheduled job or trigger)

- **GIVEN** product has no active specification
- **WHEN** GET /api/quality/specifications/product/:productId/active called
- **THEN** returns 404 with message "No active specification found for this product"

### Review Date Management

- **GIVEN** active specification with next_review_date approaching (within 30 days)
- **WHEN** specifications list loads
- **THEN** row displays warning indicator (yellow badge)
- **AND** hovering shows "Review due in X days"

- **GIVEN** active specification with next_review_date passed
- **WHEN** specifications list loads
- **THEN** row displays critical indicator (red badge)
- **AND** hovering shows "Review overdue by X days"

- **GIVEN** user updates review_frequency_days on active spec
- **WHEN** spec is a draft being edited
- **THEN** field is editable and next_review_date recalculates on approval

- **GIVEN** spec is due for review
- **WHEN** user clicks [Complete Review]
- **THEN** last_review_date set to today
- **AND** next_review_date recalculated from today + review_frequency_days
- **AND** audit log entry created

### Expiry Date Handling

- **GIVEN** specification with expiry_date set
- **WHEN** expiry_date passes
- **THEN** scheduled job marks status as 'expired'
- **AND** spec no longer returned in active resolution

- **GIVEN** user creating specification
- **WHEN** expiry_date field populated
- **THEN** validation ensures expiry_date > effective_date
- **AND** expiry_date is optional (null = no expiry)

### Permission Enforcement

- **GIVEN** user with VIEWER role
- **WHEN** accessing specifications list
- **THEN** list displays (read access)
- **AND** [+ New Specification] button hidden

- **GIVEN** user with QA_INSPECTOR role
- **WHEN** accessing specifications
- **THEN** can create/edit draft specs
- **AND** cannot approve specs (requires QA_MANAGER)

- **GIVEN** user with QA_MANAGER role
- **WHEN** accessing specifications
- **THEN** full CRUD access including approval

### Audit Trail

- **GIVEN** any specification state change (create, update, approve, supersede)
- **WHEN** action completes
- **THEN** audit log entry created with:
  - entity_type = 'specification'
  - entity_id = spec.id
  - action = 'create'|'update'|'approve'|'supersede'
  - user_id = current user
  - old_value / new_value (for updates)

## Implementation Notes

### API Endpoints

```typescript
// GET /api/quality/specifications
// Query params: status, product_id, search, page, limit, sort_by, sort_order
interface SpecificationsListResponse {
  specifications: QualitySpecification[];
  pagination: {
    total: number;
    page: number;
    limit: number;
    pages: number;
  };
}

interface QualitySpecification {
  id: string;
  org_id: string;
  product_id: string;
  product_code: string;
  product_name: string;
  spec_number: string;
  version: number;
  name: string;
  description?: string;
  effective_date: string; // ISO date
  expiry_date?: string;
  status: 'draft' | 'active' | 'expired' | 'superseded';
  approved_by?: string;
  approved_by_name?: string;
  approved_at?: string;
  superseded_by?: string;
  superseded_at?: string;
  review_frequency_days: number;
  next_review_date?: string;
  last_review_date?: string;
  notes?: string;
  created_at: string;
  created_by: string;
  updated_at: string;
  updated_by?: string;
  // Computed
  review_status: 'ok' | 'due_soon' | 'overdue';
  days_until_review?: number;
  version_count: number;
}

// GET /api/quality/specifications/:id
interface SpecificationDetailResponse {
  specification: QualitySpecification;
  version_history: {
    id: string;
    version: number;
    status: string;
    effective_date: string;
    approved_by_name?: string;
  }[];
  parameters_count: number; // From story 06.4
}

// POST /api/quality/specifications
interface CreateSpecificationRequest {
  product_id: string;
  name: string;
  description?: string;
  effective_date: string;
  expiry_date?: string;
  review_frequency_days?: number;
  notes?: string;
}

// PUT /api/quality/specifications/:id
interface UpdateSpecificationRequest {
  name?: string;
  description?: string;
  effective_date?: string;
  expiry_date?: string;
  review_frequency_days?: number;
  notes?: string;
}

// POST /api/quality/specifications/:id/approve
interface ApproveSpecificationRequest {
  // Optional: approval_notes for audit
  approval_notes?: string;
}

interface ApproveSpecificationResponse {
  specification: QualitySpecification;
  superseded_specs: { id: string; spec_number: string; version: number }[];
}

// POST /api/quality/specifications/:id/clone
interface CloneSpecificationResponse {
  specification: QualitySpecification; // New draft version
}

// GET /api/quality/specifications/product/:productId
interface ProductSpecificationsResponse {
  specifications: QualitySpecification[];
  active_spec_id?: string;
}

// GET /api/quality/specifications/product/:productId/active
interface ActiveSpecificationResponse {
  specification: QualitySpecification;
  // Or 404 if no active spec
}

// POST /api/quality/specifications/:id/complete-review
interface CompleteReviewRequest {
  review_notes?: string;
}

interface CompleteReviewResponse {
  specification: QualitySpecification;
  previous_review_date?: string;
  next_review_date: string;
}
```

### Validation (Zod)

```typescript
import { z } from 'zod';

export const createSpecificationSchema = z.object({
  product_id: z.string().uuid('Invalid product ID'),
  name: z.string()
    .min(3, 'Name must be at least 3 characters')
    .max(200, 'Name must not exceed 200 characters'),
  description: z.string().max(2000).optional(),
  effective_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Invalid date format'),
  expiry_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional().nullable(),
  review_frequency_days: z.number().int().min(1).max(3650).default(365),
  notes: z.string().max(2000).optional(),
}).refine(
  (data) => !data.expiry_date || data.expiry_date > data.effective_date,
  { message: 'Expiry date must be after effective date', path: ['expiry_date'] }
);

export const updateSpecificationSchema = createSpecificationSchema
  .partial()
  .omit({ product_id: true }); // Cannot change product

export const approveSpecificationSchema = z.object({
  approval_notes: z.string().max(500).optional(),
});

export const completeReviewSchema = z.object({
  review_notes: z.string().max(1000).optional(),
});
```

### Service Layer

```typescript
// lib/services/specification-service.ts

export class SpecificationService {
  /**
   * Get active specification for a product
   * Uses database function for consistent resolution logic
   */
  static async getActiveForProduct(
    orgId: string,
    productId: string,
    asOfDate?: Date
  ): Promise<QualitySpecification | null> {
    const { data, error } = await supabase
      .rpc('get_active_specification', {
        p_org_id: orgId,
        p_product_id: productId,
        p_as_of_date: asOfDate?.toISOString().split('T')[0] || new Date().toISOString().split('T')[0]
      });

    if (error || !data) return null;

    return this.getById(data);
  }

  /**
   * Clone specification as new version
   */
  static async cloneAsNewVersion(specId: string, userId: string): Promise<QualitySpecification> {
    const existing = await this.getById(specId);
    if (!existing) throw new NotFoundError('Specification not found');

    // Get max version for this spec_number
    const { data: maxVersion } = await supabase
      .from('quality_specifications')
      .select('version')
      .eq('org_id', existing.org_id)
      .eq('spec_number', existing.spec_number)
      .order('version', { ascending: false })
      .limit(1)
      .single();

    const newVersion = (maxVersion?.version || 0) + 1;

    const newSpec = {
      org_id: existing.org_id,
      product_id: existing.product_id,
      spec_number: existing.spec_number,
      version: newVersion,
      name: existing.name,
      description: existing.description,
      effective_date: new Date().toISOString().split('T')[0],
      expiry_date: null,
      status: 'draft',
      approved_by: null,
      approved_at: null,
      review_frequency_days: existing.review_frequency_days,
      notes: `Cloned from version ${existing.version}`,
      created_by: userId,
    };

    const { data, error } = await supabase
      .from('quality_specifications')
      .insert(newSpec)
      .select()
      .single();

    if (error) throw new DatabaseError(error.message);

    // Audit log
    await AuditService.log({
      entity_type: 'specification',
      entity_id: data.id,
      action: 'create',
      user_id: userId,
      new_value: { cloned_from: specId, version: newVersion }
    });

    return data;
  }

  /**
   * Approve specification (activates and supersedes previous)
   */
  static async approve(
    specId: string,
    userId: string,
    notes?: string
  ): Promise<{ spec: QualitySpecification; superseded: string[] }> {
    const existing = await this.getById(specId);
    if (!existing) throw new NotFoundError('Specification not found');
    if (existing.status !== 'draft') {
      throw new ValidationError('Only draft specifications can be approved');
    }

    // Update triggers handle superseding previous active specs
    const { data, error } = await supabase
      .from('quality_specifications')
      .update({
        status: 'active',
        approved_by: userId,
        approved_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        updated_by: userId,
      })
      .eq('id', specId)
      .select()
      .single();

    if (error) throw new DatabaseError(error.message);

    // Get superseded specs
    const { data: superseded } = await supabase
      .from('quality_specifications')
      .select('id, spec_number, version')
      .eq('superseded_by', specId);

    // Audit log
    await AuditService.log({
      entity_type: 'specification',
      entity_id: specId,
      action: 'approve',
      user_id: userId,
      old_value: { status: 'draft' },
      new_value: { status: 'active', approval_notes: notes }
    });

    return { spec: data, superseded: superseded || [] };
  }

  /**
   * Complete review cycle
   */
  static async completeReview(
    specId: string,
    userId: string,
    notes?: string
  ): Promise<QualitySpecification> {
    const existing = await this.getById(specId);
    if (!existing) throw new NotFoundError('Specification not found');
    if (existing.status !== 'active') {
      throw new ValidationError('Only active specifications can be reviewed');
    }

    const today = new Date().toISOString().split('T')[0];
    const nextReview = new Date();
    nextReview.setDate(nextReview.getDate() + (existing.review_frequency_days || 365));

    const { data, error } = await supabase
      .from('quality_specifications')
      .update({
        last_review_date: today,
        next_review_date: nextReview.toISOString().split('T')[0],
        updated_at: new Date().toISOString(),
        updated_by: userId,
      })
      .eq('id', specId)
      .select()
      .single();

    if (error) throw new DatabaseError(error.message);

    // Audit log
    await AuditService.log({
      entity_type: 'specification',
      entity_id: specId,
      action: 'review_completed',
      user_id: userId,
      old_value: {
        last_review_date: existing.last_review_date,
        next_review_date: existing.next_review_date
      },
      new_value: {
        last_review_date: today,
        next_review_date: nextReview.toISOString().split('T')[0],
        review_notes: notes
      }
    });

    return data;
  }

  /**
   * Generate spec_number
   */
  static async generateSpecNumber(orgId: string): Promise<string> {
    const yearMonth = new Date().toISOString().slice(0, 7).replace('-', '');

    // Get current sequence for this month
    const { data } = await supabase
      .from('quality_specifications')
      .select('spec_number')
      .eq('org_id', orgId)
      .like('spec_number', `QS-${yearMonth}-%`)
      .order('spec_number', { ascending: false })
      .limit(1)
      .single();

    let sequence = 1;
    if (data?.spec_number) {
      const lastSeq = parseInt(data.spec_number.split('-')[2], 10);
      sequence = lastSeq + 1;
    }

    return `QS-${yearMonth}-${sequence.toString().padStart(3, '0')}`;
  }
}
```

### Frontend Components

```
apps/frontend/app/(authenticated)/quality/specifications/
  page.tsx                    -- Specifications list page
  [id]/page.tsx              -- Specification detail page
  new/page.tsx               -- Create specification page
  components/
    SpecificationTable.tsx    -- DataTable with filters
    SpecificationForm.tsx     -- Create/Edit form
    SpecificationDetail.tsx   -- Read-only detail view
    ApproveModal.tsx          -- Approval confirmation dialog
    VersionHistory.tsx        -- Version list component
    ReviewStatusBadge.tsx     -- Review date status indicator
    CloneVersionDialog.tsx    -- Clone confirmation dialog
```

### UI Components Specification

**SpecificationTable.tsx**
- ShadCN DataTable pattern
- Columns: Spec Number, Name, Product, Version, Status, Effective Date, Review Due, Actions
- Row actions: View, Edit (draft only), Approve (draft only), Clone
- Filters: Status dropdown, Product search, Date range
- Sort: All columns sortable
- Review status color coding (green=ok, yellow=due_soon, red=overdue)

**SpecificationForm.tsx**
- Product dropdown (searchable, required)
- Name input (required, 3-200 chars)
- Description textarea (optional, max 2000)
- Effective date picker (required)
- Expiry date picker (optional, must be > effective)
- Review frequency input (number, default 365)
- Notes textarea (optional)

**SpecificationDetail.tsx**
- Header: Spec number, version badge, status badge
- Product link
- All fields in read-only format
- Version history sidebar
- Action buttons based on status and permissions

**ApproveModal.tsx**
- Confirmation message with product name
- Optional approval notes
- Warning about superseding existing specs
- Approve / Cancel buttons

### Services

- `lib/services/specification-service.ts` - Main service (see above)
- `lib/services/audit-service.ts` - Audit logging (shared)

## Deliverables

- Migration: `create_quality_specifications.sql`
- Database functions: `get_active_specification`, `supersede_previous_spec`
- RLS policies for quality_specifications
- API routes:
  - GET /api/quality/specifications
  - GET /api/quality/specifications/:id
  - POST /api/quality/specifications
  - PUT /api/quality/specifications/:id
  - DELETE /api/quality/specifications/:id (draft only)
  - POST /api/quality/specifications/:id/approve
  - POST /api/quality/specifications/:id/clone
  - GET /api/quality/specifications/product/:productId
  - GET /api/quality/specifications/product/:productId/active
  - POST /api/quality/specifications/:id/complete-review
- Zod validation schemas
- `SpecificationService` class
- Specifications list page
- Specification detail page
- Create specification page
- UI components (Table, Form, Detail, Modals)
- Unit tests for service layer (>90% coverage)
- Integration tests for API endpoints
- E2E test for create -> approve -> supersede flow

## Test Strategy

### Unit Tests

```typescript
describe('SpecificationService', () => {
  describe('getActiveForProduct', () => {
    it('returns active spec when one exists', async () => {});
    it('returns null when no active spec', async () => {});
    it('ignores expired specs', async () => {});
    it('ignores superseded specs', async () => {});
    it('returns most recent active by effective_date', async () => {});
  });

  describe('approve', () => {
    it('changes status to active', async () => {});
    it('sets approved_by and approved_at', async () => {});
    it('supersedes previous active spec', async () => {});
    it('calculates next_review_date', async () => {});
    it('rejects if not draft status', async () => {});
    it('creates audit log entry', async () => {});
  });

  describe('cloneAsNewVersion', () => {
    it('creates new draft with incremented version', async () => {});
    it('copies name, description, review_frequency', async () => {});
    it('clears approval fields', async () => {});
    it('sets effective_date to today', async () => {});
  });

  describe('generateSpecNumber', () => {
    it('generates QS-YYYYMM-001 format', async () => {});
    it('increments sequence within month', async () => {});
    it('resets sequence for new month', async () => {});
  });
});
```

### Integration Tests

```typescript
describe('Specifications API', () => {
  describe('POST /api/quality/specifications', () => {
    it('creates draft specification', async () => {});
    it('validates required fields', async () => {});
    it('enforces org_id from auth', async () => {});
  });

  describe('POST /api/quality/specifications/:id/approve', () => {
    it('requires QA_MANAGER role', async () => {});
    it('supersedes existing active specs', async () => {});
    it('returns 403 for unauthorized user', async () => {});
  });

  describe('GET /api/quality/specifications/product/:id/active', () => {
    it('returns active spec for product', async () => {});
    it('returns 404 when no active spec', async () => {});
    it('respects RLS for org isolation', async () => {});
  });
});
```

### E2E Tests

```typescript
describe('Specification Workflow', () => {
  it('complete lifecycle: create draft -> approve -> supersede', async () => {
    // 1. Create draft specification
    // 2. Verify status is draft
    // 3. Approve specification
    // 4. Verify status is active
    // 5. Create new version
    // 6. Approve new version
    // 7. Verify original is superseded
  });
});
```

## Definition of Done

- [ ] Migration creates quality_specifications table with all columns
- [ ] RLS policies enforce org isolation
- [ ] Database functions for active resolution and superseding work correctly
- [ ] All API endpoints implemented and tested
- [ ] Zod validation schemas complete
- [ ] SpecificationService with all methods implemented
- [ ] Specifications list page loads <500ms
- [ ] Create specification form with validation
- [ ] Edit draft specification works
- [ ] Approve workflow with confirmation
- [ ] Clone as new version creates correct data
- [ ] Active spec resolution returns correct spec
- [ ] Superseding updates previous active spec
- [ ] Review date tracking and badges display
- [ ] Complete review action updates dates
- [ ] Audit trail for all state changes
- [ ] Permission checks: VIEWER can read, QA_INSPECTOR can create/edit, QA_MANAGER can approve
- [ ] Delete restricted to draft status only
- [ ] Unit tests >90% coverage for service
- [ ] Integration tests for all API endpoints
- [ ] E2E test for full workflow

---

**Document Status**: Ready for Implementation
**Created**: 2025-12-16
**Lines**: ~650
**Complexity**: M (Medium)
**Phase**: 1A (Core Quality)
