# Story 06.2 - Database Schema
# Purpose: Tables, RLS policies, indexes, triggers
# Agent: BACKEND-DEV (database focus)

migrations:
  - path: "supabase/migrations/062_create_quality_holds_table.sql"
    type: "migration"
    description: "Quality holds + hold items tables with RLS + auto-numbering trigger"

tables:
  - name: "quality_holds"
    description: "Quality holds to block inventory from consumption pending investigation"
    columns:
      - { name: "id", type: "UUID", constraints: "PRIMARY KEY DEFAULT gen_random_uuid()" }
      - { name: "org_id", type: "UUID", constraints: "NOT NULL REFERENCES organizations(id) ON DELETE CASCADE" }
      - { name: "hold_number", type: "TEXT", constraints: "NOT NULL UNIQUE(org_id, hold_number)" }
      - { name: "reason", type: "TEXT", constraints: "NOT NULL" }
      - { name: "hold_type", type: "TEXT", constraints: "NOT NULL CHECK (hold_type IN ('qa_pending', 'investigation', 'recall', 'quarantine'))" }
      - { name: "status", type: "TEXT", constraints: "NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'released', 'disposed'))" }
      - { name: "priority", type: "TEXT", constraints: "NOT NULL DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high', 'critical'))" }
      - { name: "held_by", type: "UUID", constraints: "NOT NULL REFERENCES users(id)" }
      - { name: "held_at", type: "TIMESTAMPTZ", constraints: "NOT NULL DEFAULT now()" }
      - { name: "released_by", type: "UUID", constraints: "REFERENCES users(id)" }
      - { name: "released_at", type: "TIMESTAMPTZ", constraints: "" }
      - { name: "release_notes", type: "TEXT", constraints: "" }
      - { name: "disposition", type: "TEXT", constraints: "CHECK (disposition IN ('release', 'rework', 'scrap', 'return'))" }
      - { name: "ncr_id", type: "UUID", constraints: "REFERENCES ncr_reports(id)" }
      - { name: "created_at", type: "TIMESTAMPTZ", constraints: "NOT NULL DEFAULT now()" }
      - { name: "updated_at", type: "TIMESTAMPTZ", constraints: "NOT NULL DEFAULT now()" }
      - { name: "created_by", type: "UUID", constraints: "REFERENCES users(id)" }
      - { name: "updated_by", type: "UUID", constraints: "REFERENCES users(id)" }
    rls: true
    rls_pattern: "org_id = (SELECT org_id FROM users WHERE id = auth.uid())"
    indexes:
      - "idx_quality_holds_org_status ON quality_holds(org_id, status)"
      - "idx_quality_holds_org_held_at ON quality_holds(org_id, held_at DESC)"
      - "idx_quality_holds_org_priority ON quality_holds(org_id, priority) WHERE status = 'active'"
      - "idx_quality_holds_ncr ON quality_holds(ncr_id) WHERE ncr_id IS NOT NULL"
    constraints:
      - "CONSTRAINT released_fields_consistency CHECK ((status = 'released' AND released_by IS NOT NULL AND released_at IS NOT NULL) OR (status != 'released'))"
      - "CONSTRAINT disposition_on_release CHECK ((status = 'released' AND disposition IS NOT NULL) OR (status != 'released'))"

  - name: "quality_hold_items"
    description: "Items (LPs, WOs, batches) placed on quality hold"
    columns:
      - { name: "id", type: "UUID", constraints: "PRIMARY KEY DEFAULT gen_random_uuid()" }
      - { name: "hold_id", type: "UUID", constraints: "NOT NULL REFERENCES quality_holds(id) ON DELETE CASCADE" }
      - { name: "reference_type", type: "TEXT", constraints: "NOT NULL CHECK (reference_type IN ('lp', 'wo', 'batch'))" }
      - { name: "reference_id", type: "UUID", constraints: "NOT NULL" }
      - { name: "quantity_held", type: "DECIMAL(15,4)", constraints: "" }
      - { name: "uom", type: "TEXT", constraints: "" }
      - { name: "location_id", type: "UUID", constraints: "REFERENCES locations(id)" }
      - { name: "notes", type: "TEXT", constraints: "" }
      - { name: "created_at", type: "TIMESTAMPTZ", constraints: "NOT NULL DEFAULT now()" }
    rls: true
    rls_pattern: "EXISTS (SELECT 1 FROM quality_holds WHERE quality_holds.id = quality_hold_items.hold_id AND quality_holds.org_id = (SELECT org_id FROM users WHERE id = auth.uid()))"
    indexes:
      - "idx_quality_hold_items_hold ON quality_hold_items(hold_id)"
      - "idx_quality_hold_items_reference ON quality_hold_items(reference_type, reference_id)"
    constraints:
      - "UNIQUE(hold_id, reference_type, reference_id)"

# RLS Policies (ADR-013)
rls_policies:
  pattern: "Users Table Lookup"
  pattern_sql: "(SELECT org_id FROM users WHERE id = auth.uid())"
  policies:
    - table: "quality_holds"
      name: "quality_holds_org_isolation"
      operation: "ALL"
      using: "org_id = (SELECT org_id FROM users WHERE id = auth.uid())"
      description: "All authenticated users can read org holds"

    - table: "quality_holds"
      name: "quality_holds_insert"
      operation: "INSERT"
      with_check: "org_id = (SELECT org_id FROM users WHERE id = auth.uid())"
      description: "QA Inspector, Manager, Director can create holds"

    - table: "quality_holds"
      name: "quality_holds_update"
      operation: "UPDATE"
      using: "org_id = (SELECT org_id FROM users WHERE id = auth.uid())"
      description: "QA Manager, Director can update holds"

    - table: "quality_hold_items"
      name: "quality_hold_items_org_isolation"
      operation: "ALL"
      using: "EXISTS (SELECT 1 FROM quality_holds WHERE quality_holds.id = quality_hold_items.hold_id AND quality_holds.org_id = (SELECT org_id FROM users WHERE id = auth.uid()))"
      description: "Access hold items via parent hold org isolation"

# Triggers
triggers:
  - name: "set_hold_number"
    table: "quality_holds"
    timing: "BEFORE INSERT"
    description: "Auto-generate hold_number as QH-YYYYMMDD-NNNN"
    function: "generate_hold_number()"
    rationale: "Ensures unique sequential numbering per org per day"

  - name: "set_quality_holds_updated_at"
    table: "quality_holds"
    timing: "BEFORE UPDATE"
    description: "Update updated_at timestamp"
    function: "update_updated_at_column()"

# LP Blocking Integration
lp_blocking:
  description: "Quality holds block LP consumption by setting qa_status = 'hold'"
  trigger_points:
    - "On hold creation: Update LP qa_status to 'hold' for all LP items"
    - "On hold release: Update LP qa_status based on disposition"
    - "At consumption time: LPValidationService checks qa_status = 'hold'"

  disposition_mapping:
    release: "qa_status = 'passed' (LP can be consumed)"
    rework: "qa_status = 'pending' (LP pending re-inspection)"
    scrap: "qa_status = 'scrap', quantity_available = 0 (LP destroyed)"
    return: "qa_status = 'rejected' (LP returned to supplier)"

# Field Notes
field_notes:
  hold_type:
    description: "Classification of hold reason"
    values:
      - code: "qa_pending"
        label: "QA Pending"
        description: "Awaiting inspection results"
      - code: "investigation"
        label: "Investigation"
        description: "Under quality investigation"
      - code: "recall"
        label: "Recall"
        description: "Safety or regulatory recall"
      - code: "quarantine"
        label: "Quarantine"
        description: "Isolated for review"

  priority:
    description: "Hold urgency and aging threshold"
    values:
      - code: "critical"
        label: "Critical"
        aging_threshold_hours: 24
        description: "Immediate investigation required"
      - code: "high"
        label: "High"
        aging_threshold_hours: 48
        description: "Urgent investigation"
      - code: "medium"
        label: "Medium"
        aging_threshold_hours: 72
        description: "Standard investigation"
      - code: "low"
        label: "Low"
        aging_threshold_hours: 168
        description: "Non-urgent issue"

  disposition:
    description: "Final decision when releasing hold"
    values:
      - code: "release"
        label: "Approve for Use"
        lp_status: "passed"
        description: "LP meets all quality criteria"
      - code: "rework"
        label: "Rework"
        lp_status: "pending"
        description: "LP requires reprocessing"
      - code: "scrap"
        label: "Scrap"
        lp_status: "scrap"
        description: "LP destroyed, quantity set to 0"
      - code: "return"
        label: "Return to Supplier"
        lp_status: "rejected"
        description: "LP returned for replacement"

# Seed Data
seed_data:
  description: "No seed data for quality holds (created by users)"

# Migration SQL Pattern
migration_pattern: |
  -- Quality Holds Table
  CREATE TABLE quality_holds (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    hold_number TEXT NOT NULL,
    reason TEXT NOT NULL,
    hold_type TEXT NOT NULL CHECK (hold_type IN ('qa_pending', 'investigation', 'recall', 'quarantine')),
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'released', 'disposed')),
    priority TEXT NOT NULL DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high', 'critical')),
    held_by UUID NOT NULL REFERENCES users(id),
    held_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    released_by UUID REFERENCES users(id),
    released_at TIMESTAMPTZ,
    release_notes TEXT,
    disposition TEXT CHECK (disposition IN ('release', 'rework', 'scrap', 'return')),
    ncr_id UUID REFERENCES ncr_reports(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by UUID REFERENCES users(id),
    updated_by UUID REFERENCES users(id),
    CONSTRAINT unique_hold_number_per_org UNIQUE(org_id, hold_number),
    CONSTRAINT released_fields_consistency CHECK (
      (status = 'released' AND released_by IS NOT NULL AND released_at IS NOT NULL) OR
      (status != 'released')
    ),
    CONSTRAINT disposition_on_release CHECK (
      (status = 'released' AND disposition IS NOT NULL) OR
      (status != 'released')
    )
  );

  -- Quality Hold Items Table
  CREATE TABLE quality_hold_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    hold_id UUID NOT NULL REFERENCES quality_holds(id) ON DELETE CASCADE,
    reference_type TEXT NOT NULL CHECK (reference_type IN ('lp', 'wo', 'batch')),
    reference_id UUID NOT NULL,
    quantity_held DECIMAL(15,4),
    uom TEXT,
    location_id UUID REFERENCES locations(id),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    CONSTRAINT unique_hold_item_per_hold UNIQUE(hold_id, reference_type, reference_id)
  );

  -- Indexes for Performance
  CREATE INDEX idx_quality_holds_org_status ON quality_holds(org_id, status);
  CREATE INDEX idx_quality_holds_org_held_at ON quality_holds(org_id, held_at DESC);
  CREATE INDEX idx_quality_holds_org_priority ON quality_holds(org_id, priority) WHERE status = 'active';
  CREATE INDEX idx_quality_holds_ncr ON quality_holds(ncr_id) WHERE ncr_id IS NOT NULL;
  CREATE INDEX idx_quality_hold_items_hold ON quality_hold_items(hold_id);
  CREATE INDEX idx_quality_hold_items_reference ON quality_hold_items(reference_type, reference_id);

  -- RLS Policies
  ALTER TABLE quality_holds ENABLE ROW LEVEL SECURITY;
  ALTER TABLE quality_hold_items ENABLE ROW LEVEL SECURITY;

  CREATE POLICY "quality_holds_org_isolation"
    ON quality_holds FOR ALL
    USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

  CREATE POLICY "quality_holds_insert"
    ON quality_holds FOR INSERT
    WITH CHECK (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

  CREATE POLICY "quality_holds_update"
    ON quality_holds FOR UPDATE
    USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

  CREATE POLICY "quality_hold_items_org_isolation"
    ON quality_hold_items FOR ALL
    USING (
      EXISTS (
        SELECT 1 FROM quality_holds
        WHERE quality_holds.id = quality_hold_items.hold_id
        AND quality_holds.org_id = (SELECT org_id FROM users WHERE id = auth.uid())
      )
    );

  -- Auto-numbering Trigger
  CREATE OR REPLACE FUNCTION generate_hold_number()
  RETURNS TRIGGER AS $$
  BEGIN
    IF NEW.hold_number IS NULL OR NEW.hold_number = '' THEN
      NEW.hold_number := 'QH-' ||
        TO_CHAR(CURRENT_DATE, 'YYYYMMDD') || '-' ||
        LPAD(
          (
            SELECT COALESCE(MAX(
              CAST(
                SUBSTRING(hold_number FROM '[0-9]+$') AS INTEGER
              )
            ), 0) + 1
            FROM quality_holds
            WHERE org_id = NEW.org_id
            AND hold_number LIKE 'QH-' || TO_CHAR(CURRENT_DATE, 'YYYYMMDD') || '-%'
          )::TEXT,
          4,
          '0'
        );
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER set_hold_number
    BEFORE INSERT ON quality_holds
    FOR EACH ROW
    EXECUTE FUNCTION generate_hold_number();

  CREATE TRIGGER set_quality_holds_updated_at
    BEFORE UPDATE ON quality_holds
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
