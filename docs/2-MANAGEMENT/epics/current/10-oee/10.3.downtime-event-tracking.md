# 10.3 - Downtime Event Tracking

**Priority**: P0 (MVP)
**Story Points**: L (Large)
**Type**: full-stack
**Phase**: 1A (Core OEE)
**Model**: SONNET

**State:** ready
**Estimate:** L (4-5 days)
**Primary PRD:** `docs/1-BASELINE/product/modules/oee.md` (FR-OEE-003)
**Architecture:** `docs/1-BASELINE/architecture/modules/oee.md` (oee_downtime_events table)

---

## Goal

Implement downtime event logging and tracking system. This enables operators and supervisors to record when machines stop, classify the reason, track duration, and analyze impact on OEE. Supports manual logging, auto-detection from WO pause, and mobile logging for factory floor.

---

## User Story

As an **Operator**, I want to **log downtime events with start/end times and select a reason code** so that **production management can track why machines are not running**.

As a **Production Supervisor**, I want to **view active downtime events and see duration in real-time** so that **I can respond quickly to extended stops**.

---

## Scope

**In scope (this story)**
- `oee_downtime_events` table with start/end times, duration, reason
- Manual downtime logging via UI
- Auto-create event when WO paused (optional)
- Event status: active (no end_time) vs completed (has end_time)
- Duration auto-calculation on event end
- Impact severity classification (minor <5min, moderate <15min, major >15min)
- GET /api/oee/downtime (list events)
- GET /api/oee/downtime/:id (event detail)
- POST /api/oee/downtime (create event)
- PATCH /api/oee/downtime/:id (update event)
- PATCH /api/oee/downtime/:id/end (end active event)
- DELETE /api/oee/downtime/:id (delete event)
- Downtime log page with active events panel
- Downtime form modal (start/end)
- Real-time duration display for active events

**Out of scope (this story)**
- Downtime Pareto analysis (Phase 2)
- Auto-detection via machine sensors (Phase 3)
- Mobile scanner app (Phase 3)
- Photo/voice note attachments (Phase 2)
- Notification on extended downtime (Phase 1B)

---

## Dependencies

### Cross-Epic Dependencies

| Dependency | Story/Epic | Type | What It Provides | Status |
|------------|------------|------|------------------|--------|
| 01.1 | Org Context + RLS | HARD | organizations, users, roles | Ready |
| 01.3 | Machine Settings | HARD | machines table | Ready |
| 01.5 | Production Lines | HARD | production_lines table | Ready |
| 04.1 | Work Orders CRUD | SOFT | work_orders for linkage | Ready |

### Within Epic Dependencies

| Dependency | Story | Type | What It Provides |
|------------|-------|------|------------------|
| 10.1 | OEE Settings & Targets | SOFT | OEE enabled flag | Ready |
| 10.2 | Downtime Reason Codes | HARD | reason_code_id reference | Ready |

### Provides To (Downstream)

| Story | What This Provides |
|-------|-------------------|
| 10.4 | OEE Calculation Engine - downtime data for availability metric |
| 10.5 | Real-Time Dashboard - active downtime display |
| Phase 2 | Pareto Analysis - downtime aggregation by reason |

---

## Database Migration

```sql
-- Migration: YYYYMMDDHHMMSS_create_oee_downtime_events.sql

CREATE TABLE oee_downtime_events (
    -- Identity
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id                  UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

    -- Machine/Line Reference
    machine_id              UUID REFERENCES machines(id),
    line_id                 UUID REFERENCES production_lines(id),

    -- Work Order Context (optional)
    work_order_id           UUID REFERENCES work_orders(id),

    -- Event Type
    downtime_type           TEXT NOT NULL DEFAULT 'unplanned'
                            CHECK (downtime_type IN ('planned', 'unplanned')),

    -- Reason Classification
    reason_code_id          UUID NOT NULL REFERENCES oee_downtime_reasons(id),

    -- Timing
    start_time              TIMESTAMPTZ NOT NULL,
    end_time                TIMESTAMPTZ,
    duration_minutes        INTEGER GENERATED ALWAYS AS (
                                EXTRACT(EPOCH FROM (COALESCE(end_time, NOW()) - start_time)) / 60
                            ) STORED,

    -- Impact Severity (based on duration)
    impact_severity         TEXT GENERATED ALWAYS AS (
                                CASE
                                    WHEN EXTRACT(EPOCH FROM (COALESCE(end_time, NOW()) - start_time)) / 60 < 5 THEN 'minor'
                                    WHEN EXTRACT(EPOCH FROM (COALESCE(end_time, NOW()) - start_time)) / 60 < 15 THEN 'moderate'
                                    ELSE 'major'
                                END
                            ) STORED,

    -- Details
    logged_by               UUID REFERENCES users(id),
    notes                   TEXT,

    -- Audit
    created_at              TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at              TIMESTAMPTZ NOT NULL DEFAULT now(),

    -- Constraints
    CONSTRAINT chk_end_after_start
        CHECK (end_time IS NULL OR end_time >= start_time),
    CONSTRAINT chk_machine_or_line
        CHECK (machine_id IS NOT NULL OR line_id IS NOT NULL)
);

-- =============================================================================
-- Indexes for Performance
-- =============================================================================

CREATE INDEX idx_downtime_org ON oee_downtime_events(org_id);
CREATE INDEX idx_downtime_machine ON oee_downtime_events(machine_id) WHERE machine_id IS NOT NULL;
CREATE INDEX idx_downtime_line ON oee_downtime_events(line_id) WHERE line_id IS NOT NULL;
CREATE INDEX idx_downtime_wo ON oee_downtime_events(work_order_id) WHERE work_order_id IS NOT NULL;
CREATE INDEX idx_downtime_reason ON oee_downtime_events(reason_code_id);
CREATE INDEX idx_downtime_start ON oee_downtime_events(org_id, start_time DESC);
CREATE INDEX idx_downtime_type ON oee_downtime_events(org_id, downtime_type);

-- Active downtime events (no end_time)
CREATE INDEX idx_downtime_active ON oee_downtime_events(org_id, machine_id, start_time)
    WHERE end_time IS NULL;

-- Severity analysis
CREATE INDEX idx_downtime_severity ON oee_downtime_events(org_id, impact_severity);

-- Time range queries
CREATE INDEX idx_downtime_time_range ON oee_downtime_events(org_id, start_time, end_time);

-- =============================================================================
-- RLS Policies
-- =============================================================================

ALTER TABLE oee_downtime_events ENABLE ROW LEVEL SECURITY;

CREATE POLICY "downtime_select" ON oee_downtime_events
    FOR SELECT USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "downtime_insert" ON oee_downtime_events
    FOR INSERT WITH CHECK (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "downtime_update" ON oee_downtime_events
    FOR UPDATE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

CREATE POLICY "downtime_delete" ON oee_downtime_events
    FOR DELETE USING (
        org_id = (SELECT org_id FROM users WHERE id = auth.uid())
    );

-- =============================================================================
-- Trigger for updated_at
-- =============================================================================

CREATE TRIGGER update_oee_downtime_events_updated_at
    BEFORE UPDATE ON oee_downtime_events
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================================================
-- Function: Auto-create downtime on WO pause
-- =============================================================================

CREATE OR REPLACE FUNCTION create_downtime_on_wo_pause()
RETURNS TRIGGER AS $$
DECLARE
    v_settings RECORD;
    v_default_reason_id UUID;
BEGIN
    -- Only trigger on status change to 'paused'
    IF NEW.status = 'paused' AND OLD.status = 'in_progress' THEN

        -- Check if auto-create enabled
        SELECT * INTO v_settings FROM settings WHERE org_id = NEW.org_id;

        IF v_settings.oee_enabled = true THEN

            -- Get default "paused" reason code (or first unplanned reason)
            SELECT id INTO v_default_reason_id
            FROM oee_downtime_reasons
            WHERE org_id = NEW.org_id
              AND is_active = true
              AND is_planned = false
            ORDER BY sort_order ASC
            LIMIT 1;

            -- Create downtime event
            IF v_default_reason_id IS NOT NULL THEN
                INSERT INTO oee_downtime_events (
                    org_id,
                    machine_id,
                    line_id,
                    work_order_id,
                    downtime_type,
                    reason_code_id,
                    start_time,
                    logged_by,
                    notes
                ) VALUES (
                    NEW.org_id,
                    NEW.machine_id,
                    NEW.line_id,
                    NEW.id,
                    'unplanned',
                    v_default_reason_id,
                    NOW(),
                    NEW.updated_by,
                    'Auto-created from WO pause'
                );
            END IF;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger on work_orders (commented - requires work_orders table)
-- CREATE TRIGGER trigger_create_downtime_on_wo_pause
--     AFTER UPDATE ON work_orders
--     FOR EACH ROW
--     EXECUTE FUNCTION create_downtime_on_wo_pause();

COMMENT ON FUNCTION create_downtime_on_wo_pause IS 'Auto-creates downtime event when WO paused';
```

---

## Acceptance Criteria (Given/When/Then)

### AC-1: Manual Downtime Logging - Start

```gherkin
Scenario: Log downtime start
  Given operator on machine Mixer-01
  And WO-2451 is in_progress
  When machine stops at 14:23
  And operator logs downtime:
    | Field | Value |
    | machine_id | Mixer-01 |
    | reason_code | MECH-JAM |
    | start_time | 14:23 |
    | notes | Product stuck in hopper |
  Then downtime event created
  And end_time = NULL (active)
  And duration auto-updates every minute
  And impact_severity = 'minor' initially

Scenario: Validation - require reason code
  Given logging downtime
  When reason_code_id is NULL
  Then error: "Reason code required"

Scenario: Validation - start time not future
  Given logging downtime with start_time = tomorrow
  Then error: "Start time cannot be in future"
```

### AC-2: Manual Downtime Logging - End

```gherkin
Scenario: End active downtime
  Given active downtime event exists (started at 14:23)
  When operator resolves issue at 14:35
  And clicks [End Downtime]
  Then end_time = 14:35
  And duration_minutes = 12
  And impact_severity = 'moderate' (12 min)
  And event status = completed

Scenario: Auto-calculate duration
  Given downtime started at 14:23, ended at 14:45
  When viewing event
  Then duration_minutes = 22
  And displayed as "22 minutes" or "0h 22m"

Scenario: Update active duration in real-time
  Given downtime started 8 minutes ago
  And event still active (end_time = NULL)
  When viewing event detail
  Then duration shows "8 min (ongoing)"
  And updates every 60s via WebSocket or polling
```

### AC-3: Impact Severity Classification

```gherkin
Scenario: Minor downtime (<5 min)
  Given downtime duration = 4 minutes
  Then impact_severity = 'minor'
  And badge color = yellow

Scenario: Moderate downtime (5-15 min)
  Given downtime duration = 12 minutes
  Then impact_severity = 'moderate'
  And badge color = orange

Scenario: Major downtime (>15 min)
  Given downtime duration = 25 minutes
  Then impact_severity = 'major'
  And badge color = red
```

### AC-4: Auto-Create on WO Pause

```gherkin
Scenario: Auto-create event when WO paused
  Given WO-2451 status = 'in_progress' on Mixer-01
  And settings.oee_enabled = true
  When WO status changes to 'paused'
  Then downtime event created:
    | Field | Value |
    | work_order_id | WO-2451 |
    | machine_id | Mixer-01 |
    | start_time | NOW() |
    | reason_code_id | Default unplanned code |
    | notes | Auto-created from WO pause |
  And operator can update reason code later

Scenario: No auto-create when OEE disabled
  Given settings.oee_enabled = false
  When WO paused
  Then no downtime event created
```

### AC-5: Downtime Events List

```gherkin
Scenario: View downtime log
  Given user navigates to /oee/downtime
  When page loads
  Then DataTable displays events with columns:
    | Column | Description |
    | Machine | Machine name |
    | Start Time | Timestamp |
    | End Time | Timestamp or "Ongoing" |
    | Duration | Minutes |
    | Reason | Reason code + description |
    | Type | Planned/Unplanned badge |
    | Severity | Minor/Moderate/Major badge |
    | Actions | Edit, End, Delete |
  And active events highlighted
  And list loads within 500ms

Scenario: Filter by machine
  Given events exist for multiple machines
  When user filters by "Mixer-01"
  Then only Mixer-01 events display

Scenario: Filter by date range
  Given events exist over 30 days
  When user selects date range: 2025-01-01 to 2025-01-15
  Then only events in range display

Scenario: Filter by reason category
  Given events exist with various reasons
  When user filters by category = "Mechanical"
  Then only mechanical reason events display
```

### AC-6: Active Downtime Panel

```gherkin
Scenario: Active downtime panel
  Given 3 machines currently down
  When viewing /oee/downtime
  Then panel shows:
    | Machine | Reason | Duration | Actions |
    | Mixer-01 | MECH-JAM | 8 min (ongoing) | [End] |
    | Filler-02 | MAT-SHORTAGE | 15 min (ongoing) | [End] |
    | Labeler-03 | ELEC-SENSOR | 2 min (ongoing) | [End] |
  And durations update every 60s
  And panel positioned at top of page

Scenario: No active downtime
  Given no active downtime events
  Then panel shows: "All machines running"
  And panel color = green
```

### AC-7: Update Downtime Event

```gherkin
Scenario: Update reason code
  Given downtime event exists with reason = "OTH-UNKNOWN"
  When operator updates reason to "MECH-JAM"
  And adds notes: "Belt slipped"
  Then event updated
  And audit log records change

Scenario: Cannot update completed event after 24 hours
  Given downtime completed 2 days ago
  When attempting to update
  Then warning: "Event older than 24 hours - contact supervisor"
  And update blocked (or requires approval)
```

### AC-8: Delete Downtime Event

```gherkin
Scenario: Delete event by creator
  Given downtime event logged by current user
  And event created < 1 hour ago
  When user clicks [Delete]
  Then confirmation: "Delete this downtime event?"
  And user confirms
  Then event deleted

Scenario: Cannot delete old events
  Given event created > 24 hours ago
  When non-admin attempts delete
  Then [Delete] button hidden or disabled
  And admin can delete with reason
```

### AC-9: Downtime by Work Order

```gherkin
Scenario: Link downtime to WO
  Given WO-2451 running on Mixer-01
  When logging downtime
  Then work_order_id auto-populated from active WO
  And downtime appears in WO timeline

Scenario: View WO downtime summary
  Given WO-2451 has 3 downtime events:
    | Reason | Duration |
    | MECH-JAM | 12 min |
    | BRK-LUNCH | 30 min |
    | CHG-PLANNED | 25 min |
  When viewing WO detail
  Then summary shows:
    | Total Downtime | Planned | Unplanned |
    | 67 min | 55 min | 12 min |
```

### AC-10: Permission Enforcement

```gherkin
Scenario: Operator can log downtime
  Given user has OPERATOR role
  Then can create downtime events
  And can end own events
  And can update own events (within 1 hour)

Scenario: Supervisor can manage all downtime
  Given user has PRODUCTION_MANAGER role
  Then can create, update, delete any event
  And can override auto-created events

Scenario: Viewer read-only
  Given user has VIEWER role
  Then can view downtime log
  And [+ Log Downtime] hidden
  And [Edit], [Delete] disabled
```

### AC-11: RLS Enforcement

```gherkin
Scenario: Org isolation
  Given Org A has downtime events
  And Org B has different events
  When User A requests GET /api/oee/downtime
  Then only Org A events returned

Scenario: Cross-tenant access denied
  Given event belongs to Org B
  When User A requests GET /api/oee/downtime/:id
  Then 404 Not Found returned
```

### AC-12: Performance Requirements

```gherkin
Scenario: List performance
  Given 10,000 downtime events in org
  When loading list with pagination
  Then response time < 500ms

Scenario: Active events performance
  Given 50 active downtime events
  When polling for updates
  Then response time < 200ms
```

---

## Implementation Notes

### API Endpoints

```typescript
// GET /api/oee/downtime
interface DowntimeListParams {
  machine_id?: string;
  line_id?: string;
  work_order_id?: string;
  downtime_type?: 'planned' | 'unplanned';
  reason_category?: string;
  impact_severity?: 'minor' | 'moderate' | 'major';
  is_active?: boolean; // true = end_time IS NULL
  start_date?: string;
  end_date?: string;
  sort_by?: 'start_time' | 'duration_minutes';
  sort_order?: 'asc' | 'desc';
  page?: number;
  limit?: number;
}

interface DowntimeEvent {
  id: string;
  org_id: string;
  machine_id?: string;
  machine_name?: string;
  line_id?: string;
  line_name?: string;
  work_order_id?: string;
  work_order_number?: string;
  downtime_type: 'planned' | 'unplanned';
  reason_code_id: string;
  reason_code: string;
  reason_description: string;
  reason_category: string;
  reason_color: string;
  start_time: string;
  end_time?: string;
  duration_minutes: number;
  impact_severity: 'minor' | 'moderate' | 'major';
  logged_by: string;
  logged_by_name: string;
  notes?: string;
  created_at: string;
  updated_at: string;
}

// POST /api/oee/downtime
interface CreateDowntimeRequest {
  machine_id?: string;
  line_id?: string;
  work_order_id?: string;
  reason_code_id: string;
  start_time: string;
  notes?: string;
}

// PATCH /api/oee/downtime/:id
interface UpdateDowntimeRequest {
  reason_code_id?: string;
  notes?: string;
}

// PATCH /api/oee/downtime/:id/end
interface EndDowntimeRequest {
  end_time?: string; // Optional, defaults to NOW()
}

// GET /api/oee/downtime/active
interface ActiveDowntimeResponse {
  active_events: DowntimeEvent[];
  count: number;
}
```

---

## Deliverables

### Database
- [ ] Migration: `oee_downtime_events` table with RLS
- [ ] Generated columns: duration_minutes, impact_severity
- [ ] Function: `create_downtime_on_wo_pause()`
- [ ] All indexes for performance

### API Routes
- [ ] `GET /api/oee/downtime` - List events
- [ ] `GET /api/oee/downtime/active` - Active events
- [ ] `POST /api/oee/downtime` - Create event
- [ ] `PATCH /api/oee/downtime/:id` - Update event
- [ ] `PATCH /api/oee/downtime/:id/end` - End event
- [ ] `DELETE /api/oee/downtime/:id` - Delete event

### Service Layer
- [ ] `DowntimeEventService.list()` - List with joins
- [ ] `DowntimeEventService.create()` - Create event
- [ ] `DowntimeEventService.end()` - End active event
- [ ] `DowntimeEventService.getActive()` - Active events
- [ ] `DowntimeEventService.getByWorkOrder()` - WO summary

### Frontend
- [ ] Downtime log page (/oee/downtime)
- [ ] Active downtime panel
- [ ] Log downtime modal
- [ ] End downtime confirmation
- [ ] Severity badges
- [ ] Real-time duration updates

### Tests
- [ ] Unit tests: DowntimeEventService (>80% coverage)
- [ ] Integration tests: All endpoints
- [ ] Trigger test: Auto-create on WO pause
- [ ] E2E: Full logging workflow

---

## Definition of Done

- [ ] Table created with generated columns
- [ ] Auto-create trigger functional
- [ ] All API endpoints working
- [ ] Active events update in real-time
- [ ] Frontend complete with filtering
- [ ] Tests passing (>80% coverage)

---

**Document Status**: Ready for Implementation
**Created**: 2025-01-15
**Complexity**: L (Large)
**Phase**: 1A (Core OEE)
