# 07.7 - Inventory Allocation Engine (FIFO/FEFO + Backorders)

**Priority:** P0 (MVP - Phase 1B)
**Story Points:** L (Large)
**Complexity:** L (4-5 days)
**Type:** backend

**State:** blocked
**Primary PRD:** `docs/1-BASELINE/product/modules/shipping.md` (FR-7.12, FR-7.16, FR-7.18)
**Architecture:** `docs/1-BASELINE/architecture/modules/shipping.md` (lines 128-139, 332-334, 664-694, 790-819)

---

## BLOCKER ALERT

**HARD DEPENDENCY:** This story is BLOCKED by Epic 05 (Warehouse Module) Phase 0 completion.

**Required from Epic 05:**
- `license_plates` table with status, qa_status, expiry_date, quantity columns
- `lp_reservations` table for inventory reservation tracking
- License plate status workflow (available -> reserved -> consumed)
- FIFO/FEFO query patterns established

**Cannot start until:** Epic 05.1-05.4 (LP Foundation) stories are complete.

---

## MVP Scope

This story implements the core inventory allocation engine that reserves License Plates (LPs) against confirmed sales order lines using FIFO or FEFO strategies. It is a critical component enabling the pick/pack/ship workflow.

**Key functionality:**
- `inventory_allocations` table linking SO lines to reserved LPs
- AllocationService with FIFO/FEFO allocation algorithm
- Auto-allocation trigger on SO confirmation (configurable)
- Manual allocation endpoint for manager override
- Allocation release (cancel/deallocate)
- Backorder signal creation when insufficient inventory
- Allocation view component for SO detail page

**Status workflow impact:** confirmed -> allocated (when all lines >= threshold)

---

## Dependencies

### Epic Dependencies (BLOCKERS)
- **Epic 05.1** - License Plates table schema (status, qa_status, expiry_date)
- **Epic 05.3** - LP Reservations table and reservation logic
- **Epic 05.4** - FIFO/FEFO query patterns
- **Epic 01.1** - Org context, RLS, users table
- **Epic 02.1** - Products table (for SO line product lookup)
- **Epic 02.2** - Product settings (shelf_life, picking_strategy)

### Story Dependencies (within Epic 07)
- **Story 07.2** - Sales Orders CRUD (provides sales_orders, sales_order_lines tables)
- **Story 07.3** - SO Status Workflow (provides status transitions)

### Provides To
- **Story 07.8** - Pick List Generation (uses allocations to create pick lines)
- **Story 07.15** - Shipping Dashboard (backorder alerts)
- **Epic 03** - Planning Module (backorder signals for MRP/PO creation)

---

## Goal

Enable automatic and manual inventory allocation from available License Plates to confirmed sales order lines using FIFO/FEFO strategies, with backorder handling for insufficient inventory.

## User Story

As a **Warehouse Manager**, I want **inventory to be automatically allocated from available License Plates when a sales order is confirmed** so that **I can ensure correct stock is reserved and any shortages are immediately visible as backorders**.

## Scope

**In scope (this story)**
- `inventory_allocations` table (sales_order_line_id, license_plate_id, quantity_allocated, quantity_picked)
- `POST /api/shipping/sales-orders/:id/allocate` endpoint (manual allocation)
- `POST /api/shipping/sales-orders/:id/release-allocation` endpoint (release/cancel)
- `GET /api/shipping/sales-orders/:id/allocations` endpoint (view allocations)
- AllocationService with:
  - `allocate(soId)` - allocate all lines
  - `allocateLine(soLineId)` - allocate single line
  - `releaseAllocation(soId)` - release all allocations
  - `releaseLineAllocation(soLineId)` - release single line allocation
- FIFO allocation logic: ORDER BY created_at ASC
- FEFO allocation logic: ORDER BY expiry_date ASC, created_at ASC
- Product-level picking strategy setting (from Epic 02 product settings)
- Partial allocation support (allocate what's available)
- Backorder flag when quantity_allocated < quantity_ordered
- SO status transition: confirmed -> allocated (when allocation_threshold met)
- AllocationView component for SO detail page
- Auto-allocation trigger on SO confirm (configurable setting)
- Concurrency handling with SELECT FOR UPDATE
- Transaction rollback on partial failure

**Out of scope (this story)**
- Lot-specific allocation (Story 07.8 - uses requested_lot field)
- Cross-dock allocation (Phase 2)
- Multi-warehouse allocation (Phase 2)
- Wave allocation optimization (Phase 2)
- Allocation priority queues (Phase 2)

---

## Architecture Design Decisions (ADRs)

### ADR-07.7.1: FIFO vs FEFO Selection Strategy

**Context:** Products may need different picking strategies based on shelf life.

**Decision:** Use product-level `picking_strategy` field (FIFO or FEFO).
- Default: FIFO for all products
- Override: FEFO for products with `shelf_life_days IS NOT NULL`
- Query: `SELECT picking_strategy FROM products WHERE id = :product_id`

**Alternatives:**
| Option | Pros | Cons |
|--------|------|------|
| Global setting | Simple | No product flexibility |
| Product-level | Per-product control | More queries |
| Customer-level | Customer preferences | Complex, rare use case |

**Consequences:** Query products table for each line allocation (cacheable).

### ADR-07.7.2: Partial Allocation Policy

**Context:** What happens when insufficient inventory exists?

**Decision:** Allow partial allocation with 80% threshold for status transition.
- Allocate whatever is available
- Set `backorder_flag = true` on SO line if quantity_allocated < quantity_ordered
- SO status -> 'allocated' ONLY IF all lines have quantity_allocated >= 80% of quantity_ordered
- Dashboard alert for partial allocations

**Alternatives:**
| Option | Pros | Cons |
|--------|------|------|
| 100% required | Clean | Blocks orders |
| Any partial OK | Flexible | May ship incomplete |
| Configurable threshold | Best of both | More settings |

**Consequences:** Org-level setting `allocation_threshold_pct` (default 80%).

### ADR-07.7.3: Backorder Creation Policy

**Context:** Should backorders automatically trigger PO/production signals?

**Decision:** Create backorder record, defer PO/production linkage.
- Create `backorder_records` entry (or flag on SO line)
- Publish event `backorder.created` for Planning module consumption
- No automatic PO creation in shipping module

**Alternatives:**
| Option | Pros | Cons |
|--------|------|------|
| Auto-create PO | End-to-end | Tight coupling, may over-order |
| Manual review | Control | Slower response |
| Event-based | Decoupled | Requires Planning module |

**Consequences:** Planning module (Epic 03) will subscribe to backorder events.

### ADR-07.7.4: Allocation Locking Strategy

**Context:** Prevent race conditions when multiple users allocate simultaneously.

**Decision:** Use pessimistic locking with `SELECT ... FOR UPDATE`.
- Lock LP rows during allocation transaction
- Timeout after 5 seconds to prevent deadlocks
- Retry logic (3 attempts with exponential backoff)

**Alternatives:**
| Option | Pros | Cons |
|--------|------|------|
| Optimistic (version) | Better concurrency | Conflicts require retry |
| Pessimistic (locks) | No conflicts | Potential deadlocks |
| Queue-based | Serialized | Latency |

**Consequences:** Single allocation transaction at a time per LP pool.

### ADR-07.7.5: Concurrent Allocation Conflict Resolution

**Context:** Two users allocating same product simultaneously.

**Decision:** First-commit wins with user notification.
- Transaction isolation level: SERIALIZABLE
- If LP already reserved, skip and try next LP
- Return allocation result with any skipped LPs noted
- User sees "Some items allocated by another user" warning

**Consequences:** Allocation results may vary based on timing.

---

## Allocation Algorithm

### FIFO/FEFO Allocation Pseudocode

```
FUNCTION allocateSalesOrder(soId: UUID) -> AllocationResult:
    BEGIN TRANSACTION (SERIALIZABLE)

    so = getSalesOrder(soId)
    IF so.status != 'confirmed':
        ROLLBACK
        RETURN Error("Order must be confirmed before allocation")

    results = []

    FOR EACH line IN so.lines:
        lineResult = allocateLine(line)
        results.append(lineResult)

    // Calculate allocation status
    allocationMetrics = calculateAllocationMetrics(results)

    IF allocationMetrics.fulfilledPercentage >= org.allocation_threshold_pct:
        so.status = 'allocated'
    ELSE:
        createBackorderAlert(so, allocationMetrics.shortfall)

    COMMIT TRANSACTION
    RETURN AllocationResult(results, allocationMetrics)


FUNCTION allocateLine(soLine: SalesOrderLine) -> LineAllocationResult:
    remainingQty = soLine.quantity_ordered - soLine.quantity_allocated
    IF remainingQty <= 0:
        RETURN AlreadyFullyAllocated()

    product = getProduct(soLine.product_id)
    pickingStrategy = product.picking_strategy ?? 'FIFO'

    // Query available License Plates
    availableLPs = SELECT * FROM license_plates
        WHERE product_id = soLine.product_id
          AND status = 'available'
          AND qa_status = 'passed'
          AND quantity > 0
          AND org_id = :orgId
        ORDER BY
            CASE WHEN pickingStrategy = 'FEFO'
                THEN (expiry_date, created_at)
                ELSE (created_at, expiry_date)
            END ASC
        FOR UPDATE SKIP LOCKED  -- Skip already-locked LPs
        LIMIT 100  -- Process in batches

    allocatedQty = 0
    allocations = []

    FOR EACH lp IN availableLPs:
        IF allocatedQty >= remainingQty:
            BREAK

        qtyToAllocate = MIN(lp.quantity, remainingQty - allocatedQty)

        // Create allocation record
        allocation = INSERT INTO inventory_allocations (
            org_id, sales_order_line_id, license_plate_id,
            quantity_allocated, allocated_at, allocated_by
        ) VALUES (...)

        // Update LP status
        IF qtyToAllocate == lp.quantity:
            UPDATE license_plates SET status = 'reserved' WHERE id = lp.id
        ELSE:
            // Partial allocation - LP remains available with reduced qty
            // Note: Actual qty reduction handled by lp_reservations table
            INSERT INTO lp_reservations (lp_id, so_line_id, reserved_qty, status)
            VALUES (lp.id, soLine.id, qtyToAllocate, 'active')

        allocatedQty += qtyToAllocate
        allocations.append(allocation)

    // Update SO line quantity_allocated
    UPDATE sales_order_lines
        SET quantity_allocated = quantity_allocated + allocatedQty
        WHERE id = soLine.id

    // Check for backorder
    IF allocatedQty < remainingQty:
        backorderQty = remainingQty - allocatedQty
        PUBLISH event 'backorder.created' (soLine, backorderQty)
        SET soLine.backorder_flag = true

    RETURN LineAllocationResult(allocations, allocatedQty, backorderQty)
```

### Allocation Flow Diagram (ASCII)

```
+---------------------+
|   SO Confirmed      |
|   (trigger)         |
+----------+----------+
           |
           v
+---------------------+
|   Validate SO       |
|   status='confirmed'|
+----------+----------+
           |
           v
+---------------------+
|   For Each SO Line  |<------------------+
+----------+----------+                   |
           |                              |
           v                              |
+---------------------+                   |
| Get Product         |                   |
| picking_strategy    |                   |
+----------+----------+                   |
           |                              |
           v                              |
+---------------------+                   |
| Query Available LPs |                   |
| WHERE:              |                   |
| - product_id match  |                   |
| - status='available'|                   |
| - qa_status='passed'|                   |
| ORDER BY FIFO/FEFO  |                   |
| FOR UPDATE SKIP     |                   |
+----------+----------+                   |
           |                              |
           v                              |
+---------------------+                   |
| Loop: Allocate from |                   |
| LPs until qty met   |                   |
| or no more LPs      |                   |
+----------+----------+                   |
           |                              |
           v                              |
+---------------------+     +-------------+
| Create allocation   |     |             |
| records             |     |             |
| Update LP status    |---->| Next Line   |
| Update SO line qty  |     |             |
+----------+----------+     +-------------+
           |
           v
+---------------------+
| qty_allocated <     |    Yes     +------------------+
| qty_ordered?        |----------->| Create Backorder |
+----------+----------+            | Signal           |
           | No                    +------------------+
           v
+---------------------+
| All lines >= 80%?   |    Yes     +------------------+
| allocated           |----------->| SO status =      |
+----------+----------+            | 'allocated'      |
           | No                    +------------------+
           v
+---------------------+
| Keep status         |
| 'confirmed'         |
| Dashboard alert     |
+---------------------+
```

### Allocation Release Flow

```
+---------------------+
|   Release Request   |
|   (SO or Line)      |
+----------+----------+
           |
           v
+---------------------+
|   Get allocations   |
|   for SO/Line       |
+----------+----------+
           |
           v
+---------------------+
|   For Each          |
|   Allocation        |<------------------+
+----------+----------+                   |
           |                              |
           v                              |
+---------------------+                   |
| Delete allocation   |                   |
| record              |                   |
+----------+----------+                   |
           |                              |
           v                              |
+---------------------+                   |
| Update LP status    |                   |
| reserved->available |---->| Next Alloc  |
+----------+----------+     +-------------+
           |
           v
+---------------------+
| Update SO line      |
| quantity_allocated=0|
+----------+----------+
           |
           v
+---------------------+
| SO status ->        |
| 'confirmed'         |
+---------------------+
```

---

## Edge Cases and Error Handling

### Edge Case 1: Expired License Plates

**Scenario:** LP expiry_date is in the past during allocation.
**Handling:**
- Exclude LPs where `expiry_date < CURRENT_DATE`
- If FEFO and all remaining LPs expired, create backorder
- Consider adding `expiry_date > CURRENT_DATE + :buffer_days` for safety margin

### Edge Case 2: QA Hold License Plates

**Scenario:** LP qa_status changes to 'failed' or 'quarantine' after allocation.
**Handling:**
- Allocation only considers `qa_status = 'passed'`
- If LP status changes after allocation, trigger re-allocation check
- Dashboard alert for "Allocated LP now on QA hold"

### Edge Case 3: Insufficient Inventory

**Scenario:** No available LPs for a product.
**Handling:**
- Create backorder for full quantity
- SO status remains 'confirmed' (not 'allocated')
- Dashboard shows "Insufficient inventory" alert
- Optional: Publish event for Planning module to suggest PO

### Edge Case 4: Concurrent Allocation Conflict

**Scenario:** Two users allocate same product simultaneously.
**Handling:**
- `FOR UPDATE SKIP LOCKED` prevents deadlocks
- If LP locked by another transaction, skip to next LP
- If no LPs available after skipping, partial allocation
- Return warning: "Some items allocated by concurrent user"

### Edge Case 5: SO Cancelled After Allocation

**Scenario:** SO cancelled while allocations exist.
**Handling:**
- Cancel triggers `releaseAllocation(soId)`
- All allocation records deleted
- LP statuses reset to 'available'
- SO line quantity_allocated reset to 0
- Handled in Story 07.5 (SO Cancellation)

### Edge Case 6: Product Without Picking Strategy

**Scenario:** `products.picking_strategy` is NULL.
**Handling:**
- Default to FIFO
- Log warning for configuration review

### Edge Case 7: Zero Quantity LP

**Scenario:** LP exists but quantity = 0 (already consumed).
**Handling:**
- Exclude in WHERE clause: `quantity > 0`
- Should not occur if LP lifecycle managed correctly

---

## Performance Considerations

### Index Strategy

```sql
-- Primary allocation query (CRITICAL)
CREATE INDEX idx_lp_allocation_query ON license_plates (
    org_id,
    product_id,
    status,
    qa_status,
    expiry_date,
    created_at
) WHERE status = 'available' AND qa_status = 'passed';

-- Allocation lookup by SO line
CREATE INDEX idx_allocations_so_line ON inventory_allocations (
    sales_order_line_id
);

-- Allocation lookup by LP
CREATE INDEX idx_allocations_lp ON inventory_allocations (
    license_plate_id
);

-- LP reservation lookup
CREATE INDEX idx_lp_reservations_lp ON lp_reservations (
    lp_id, status
) WHERE status = 'active';
```

### Batch Processing

- Process SO lines in batches of 10
- Query up to 100 LPs per product at a time
- Commit partial results every 50 allocations
- Allow resume from last committed point on failure

### Expected Performance

| Operation | Target | Notes |
|-----------|--------|-------|
| Single line allocation | < 200ms | With index |
| 10-line SO allocation | < 1s | Typical order |
| 50-line SO allocation | < 5s | Large order |
| Release allocation | < 500ms | Simple DELETE |
| Allocation view query | < 200ms | With joins |

### Caching Strategy

```typescript
// Redis keys
'org:{orgId}:allocation:in_progress:{soId}'   // Lock key (5 min TTL)
'org:{orgId}:product:{productId}:picking_strategy'  // 24 hour TTL
'org:{orgId}:settings:allocation_threshold'   // 1 hour TTL
```

---

## Acceptance Criteria (Given/When/Then)

### AC-1: Auto-Allocation on SO Confirmation

**Given** a confirmed SO with 3 lines (Product A: 100, Product B: 50, Product C: 25)
**And** sufficient available LPs for all products
**When** auto-allocation setting is enabled
**Then** allocation runs immediately after confirmation
**And** quantity_allocated equals quantity_ordered for all lines
**And** SO status changes to 'allocated'

### AC-2: FIFO Allocation Order

**Given** Product A has 3 available LPs:
  - LP-001: created 2025-01-01, qty 50
  - LP-002: created 2025-01-15, qty 50
  - LP-003: created 2025-01-20, qty 50
**And** picking_strategy = 'FIFO'
**When** SO line for 80 units of Product A is allocated
**Then** LP-001 is fully allocated (50 units)
**Then** LP-002 is partially allocated (30 units)
**And** LP-003 is not allocated

### AC-3: FEFO Allocation Order

**Given** Product B has 3 available LPs:
  - LP-101: expiry 2025-06-01, qty 50
  - LP-102: expiry 2025-03-01, qty 50
  - LP-103: expiry 2025-04-15, qty 50
**And** picking_strategy = 'FEFO'
**When** SO line for 80 units of Product B is allocated
**Then** LP-102 (earliest expiry) is fully allocated (50 units)
**Then** LP-103 is partially allocated (30 units)
**And** LP-101 is not allocated

### AC-4: Partial Allocation Creates Backorder

**Given** SO line for 100 units of Product C
**And** only 60 units available across all LPs
**When** allocation runs
**Then** quantity_allocated = 60
**And** backorder_flag = true on SO line
**And** backorder.created event published with shortfall = 40
**And** SO status remains 'confirmed' (below 80% threshold)

### AC-5: Manual Allocation Endpoint

**Given** SO in 'confirmed' status with no allocations
**And** user has Manager role
**When** POST /api/shipping/sales-orders/:id/allocate called
**Then** allocation runs for all lines
**And** allocation results returned with per-line breakdown

**Given** user has Viewer role
**When** POST /api/shipping/sales-orders/:id/allocate called
**Then** 403 Forbidden returned

### AC-6: Release Allocation

**Given** SO with allocations (3 LPs reserved)
**When** POST /api/shipping/sales-orders/:id/release-allocation called
**Then** all allocation records deleted
**And** LP statuses reset to 'available'
**And** SO line quantity_allocated reset to 0
**And** SO status reset to 'confirmed'

### AC-7: Allocation View API

**Given** SO with allocations
**When** GET /api/shipping/sales-orders/:id/allocations called
**Then** response includes:
  - Per-line allocations with LP details
  - Total allocated vs ordered per line
  - Backorder quantities
  - Allocation timestamps and users

### AC-8: Allocation View Component

**Given** user views SO detail page
**And** SO has allocations
**When** 'Allocations' tab clicked
**Then** AllocationView component displays:
  - Lines table with allocated LPs nested
  - LP barcode, location, lot, expiry for each allocation
  - Quantity allocated from each LP
  - Status indicators (fully/partially allocated)
  - Backorder warnings

### AC-9: Exclude QA-Failed and Expired LPs

**Given** available LPs include:
  - LP-201: qa_status = 'passed', expiry = future (VALID)
  - LP-202: qa_status = 'failed' (INVALID)
  - LP-203: qa_status = 'quarantine' (INVALID)
  - LP-204: expiry_date = yesterday (INVALID)
**When** allocation runs
**Then** only LP-201 is considered for allocation

### AC-10: Concurrent Allocation Protection

**Given** two users trigger allocation for different SOs
**Both** SOs need Product A
**And** only 50 units available
**When** both allocations run simultaneously
**Then** one SO gets allocation, other gets backorder
**And** no duplicate allocation of same LP quantity
**And** no deadlock occurs

### AC-11: Allocation Threshold Configuration

**Given** org setting allocation_threshold_pct = 80%
**And** SO with line for 100 units
**When** 75 units allocated (75%)
**Then** SO status remains 'confirmed'
**And** dashboard shows 'Under-allocated' alert

**Given** 85 units allocated (85%)
**When** allocation completes
**Then** SO status changes to 'allocated'

### AC-12: Re-allocation After Release

**Given** SO with full allocation
**When** release-allocation called
**And** allocate called again
**Then** new allocation runs fresh
**And** may allocate different LPs (based on current availability)

---

## Implementation Notes

### API Endpoints

```typescript
// POST /api/shipping/sales-orders/:id/allocate
// Trigger allocation for confirmed SO
interface AllocateRequest {
  force?: boolean;  // Re-allocate even if already allocated
}

interface AllocateResponse {
  success: boolean;
  so_status: 'confirmed' | 'allocated';
  lines: {
    line_id: UUID;
    product_id: UUID;
    product_name: string;
    quantity_ordered: number;
    quantity_allocated: number;
    backorder_qty: number;
    allocations: {
      allocation_id: UUID;
      lp_id: UUID;
      lp_number: string;
      location: string;
      lot_number: string;
      expiry_date: Date | null;
      quantity_allocated: number;
    }[];
  }[];
  total_ordered: number;
  total_allocated: number;
  fulfillment_pct: number;
  warnings: string[];  // e.g., "Concurrent allocation detected"
}

// POST /api/shipping/sales-orders/:id/release-allocation
interface ReleaseAllocationResponse {
  success: boolean;
  so_status: 'confirmed';
  released_count: number;  // Number of allocation records deleted
  lps_released: number;    // Number of LPs returned to available
}

// GET /api/shipping/sales-orders/:id/allocations
interface AllocationViewResponse {
  so_id: UUID;
  so_status: string;
  lines: {
    line_id: UUID;
    line_number: number;
    product: {
      id: UUID;
      name: string;
      sku: string;
    };
    quantity_ordered: number;
    quantity_allocated: number;
    quantity_picked: number;
    backorder_flag: boolean;
    backorder_qty: number;
    allocations: {
      id: UUID;
      license_plate: {
        id: UUID;
        lp_number: string;
        location: {
          id: UUID;
          name: string;
          zone: string;
        };
        lot_number: string | null;
        expiry_date: Date | null;
        qa_status: string;
      };
      quantity_allocated: number;
      quantity_picked: number;
      allocated_at: Date;
      allocated_by: {
        id: UUID;
        name: string;
      };
    }[];
  }[];
  summary: {
    total_lines: number;
    fully_allocated_lines: number;
    partial_allocated_lines: number;
    unallocated_lines: number;
    total_quantity_ordered: number;
    total_quantity_allocated: number;
    fulfillment_pct: number;
  };
}
```

### Database

```sql
-- inventory_allocations table
CREATE TABLE inventory_allocations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id),
  sales_order_line_id UUID NOT NULL REFERENCES sales_order_lines(id) ON DELETE CASCADE,
  license_plate_id UUID NOT NULL REFERENCES license_plates(id),
  quantity_allocated DECIMAL(15,4) NOT NULL CHECK (quantity_allocated > 0),
  quantity_picked DECIMAL(15,4) DEFAULT 0 CHECK (quantity_picked >= 0),
  allocated_at TIMESTAMPTZ DEFAULT now(),
  allocated_by UUID REFERENCES users(id),
  released_at TIMESTAMPTZ,  -- NULL if active, set when released

  UNIQUE(sales_order_line_id, license_plate_id)  -- Prevent duplicate allocation
);

-- Indexes
CREATE INDEX idx_inventory_allocations_so_line ON inventory_allocations(sales_order_line_id);
CREATE INDEX idx_inventory_allocations_lp ON inventory_allocations(license_plate_id);
CREATE INDEX idx_inventory_allocations_org_active ON inventory_allocations(org_id)
  WHERE released_at IS NULL;

-- RLS Policy
ALTER TABLE inventory_allocations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "inventory_allocations_org_isolation" ON inventory_allocations
  FOR ALL USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- Add backorder_flag to sales_order_lines
ALTER TABLE sales_order_lines ADD COLUMN IF NOT EXISTS backorder_flag BOOLEAN DEFAULT false;

-- Add allocation settings to org or shipping_settings table
-- Option 1: Add to organizations table
ALTER TABLE organizations ADD COLUMN IF NOT EXISTS allocation_threshold_pct DECIMAL(5,2) DEFAULT 80.00;
ALTER TABLE organizations ADD COLUMN IF NOT EXISTS auto_allocate_on_confirm BOOLEAN DEFAULT true;

-- Option 2: Create shipping_settings table (preferred)
CREATE TABLE IF NOT EXISTS shipping_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) UNIQUE,
  auto_allocate_on_confirm BOOLEAN DEFAULT true,
  allocation_threshold_pct DECIMAL(5,2) DEFAULT 80.00,
  default_picking_strategy TEXT DEFAULT 'FIFO',  -- FIFO or FEFO
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
```

### Frontend Components

```
apps/frontend/app/(authenticated)/shipping/
  sales-orders/
    [id]/
      page.tsx               -- Add Allocations tab
      components/
        AllocationTab.tsx    -- Tab container
        AllocationView.tsx   -- Main allocation display
        AllocationTable.tsx  -- Lines with nested LP allocations
        AllocationActions.tsx -- Allocate/Release buttons
        AllocationProgress.tsx -- Progress bar per line
        BackorderAlert.tsx   -- Warning banner for backorders
```

### Services

```typescript
// lib/services/allocation-service.ts
export class AllocationService {
  // Main allocation methods
  async allocateSalesOrder(soId: string, options?: AllocateOptions): Promise<AllocationResult>;
  async allocateLine(soLineId: string): Promise<LineAllocationResult>;

  // Release methods
  async releaseAllocation(soId: string): Promise<ReleaseResult>;
  async releaseLineAllocation(soLineId: string): Promise<ReleaseResult>;

  // Query methods
  async getAllocations(soId: string): Promise<AllocationViewResponse>;
  async getLineAllocations(soLineId: string): Promise<LineAllocation[]>;

  // Helper methods
  async getAvailableLPs(productId: string, strategy: 'FIFO' | 'FEFO', limit?: number): Promise<LP[]>;
  async getPickingStrategy(productId: string): Promise<'FIFO' | 'FEFO'>;
  async getAllocationThreshold(orgId: string): Promise<number>;

  // Metrics
  calculateFulfillmentPct(lines: SOLine[]): number;
  calculateBackorderQty(line: SOLine): number;
}

// lib/services/backorder-service.ts
export class BackorderService {
  async createBackorderSignal(soLineId: string, shortfallQty: number): Promise<void>;
  async getBackorders(orgId: string, filters?: BackorderFilters): Promise<Backorder[]>;
}
```

### Validation (Zod)

```typescript
// lib/validation/allocation-schema.ts
const allocateRequestSchema = z.object({
  force: z.boolean().optional().default(false),
});

const releaseAllocationRequestSchema = z.object({
  // No body required
});

const allocationLineSchema = z.object({
  line_id: z.string().uuid(),
  quantity_allocated: z.number().positive(),
  allocations: z.array(z.object({
    lp_id: z.string().uuid(),
    quantity: z.number().positive(),
  })),
});
```

### Key Business Rules

1. **Allocation Prerequisites:**
   - SO must be in 'confirmed' status
   - SO cannot already be in 'allocated' or later status (unless force=true)
   - User must have Manager+ role

2. **LP Eligibility:**
   - status = 'available'
   - qa_status = 'passed'
   - quantity > 0
   - expiry_date > CURRENT_DATE (if set)
   - Same org_id as SO

3. **Allocation Strategy:**
   - FIFO: oldest created_at first
   - FEFO: earliest expiry_date first, then created_at
   - Strategy determined by product.picking_strategy

4. **Partial Allocation:**
   - Allocate available quantity, create backorder for remainder
   - Update sales_order_lines.quantity_allocated
   - Set backorder_flag = true if short

5. **Status Transition:**
   - confirmed -> allocated: when all lines >= allocation_threshold_pct
   - allocated -> confirmed: when allocation released

6. **Concurrency:**
   - SELECT FOR UPDATE SKIP LOCKED on LP rows
   - Transaction isolation: SERIALIZABLE
   - Retry logic: 3 attempts, exponential backoff

7. **Cascade Effects:**
   - SO cancel -> release all allocations
   - SO line delete -> release line allocations
   - LP status change -> may trigger reallocation check

---

## Deliverables

- `inventory_allocations` table with RLS policies
- `shipping_settings` table for org-level allocation settings
- `backorder_flag` column on sales_order_lines
- API route: POST /api/shipping/sales-orders/:id/allocate
- API route: POST /api/shipping/sales-orders/:id/release-allocation
- API route: GET /api/shipping/sales-orders/:id/allocations
- AllocationService with FIFO/FEFO logic
- BackorderService for backorder signal creation
- AllocationView component for SO detail page
- Unit tests for AllocationService (>90% coverage)
- Integration tests for API endpoints
- Concurrency tests for allocation conflicts
- E2E test: Confirm SO -> Auto-allocate -> View allocations

---

## Definition of Done

- [ ] inventory_allocations table created with RLS policies
- [ ] shipping_settings table created for org configuration
- [ ] FIFO allocation orders LPs by created_at ASC
- [ ] FEFO allocation orders LPs by expiry_date ASC, created_at ASC
- [ ] Product picking_strategy determines FIFO vs FEFO
- [ ] Partial allocation sets backorder_flag on SO line
- [ ] SO status transitions to 'allocated' when threshold met
- [ ] Manual allocate endpoint works for Manager+ role
- [ ] Release allocation resets LP status and SO line quantities
- [ ] Allocation view API returns nested LP details
- [ ] AllocationView component displays in SO detail page
- [ ] Expired and QA-failed LPs excluded from allocation
- [ ] SELECT FOR UPDATE prevents concurrent allocation conflicts
- [ ] Transaction rollback on partial failure
- [ ] Backorder.created event published for Planning module
- [ ] Unit tests cover allocation algorithm (>90% coverage)
- [ ] Integration tests cover API endpoints
- [ ] Concurrency tests verify no duplicate allocations
- [ ] E2E test: Full allocation workflow

---

## Future Phases (Not in This Story)

### Phase 1B Extensions

- **Story 07.8: Lot-Specific Allocation**
  - Honor sales_order_lines.requested_lot field
  - Override FIFO/FEFO to allocate specific lot first

### Phase 2

- **Cross-Dock Allocation**
  - Allocate from incoming POs (not yet received)
  - Link ASN to SO allocation

- **Multi-Warehouse Allocation**
  - Allocate from multiple warehouses
  - Distance/cost optimization

- **Wave Allocation Optimization**
  - Batch allocations for multiple SOs
  - Optimize pick paths during allocation

- **Allocation Priority Queues**
  - Priority customers get allocation first
  - Rush order handling

### Phase 3

- **Real-Time Inventory Sync**
  - WebSocket updates when LPs change
  - Re-allocation suggestions

- **Predictive Allocation**
  - Reserve inventory before SO confirmed
  - Based on historical patterns

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-12-16 | Initial story for Epic 07 Phase 1B | ARCHITECT-AGENT |
