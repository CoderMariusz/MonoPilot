# 07.23 - Customer Pricing Agreements

**Story ID:** 07.23
**Epic:** 07 - Shipping
**Phase:** 3
**Complexity:** M (Medium)
**Estimate:** 4-5 days
**Type:** Backend + Frontend
**Priority:** P2
**State:** ready

**Primary PRD:** `docs/1-BASELINE/product/modules/shipping.md` (FR-7.8)
**UX Wireframes:** TBD (SHIP-023)

## PRD References

| FR ID | Requirement | Priority | Phase | Covered |
|-------|-------------|----------|-------|---------|
| FR-7.8 | Customer Pricing Agreements | P2 | 3 | Yes |

## User Story

**As a** sales manager,
**I want** to define customer-specific pricing agreements with volume discounts and effective dates,
**So that** sales clerks can automatically apply negotiated prices to sales orders without manual lookup.

**As a** sales clerk,
**I want** SO line prices to auto-populate from customer pricing agreements,
**So that** I can quickly create accurate quotes without remembering special pricing for each customer.

## Goal

Implement customer pricing agreements to enable customer-specific pricing per product, volume-based discounts, contract pricing with effective date ranges, and pricing agreement templates. Agreements automatically integrate with SO line pricing, providing the price lookup hierarchy: Customer Agreement > Product Standard Price > Manual Entry.

## Scope

**In scope:**
- Customer pricing agreements CRUD (contract name, effective dates, status)
- Agreement line items (product, price, min/max qty, discount type)
- Volume discount tiers (price breaks based on quantity)
- Agreement effective date validation (from/to dates)
- Agreement status workflow (draft, active, expired, cancelled)
- Agreement templates (save/apply to multiple customers)
- Integration with SO line pricing (auto-lookup from agreement)
- Agreement overlap prevention (same product, same date range)
- Price history tracking per agreement

**Out of scope:**
- Multi-currency pricing (Phase 4)
- Customer tiering (Gold/Silver/Bronze) (Phase 4)
- Price approval workflows (Phase 4)
- EDI price catalog integration (Phase 4)
- Promotional pricing campaigns (Phase 4)
- Cost-plus margin pricing (Phase 4)

## Dependencies

| Story | Requirement | Status |
|-------|-------------|--------|
| 07.1 | Customers CRUD | Required - provides customers table |
| 07.2 | Sales Orders Core | Required - SO line integration |
| 02.1 | Products CRUD | Required - products.std_price |
| 07.4 | SO Line Pricing | Required - getProductPrice() integration |

## Acceptance Criteria (Given/When/Then)

### Pricing Agreement CRUD (FR-7.8)

#### Create Agreement
- GIVEN sales manager navigates to customer detail > Pricing tab, WHEN "Add Agreement" clicked, THEN agreement form modal opens with fields: name, effective_from, effective_to, status, notes.
- GIVEN valid agreement data entered (name: "2026 Annual Contract", effective_from: 2026-01-01, effective_to: 2026-12-31), WHEN "Create" clicked, THEN agreement is created with status "draft".
- GIVEN agreement name is empty, WHEN form submitted, THEN error "Agreement name is required" displays.
- GIVEN effective_from > effective_to, WHEN form submitted, THEN error "End date must be after start date" displays.

#### Agreement Line Items
- GIVEN agreement exists, WHEN sales manager clicks "Add Item", THEN item form displays: product selector, unit_price, min_qty, max_qty, discount (optional).
- GIVEN item with product_id = "PROD001", unit_price = 9.50, min_qty = 1, max_qty = 99, WHEN saved, THEN item appears in agreement lines list.
- GIVEN item with min_qty = 100, max_qty = 499, unit_price = 9.00, WHEN saved, THEN volume tier created for qty 100-499.
- GIVEN item with max_qty < min_qty, WHEN form submitted, THEN error "Max quantity must be >= min quantity" displays.
- GIVEN item for product already exists in agreement with overlapping qty range, WHEN form submitted, THEN error "Quantity range overlaps existing item" displays.

#### Volume Discount Tiers
- GIVEN agreement with 3 tiers for product PROD001:
  - Tier 1: qty 1-99, price $10.00
  - Tier 2: qty 100-499, price $9.50
  - Tier 3: qty 500+, price $9.00
- WHEN SO line for 150 units created, THEN unit_price = $9.50 (Tier 2 applied).
- GIVEN SO line with qty = 600, WHEN price lookup executed, THEN unit_price = $9.00 (Tier 3 applied).
- GIVEN agreement line with max_qty = NULL, WHEN qty 1000 requested, THEN tier applies (unlimited upper bound).

#### Agreement Status Workflow
- GIVEN agreement with status "draft", WHEN sales manager clicks "Activate", THEN status changes to "active".
- GIVEN agreement with status "active", WHEN effective_to date passes, THEN status automatically changes to "expired" (via scheduled job or on-demand check).
- GIVEN agreement with status "active", WHEN "Cancel" clicked, THEN confirmation dialog displays; on confirm, status = "cancelled".
- GIVEN cancelled agreement, WHEN SO created, THEN agreement prices NOT applied (skipped in lookup).
- GIVEN expired agreement, WHEN new SO created after effective_to, THEN agreement prices NOT applied.

#### Agreement Effective Dates
- GIVEN agreement effective_from = 2026-01-01, effective_to = 2026-12-31, WHEN SO created on 2026-06-15, THEN agreement prices applied.
- GIVEN agreement effective_from = 2026-01-01, WHEN SO created on 2025-12-15, THEN agreement prices NOT applied (before start date).
- GIVEN agreement effective_from = 2026-01-01, effective_to = 2026-06-30, WHEN SO created on 2026-07-01, THEN agreement prices NOT applied (after end date).

#### Overlap Prevention
- GIVEN customer has active agreement for product PROD001 (2026-01-01 to 2026-12-31), WHEN creating new agreement for same product with dates 2026-06-01 to 2027-06-01, THEN error "Agreement overlaps existing agreement for this product" displays.
- GIVEN customer has agreement expiring 2026-06-30, WHEN new agreement starts 2026-07-01, THEN NO error (no overlap - sequential).
- GIVEN multiple agreements exist, WHEN calculating price, THEN system uses agreement with latest effective_from date that is valid.

### Integration with SO Line Pricing

#### Price Lookup Hierarchy
- GIVEN customer has active pricing agreement for product PROD001, WHEN SO line created for PROD001, THEN unit_price auto-populates from agreement (not products.std_price).
- GIVEN customer has NO pricing agreement for product PROD002, WHEN SO line created for PROD002, THEN unit_price auto-populates from products.std_price.
- GIVEN customer has agreement but it's expired, WHEN SO line created, THEN unit_price from products.std_price (agreement skipped).
- GIVEN multiple valid agreements exist (edge case - should be prevented), WHEN price lookup, THEN most specific agreement used (latest effective_from).

#### Volume Tier Application
- GIVEN SO line for product with volume tiers, WHEN quantity = 50, THEN Tier 1 price applied.
- GIVEN SO line quantity changes from 50 to 150, WHEN line saved, THEN price recalculates to Tier 2.
- GIVEN no tier matches qty (e.g., min_qty = 10, user orders 5), WHEN price lookup, THEN fallback to products.std_price with warning.

#### Manual Override
- GIVEN agreement price auto-applied to SO line, WHEN sales clerk manually edits unit_price, THEN override allowed (before SO confirmation).
- GIVEN manual price override applied, WHEN line displayed, THEN "Manual override" indicator shown.
- GIVEN SO status = "confirmed", WHEN price edit attempted, THEN edit blocked (price locked).

### Pricing Agreement Templates

#### Create Template
- GIVEN sales manager on Pricing Agreements list, WHEN "Save as Template" clicked on existing agreement, THEN template form displays: template_name, description.
- GIVEN template name "Standard Volume Pricing" entered, WHEN saved, THEN template created with copy of agreement items.
- GIVEN template exists, WHEN applied to new customer, THEN new agreement created with template items and customer-specific effective dates.

#### Apply Template
- GIVEN customer without pricing agreement, WHEN "Apply Template" clicked, THEN template selector displays all org templates.
- GIVEN template "Standard Volume Pricing" selected, WHEN effective dates entered (2026-01-01 to 2026-12-31), THEN new agreement created for customer with template items.
- GIVEN template has 5 product items, WHEN applied, THEN all 5 items copied to new agreement.

### Audit & History

#### Price History
- GIVEN agreement item price changed from $10.00 to $9.50, WHEN change saved, THEN price history entry created (old_price, new_price, changed_by, changed_at).
- GIVEN SO references agreement line, WHEN agreement line later modified, THEN SO keeps original agreed price (snapshot at creation).
- GIVEN agreement history tab viewed, WHEN loaded, THEN all price changes for agreement displayed chronologically.

### Multi-tenancy

- GIVEN User A from Org A, WHEN querying pricing agreements, THEN only Org A agreements returned.
- GIVEN User A from Org A attempts to view Org B agreement via direct API, WHEN request processed, THEN 404 returned (RLS enforced).

### Permissions

- GIVEN user with role "VIEWER", WHEN viewing customer pricing tab, THEN agreements viewable but Create/Edit/Delete hidden.
- GIVEN user with role "SALES" or "ADMIN", WHEN viewing customer pricing tab, THEN full CRUD actions available.
- GIVEN user with role "PROD_OPERATOR", WHEN accessing pricing agreements, THEN 403 Forbidden returned.

## Technical Specification

### Database Schema

#### customer_pricing_agreements table

```sql
CREATE TABLE customer_pricing_agreements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  customer_id UUID NOT NULL REFERENCES customers(id) ON DELETE CASCADE,

  -- Agreement identification
  agreement_code VARCHAR(50) NOT NULL,
  name VARCHAR(255) NOT NULL,
  description TEXT,

  -- Effective period
  effective_from DATE NOT NULL,
  effective_to DATE,

  -- Status
  status VARCHAR(20) NOT NULL DEFAULT 'draft',
  -- draft, active, expired, cancelled

  -- Template reference (if created from template)
  template_id UUID REFERENCES pricing_agreement_templates(id),

  -- Audit
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES users(id),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  updated_by UUID REFERENCES users(id),
  activated_at TIMESTAMPTZ,
  cancelled_at TIMESTAMPTZ,
  cancelled_by UUID REFERENCES users(id),
  cancellation_reason TEXT,

  -- Constraints
  CONSTRAINT cpa_org_code_unique UNIQUE(org_id, agreement_code),
  CONSTRAINT cpa_status_check CHECK (status IN ('draft', 'active', 'expired', 'cancelled')),
  CONSTRAINT cpa_dates_valid CHECK (effective_to IS NULL OR effective_to >= effective_from)
);

-- Indexes
CREATE INDEX idx_cpa_org_id ON customer_pricing_agreements(org_id);
CREATE INDEX idx_cpa_customer_id ON customer_pricing_agreements(customer_id);
CREATE INDEX idx_cpa_status ON customer_pricing_agreements(status);
CREATE INDEX idx_cpa_effective ON customer_pricing_agreements(effective_from, effective_to);
CREATE INDEX idx_cpa_active_lookup ON customer_pricing_agreements(customer_id, status, effective_from, effective_to)
  WHERE status = 'active';
```

#### customer_pricing_agreement_items table

```sql
CREATE TABLE customer_pricing_agreement_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  agreement_id UUID NOT NULL REFERENCES customer_pricing_agreements(id) ON DELETE CASCADE,

  -- Product reference
  product_id UUID NOT NULL REFERENCES products(id) ON DELETE RESTRICT,

  -- Pricing
  unit_price DECIMAL(15,4) NOT NULL,

  -- Volume tier bounds
  min_qty DECIMAL(15,4) NOT NULL DEFAULT 1,
  max_qty DECIMAL(15,4),  -- NULL = unlimited

  -- Optional discount override
  discount JSONB,  -- {type: 'percent'|'fixed', value: decimal}

  -- Notes
  notes TEXT,

  -- Audit
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES users(id),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  -- Constraints
  CONSTRAINT cpai_qty_valid CHECK (min_qty > 0 AND (max_qty IS NULL OR max_qty >= min_qty)),
  CONSTRAINT cpai_price_positive CHECK (unit_price >= 0)
);

-- Indexes
CREATE INDEX idx_cpai_agreement_id ON customer_pricing_agreement_items(agreement_id);
CREATE INDEX idx_cpai_product_id ON customer_pricing_agreement_items(product_id);
CREATE INDEX idx_cpai_lookup ON customer_pricing_agreement_items(agreement_id, product_id, min_qty, max_qty);
```

#### pricing_agreement_templates table

```sql
CREATE TABLE pricing_agreement_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

  -- Template identification
  template_code VARCHAR(50) NOT NULL,
  name VARCHAR(255) NOT NULL,
  description TEXT,

  -- Status
  is_active BOOLEAN DEFAULT true,

  -- Audit
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES users(id),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  -- Constraints
  CONSTRAINT pat_org_code_unique UNIQUE(org_id, template_code)
);

-- Template items mirror agreement items
CREATE TABLE pricing_agreement_template_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  template_id UUID NOT NULL REFERENCES pricing_agreement_templates(id) ON DELETE CASCADE,
  product_id UUID NOT NULL REFERENCES products(id) ON DELETE RESTRICT,
  unit_price DECIMAL(15,4) NOT NULL,
  min_qty DECIMAL(15,4) NOT NULL DEFAULT 1,
  max_qty DECIMAL(15,4),
  discount JSONB,
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### customer_pricing_history table

```sql
CREATE TABLE customer_pricing_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  agreement_item_id UUID NOT NULL REFERENCES customer_pricing_agreement_items(id) ON DELETE CASCADE,

  -- Change tracking
  old_price DECIMAL(15,4),
  new_price DECIMAL(15,4) NOT NULL,
  old_min_qty DECIMAL(15,4),
  new_min_qty DECIMAL(15,4),
  old_max_qty DECIMAL(15,4),
  new_max_qty DECIMAL(15,4),

  -- Audit
  changed_at TIMESTAMPTZ DEFAULT NOW(),
  changed_by UUID REFERENCES users(id),
  change_reason TEXT
);

CREATE INDEX idx_cph_item_id ON customer_pricing_history(agreement_item_id);
CREATE INDEX idx_cph_changed_at ON customer_pricing_history(changed_at);
```

### RLS Policies

```sql
-- customer_pricing_agreements
ALTER TABLE customer_pricing_agreements ENABLE ROW LEVEL SECURITY;

CREATE POLICY "cpa_org_isolation" ON customer_pricing_agreements
  FOR ALL USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- customer_pricing_agreement_items
ALTER TABLE customer_pricing_agreement_items ENABLE ROW LEVEL SECURITY;

CREATE POLICY "cpai_org_isolation" ON customer_pricing_agreement_items
  FOR ALL USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- pricing_agreement_templates
ALTER TABLE pricing_agreement_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "pat_org_isolation" ON pricing_agreement_templates
  FOR ALL USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- pricing_agreement_template_items
ALTER TABLE pricing_agreement_template_items ENABLE ROW LEVEL SECURITY;

CREATE POLICY "pati_org_isolation" ON pricing_agreement_template_items
  FOR ALL USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- customer_pricing_history
ALTER TABLE customer_pricing_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "cph_org_isolation" ON customer_pricing_history
  FOR ALL USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));
```

### API Endpoints

```
# Pricing Agreements
GET    /api/shipping/customers/:customerId/pricing-agreements              - List agreements for customer
GET    /api/shipping/customers/:customerId/pricing-agreements/:id          - Get agreement details
POST   /api/shipping/customers/:customerId/pricing-agreements              - Create agreement
PUT    /api/shipping/customers/:customerId/pricing-agreements/:id          - Update agreement
DELETE /api/shipping/customers/:customerId/pricing-agreements/:id          - Delete agreement (draft only)
POST   /api/shipping/customers/:customerId/pricing-agreements/:id/activate - Activate agreement
POST   /api/shipping/customers/:customerId/pricing-agreements/:id/cancel   - Cancel agreement

# Agreement Items
GET    /api/shipping/customers/:customerId/pricing-agreements/:id/items              - List items
POST   /api/shipping/customers/:customerId/pricing-agreements/:id/items              - Add item
PUT    /api/shipping/customers/:customerId/pricing-agreements/:id/items/:itemId      - Update item
DELETE /api/shipping/customers/:customerId/pricing-agreements/:id/items/:itemId      - Remove item

# Price Lookup (for SO integration)
GET    /api/shipping/customers/:customerId/products/:productId/price       - Get agreed price
POST   /api/shipping/pricing/lookup                                         - Bulk price lookup

# Templates
GET    /api/shipping/pricing-templates                                      - List templates
GET    /api/shipping/pricing-templates/:id                                  - Get template
POST   /api/shipping/pricing-templates                                      - Create template
PUT    /api/shipping/pricing-templates/:id                                  - Update template
DELETE /api/shipping/pricing-templates/:id                                  - Delete template
POST   /api/shipping/pricing-templates/:id/apply                            - Apply template to customer

# History
GET    /api/shipping/customers/:customerId/pricing-agreements/:id/history  - Get price history
```

### Service Methods

**Location:** `lib/services/customer-pricing-service.ts`

```typescript
interface CustomerPricingService {
  // Agreements
  listAgreements(customerId: string, filters?: AgreementFilters): Promise<PricingAgreement[]>;
  getAgreement(agreementId: string): Promise<PricingAgreement>;
  createAgreement(customerId: string, data: CreateAgreementInput): Promise<PricingAgreement>;
  updateAgreement(agreementId: string, data: UpdateAgreementInput): Promise<PricingAgreement>;
  deleteAgreement(agreementId: string): Promise<void>;
  activateAgreement(agreementId: string): Promise<PricingAgreement>;
  cancelAgreement(agreementId: string, reason?: string): Promise<PricingAgreement>;

  // Agreement Items
  listAgreementItems(agreementId: string): Promise<PricingAgreementItem[]>;
  addAgreementItem(agreementId: string, data: CreateItemInput): Promise<PricingAgreementItem>;
  updateAgreementItem(itemId: string, data: UpdateItemInput): Promise<PricingAgreementItem>;
  removeAgreementItem(itemId: string): Promise<void>;

  // Price Lookup (called from PricingService)
  getAgreedPrice(customerId: string, productId: string, quantity: number, orderDate?: Date): Promise<AgreedPrice | null>;
  bulkPriceLookup(customerId: string, items: PriceLookupItem[]): Promise<AgreedPrice[]>;

  // Validation
  validateNoOverlap(customerId: string, productId: string, effectiveFrom: Date, effectiveTo?: Date, excludeId?: string): Promise<boolean>;
  validateQuantityRange(agreementId: string, productId: string, minQty: number, maxQty?: number, excludeId?: string): Promise<boolean>;

  // Templates
  listTemplates(): Promise<PricingTemplate[]>;
  createTemplate(data: CreateTemplateInput): Promise<PricingTemplate>;
  applyTemplate(templateId: string, customerId: string, effectiveFrom: Date, effectiveTo?: Date): Promise<PricingAgreement>;
  saveAsTemplate(agreementId: string, templateName: string): Promise<PricingTemplate>;

  // History
  getAgreementHistory(agreementId: string): Promise<PricingHistory[]>;
  recordPriceChange(itemId: string, oldPrice: number, newPrice: number, reason?: string): Promise<void>;

  // Status Management
  expireOutdatedAgreements(): Promise<number>;  // For scheduled job
}

interface AgreedPrice {
  unit_price: number;
  agreement_id: string;
  agreement_name: string;
  tier_applied: string;  // e.g., "Tier 2: 100-499 units"
  discount?: { type: 'percent' | 'fixed'; value: number };
  source: 'agreement' | 'std_price' | 'manual';
}
```

### Zod Validation Schemas

**Location:** `lib/validation/customer-pricing.ts`

```typescript
import { z } from 'zod';

// Agreement schema
export const pricingAgreementSchema = z.object({
  agreement_code: z.string()
    .min(1, 'Agreement code is required')
    .max(50, 'Agreement code must be at most 50 characters')
    .regex(/^[A-Z0-9-]+$/, 'Code must be uppercase alphanumeric with hyphens'),
  name: z.string()
    .min(1, 'Agreement name is required')
    .max(255, 'Name must be at most 255 characters'),
  description: z.string().max(1000).optional().nullable(),
  effective_from: z.coerce.date(),
  effective_to: z.coerce.date().optional().nullable(),
  status: z.enum(['draft', 'active', 'expired', 'cancelled']).default('draft'),
}).refine((data) => {
  if (data.effective_to && data.effective_to < data.effective_from) {
    return false;
  }
  return true;
}, {
  message: 'End date must be after start date',
  path: ['effective_to'],
});

// Agreement Item schema
export const pricingAgreementItemSchema = z.object({
  product_id: z.string().uuid('Invalid product ID'),
  unit_price: z.number()
    .min(0, 'Price must be non-negative')
    .max(999999999, 'Price exceeds maximum'),
  min_qty: z.number()
    .min(0.0001, 'Minimum quantity must be positive')
    .default(1),
  max_qty: z.number()
    .min(0.0001, 'Maximum quantity must be positive')
    .optional()
    .nullable(),
  discount: z.object({
    type: z.enum(['percent', 'fixed']),
    value: z.number().min(0, 'Discount must be non-negative'),
  }).optional().nullable(),
  notes: z.string().max(500).optional().nullable(),
}).refine((data) => {
  if (data.max_qty !== null && data.max_qty !== undefined && data.max_qty < data.min_qty) {
    return false;
  }
  return true;
}, {
  message: 'Max quantity must be >= min quantity',
  path: ['max_qty'],
}).refine((data) => {
  if (data.discount?.type === 'percent' && data.discount.value > 100) {
    return false;
  }
  return true;
}, {
  message: 'Percentage discount cannot exceed 100%',
  path: ['discount', 'value'],
});

// Template schema
export const pricingTemplateSchema = z.object({
  template_code: z.string()
    .min(1, 'Template code is required')
    .max(50, 'Template code must be at most 50 characters'),
  name: z.string()
    .min(1, 'Template name is required')
    .max(255, 'Name must be at most 255 characters'),
  description: z.string().max(1000).optional().nullable(),
  is_active: z.boolean().default(true),
});

// Price lookup request schema
export const priceLookupSchema = z.object({
  customer_id: z.string().uuid(),
  product_id: z.string().uuid(),
  quantity: z.number().positive(),
  order_date: z.coerce.date().optional(),
});

export const bulkPriceLookupSchema = z.object({
  customer_id: z.string().uuid(),
  items: z.array(z.object({
    product_id: z.string().uuid(),
    quantity: z.number().positive(),
  })),
  order_date: z.coerce.date().optional(),
});

export type PricingAgreementInput = z.infer<typeof pricingAgreementSchema>;
export type PricingAgreementItemInput = z.infer<typeof pricingAgreementItemSchema>;
export type PricingTemplateInput = z.infer<typeof pricingTemplateSchema>;
```

## UI Components

### Pages

- `app/(authenticated)/shipping/customers/[id]/pricing/page.tsx` - Customer pricing agreements tab
- `app/(authenticated)/shipping/pricing-templates/page.tsx` - Pricing templates list

### Components

**Location:** `components/shipping/pricing/`

```
PricingAgreementsList.tsx       - List of customer pricing agreements
PricingAgreementCard.tsx        - Agreement summary card
PricingAgreementForm.tsx        - Create/Edit agreement modal
PricingAgreementDetail.tsx      - Agreement detail view with items
PricingItemsTable.tsx           - Agreement items DataTable
PricingItemForm.tsx             - Add/Edit agreement item modal
VolumeTierDisplay.tsx           - Visual tier display component
PricingStatusBadge.tsx          - Status badge (draft/active/expired/cancelled)
PriceSourceIndicator.tsx        - Shows price source in SO line (agreement/std/manual)
PricingTemplatesList.tsx        - Templates list view
PricingTemplateForm.tsx         - Create/Edit template modal
ApplyTemplateDialog.tsx         - Apply template to customer dialog
PricingHistoryTable.tsx         - Price change history table
```

### Component Details

**PricingAgreementsList.tsx**
```tsx
interface PricingAgreementsListProps {
  customerId: string;
  agreements: PricingAgreement[];
  onCreateClick: () => void;
  onEditClick: (agreement: PricingAgreement) => void;
  onActivateClick: (agreementId: string) => void;
  onCancelClick: (agreementId: string) => void;
  isLoading: boolean;
}
```

**PricingItemForm.tsx**
```tsx
interface PricingItemFormProps {
  agreementId: string;
  existingItems: PricingAgreementItem[];
  item?: PricingAgreementItem;  // For edit mode
  onSave: (item: PricingAgreementItemInput) => void;
  onCancel: () => void;
}

// Fields:
// - Product selector (with search, shows SKU + name)
// - Unit Price (currency input)
// - Min Quantity (number input)
// - Max Quantity (number input, optional, "unlimited" checkbox)
// - Discount (toggle, type selector, value input)
// - Notes (textarea)
```

**VolumeTierDisplay.tsx**
```tsx
interface VolumeTierDisplayProps {
  items: PricingAgreementItem[];  // Grouped by product
  productName: string;
}

// Visual display:
// +-----------------------------------+
// | Product: Organic Tomato Sauce     |
// +-----------------------------------+
// | Qty 1-99      | $10.00            |
// | Qty 100-499   | $9.50 (5% off)    |
// | Qty 500+      | $9.00 (10% off)   |
// +-----------------------------------+
```

**PriceSourceIndicator.tsx**
```tsx
interface PriceSourceIndicatorProps {
  source: 'agreement' | 'std_price' | 'manual';
  agreementName?: string;
  tierName?: string;
}

// Display examples:
// - Agreement: "2026 Annual Contract - Tier 2"
// - Standard: "Product standard price"
// - Manual: "Manual override"
```

## Integration with PricingService

### Updated getProductPrice() Flow

**Location:** `lib/services/pricing-service.ts`

```typescript
export async function getProductPrice(
  productId: string,
  customerId?: string,
  quantity: number = 1,
  orderDate: Date = new Date()
): Promise<PriceResult> {
  // 1. Check customer pricing agreement (if customerId provided)
  if (customerId) {
    const agreedPrice = await CustomerPricingService.getAgreedPrice(
      customerId,
      productId,
      quantity,
      orderDate
    );

    if (agreedPrice) {
      return {
        unit_price: agreedPrice.unit_price,
        source: 'agreement',
        agreement_id: agreedPrice.agreement_id,
        agreement_name: agreedPrice.agreement_name,
        tier_info: agreedPrice.tier_applied,
        discount: agreedPrice.discount,
      };
    }
  }

  // 2. Fallback to product standard price
  const { data: product } = await supabase
    .from('products')
    .select('std_price, name')
    .eq('id', productId)
    .single();

  if (product?.std_price) {
    return {
      unit_price: product.std_price,
      source: 'std_price',
      product_name: product.name,
    };
  }

  // 3. No price available - manual entry required
  return {
    unit_price: null,
    source: 'manual',
    warning: 'No price available. Please enter manually.',
  };
}

interface PriceResult {
  unit_price: number | null;
  source: 'agreement' | 'std_price' | 'manual';
  agreement_id?: string;
  agreement_name?: string;
  tier_info?: string;
  discount?: { type: 'percent' | 'fixed'; value: number };
  product_name?: string;
  warning?: string;
}
```

## Test Cases

### Unit Tests

**customer-pricing-service.test.ts**
```typescript
describe('CustomerPricingService', () => {
  describe('getAgreedPrice', () => {
    it('returns correct price for active agreement within date range');
    it('applies correct volume tier based on quantity');
    it('returns null for expired agreement');
    it('returns null for cancelled agreement');
    it('returns null for draft agreement');
    it('returns null for agreement outside effective dates');
    it('handles unlimited max_qty (NULL) correctly');
    it('returns most recent agreement when multiple valid');
  });

  describe('validateNoOverlap', () => {
    it('returns false when new agreement overlaps existing');
    it('returns true for sequential date ranges');
    it('returns true for different products');
  });

  describe('validateQuantityRange', () => {
    it('returns false for overlapping quantity ranges');
    it('returns true for adjacent ranges');
    it('returns true for same min_qty different product');
  });

  describe('activateAgreement', () => {
    it('changes status from draft to active');
    it('sets activated_at timestamp');
    it('rejects activation of cancelled agreement');
  });

  describe('applyTemplate', () => {
    it('creates new agreement from template');
    it('copies all template items to agreement');
    it('sets custom effective dates');
  });
});
```

### Integration Tests

**customer-pricing-api.test.ts**
```typescript
describe('Customer Pricing API', () => {
  describe('GET /api/shipping/customers/:customerId/pricing-agreements', () => {
    it('returns only customer agreements');
    it('returns 404 for cross-org customer');
    it('filters by status');
  });

  describe('POST /api/shipping/customers/:customerId/pricing-agreements', () => {
    it('creates agreement with valid data');
    it('rejects invalid date range');
    it('rejects duplicate agreement code');
  });

  describe('POST /api/shipping/customers/:customerId/pricing-agreements/:id/activate', () => {
    it('activates draft agreement');
    it('rejects non-draft agreement');
    it('creates audit log entry');
  });

  describe('GET /api/shipping/customers/:customerId/products/:productId/price', () => {
    it('returns agreement price when active agreement exists');
    it('returns std_price when no agreement');
    it('applies correct volume tier');
    it('respects effective date range');
  });
});
```

### E2E Tests

**customer-pricing-agreements.spec.ts**
```typescript
describe('Customer Pricing Agreements', () => {
  it('creates new pricing agreement for customer');
  it('adds volume tier items to agreement');
  it('activates agreement and verifies status');
  it('creates SO and verifies agreement price applied');
  it('applies template to new customer');
  it('shows price history after modification');
});
```

## Security Considerations

1. **RLS Enforcement**
   - All tables have org_id RLS policies
   - Cross-tenant access returns 404 (not 403)

2. **Permission Checks**
   - VIEWER role: read-only access
   - SALES/ADMIN role: full CRUD access
   - PROD_OPERATOR role: no access

3. **Audit Trail**
   - All price changes logged in customer_pricing_history
   - Agreement status changes tracked (activated_at, cancelled_by)
   - SO creation logs applied agreement reference

4. **Data Integrity**
   - Foreign key constraints on customer_id, product_id
   - Overlap prevention at database and service level
   - Quantity range validation prevents gaps/overlaps

## Deliverables

- [ ] `customer_pricing_agreements` table migration
- [ ] `customer_pricing_agreement_items` table migration
- [ ] `pricing_agreement_templates` table migration
- [ ] `pricing_agreement_template_items` table migration
- [ ] `customer_pricing_history` table migration
- [ ] RLS policies for all pricing tables
- [ ] CustomerPricingService (`lib/services/customer-pricing-service.ts`)
- [ ] Updated PricingService.getProductPrice() with agreement lookup
- [ ] Zod schemas (`lib/validation/customer-pricing.ts`)
- [ ] API routes for agreements CRUD
- [ ] API routes for agreement items CRUD
- [ ] API routes for templates CRUD
- [ ] API route for price lookup
- [ ] PricingAgreementsList component
- [ ] PricingAgreementForm component
- [ ] PricingAgreementDetail component
- [ ] PricingItemsTable component
- [ ] PricingItemForm component
- [ ] VolumeTierDisplay component
- [ ] PriceSourceIndicator component
- [ ] PricingTemplatesList component
- [ ] ApplyTemplateDialog component
- [ ] Customer pricing tab page
- [ ] Unit tests (>80% coverage)
- [ ] Integration tests
- [ ] E2E tests

## Definition of Done

- [ ] All database tables created with RLS policies
- [ ] Agreement CRUD operations functional
- [ ] Agreement items CRUD operations functional
- [ ] Volume tier pricing applies correctly
- [ ] Effective date validation works
- [ ] Overlap prevention enforced
- [ ] Agreement status workflow functional (draft > active > expired/cancelled)
- [ ] Templates CRUD operations functional
- [ ] Template application creates correct agreement
- [ ] Price lookup returns agreement price when valid
- [ ] Price lookup falls back to std_price when no agreement
- [ ] Price source indicator displays correctly in SO form
- [ ] Price history tracked for all changes
- [ ] Multi-tenant isolation verified
- [ ] Permission checks enforced
- [ ] Unit tests pass (>80% coverage)
- [ ] Integration tests pass
- [ ] E2E tests pass
- [ ] Code reviewed and approved
- [ ] Documentation updated

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2026-01-15 | Initial story creation | ARCHITECT-AGENT |
