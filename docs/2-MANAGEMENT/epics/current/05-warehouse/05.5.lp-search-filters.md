# 05.5 - LP Search & Filters

| Field | Value |
|-------|-------|
| **Story ID** | 05.5 |
| **Epic** | 05 - Warehouse |
| **Status** | Ready |
| **Phase** | Phase 0 (LP Foundation) |
| **Priority** | P0 (CRITICAL) |
| **Complexity** | M (Medium) |
| **Estimate** | 2-3 days |
| **Type** | Backend + Frontend |
| **Model** | SONNET |

---

## CRITICAL DEPENDENCY NOTICE

**THIS STORY SUPPORTS EPIC 04 PRODUCTION.**

Epic 04 Phase 1 stories (04.6a-e Material Consumption, 04.7a-d Output Registration) require advanced LP search and filtering to:
- Find available LPs by product for consumption
- Filter by warehouse/location for WO-specific picking
- Search by batch number for traceability requirements
- Filter by expiry date range for FEFO compliance
- Quick lookup by LP number for corrections

**Supports:** Epic 04.6a-e (finding LPs for consumption), 04.7 (finding output location)

---

## PRD References

| FR ID | Requirement | Priority | Coverage |
|-------|-------------|----------|----------|
| WH-FR-002 | LP Tracking - Search & Filter | P0 | Full |
| WH-FR-009 | Batch Tracking - Search by batch | P0 | Full |
| WH-FR-010 | Expiry Tracking - Filter by expiry range | P0 | Full |

**Primary PRD:** `docs/1-BASELINE/product/modules/warehouse.md` (lines 71, 74, 177)
**Architecture:** `docs/1-BASELINE/architecture/modules/warehouse.md`

---

## MVP Scope

### In Scope (This Story)

1. **Search Functionality**
   - Search by LP number (full or partial match)
   - Search by batch number (exact match)
   - Prefix search optimization with trigram indexes

2. **Filter Capabilities**
   - Filter by product (single or multiple)
   - Filter by warehouse (single)
   - Filter by location (single or multiple)
   - Filter by status (available, reserved, consumed, blocked)
   - Filter by QA status (pending, passed, failed, quarantine)
   - Filter by expiry date range (before/after dates)
   - Filter by batch number (exact match)

3. **Sort Options**
   - Sort by: lp_number, created_at, expiry_date, quantity, batch_number
   - Sort order: asc, desc

4. **API Enhancements**
   - Advanced query endpoint with all filters
   - Query parameter validation
   - Performance optimization (response < 500ms with 10K LPs)

5. **Desktop UI**
   - Enhanced filter panel with all options
   - Search input with debounce (300ms)
   - Filter chips/badges showing active filters
   - Clear all filters button
   - Filter presets (e.g., "Expiring Soon", "Available Stock")

6. **Performance Optimization**
   - Database indexes for all filter fields
   - Query optimization for complex filter combinations
   - Pagination support (50/100/200 items per page)

### Out of Scope (Other Stories)

| Feature | Deferred To | Reason |
|---------|-------------|--------|
| Saved filter templates | 05.36 | Advanced inventory browser |
| Export filtered results | 05.38 | Reporting feature |
| Advanced text search (product name, location) | 05.36 | Full-text search |
| Filter by zone | 05.30 | Zone management |
| Filter by pallet | 05.26 | Pallet management |
| Scanner filter UI | 05.17+ | Scanner workflows |
| Multi-org search (admin) | Future | Admin features |

---

## Epic 04 Dependency Status

- [x] **CRITICAL - Supports Epic 04 Phase 1**

This story provides:
1. Product-based LP search for material consumption
2. Location/warehouse filtering for WO picking
3. Batch number search for traceability
4. Expiry filtering for FEFO compliance
5. Quick LP number lookup for corrections

---

## Goal

Provide comprehensive search and filtering capabilities for License Plates to enable efficient LP discovery for production operations, inventory management, and traceability requirements.

---

## User Story

As a **Warehouse Operator or Production Supervisor**, I want to **quickly search and filter License Plates by multiple criteria** so that **I can find the exact inventory I need for production, quality checks, or stock management**.

---

## Dependencies

| Dependency | Story/Epic | Type | Status | Notes |
|------------|------------|------|--------|-------|
| 05.1 | LP Table + CRUD | HARD | Ready | Requires license_plates table and base query structure |
| 01.8 | Warehouses CRUD | HARD | Ready | FK to warehouses for filtering |
| 01.9 | Locations CRUD | HARD | Ready | FK to locations for filtering |
| 02.1 | Products CRUD | HARD | Ready | FK to products for filtering |

**Dependents (What This Unblocks):**
- 04.6a-e (Material Consumption) - Find LPs by product/location
- 04.7a-d (Output Registration) - Find destination location
- 05.4 (FIFO/FEFO Pick) - Uses filtered queries
- 05.8 (GRN from PO) - Search existing LPs
- 05.36 (Inventory Browser) - Advanced UI uses this foundation

---

## Acceptance Criteria (Given/When/Then)

### AC-1: LP Number Search (WH-FR-002)

```gherkin
Scenario: Full LP number search
  Given LP 'LP00000123' exists
  When user searches for 'LP00000123'
  Then LP returned in results
  And response time < 200ms

Scenario: Partial LP number search (prefix)
  Given LPs: 'LP00000123', 'LP00000124', 'LP00000200'
  When user searches for 'LP000001'
  Then 'LP00000123' and 'LP00000124' returned
  And 'LP00000200' not in results
  And response time < 300ms

Scenario: Case-insensitive LP number search
  Given LP 'LP00000123' exists
  When user searches for 'lp00000123' (lowercase)
  Then LP returned in results

Scenario: LP number search with no matches
  Given no LP starting with 'ABC'
  When user searches for 'ABC123'
  Then empty result set returned
  And no error shown

Scenario: LP number search performance
  Given 10,000 LPs in database
  When user searches for LP number prefix
  Then results return in < 300ms
  And uses idx_lp_number_search index
```

### AC-2: Batch Number Search (WH-FR-009)

```gherkin
Scenario: Exact batch number match
  Given 3 LPs with batch_number = 'BATCH-2025-001'
  And 2 LPs with batch_number = 'BATCH-2025-002'
  When user filters by batch_number = 'BATCH-2025-001'
  Then 3 LPs with matching batch returned
  And response time < 300ms

Scenario: Batch number search with null values
  Given 5 LPs with batch_number = 'BATCH-001'
  And 10 LPs with batch_number = NULL
  When user filters by batch_number = 'BATCH-001'
  Then only 5 LPs with 'BATCH-001' returned
  And NULL batch LPs excluded

Scenario: Batch number search case-sensitive
  Given LP with batch_number = 'Batch-001'
  When user searches for 'batch-001' (lowercase)
  Then LP returned (case-insensitive match)

Scenario: Batch number search performance
  Given 10,000 LPs with various batch numbers
  When user filters by batch number
  Then results return in < 300ms
  And uses idx_lp_batch index
```

### AC-3: Product Filter

```gherkin
Scenario: Filter by single product
  Given 20 LPs for product A
  And 30 LPs for product B
  When user filters by product_id = A
  Then only 20 LPs for product A returned

Scenario: Filter by multiple products
  Given LPs for products A, B, C
  When user filters by product_ids = [A, B]
  Then LPs for products A and B returned
  And product C LPs excluded

Scenario: Product filter with no matches
  Given no LPs for product X
  When user filters by product_id = X
  Then empty result set returned
  And message "No license plates found" displayed

Scenario: Product filter performance
  Given 100 LPs per product across 100 products
  When user filters by product_id
  Then results return in < 500ms
  And uses idx_lp_org_product index
```

### AC-4: Warehouse & Location Filters

```gherkin
Scenario: Filter by warehouse
  Given 50 LPs in Warehouse A
  And 30 LPs in Warehouse B
  When user filters by warehouse_id = A
  Then only 50 LPs in Warehouse A returned

Scenario: Filter by specific location
  Given 10 LPs at location ZONE-A-01
  And 15 LPs at location ZONE-A-02
  When user filters by location_id = ZONE-A-01
  Then only 10 LPs at ZONE-A-01 returned

Scenario: Filter by warehouse AND location
  Given LP at Warehouse A, Location ZONE-A-01
  And LP at Warehouse B, Location ZONE-A-01 (same location code, different warehouse)
  When user filters by warehouse_id = A AND location_id = ZONE-A-01
  Then only LP from Warehouse A returned

Scenario: Filter by multiple locations
  Given LPs at locations ZONE-A-01, ZONE-A-02, ZONE-B-01
  When user filters by location_ids = [ZONE-A-01, ZONE-A-02]
  Then LPs from ZONE-A-01 and ZONE-A-02 returned
  And ZONE-B-01 LPs excluded

Scenario: Location filter performance
  Given 10,000 LPs across 50 locations
  When user filters by location_id
  Then results return in < 500ms
  And uses idx_lp_org_location index
```

### AC-5: Status Filters

```gherkin
Scenario: Filter by LP status
  Given 40 available LPs, 30 reserved LPs, 20 consumed LPs, 10 blocked LPs
  When user filters by status = 'available'
  Then 40 available LPs returned
  And other status LPs excluded

Scenario: Filter by multiple statuses
  Given LPs with various statuses
  When user filters by status = ['available', 'reserved']
  Then available and reserved LPs returned
  And consumed and blocked LPs excluded

Scenario: Filter by QA status
  Given 50 pending LPs, 40 passed LPs, 8 failed LPs, 2 quarantine LPs
  When user filters by qa_status = 'passed'
  Then only 40 passed LPs returned

Scenario: Combined status and QA status filter
  Given LPs with various status/QA combinations
  When user filters by status='available' AND qa_status='passed'
  Then only LPs with both conditions returned
  And response time < 500ms

Scenario: Status filter performance
  Given 10,000 LPs with various statuses
  When user filters by status
  Then results return in < 500ms
  And uses idx_lp_org_status and idx_lp_org_qa indexes
```

### AC-6: Expiry Date Range Filter (WH-FR-010)

```gherkin
Scenario: Filter by expiry before date
  Given 10 LPs expiring on 2025-01-15
  And 15 LPs expiring on 2025-02-15
  When user filters by expiry_before = '2025-02-01'
  Then 10 LPs expiring on 2025-01-15 returned
  And 2025-02-15 LPs excluded

Scenario: Filter by expiry after date
  Given 10 LPs expiring on 2025-01-15
  And 15 LPs expiring on 2025-02-15
  When user filters by expiry_after = '2025-02-01'
  Then 15 LPs expiring on 2025-02-15 returned
  And 2025-01-15 LPs excluded

Scenario: Filter by expiry range
  Given LPs expiring on 2025-01-15, 2025-02-15, 2025-03-15
  When user filters by expiry_after='2025-02-01' AND expiry_before='2025-03-01'
  Then only LPs expiring on 2025-02-15 returned

Scenario: Expiry filter excludes NULL expiry dates
  Given 20 LPs with expiry dates
  And 30 LPs with expiry_date = NULL
  When user filters by expiry_before = '2025-12-31'
  Then only 20 LPs with expiry dates considered
  And NULL expiry LPs excluded from results

Scenario: Expiry filter performance
  Given 10,000 LPs with various expiry dates
  When user filters by expiry range
  Then results return in < 500ms
  And uses idx_lp_expiry index
```

### AC-7: Combined Multi-Filter Query

```gherkin
Scenario: Combined filters (product + status + QA)
  Given 100 LPs total
  When user filters by:
    | product_id | status | qa_status |
    | Product A | available | passed |
  Then only LPs matching ALL criteria returned
  And response time < 500ms

Scenario: Complex filter (5+ conditions)
  Given 10,000 LPs in database
  When user filters by:
    | Criteria | Value |
    | product_id | Product A |
    | warehouse_id | WH-001 |
    | status | available |
    | qa_status | passed |
    | expiry_after | 2025-02-01 |
  Then only LPs matching ALL 5 conditions returned
  And response time < 500ms
  And query uses appropriate composite indexes

Scenario: Filter with search
  Given 100 LPs for product A
  When user searches 'LP000001' AND filters by product_id = A
  Then only LPs matching BOTH search and filter returned

Scenario: Empty result with multiple filters
  Given no LPs matching complex filter criteria
  When user applies multiple filters
  Then empty result set returned
  And message "No license plates match your filters" displayed
  And no query timeout or error
```

### AC-8: Sort Options

```gherkin
Scenario: Sort by LP number ascending
  Given LPs: LP00000100, LP00000001, LP00000050
  When user sorts by lp_number ASC
  Then results ordered: LP00000001, LP00000050, LP00000100

Scenario: Sort by created_at descending (default)
  Given LPs created at different times
  When user requests LP list without sort param
  Then results ordered by created_at DESC (newest first)

Scenario: Sort by expiry_date ascending
  Given LPs with expiry dates 2025-01-15, 2025-03-15, 2025-02-15
  When user sorts by expiry_date ASC
  Then results ordered: 2025-01-15, 2025-02-15, 2025-03-15

Scenario: Sort by quantity descending
  Given LPs with quantities 100, 50, 200
  When user sorts by quantity DESC
  Then results ordered: 200, 100, 50

Scenario: Sort with NULL values (expiry)
  Given 5 LPs with expiry dates and 10 LPs with NULL expiry
  When user sorts by expiry_date ASC
  Then LPs with dates sorted first (ascending)
  And NULL expiry LPs appear last

Scenario: Sort performance
  Given 10,000 LPs
  When user sorts by any supported field
  Then results return in < 500ms
  And pagination applied to sorted results
```

### AC-9: Pagination

```gherkin
Scenario: Default pagination
  Given 200 LPs match filter criteria
  When user requests LP list without pagination params
  Then page 1 returned with 50 items (default limit)
  And pagination metadata includes total=200, pages=4

Scenario: Custom page size
  Given 200 LPs match filter criteria
  When user requests page=1 with limit=100
  Then 100 items returned
  And pagination shows total=200, pages=2

Scenario: Navigate to page 2
  Given 200 LPs match filter criteria
  When user requests page=2 with limit=50
  Then items 51-100 returned
  And correct pagination metadata

Scenario: Maximum page size limit
  Given 500 LPs match filter criteria
  When user requests limit=500
  Then maximum 200 items returned (enforced limit)
  And warning "Maximum page size is 200"

Scenario: Pagination with filters
  Given 1000 total LPs, 100 match filters
  When user applies filters and requests page=1
  Then pagination based on filtered count (100)
  And shows pages=2 with limit=50
```

### AC-10: Desktop UI - Filter Panel

```gherkin
Scenario: Open filter panel
  Given user on LP list page
  When user clicks "Filters" button
  Then filter panel slides in from left or top
  And all filter options visible

Scenario: Apply single filter
  Given filter panel open
  When user selects warehouse = "WH-001"
  And clicks "Apply Filters"
  Then LP list refreshes with filtered results
  And filter chip "Warehouse: WH-001" appears above table

Scenario: Apply multiple filters
  Given filter panel open
  When user selects:
    | Filter | Value |
    | Warehouse | WH-001 |
    | Status | available |
    | QA Status | passed |
  And clicks "Apply Filters"
  Then 3 filter chips appear above table
  And LP list shows only matching results

Scenario: Clear single filter chip
  Given 3 active filter chips displayed
  When user clicks X on "Status: available" chip
  Then that filter removed
  And LP list refreshes without status filter
  And other 2 filters remain active

Scenario: Clear all filters
  Given multiple filters applied
  When user clicks "Clear All Filters" button
  Then all filter chips removed
  And LP list shows unfiltered results (all LPs)

Scenario: Filter presets
  Given filter panel open
  When user clicks "Expiring Soon" preset
  Then expiry_before filter automatically set to today + 30 days
  And status filter set to 'available'
  And filters applied automatically
```

### AC-11: Desktop UI - Search Input

```gherkin
Scenario: Search input with debounce
  Given user on LP list page
  When user types 'LP000001' in search box
  Then search waits 300ms after last keystroke
  And then executes search query
  And results display with search term highlighted

Scenario: Clear search
  Given search term 'LP000001' active with results
  When user clicks X in search input
  Then search cleared
  And full LP list displayed
  And all filters remain active (if any)

Scenario: Search with enter key
  Given user typing in search box
  When user presses Enter key
  Then search executes immediately (bypasses debounce)

Scenario: Search loading state
  Given user enters search term
  When search is executing (< 300ms)
  Then search input shows loading spinner
  And "Searching..." indicator appears
```

### AC-12: Performance Requirements

```gherkin
Scenario: Simple filter performance (< 500ms)
  Given 10,000 LPs in database
  When user filters by single criterion (product, warehouse, status)
  Then results return in < 500ms

Scenario: Complex filter performance (< 500ms)
  Given 10,000 LPs in database
  When user filters by 5+ criteria
  Then results return in < 500ms

Scenario: Search performance (< 300ms)
  Given 10,000 LPs in database
  When user searches by LP number prefix
  Then results return in < 300ms

Scenario: Combined search + filter performance (< 500ms)
  Given 10,000 LPs in database
  When user applies search AND 3+ filters
  Then results return in < 500ms

Scenario: Index usage verification
  Given complex filter query
  When query EXPLAIN executed
  Then appropriate indexes used (no table scans)
  And query plan shows index-only or index scan
```

---

## Technical Specification

### API Enhancements

#### Query Parameters (Extended from 05.1)

```typescript
// GET /api/warehouse/license-plates

interface LPQueryParams {
  // Search
  search?: string;              // LP number prefix search (min 2 chars)
  batch_number?: string;        // Exact batch match

  // Filters
  product_id?: string;          // Single product UUID
  product_ids?: string[];       // Multiple products (comma-separated or array)
  warehouse_id?: string;        // Single warehouse UUID
  location_id?: string;         // Single location UUID
  location_ids?: string[];      // Multiple locations
  status?: LPStatus;            // Single status
  statuses?: LPStatus[];        // Multiple statuses
  qa_status?: QAStatus;         // Single QA status
  qa_statuses?: QAStatus[];     // Multiple QA statuses

  // Date range filters
  expiry_before?: string;       // ISO date (YYYY-MM-DD)
  expiry_after?: string;        // ISO date (YYYY-MM-DD)
  created_before?: string;      // ISO date
  created_after?: string;       // ISO date

  // Sort & pagination
  sort?: 'lp_number' | 'created_at' | 'expiry_date' | 'quantity' | 'batch_number';
  order?: 'asc' | 'desc';
  page?: number;                // Default 1
  limit?: number;               // Default 50, max 200
}
```

#### Query Examples

```bash
# Simple search
GET /api/warehouse/license-plates?search=LP000001

# Product filter
GET /api/warehouse/license-plates?product_id=uuid&status=available

# Complex filter
GET /api/warehouse/license-plates?product_id=uuid&warehouse_id=uuid&status=available&qa_status=passed&expiry_after=2025-02-01&sort=expiry_date&order=asc

# Batch search
GET /api/warehouse/license-plates?batch_number=BATCH-2025-001

# Multiple products
GET /api/warehouse/license-plates?product_ids=uuid1,uuid2,uuid3

# Expiry range
GET /api/warehouse/license-plates?expiry_after=2025-01-01&expiry_before=2025-03-31
```

### Service Layer Updates

```typescript
// lib/services/license-plate-service.ts

// Extend existing LicensePlateListParams from 05.1
export interface LicensePlateListParams {
  // ... existing fields from 05.1 ...

  // NEW: Enhanced filters
  product_ids?: string[];
  location_ids?: string[];
  statuses?: LPStatus[];
  qa_statuses?: QAStatus[];
  created_before?: string;
  created_after?: string;
}

export class LicensePlateService {
  /**
   * Enhanced list method with advanced filtering
   * Optimized query builder with proper index usage
   */
  static async list(params: LicensePlateListParams): Promise<PaginatedResult<LicensePlate>> {
    const supabase = getSupabaseClient();
    let query = supabase
      .from('license_plates')
      .select(`
        *,
        product:products(id, name, code),
        location:locations(id, name, full_path),
        warehouse:warehouses(id, name, code)
      `, { count: 'exact' });

    // Search by LP number (prefix)
    if (params.search) {
      query = query.ilike('lp_number', `${params.search}%`);
    }

    // Filter by batch (exact)
    if (params.batch_number) {
      query = query.eq('batch_number', params.batch_number);
    }

    // Filter by product(s)
    if (params.product_id) {
      query = query.eq('product_id', params.product_id);
    } else if (params.product_ids && params.product_ids.length > 0) {
      query = query.in('product_id', params.product_ids);
    }

    // Filter by warehouse
    if (params.warehouse_id) {
      query = query.eq('warehouse_id', params.warehouse_id);
    }

    // Filter by location(s)
    if (params.location_id) {
      query = query.eq('location_id', params.location_id);
    } else if (params.location_ids && params.location_ids.length > 0) {
      query = query.in('location_id', params.location_ids);
    }

    // Filter by status(es)
    if (params.status) {
      query = query.eq('status', params.status);
    } else if (params.statuses && params.statuses.length > 0) {
      query = query.in('status', params.statuses);
    }

    // Filter by QA status(es)
    if (params.qa_status) {
      query = query.eq('qa_status', params.qa_status);
    } else if (params.qa_statuses && params.qa_statuses.length > 0) {
      query = query.in('qa_status', params.qa_statuses);
    }

    // Filter by expiry date range
    if (params.expiry_before) {
      query = query.lte('expiry_date', params.expiry_before);
    }
    if (params.expiry_after) {
      query = query.gte('expiry_date', params.expiry_after);
    }

    // Filter by created date range
    if (params.created_before) {
      query = query.lte('created_at', params.created_before);
    }
    if (params.created_after) {
      query = query.gte('created_at', params.created_after);
    }

    // Sort
    const sortField = params.sort || 'created_at';
    const sortOrder = params.order || 'desc';
    query = query.order(sortField, { ascending: sortOrder === 'asc', nullsFirst: false });

    // Pagination
    const page = params.page || 1;
    const limit = Math.min(params.limit || 50, 200); // Max 200 per page
    const offset = (page - 1) * limit;
    query = query.range(offset, offset + limit - 1);

    const { data, error, count } = await query;

    if (error) throw error;

    return {
      data: data || [],
      pagination: {
        page,
        limit,
        total: count || 0,
        total_pages: Math.ceil((count || 0) / limit),
      },
    };
  }

  /**
   * Search LPs by batch number (exact match)
   */
  static async searchByBatch(batch_number: string): Promise<LicensePlate[]> {
    return this.list({ batch_number, limit: 200 }).then(res => res.data);
  }

  /**
   * Get expiring soon LPs (preset filter)
   */
  static async getExpiringSoon(days: number = 30): Promise<LicensePlate[]> {
    const futureDate = new Date();
    futureDate.setDate(futureDate.getDate() + days);

    return this.list({
      status: 'available',
      expiry_before: futureDate.toISOString().split('T')[0],
      sort: 'expiry_date',
      order: 'asc',
      limit: 200,
    }).then(res => res.data);
  }

  /**
   * Get available stock for product(s) - preset filter
   */
  static async getAvailableStock(
    product_ids: string[],
    warehouse_id?: string
  ): Promise<LicensePlate[]> {
    return this.list({
      product_ids,
      warehouse_id,
      status: 'available',
      qa_status: 'passed',
      sort: 'created_at',
      order: 'asc',
      limit: 200,
    }).then(res => res.data);
  }
}
```

### Validation Schema Updates (Zod)

```typescript
// lib/validation/license-plate.ts

// Extend existing lpQuerySchema from 05.1
export const lpQuerySchema = z.object({
  // Search
  search: z.string().min(2, "Search term must be at least 2 characters").optional(),
  batch_number: z.string().max(100).optional(),

  // Single filters
  product_id: z.string().uuid().optional(),
  warehouse_id: z.string().uuid().optional(),
  location_id: z.string().uuid().optional(),
  status: lpStatusEnum.optional(),
  qa_status: qaStatusEnum.optional(),

  // Multiple filters (arrays)
  product_ids: z.array(z.string().uuid()).optional(),
  location_ids: z.array(z.string().uuid()).optional(),
  statuses: z.array(lpStatusEnum).optional(),
  qa_statuses: z.array(qaStatusEnum).optional(),

  // Date range filters
  expiry_before: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD").optional(),
  expiry_after: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD").optional(),
  created_before: z.string().datetime().optional(),
  created_after: z.string().datetime().optional(),

  // Sort & pagination
  sort: z.enum(['lp_number', 'created_at', 'expiry_date', 'quantity', 'batch_number']).default('created_at'),
  order: z.enum(['asc', 'desc']).default('desc'),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(200).default(50),
}).refine(
  (data) => {
    // Validate date range logic
    if (data.expiry_before && data.expiry_after) {
      return new Date(data.expiry_before) >= new Date(data.expiry_after);
    }
    return true;
  },
  {
    message: "expiry_before must be greater than or equal to expiry_after",
    path: ["expiry_before"],
  }
);

export type LPQueryParams = z.infer<typeof lpQuerySchema>;
```

### Database Indexes (Additions to 05.1)

```sql
-- Additional indexes for search and filtering
-- (These complement the indexes already created in 05.1)

-- Batch number search (already in 05.1, but confirm)
CREATE INDEX IF NOT EXISTS idx_lp_batch
ON license_plates(batch_number)
WHERE batch_number IS NOT NULL;

-- LP number search with text pattern ops (already in 05.1)
CREATE INDEX IF NOT EXISTS idx_lp_number_search
ON license_plates(org_id, lp_number text_pattern_ops);

-- Composite indexes for common filter combinations
CREATE INDEX idx_lp_product_status_qa
ON license_plates(org_id, product_id, status, qa_status);

CREATE INDEX idx_lp_warehouse_location_status
ON license_plates(org_id, warehouse_id, location_id, status);

-- Date range queries
CREATE INDEX idx_lp_created_range
ON license_plates(org_id, created_at);

-- Expiry with status (for "expiring soon available stock" queries)
CREATE INDEX idx_lp_expiry_status
ON license_plates(org_id, expiry_date, status)
WHERE expiry_date IS NOT NULL;
```

---

## UI Components

### New Components

```
components/warehouse/license-plates/
  LPAdvancedFilters.tsx          -- Full filter panel with all options
  LPFilterChips.tsx              -- Active filter chips display
  LPSearchInput.tsx              -- Search input with debounce (enhance from 05.1)
  LPFilterPresets.tsx            -- Preset filter buttons
  LPFilterDateRange.tsx          -- Date range picker component
  LPFilterMultiSelect.tsx        -- Multi-select for products/locations
```

### Enhanced Components (from 05.1)

```
components/warehouse/license-plates/
  LPDataTable.tsx                -- Add filter chips row, empty state message
  LPFilters.tsx                  -- Replace with LPAdvancedFilters
```

### Filter Panel UI Structure

```tsx
// LPAdvancedFilters.tsx
<Sheet open={isOpen} onOpenChange={setIsOpen}>
  <SheetContent side="left" className="w-[400px]">
    <SheetHeader>
      <SheetTitle>Filter License Plates</SheetTitle>
    </SheetHeader>

    <div className="space-y-4 py-4">
      {/* Search */}
      <div>
        <Label>LP Number or Batch</Label>
        <Input placeholder="Search LP or batch..." />
      </div>

      {/* Product Filter */}
      <div>
        <Label>Product</Label>
        <MultiSelect
          options={products}
          value={selectedProducts}
          onChange={setSelectedProducts}
        />
      </div>

      {/* Warehouse Filter */}
      <div>
        <Label>Warehouse</Label>
        <Select value={warehouse} onValueChange={setWarehouse}>
          <SelectTrigger>
            <SelectValue placeholder="All warehouses" />
          </SelectTrigger>
          <SelectContent>
            {warehouses.map(wh => (
              <SelectItem key={wh.id} value={wh.id}>
                {wh.name}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Location Filter */}
      <div>
        <Label>Location</Label>
        <MultiSelect
          options={locations}
          value={selectedLocations}
          onChange={setSelectedLocations}
        />
      </div>

      {/* Status Filter */}
      <div>
        <Label>Status</Label>
        <div className="flex gap-2 flex-wrap">
          {['available', 'reserved', 'consumed', 'blocked'].map(status => (
            <Badge
              key={status}
              variant={selectedStatuses.includes(status) ? 'default' : 'outline'}
              className="cursor-pointer"
              onClick={() => toggleStatus(status)}
            >
              {status}
            </Badge>
          ))}
        </div>
      </div>

      {/* QA Status Filter */}
      <div>
        <Label>QA Status</Label>
        <div className="flex gap-2 flex-wrap">
          {['pending', 'passed', 'failed', 'quarantine'].map(qa => (
            <Badge
              key={qa}
              variant={selectedQAStatuses.includes(qa) ? 'default' : 'outline'}
              className="cursor-pointer"
              onClick={() => toggleQAStatus(qa)}
            >
              {qa}
            </Badge>
          ))}
        </div>
      </div>

      {/* Expiry Date Range */}
      <div>
        <Label>Expiry Date Range</Label>
        <div className="space-y-2">
          <DatePicker
            label="From"
            value={expiryAfter}
            onChange={setExpiryAfter}
          />
          <DatePicker
            label="To"
            value={expiryBefore}
            onChange={setExpiryBefore}
          />
        </div>
      </div>

      {/* Filter Presets */}
      <div>
        <Label>Quick Filters</Label>
        <div className="flex gap-2 flex-wrap">
          <Button variant="outline" size="sm" onClick={applyExpiringSoon}>
            Expiring Soon (30d)
          </Button>
          <Button variant="outline" size="sm" onClick={applyAvailableStock}>
            Available Stock
          </Button>
          <Button variant="outline" size="sm" onClick={applyPendingQA}>
            Pending QA
          </Button>
        </div>
      </div>
    </div>

    <SheetFooter>
      <Button variant="outline" onClick={clearAllFilters}>
        Clear All
      </Button>
      <Button onClick={applyFilters}>
        Apply Filters
      </Button>
    </SheetFooter>
  </SheetContent>
</Sheet>
```

### Filter Chips Display

```tsx
// LPFilterChips.tsx
<div className="flex gap-2 flex-wrap items-center mb-4">
  {activeFilters.map(filter => (
    <Badge key={filter.key} variant="secondary" className="gap-1">
      <span>{filter.label}: {filter.value}</span>
      <X
        className="h-3 w-3 cursor-pointer"
        onClick={() => removeFilter(filter.key)}
      />
    </Badge>
  ))}

  {activeFilters.length > 0 && (
    <Button variant="ghost" size="sm" onClick={clearAllFilters}>
      Clear All
    </Button>
  )}
</div>
```

---

## Key Business Rules

1. **Search Behavior**
   - LP number search is prefix-based, case-insensitive
   - Batch number search is exact match, case-insensitive
   - Minimum 2 characters required for search to execute

2. **Filter Combinations**
   - All filters use AND logic (must match all selected criteria)
   - Multiple values within same filter type use OR logic (e.g., product A OR B)
   - Empty filter = no restriction on that field

3. **Date Range Filters**
   - expiry_before and expiry_after are inclusive
   - NULL expiry dates excluded from expiry date filters
   - Date format must be YYYY-MM-DD (ISO 8601)

4. **Performance**
   - All queries must use appropriate indexes
   - Response time < 500ms for complex filters with 10K LPs
   - Response time < 300ms for simple search/filter
   - Maximum page size enforced at 200 items

5. **Filter Persistence**
   - Active filters preserved during pagination
   - Filters cleared only on explicit user action
   - Filter state stored in URL query params for bookmarking

---

## Deliverables

### Backend
- [ ] Enhanced API endpoint with all query parameters
- [ ] Extended service methods for advanced filtering
- [ ] Query builder with proper index usage
- [ ] Validation schema for all filter parameters
- [ ] Additional database indexes

### Frontend
- [ ] Advanced filter panel (LPAdvancedFilters.tsx)
- [ ] Filter chips display (LPFilterChips.tsx)
- [ ] Enhanced search input with debounce
- [ ] Filter presets UI (LPFilterPresets.tsx)
- [ ] Date range picker component
- [ ] Multi-select components for products/locations
- [ ] Empty state UI for no results
- [ ] Filter state management (URL params)

### Tests
- [ ] Unit tests: Filter logic for each parameter
- [ ] Integration tests: All query combinations
- [ ] Performance tests: 10K LP dataset
- [ ] E2E tests: Filter panel interactions

---

## Test Cases

### Unit Tests

**File:** `__tests__/unit/services/license-plate-filter.test.ts`

| Test Case | Description |
|-----------|-------------|
| `list()` with LP number search | Prefix match returns correct LPs |
| `list()` with batch number filter | Exact match returns correct LPs |
| `list()` with single product filter | Returns only LPs for that product |
| `list()` with multiple products | Returns LPs for all selected products |
| `list()` with warehouse filter | Returns only LPs in that warehouse |
| `list()` with location filter | Returns only LPs at that location |
| `list()` with status filter | Returns only LPs with that status |
| `list()` with QA status filter | Returns only LPs with that QA status |
| `list()` with expiry_before filter | Returns LPs expiring before date |
| `list()` with expiry_after filter | Returns LPs expiring after date |
| `list()` with expiry range | Returns LPs within date range |
| `list()` with complex multi-filter | All conditions applied with AND |
| `list()` with sort by expiry_date | Results sorted correctly |
| `list()` with pagination | Returns correct page of results |
| `getExpiringSoon()` preset | Returns LPs expiring within days |
| `getAvailableStock()` preset | Returns available+passed LPs |

### Integration Tests

**File:** `__tests__/integration/api/warehouse/lp-filters.test.ts`

| Test Case | Description |
|-----------|-------------|
| GET with search param | Search returns correct results |
| GET with batch_number param | Batch filter works |
| GET with product_ids param | Multiple products filter |
| GET with status param | Status filter works |
| GET with qa_status param | QA status filter works |
| GET with expiry range params | Date range filter works |
| GET with 5+ combined params | Complex filter returns correct results |
| GET with invalid date format | Returns 400 validation error |
| GET with page size > 200 | Enforces maximum limit |
| GET with no matches | Returns empty array with 200 status |
| Performance test (10K LPs) | Response time < 500ms |

### E2E Tests

**File:** `__tests__/e2e/warehouse/lp-filters.spec.ts`

| Test Case | Description |
|-----------|-------------|
| Open filter panel | Panel slides in, all options visible |
| Apply single filter | Results update, chip appears |
| Apply multiple filters | Multiple chips, combined results |
| Remove filter chip | Filter removed, results update |
| Clear all filters | All chips removed, full list shown |
| Search LP number | Debounced search executes, results update |
| Apply filter preset | Preset applies multiple filters |
| Sort results | Column sort toggles asc/desc |
| Paginate filtered results | Pagination works with active filters |

---

## Definition of Done

### Backend
- [ ] API endpoint accepts all filter parameters
- [ ] Query builder uses appropriate indexes for each filter
- [ ] Response times meet requirements:
  - Simple filter: < 500ms
  - Complex filter (5+ params): < 500ms
  - Search: < 300ms
- [ ] Validation rejects invalid parameters
- [ ] Pagination enforces max limit (200)
- [ ] All database indexes created

### Frontend
- [ ] Advanced filter panel renders with all options
- [ ] Filter chips display active filters
- [ ] Search input debounces (300ms)
- [ ] Filter presets apply correctly
- [ ] Multi-select components work for products/locations
- [ ] Date range picker validates dates
- [ ] Clear all filters button works
- [ ] Filter state persisted in URL params
- [ ] Empty state shown for no results
- [ ] Loading states during query execution

### Testing
- [ ] Unit tests: >80% coverage on filter logic
- [ ] Integration tests: All filter combinations covered
- [ ] Performance tests: 10K LP dataset, all < 500ms
- [ ] E2E tests: Filter panel interactions passing

### Documentation
- [ ] Query parameters documented
- [ ] Filter presets documented
- [ ] Index usage explained

---

## Future Phases (Not in This Story)

### Story 05.36 - Inventory Browser (Advanced)
- Saved filter templates
- Custom filter combinations
- Advanced grouping/aggregation
- Full-text search (product name, location name)

### Story 05.38 - Inventory Reports
- Export filtered results (CSV, Excel)
- Scheduled reports with filters
- Email reports

### Story 05.30 - Zone Management
- Filter by zone
- Zone-based pick suggestions

### Story 05.26 - Pallet Management
- Filter by pallet ID
- Pallet-level search

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Query performance with complex filters | HIGH | MEDIUM | Composite indexes, query optimization, pagination |
| Too many filter options overwhelming UI | MEDIUM | LOW | Progressive disclosure, presets, clear defaults |
| Filter state management complexity | MEDIUM | MEDIUM | URL params, clear state structure |
| Date range validation edge cases | LOW | MEDIUM | Comprehensive validation tests |
| Index maintenance overhead | LOW | LOW | Monitor query plans, remove unused indexes |

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-12-16 | Initial story creation with comprehensive filter requirements | SONNET |
