# 05.4 - LP Status Management

**Priority**: P0 (Phase 0 - CRITICAL)
**Story Points**: M (Medium - 2-3 days)
**Type:** backend + frontend
**Model:** opus

**State:** ready
**Primary PRD:** `docs/1-BASELINE/product/modules/warehouse.md` (WH-FR-002, WH-FR-008)
**Production PRD:** `docs/1-BASELINE/product/modules/production.md` (consumption validation)
**Architecture:** `docs/1-BASELINE/architecture/modules/warehouse.md`

---

## CRITICAL - Supports Epic 04.6 (Material Consumption)

**THIS STORY SUPPORTS EPIC 04 PRODUCTION PHASE 1**

Epic 04.6 (Material Consumption - Desktop/Scanner) requires:
1. Status validation: LP must have `status='available'` before consumption
2. QA validation: LP must have `qa_status='passed'` before consumption
3. Status transition: LP.status updates to `'consumed'` when fully consumed
4. Audit trail of all status changes (who, when, why)
5. API methods for status validation and transitions

---

## MVP Scope

This story delivers the **LP Status Management infrastructure** that Epic 04 Production and other modules need:

**In Scope:**
- Status field validation and transitions (available → reserved → consumed → blocked)
- QA Status field validation and transitions (pending → passed/failed/quarantine)
- Status transition rules and constraints
- API endpoints for status updates (`/api/warehouse/license-plates/:id/status`, `/api/warehouse/license-plates/:id/qa-status`)
- Service methods for status validation and transitions
- Desktop UI components (status badges, status change modals, audit log display)
- Audit trail table (`lp_status_audit`) tracking all status changes
- Validation logic Epic 04.6 will consume
- Tests for all status transitions and edge cases

**Out of Scope:**
- Status-based filtering in LP list (Story 05.5 - LP CRUD implements)
- Automatic status changes from consumption (Epic 04.6 implements)
- Automatic status changes from reservations (Story 05.3 implements)
- Scanner UI for status changes (Phase 2)
- Quarantine location moves (Phase 1 - Story 05.11 implements)

---

## Epic 04 Dependency Status

- [x] **CRITICAL - Supports Epic 04 Phase 1**
- [ ] NOT CRITICAL - Can defer

**Rationale:** Epic 04.6 (Material Consumption) requires status validation before consumption:
1. `validateLPForConsumption(lpId)` - checks status='available' AND qa_status='passed'
2. `updateLPStatus(lpId, newStatus)` - transitions status with audit trail
3. `updateQAStatus(lpId, newQAStatus)` - transitions QA status with audit trail
4. Status business rules enforced consistently

---

## Goal

Enable comprehensive lifecycle tracking of License Plates through status and QA status fields, with strict validation rules, audit trails, and transitions that support consumption, reservations, and quality control workflows.

## User Story

As a **warehouse manager**, I want **to track and manage LP status and QA status throughout their lifecycle** so that **only available and QA-passed LPs can be consumed, and I have a complete audit trail of all status changes**.

## Scope

**In scope (this story)**
- Status field: available, reserved, consumed, blocked
- QA Status field: pending, passed, failed, quarantine
- Status transition validation rules
- QA Status transition rules with automatic status updates
- Status audit trail table
- Service methods for status validation and transitions
- API endpoints for status updates
- Desktop UI: status badges, change modals, audit log
- Unit tests for all transitions and edge cases
- Integration tests for audit trail

**Out of scope (this story)**
- LP list filtering by status (Story 05.5)
- Automatic status updates from consumption (Epic 04.6)
- Automatic status updates from reservations (Story 05.3)
- Scanner status change UI (Phase 2)
- Stock moves to quarantine locations (Story 05.11)

## Dependencies

- **05.0** - Warehouse Settings (default_qa_status, require_qa_on_receipt)
- **05.1** - LP Table + Basic Service (license_plates table with status/qa_status columns)

---

## Status Transition Rules

### LP Status Transitions

```
     ┌─────────────┐
     │  available  │ ◄──────────────────┐
     └─────┬───────┘                    │
           │                            │
           │ (full reservation)         │ (release reservation)
           v                            │
     ┌─────────────┐                    │
     │  reserved   │ ───────────────────┘
     └─────┬───────┘
           │
           │ (full consumption)
           v
     ┌─────────────┐
     │  consumed   │ (TERMINAL STATE)
     └─────────────┘

     ┌─────────────┐
     │   blocked   │ (QA failed, manual block)
     └─────┬───────┘
           │
           │ (manual unblock)
           v
     ┌─────────────┐
     │  available  │
     └─────────────┘
```

**Valid Transitions:**
- `available → reserved` (via Story 05.3 reservation service)
- `reserved → available` (via Story 05.3 release)
- `available → consumed` (via Epic 04.6 consumption)
- `reserved → consumed` (via Epic 04.6 consumption from reservation)
- `available → blocked` (manual or QA failure)
- `blocked → available` (manual unblock)

**Invalid Transitions:**
- `consumed → *` (consumed is terminal, except reversals in future phases)
- `reserved → blocked` (must release first)

### QA Status Transitions

```
     ┌─────────────┐
     │   pending   │ (default on receipt)
     └──────┬──────┘
            │
       ┌────┴────┐
       │         │
       v         v
  ┌────────┐  ┌────────┐
  │ passed │  │ failed │
  └────────┘  └───┬────┘
                  │
                  │ (quarantine)
                  v
            ┌────────────┐
            │ quarantine │
            └─────┬──────┘
                  │
                  │ (release)
                  v
            ┌────────┐
            │ passed │
            └────────┘
```

**Side Effects:**
- `qa_status: pending → failed` triggers `status → blocked`
- `qa_status: failed → quarantine` triggers `status → blocked` (if not already)
- `qa_status: quarantine → passed` triggers `status → available`

---

## Interface Contract for Epic 04.6

**CRITICAL: These methods are the contract that Epic 04.6 will consume.**

```typescript
// lib/services/lp-status-service.ts

export type LPStatus = 'available' | 'reserved' | 'consumed' | 'blocked';
export type QAStatus = 'pending' | 'passed' | 'failed' | 'quarantine';

export interface StatusValidationResult {
  valid: boolean;
  error?: string;
  currentStatus?: LPStatus;
  currentQAStatus?: QAStatus;
}

export interface StatusAuditEntry {
  id: string;
  lp_id: string;
  field_name: 'status' | 'qa_status';
  old_value: string;
  new_value: string;
  reason: string | null;
  changed_by: string;
  changed_at: string;
}

/**
 * Validate LP is available for consumption (Epic 04.6 uses this)
 * @param lpId - License Plate ID
 * @returns Validation result with error if invalid
 */
export async function validateLPForConsumption(
  lpId: string
): Promise<StatusValidationResult>;

/**
 * Update LP status with validation and audit trail
 * @param lpId - License Plate ID
 * @param newStatus - New status value
 * @param reason - Optional reason for change
 * @returns Updated LP
 */
export async function updateLPStatus(
  lpId: string,
  newStatus: LPStatus,
  reason?: string
): Promise<LicensePlate>;

/**
 * Update QA status with side effects and audit trail
 * @param lpId - License Plate ID
 * @param newQAStatus - New QA status value
 * @param reason - Optional reason for change
 * @returns Updated LP
 */
export async function updateQAStatus(
  lpId: string,
  newQAStatus: QAStatus,
  reason?: string
): Promise<LicensePlate>;

/**
 * Get status audit trail for LP
 * @param lpId - License Plate ID
 * @returns List of audit entries
 */
export async function getStatusAuditTrail(
  lpId: string
): Promise<StatusAuditEntry[]>;

/**
 * Validate status transition is allowed
 * @param currentStatus - Current LP status
 * @param newStatus - Proposed new status
 * @returns Validation result
 */
export async function validateStatusTransition(
  currentStatus: LPStatus,
  newStatus: LPStatus
): Promise<StatusValidationResult>;

/**
 * Check if LP status allows consumption
 * @param status - LP status
 * @param qaStatus - LP QA status
 * @returns True if consumption allowed
 */
export function isConsumptionAllowed(
  status: LPStatus,
  qaStatus: QAStatus
): boolean;
```

---

## Acceptance Criteria (Given/When/Then)

### AC-1: Default QA Status on LP Creation (WH-FR-008)

```gherkin
Scenario: LP created with default QA status from settings
Given warehouse_settings.require_qa_on_receipt = true
And warehouse_settings.default_qa_status = 'pending'
When LP created via GRN
Then LP.qa_status = 'pending'
And LP.status = 'available' (status not affected by QA pending)
```

### AC-2: QA Pass Transition (WH-FR-008)

```gherkin
Scenario: QA inspector passes LP
Given LP with qa_status='pending' AND status='available'
When updateQAStatus(lpId, 'passed', 'QA inspection passed') called
Then LP.qa_status updates to 'passed'
And LP.status remains 'available'
And status_audit entry created with:
  - field_name = 'qa_status'
  - old_value = 'pending'
  - new_value = 'passed'
  - reason = 'QA inspection passed'
  - changed_by = current user
  - changed_at = NOW()
And operation completes in <200ms
```

### AC-3: QA Fail Triggers Blocked Status (WH-FR-008)

```gherkin
Scenario: QA failure blocks LP
Given LP with qa_status='pending' AND status='available'
When updateQAStatus(lpId, 'failed', 'Failed moisture test') called
Then LP.qa_status updates to 'failed'
And LP.status updates to 'blocked' (automatic side effect)
And 2 audit entries created:
  - Entry 1: qa_status: pending → failed
  - Entry 2: status: available → blocked (reason: 'Auto-blocked: QA failed')
```

### AC-4: Quarantine Transition (WH-FR-008)

```gherkin
Scenario: Move failed LP to quarantine
Given LP with qa_status='failed' AND status='blocked'
When updateQAStatus(lpId, 'quarantine', 'Moved to quarantine location') called
Then LP.qa_status updates to 'quarantine'
And LP.status remains 'blocked'
And audit entry created for qa_status change
```

### AC-5: Release from Quarantine (WH-FR-008)

```gherkin
Scenario: Release LP from quarantine after retest
Given LP with qa_status='quarantine' AND status='blocked'
When updateQAStatus(lpId, 'passed', 'Retest passed') called
Then LP.qa_status updates to 'passed'
And LP.status updates to 'available' (automatic side effect)
And 2 audit entries created
```

### AC-6: Consumption Validation - Success (WH-FR-008)

```gherkin
Scenario: Valid LP for consumption
Given LP with status='available' AND qa_status='passed'
When validateLPForConsumption(lpId) called
Then returns { valid: true }
```

### AC-7: Consumption Validation - QA Not Passed (WH-FR-008)

```gherkin
Scenario: Block consumption of non-QA-passed LP
Given LP with status='available' AND qa_status='pending'
When validateLPForConsumption(lpId) called
Then returns {
  valid: false,
  error: "LP not QA approved for consumption (qa_status: pending)",
  currentQAStatus: 'pending'
}
```

### AC-8: Consumption Validation - Status Not Available

```gherkin
Scenario: Block consumption of consumed LP
Given LP with status='consumed' AND qa_status='passed'
When validateLPForConsumption(lpId) called
Then returns {
  valid: false,
  error: "LP not available for consumption (status: consumed)",
  currentStatus: 'consumed'
}
```

### AC-9: Reserved LP Consumption Allowed

```gherkin
Scenario: Reserved LP can be consumed (by WO that reserved it)
Given LP with status='reserved' AND qa_status='passed'
When validateLPForConsumption(lpId) called
Then returns { valid: true } (Epic 04.6 validates reservation ownership)
```

### AC-10: Blocked LP Consumption Blocked

```gherkin
Scenario: Cannot consume blocked LP
Given LP with status='blocked' AND qa_status='failed'
When validateLPForConsumption(lpId) called
Then returns {
  valid: false,
  error: "LP not available for consumption (status: blocked, qa_status: failed)"
}
```

### AC-11: Invalid Status Transition Blocked (WH-FR-002)

```gherkin
Scenario: Cannot transition from consumed status
Given LP with status='consumed'
When updateLPStatus(lpId, 'available') attempted
Then returns 400 error "Invalid status transition: consumed → available (consumed is terminal)"
And LP.status remains 'consumed'
And no audit entry created
```

### AC-12: Desktop UI - Status Badge Colors

```gherkin
Scenario: Status badges display with correct colors
Given user views LP detail page
When LP has status='available' AND qa_status='passed'
Then status badge displays "Available" in green
And QA status badge displays "Passed" in green

When LP has status='blocked' AND qa_status='failed'
Then status badge displays "Blocked" in red
And QA status badge displays "Failed" in red

When LP has status='available' AND qa_status='pending'
Then status badge displays "Available" in green
And QA status badge displays "Pending" in yellow

When LP has status='consumed'
Then status badge displays "Consumed" in gray
```

### AC-13: Desktop UI - Change QA Status Modal (Manager Only)

```gherkin
Scenario: Manager changes QA status
Given Manager role user views LP with qa_status='pending'
And "Change QA Status" button visible
When clicks "Change QA Status"
Then modal opens with:
  - Current QA Status: Pending
  - Radio options: Passed, Failed
  - Reason field (required)
  - Confirm/Cancel buttons
When selects "Passed" and enters reason "Visual inspection OK"
And clicks Confirm
Then updateQAStatus API called
And modal closes
And success toast: "QA Status updated to Passed"
And LP detail refreshes with new qa_status
```

### AC-14: Desktop UI - Audit Trail Display

```gherkin
Scenario: View status change history
Given LP with 5 status changes
When user clicks "Status History" tab on LP detail page
Then displays table with columns:
  - Field (Status or QA Status)
  - Old Value
  - New Value
  - Reason
  - Changed By
  - Changed At
And entries sorted by changed_at DESC (newest first)
And "QA Status: pending → failed" entry shows reason "Failed moisture test"
```

### AC-15: Permissions - QA Status Change (WH-FR-008)

```gherkin
Scenario: Only Manager/QA role can change QA status
Given Operator role user views LP
When LP detail page loads
Then "Change QA Status" button NOT visible

Given Manager role user views same LP
Then "Change QA Status" button visible
```

### AC-16: Permissions - Manual Block/Unblock

```gherkin
Scenario: Manager can manually block/unblock LP
Given Manager views LP with status='available'
When clicks "Block LP" button
Then confirmation modal: "Block LP-00001? Reason required."
When enters reason "Damaged packaging"
And clicks Confirm
Then LP.status updates to 'blocked'
And audit entry created
And "Unblock LP" button now visible
```

### AC-17: Audit Trail Query Performance (WH-FR-002)

```gherkin
Scenario: Audit trail retrieval is fast
Given LP with 100 audit entries
When getStatusAuditTrail(lpId) called
Then returns all entries in <200ms
And entries include user.name (joined)
```

### AC-18: Batch QA Status Update (Bonus - Low Priority)

```gherkin
Scenario: Update QA status for multiple LPs (same GRN)
Given 10 LPs from same GRN all with qa_status='pending'
When Manager selects all 10 and clicks "Batch Update QA Status"
Then modal allows selecting new qa_status and reason
When "Passed" selected with reason "Batch QA passed"
Then all 10 LPs qa_status updated to 'passed'
And 10 audit entries created
And operation completes in <1000ms
```

---

## Implementation Notes

### Database Schema

```sql
-- Add to license_plates table (already exists from 05.1)
-- Just documenting the fields this story manages:
--   status TEXT NOT NULL DEFAULT 'available'
--   qa_status TEXT NOT NULL DEFAULT 'pending'

-- Status audit trail table (NEW)
CREATE TABLE lp_status_audit (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id),
  lp_id UUID NOT NULL REFERENCES license_plates(id),
  field_name TEXT NOT NULL,  -- 'status' or 'qa_status'
  old_value TEXT NOT NULL,
  new_value TEXT NOT NULL,
  reason TEXT,
  changed_by UUID NOT NULL REFERENCES users(id),
  changed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Constraints
  CONSTRAINT valid_field_name CHECK (field_name IN ('status', 'qa_status'))
);

-- Indexes
CREATE INDEX idx_status_audit_lp ON lp_status_audit(lp_id, changed_at DESC);
CREATE INDEX idx_status_audit_org ON lp_status_audit(org_id, changed_at DESC);
CREATE INDEX idx_status_audit_field ON lp_status_audit(lp_id, field_name);

-- RLS
ALTER TABLE lp_status_audit ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Status audit org isolation" ON lp_status_audit
  FOR ALL USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));
```

### Status Validation Logic

```typescript
// lib/services/lp-status-service.ts

const VALID_TRANSITIONS: Record<LPStatus, LPStatus[]> = {
  available: ['reserved', 'consumed', 'blocked'],
  reserved: ['available', 'consumed'],
  consumed: [],  // Terminal state
  blocked: ['available']
};

export async function validateStatusTransition(
  currentStatus: LPStatus,
  newStatus: LPStatus
): Promise<StatusValidationResult> {
  // Cannot transition from same status to same status
  if (currentStatus === newStatus) {
    return {
      valid: false,
      error: `Status is already ${currentStatus}`
    };
  }

  // Check if transition is in valid transitions map
  const allowedTransitions = VALID_TRANSITIONS[currentStatus];
  if (!allowedTransitions.includes(newStatus)) {
    return {
      valid: false,
      error: `Invalid status transition: ${currentStatus} → ${newStatus}`,
      currentStatus
    };
  }

  return { valid: true };
}

export async function validateLPForConsumption(
  lpId: string
): Promise<StatusValidationResult> {
  const lp = await getLicensePlate(lpId);

  // Check status (available or reserved allowed)
  if (lp.status !== 'available' && lp.status !== 'reserved') {
    return {
      valid: false,
      error: `LP not available for consumption (status: ${lp.status})`,
      currentStatus: lp.status,
      currentQAStatus: lp.qa_status
    };
  }

  // Check QA status (must be passed)
  if (lp.qa_status !== 'passed') {
    return {
      valid: false,
      error: `LP not QA approved for consumption (qa_status: ${lp.qa_status})`,
      currentStatus: lp.status,
      currentQAStatus: lp.qa_status
    };
  }

  return { valid: true };
}

export function isConsumptionAllowed(
  status: LPStatus,
  qaStatus: QAStatus
): boolean {
  return (status === 'available' || status === 'reserved') && qaStatus === 'passed';
}
```

### QA Status Side Effects

```typescript
// lib/services/lp-status-service.ts

const QA_STATUS_SIDE_EFFECTS: Record<QAStatus, { status?: LPStatus; reason: string } | null> = {
  pending: null,
  passed: { status: 'available', reason: 'Auto-unblocked: QA passed' },  // If from quarantine
  failed: { status: 'blocked', reason: 'Auto-blocked: QA failed' },
  quarantine: null  // Status already blocked from 'failed'
};

export async function updateQAStatus(
  lpId: string,
  newQAStatus: QAStatus,
  reason?: string
): Promise<LicensePlate> {
  const supabase = createClient();
  const userId = await getCurrentUserId();
  const lp = await getLicensePlate(lpId);

  // Start transaction
  const { data, error } = await supabase.rpc('update_qa_status_with_audit', {
    p_lp_id: lpId,
    p_old_qa_status: lp.qa_status,
    p_new_qa_status: newQAStatus,
    p_reason: reason,
    p_user_id: userId
  });

  // Handle side effects
  const sideEffect = QA_STATUS_SIDE_EFFECTS[newQAStatus];
  if (sideEffect && (newQAStatus === 'failed' || (newQAStatus === 'passed' && lp.status === 'blocked'))) {
    await updateLPStatus(lpId, sideEffect.status, sideEffect.reason);
  }

  return data;
}
```

### API Endpoints

```typescript
// Status management endpoints
PUT    /api/warehouse/license-plates/:id/status         -- Update status
PUT    /api/warehouse/license-plates/:id/qa-status      -- Update QA status
GET    /api/warehouse/license-plates/:id/status-audit   -- Get audit trail
POST   /api/warehouse/license-plates/:id/block          -- Block LP (shortcut)
POST   /api/warehouse/license-plates/:id/unblock        -- Unblock LP (shortcut)

// Validation endpoints (for Epic 04.6)
POST   /api/warehouse/license-plates/:id/validate-consumption  -- Validate for consumption
```

### Frontend Components

```
app/(authenticated)/warehouse/
  license-plates/[id]/
    components/
      StatusBadge.tsx              -- Status badge with color coding
      QAStatusBadge.tsx            -- QA status badge with color coding
      ChangeQAStatusModal.tsx      -- QA status update modal (Manager only)
      BlockLPModal.tsx             -- Block/unblock confirmation modal
      StatusAuditTrail.tsx         -- Audit history table
      StatusTimelineView.tsx       -- Visual timeline of status changes
```

### Services

```typescript
// lib/services/lp-status-service.ts
export async function validateLPForConsumption(lpId: string): Promise<StatusValidationResult>
export async function updateLPStatus(lpId: string, newStatus: LPStatus, reason?: string): Promise<LicensePlate>
export async function updateQAStatus(lpId: string, newQAStatus: QAStatus, reason?: string): Promise<LicensePlate>
export async function getStatusAuditTrail(lpId: string): Promise<StatusAuditEntry[]>
export async function validateStatusTransition(current: LPStatus, new: LPStatus): Promise<StatusValidationResult>
export function isConsumptionAllowed(status: LPStatus, qaStatus: QAStatus): boolean
export async function blockLP(lpId: string, reason: string): Promise<LicensePlate>
export async function unblockLP(lpId: string, reason: string): Promise<LicensePlate>
```

### Validation (Zod)

```typescript
// lib/validation/lp-status-schemas.ts
import { z } from 'zod';

export const lpStatusEnum = z.enum(['available', 'reserved', 'consumed', 'blocked']);
export const qaStatusEnum = z.enum(['pending', 'passed', 'failed', 'quarantine']);

export const updateStatusSchema = z.object({
  status: lpStatusEnum,
  reason: z.string().optional(),
});

export const updateQAStatusSchema = z.object({
  qa_status: qaStatusEnum,
  reason: z.string().min(1, "Reason required for QA status change"),
});

export const blockLPSchema = z.object({
  reason: z.string().min(5, "Reason must be at least 5 characters"),
});
```

---

## Key Business Rules

1. **Terminal Status**: `consumed` is a terminal state (no transitions out except future reversals)
2. **QA Required**: Only `qa_status='passed'` LPs can be consumed
3. **Status Allowed**: Only `status='available'` or `status='reserved'` LPs can be consumed
4. **QA Fail Blocks**: `qa_status → failed` automatically triggers `status → blocked`
5. **Quarantine Release**: `qa_status: quarantine → passed` automatically triggers `status → blocked → available`
6. **Audit Required**: ALL status changes must create audit trail entries
7. **Reason Required**: QA status changes require reason (not required for automatic side effects)
8. **Reserved Consumption**: Reserved LPs can be consumed (Epic 04.6 validates ownership)
9. **No Self-Transitions**: Cannot transition from status X to status X
10. **Manager Only**: QA status changes and manual block/unblock are Manager/QA role only
11. **Default QA**: New LPs get `qa_status` from `warehouse_settings.default_qa_status`
12. **Available Default**: New LPs get `status='available'` by default (unless QA fails)

---

## Deliverables

- **Migration**: `lp_status_audit` table with RLS
- **API Routes**:
  - `PUT /api/warehouse/license-plates/:id/status`
  - `PUT /api/warehouse/license-plates/:id/qa-status`
  - `GET /api/warehouse/license-plates/:id/status-audit`
  - `POST /api/warehouse/license-plates/:id/block`
  - `POST /api/warehouse/license-plates/:id/unblock`
  - `POST /api/warehouse/license-plates/:id/validate-consumption`
- **Services**:
  - `lp-status-service.ts` (all methods in Interface Contract)
- **Components**:
  - `StatusBadge.tsx`
  - `QAStatusBadge.tsx`
  - `ChangeQAStatusModal.tsx`
  - `BlockLPModal.tsx`
  - `StatusAuditTrail.tsx`
- **Tests**:
  - Unit tests for status transition validation
  - Unit tests for QA status side effects
  - Integration tests for audit trail creation
  - Permission tests (Manager vs Operator)
  - Edge cases: terminal state, invalid transitions

---

## Test Cases (Edge Cases)

### Status Transition Tests

| Test Case | Current Status | New Status | Expected Result |
|-----------|----------------|------------|-----------------|
| Valid: available → reserved | available | reserved | Success |
| Valid: reserved → available | reserved | available | Success |
| Valid: available → consumed | available | consumed | Success |
| Valid: available → blocked | available | blocked | Success |
| Valid: blocked → available | blocked | available | Success |
| Invalid: consumed → available | consumed | available | Error: terminal state |
| Invalid: consumed → blocked | consumed | blocked | Error: terminal state |
| Invalid: reserved → blocked | reserved | blocked | Error: invalid transition |
| Self-transition: available → available | available | available | Error: already available |

### QA Status Tests

| Test Case | Current QA | New QA | Side Effect | Expected Result |
|-----------|------------|--------|-------------|-----------------|
| QA Pass | pending | passed | None | Success |
| QA Fail | pending | failed | status → blocked | 2 audit entries |
| Quarantine | failed | quarantine | None | Success |
| Release | quarantine | passed | status → available | 2 audit entries |
| Invalid: passed → pending | passed | pending | None | Error: invalid transition |

### Consumption Validation Tests

| Test Case | Status | QA Status | Expected Result |
|-----------|--------|-----------|-----------------|
| Valid | available | passed | { valid: true } |
| Valid reserved | reserved | passed | { valid: true } |
| Invalid: consumed | consumed | passed | Error: status consumed |
| Invalid: blocked | blocked | passed | Error: status blocked |
| Invalid: QA pending | available | pending | Error: qa_status pending |
| Invalid: QA failed | available | failed | Error: qa_status failed |
| Invalid: both | blocked | pending | Error: status blocked, qa_status pending |

### Audit Trail Tests

| Test Case | Action | Expected Entries |
|-----------|--------|------------------|
| Simple status change | available → blocked | 1 entry (status) |
| QA fail | pending → failed | 2 entries (qa_status + status) |
| QA pass from quarantine | quarantine → passed | 2 entries (qa_status + status) |
| Batch update 10 LPs | 10 LPs: pending → passed | 10 entries |

---

## Definition of Done

- [ ] `lp_status_audit` table created with indexes
- [ ] RLS policy enforces org_id isolation on audit table
- [ ] Status transition validation enforces VALID_TRANSITIONS map
- [ ] QA status side effects (failed → blocked, passed → available) working
- [ ] `validateLPForConsumption()` checks both status and qa_status
- [ ] Audit trail entry created for EVERY status change
- [ ] Reason field captured in audit trail
- [ ] API endpoints functional with <200ms response
- [ ] Desktop UI: StatusBadge shows correct colors
- [ ] Desktop UI: QAStatusBadge shows correct colors
- [ ] Desktop UI: ChangeQAStatusModal for Manager role only
- [ ] Desktop UI: BlockLPModal with reason required
- [ ] Desktop UI: StatusAuditTrail displays sorted entries
- [ ] Permissions: Manager/QA can change QA status, Operator cannot
- [ ] Consumed status blocks all transitions (except in tests)
- [ ] Unit tests >80% coverage
- [ ] Edge case tests: terminal state, invalid transitions, side effects
- [ ] Integration tests for audit trail creation
- [ ] Service methods match interface contract for Epic 04.6
- [ ] Documentation updated

---

## Future Phases (Not in This Story)

### Epic 04.6 (Material Consumption)
- Automatic status update: `available → consumed` when LP fully consumed
- Automatic `consumed_by_wo_id` tracking
- Consumption reversal (status: `consumed → available`)

### Story 05.3 (LP Reservations)
- Automatic status update: `available → reserved` when fully reserved
- Automatic status update: `reserved → available` when reservation released

### Story 05.11 (Stock Moves)
- Automatic stock move to quarantine location when `qa_status → quarantine`
- Movement history tracking with status at time of move

### Phase 2 (Scanner Workflows)
- Scanner UI for QA status updates
- Barcode scan to block/unblock LP
- Audio feedback on status changes

### Phase 3 (Advanced)
- Workflow rules: auto-block LP on expiry
- Workflow rules: auto-quarantine on threshold breach
- Approval workflows for unblock actions

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-12-16 | Initial story - LP Status Management | SONNET (Story Writer) |
