# 05.2 - LP Genealogy Tracking

**Priority**: P0 (Phase 0 - CRITICAL)
**Story Points**: L (3-4 days)
**Type:** backend + frontend

**State:** ready
**Primary PRD:** `docs/1-BASELINE/product/modules/warehouse.md` (WH-FR-028)
**Architecture:** `docs/1-BASELINE/architecture/modules/warehouse.md`

---

## MVP Scope

LP Genealogy Tracking provides the data model and service layer for recording parent-child relationships between License Plates. This is **CRITICAL infrastructure** that Epic 04 Production (Output Registration) depends on for material traceability.

**Phase 0 MVP includes:**
- `lp_genealogy` table with RLS policies
- Genealogy service with all CRUD operations
- Four operation types: `consume`, `output`, `split`, `merge`
- Recursive CTE queries for forward/backward tracing (10 level depth limit)
- API endpoints for genealogy creation and querying
- Desktop UI: Genealogy tree visualization panel in LP detail view
- Service methods Epic 04 requires:
  - `linkConsumption(parentLpId, childLpId, woId, qty)`
  - `linkOutput(consumedLpIds[], outputLpId, woId)`
  - `getForwardTrace(lpId)` - where did this LP go?
  - `getBackwardTrace(lpId)` - where did this LP come from?
- Genealogy reversal support (for consumption corrections)
- Multi-level tree traversal tests

**Phase 0 EXCLUDES:**
- Interactive genealogy tree visualization (Story 05.31)
- Genealogy export to PDF/Excel (Phase 3)
- Real-time genealogy updates via WebSocket (Phase 3)
- Cross-organization genealogy (out of scope - data isolation)
- Genealogy analytics/reporting (Phase 4)

---

## Epic 04 Dependency Status

- [x] **CRITICAL - Unblocks Epic 04.7 (Output Registration)**
- [ ] NOT CRITICAL - Can defer

**What Epic 04 Production Needs from 05.2:**

| Epic 04 Story | Genealogy Feature Required | Method |
|---------------|---------------------------|--------|
| 04.6a-e (Consumption) | Link consumed LP to WO | `linkConsumption()` |
| 04.7a-d (Output Registration) | Link consumed LPs to output LP | `linkOutput()` |
| 04.7c (By-Products) | Link consumed LPs to by-product LPs | `linkOutput()` |
| Any Traceability Query | Forward/backward trace | `getForwardTrace()`, `getBackwardTrace()` |

**Critical Integration:** When Production creates an output LP from consumed materials, it MUST call `linkOutput()` to establish genealogy. This enables full forward and backward traceability for food safety compliance.

---

## Goal

Implement the LP Genealogy tracking system to record and query parent-child relationships between License Plates, enabling full forward and backward traceability for production operations, split/merge operations, and regulatory compliance.

## User Story

As a **production manager**, I want **to trace the complete history of any License Plate - where its materials came from and where it went** so that **I can respond to quality recalls, audit production batches, and ensure full traceability for food safety compliance**.

## Scope

**In scope (this story)**
- `lp_genealogy` table creation with proper indexes
- RLS policy for org_id isolation
- Genealogy service: `lp-genealogy-service.ts`
- Core operations:
  - `linkConsumption(parentLpId, childLpId, woId, qty)` - Record LP consumed in production
  - `linkOutput(consumedLpIds[], outputLpId, woId)` - Link multiple consumed LPs to output
  - `linkSplit(sourceLpId, newLpId, qty)` - Record split operation
  - `linkMerge(sourceLpIds[], targetLpId)` - Record merge operation
  - `reverseLink(genealogyId)` - Mark link as reversed (for corrections)
- Query operations:
  - `getForwardTrace(lpId, maxDepth)` - Find all descendants
  - `getBackwardTrace(lpId, maxDepth)` - Find all ancestors
  - `getFullTree(lpId, direction)` - Get complete genealogy tree
  - `getGenealogyByWO(woId)` - Get all genealogy for a WO
- API endpoints for all operations
- Desktop UI: Genealogy tree panel in LP detail view
- Zod validation schemas
- Unit tests for recursive queries
- E2E test for multi-level genealogy scenarios

**Out of scope (this story)**
- Interactive tree visualization (drag/zoom) - Story 05.31
- Genealogy-based recall functionality - Epic 06 Quality
- Scanner genealogy view - Story 05.22
- Genealogy export to documents - Phase 3
- Genealogy analytics dashboards - Phase 4

## Dependencies

- **05.0** - Warehouse Settings (org_id configuration)
- **05.1** - LP Table + Basic Service (`license_plates` table must exist)
- **01.1** - Multi-tenancy (RLS, org_id filtering)
- **01.8, 01.9** - Warehouses, Locations (LP location context)
- **02.1** - Products (for genealogy display context)
- **03.10** - Work Orders (wo_id reference for production genealogy)

---

## Acceptance Criteria (Given/When/Then)

### AC-1: Genealogy Table Creation

**Given** database migration for `lp_genealogy` table
**When** migration is applied
**Then**
- Table `lp_genealogy` exists with all required columns
- `id`, `org_id`, `parent_lp_id`, `child_lp_id`, `operation_type`, `quantity`, `operation_date`, `wo_id`, `operation_id`, `is_reversed`, `created_at` columns present
- Foreign key constraints to `license_plates` and `work_orders` tables
- Indexes created on `parent_lp_id`, `child_lp_id`, `wo_id`
- RLS policy enforces org_id isolation

### AC-2: RLS Policy Enforcement

**Given** user belongs to org_id = 'org-abc'
**When** user queries `lp_genealogy` table
**Then**
- Only records with org_id = 'org-abc' are returned
- Attempting to insert record with different org_id fails
- API returns 403 Forbidden if org_id mismatch detected
- Direct SQL queries also filtered by RLS

### AC-3: Link Consumption Operation

**Given** parent LP (LP-001, qty: 100) and output LP (LP-002) in work order WO-001
**When** `linkConsumption(LP-001, LP-002, WO-001, 50)` is called
**Then**
- New `lp_genealogy` record created with:
  - `parent_lp_id` = LP-001
  - `child_lp_id` = LP-002
  - `operation_type` = 'consume'
  - `quantity` = 50
  - `wo_id` = WO-001
  - `is_reversed` = false
  - `operation_date` = current timestamp
- Operation completes in <200ms
- Returns created genealogy record ID

### AC-4: Link Output Operation (Multiple Consumed LPs)

**Given** three consumed LPs (LP-001, LP-002, LP-003) and new output LP (LP-004) from WO-001
**When** `linkOutput([LP-001, LP-002, LP-003], LP-004, WO-001)` is called
**Then**
- Three `lp_genealogy` records created:
  - LP-001 -> LP-004 (consume)
  - LP-002 -> LP-004 (consume)
  - LP-003 -> LP-004 (consume)
- All records share same `wo_id` = WO-001
- All records have `operation_type` = 'output'
- Operation completes in <500ms (batch insert)
- Returns array of created genealogy record IDs

### AC-5: Link Split Operation

**Given** source LP (LP-001, qty: 100) and split creates new LP (LP-005)
**When** `linkSplit(LP-001, LP-005, 30)` is called
**Then**
- New `lp_genealogy` record created with:
  - `parent_lp_id` = LP-001
  - `child_lp_id` = LP-005
  - `operation_type` = 'split'
  - `quantity` = 30
  - `wo_id` = null (split is not a production operation)
- Operation completes in <200ms

### AC-6: Link Merge Operation

**Given** three source LPs (LP-001, LP-002, LP-003) merge into LP-001 (primary)
**When** `linkMerge([LP-002, LP-003], LP-001)` is called
**Then**
- Two `lp_genealogy` records created:
  - LP-002 -> LP-001 (merge)
  - LP-003 -> LP-001 (merge)
- `operation_type` = 'merge' for all records
- Quantities from each source LP captured
- Operation completes in <300ms

### AC-7: Reverse Genealogy Link

**Given** existing genealogy record (ID: gen-001) for consumption
**When** `reverseLink('gen-001')` is called (consumption correction)
**Then**
- Record `gen-001` updated: `is_reversed` = true
- `reversed_at` timestamp set to current time
- `reversed_by` set to current user ID
- Original record preserved (not deleted) for audit
- Operation completes in <100ms

### AC-8: Forward Trace Query (Single Level)

**Given** LP-001 was consumed to create LP-002, which was consumed to create LP-003
**When** `getForwardTrace(LP-001, maxDepth: 1)` is called
**Then**
- Returns array: [{ lp_id: LP-002, operation_type: 'consume', quantity: X, depth: 1 }]
- Only direct children returned (depth 1)
- Response time <200ms

### AC-9: Forward Trace Query (Multi-Level)

**Given** LP-001 -> LP-002 -> LP-003 -> LP-004 -> LP-005 (5-level chain)
**When** `getForwardTrace(LP-001, maxDepth: 10)` is called
**Then**
- Returns array with all 4 descendants: LP-002, LP-003, LP-004, LP-005
- Each result includes: lp_id, lp_number, product_name, operation_type, quantity, depth, operation_date
- Results ordered by depth ASC (closest first)
- Response time <500ms for up to 10 levels

### AC-10: Backward Trace Query (Multi-Level)

**Given** LP-005 is the end product, with ancestors: LP-004 -> LP-003 -> LP-002 -> LP-001
**When** `getBackwardTrace(LP-005, maxDepth: 10)` is called
**Then**
- Returns array with all 4 ancestors: LP-004, LP-003, LP-002, LP-001
- Each result includes: lp_id, lp_number, product_name, operation_type, quantity, depth, operation_date
- Results ordered by depth ASC (closest ancestors first)
- Response time <500ms for up to 10 levels

### AC-11: Forward Trace - Complex Tree (Multiple Children)

**Given** LP-001 was split into LP-002 and LP-003, LP-002 consumed to LP-004, LP-003 consumed to LP-005
**When** `getForwardTrace(LP-001, maxDepth: 5)` is called
**Then**
- Returns all descendants: [LP-002, LP-003, LP-004, LP-005]
- Tree structure preserved in response (LP-002 and LP-003 at depth 1, LP-004 and LP-005 at depth 2)
- No duplicates in result set

### AC-12: Backward Trace - Complex Tree (Multiple Parents)

**Given** LP-005 was created from consuming LP-001 and LP-002 and LP-003 (multiple inputs)
**When** `getBackwardTrace(LP-005, maxDepth: 5)` is called
**Then**
- Returns all ancestors: [LP-001, LP-002, LP-003]
- All at depth 1 (direct parents)
- If ancestors have their own parents, those are included at depth 2+

### AC-13: Depth Limit Enforcement

**Given** genealogy chain of 15 levels: LP-001 -> LP-002 -> ... -> LP-015
**When** `getForwardTrace(LP-001, maxDepth: 10)` is called
**Then**
- Returns only first 10 levels (LP-002 through LP-011)
- LP-012 through LP-015 excluded due to depth limit
- Warning flag in response: `hasMoreLevels: true`
- Performance stays under 1 second

### AC-14: Reversed Links Excluded by Default

**Given** LP-001 -> LP-002 genealogy link exists but is_reversed = true
**When** `getForwardTrace(LP-001)` is called without `includeReversed` flag
**Then**
- LP-002 NOT included in results (reversed links skipped)
- Results only show active genealogy links
- Can pass `includeReversed: true` to see all links

### AC-15: Get Genealogy by Work Order

**Given** WO-001 has 3 consumption links and 1 output link
**When** `getGenealogyByWO('WO-001')` is called
**Then**
- Returns all 4 genealogy records for WO-001
- Results grouped by operation_type: { consume: [...], output: [...] }
- Response time <300ms

### AC-16: Desktop UI - Genealogy Panel in LP Detail

**Given** user views LP detail page for LP-001 which has genealogy history
**When** page loads
**Then**
- "Genealogy" tab/panel visible
- Shows "Ancestors" section with backward trace (where materials came from)
- Shows "Descendants" section with forward trace (where LP went)
- Each item displays: LP number, product name, operation type badge, quantity, date
- Clicking an LP navigates to that LP's detail page
- Expand/collapse for each level of the tree

### AC-17: Desktop UI - Empty Genealogy State

**Given** user views LP detail page for newly created LP (no genealogy)
**When** page loads
**Then**
- Genealogy panel shows: "No genealogy history for this LP"
- Message explains: "Genealogy links are created when LP is consumed in production, split, or merged"
- Panel still visible but with empty state

### AC-18: Desktop UI - Genealogy Loading State

**Given** user views LP detail page with complex genealogy (many levels)
**When** genealogy panel is loading
**Then**
- Skeleton loader displays while query executes
- "Loading genealogy..." text shown
- Panel becomes interactive within 2 seconds
- Error state displayed if query fails with retry button

### AC-19: API Validation - Invalid LP IDs

**Given** API call to link genealogy with non-existent LP IDs
**When** `linkConsumption('invalid-id', 'LP-002', 'WO-001', 50)` is called
**Then**
- API returns 404 error: "Parent LP not found"
- No genealogy record created
- Same validation for child_lp_id and wo_id

### AC-20: API Validation - Self-Reference Prevention

**Given** attempt to create genealogy link where parent and child are same LP
**When** `linkConsumption('LP-001', 'LP-001', 'WO-001', 50)` is called
**Then**
- API returns 400 error: "Cannot create self-referencing genealogy link"
- No genealogy record created

### AC-21: API Validation - Duplicate Link Prevention

**Given** genealogy link LP-001 -> LP-002 (consume) already exists
**When** `linkConsumption('LP-001', 'LP-002', 'WO-001', 50)` is called again
**Then**
- API returns 409 Conflict: "Genealogy link already exists between these LPs for this operation"
- Duplicate record not created

### AC-22: API Validation - Operation Type Enum

**Given** attempt to create genealogy with invalid operation_type
**When** API receives `operation_type: 'invalid'`
**Then**
- API returns 400 error: "Invalid operation type. Must be one of: consume, output, split, merge"
- Zod schema validates operation_type enum

### AC-23: Performance - Large Genealogy Tree

**Given** LP with genealogy tree of 100+ nodes across 10 levels
**When** `getFullTree(lpId, 'both')` is called
**Then**
- Complete tree returned within 1 second
- Memory usage stays below 50MB
- Recursive CTE uses proper indexes
- Results paginated if >100 nodes (with `hasMore` flag)

### AC-24: Audit Trail - Genealogy Creation Logging

**Given** any genealogy link creation
**When** link is created
**Then**
- `created_at` timestamp automatically set
- `created_by` set to current user ID
- Audit log entry records: operation, user, timestamp, LP IDs involved
- Audit log queryable for compliance reporting

### AC-25: Recursive CTE - Cycle Detection

**Given** accidental circular reference attempt (LP-001 -> LP-002 -> LP-001)
**When** genealogy query runs
**Then**
- CTE detects cycle and terminates safely
- Error logged: "Circular reference detected in genealogy"
- Partial results returned up to cycle point
- System does not hang or crash

---

## Implementation Notes

### Database Schema

```sql
-- lp_genealogy table
CREATE TABLE lp_genealogy (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id),
  parent_lp_id UUID NOT NULL REFERENCES license_plates(id),
  child_lp_id UUID NOT NULL REFERENCES license_plates(id),
  operation_type TEXT NOT NULL CHECK (operation_type IN ('consume', 'output', 'split', 'merge')),
  quantity DECIMAL(15,4) NOT NULL,
  operation_date TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  wo_id UUID REFERENCES work_orders(id),
  operation_id UUID,  -- Reference to wo_operations if applicable
  is_reversed BOOLEAN DEFAULT false,
  reversed_at TIMESTAMPTZ,
  reversed_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES users(id),

  -- Prevent self-reference
  CONSTRAINT no_self_reference CHECK (parent_lp_id != child_lp_id),

  -- Unique constraint for non-reversed links
  CONSTRAINT unique_genealogy_link UNIQUE (parent_lp_id, child_lp_id, operation_type)
    WHERE (is_reversed = false)
);

-- Indexes for performance
CREATE INDEX idx_genealogy_org ON lp_genealogy(org_id);
CREATE INDEX idx_genealogy_parent ON lp_genealogy(parent_lp_id);
CREATE INDEX idx_genealogy_child ON lp_genealogy(child_lp_id);
CREATE INDEX idx_genealogy_wo ON lp_genealogy(wo_id) WHERE wo_id IS NOT NULL;
CREATE INDEX idx_genealogy_operation ON lp_genealogy(org_id, operation_type);
CREATE INDEX idx_genealogy_date ON lp_genealogy(operation_date);

-- RLS Policy
ALTER TABLE lp_genealogy ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Genealogy org isolation" ON lp_genealogy
  FOR ALL USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));
```

### Recursive CTE Queries

```sql
-- Forward Trace (find all descendants)
WITH RECURSIVE descendants AS (
  -- Base case: direct children
  SELECT
    g.child_lp_id AS lp_id,
    lp.lp_number,
    p.name AS product_name,
    g.operation_type,
    g.quantity,
    g.operation_date,
    1 AS depth,
    ARRAY[g.parent_lp_id] AS path
  FROM lp_genealogy g
  JOIN license_plates lp ON g.child_lp_id = lp.id
  JOIN products p ON lp.product_id = p.id
  WHERE g.parent_lp_id = $1  -- Starting LP ID
    AND g.org_id = $2
    AND g.is_reversed = false

  UNION ALL

  -- Recursive case: children of children
  SELECT
    g.child_lp_id AS lp_id,
    lp.lp_number,
    p.name AS product_name,
    g.operation_type,
    g.quantity,
    g.operation_date,
    d.depth + 1 AS depth,
    d.path || g.parent_lp_id
  FROM lp_genealogy g
  JOIN descendants d ON g.parent_lp_id = d.lp_id
  JOIN license_plates lp ON g.child_lp_id = lp.id
  JOIN products p ON lp.product_id = p.id
  WHERE g.org_id = $2
    AND g.is_reversed = false
    AND d.depth < $3  -- Max depth limit
    AND NOT (g.child_lp_id = ANY(d.path))  -- Cycle detection
)
SELECT DISTINCT ON (lp_id) *
FROM descendants
ORDER BY lp_id, depth;

-- Backward Trace (find all ancestors)
WITH RECURSIVE ancestors AS (
  -- Base case: direct parents
  SELECT
    g.parent_lp_id AS lp_id,
    lp.lp_number,
    p.name AS product_name,
    g.operation_type,
    g.quantity,
    g.operation_date,
    1 AS depth,
    ARRAY[g.child_lp_id] AS path
  FROM lp_genealogy g
  JOIN license_plates lp ON g.parent_lp_id = lp.id
  JOIN products p ON lp.product_id = p.id
  WHERE g.child_lp_id = $1  -- Starting LP ID
    AND g.org_id = $2
    AND g.is_reversed = false

  UNION ALL

  -- Recursive case: parents of parents
  SELECT
    g.parent_lp_id AS lp_id,
    lp.lp_number,
    p.name AS product_name,
    g.operation_type,
    g.quantity,
    g.operation_date,
    a.depth + 1 AS depth,
    a.path || g.child_lp_id
  FROM lp_genealogy g
  JOIN ancestors a ON g.child_lp_id = a.lp_id
  JOIN license_plates lp ON g.parent_lp_id = lp.id
  JOIN products p ON lp.product_id = p.id
  WHERE g.org_id = $2
    AND g.is_reversed = false
    AND a.depth < $3  -- Max depth limit
    AND NOT (g.parent_lp_id = ANY(a.path))  -- Cycle detection
)
SELECT DISTINCT ON (lp_id) *
FROM ancestors
ORDER BY lp_id, depth;
```

### API Endpoints

```typescript
// Link genealogy operations
POST /api/warehouse/genealogy/link-consumption
Body: {
  parentLpId: string;    // LP being consumed
  childLpId: string;     // Output LP
  woId: string;          // Work Order reference
  quantity: number;      // Qty consumed
  operationId?: string;  // WO Operation reference
}
Response: { id: string; created: true }

POST /api/warehouse/genealogy/link-output
Body: {
  consumedLpIds: string[];  // Array of consumed LP IDs
  outputLpId: string;       // New output LP
  woId: string;             // Work Order reference
}
Response: { ids: string[]; created: true }

POST /api/warehouse/genealogy/link-split
Body: {
  sourceLpId: string;    // Original LP
  newLpId: string;       // Split-off LP
  quantity: number;      // Qty split
}
Response: { id: string; created: true }

POST /api/warehouse/genealogy/link-merge
Body: {
  sourceLpIds: string[];  // LPs being merged
  targetLpId: string;     // Primary LP (remains)
}
Response: { ids: string[]; created: true }

POST /api/warehouse/genealogy/:id/reverse
Response: { id: string; reversed: true; reversedAt: string }

// Query operations
GET /api/warehouse/genealogy/forward-trace/:lpId?maxDepth=10&includeReversed=false
Response: {
  lpId: string;
  descendants: Array<{
    lp_id: string;
    lp_number: string;
    product_name: string;
    operation_type: 'consume' | 'output' | 'split' | 'merge';
    quantity: number;
    operation_date: string;
    depth: number;
  }>;
  hasMoreLevels: boolean;
  totalCount: number;
}

GET /api/warehouse/genealogy/backward-trace/:lpId?maxDepth=10&includeReversed=false
Response: {
  lpId: string;
  ancestors: Array<{
    lp_id: string;
    lp_number: string;
    product_name: string;
    operation_type: 'consume' | 'output' | 'split' | 'merge';
    quantity: number;
    operation_date: string;
    depth: number;
  }>;
  hasMoreLevels: boolean;
  totalCount: number;
}

GET /api/warehouse/genealogy/full-tree/:lpId?direction=both&maxDepth=5
Response: {
  lpId: string;
  ancestors: [...];      // Same format as backward-trace
  descendants: [...];    // Same format as forward-trace
  hasMoreLevels: { ancestors: boolean; descendants: boolean };
}

GET /api/warehouse/genealogy/by-wo/:woId
Response: {
  woId: string;
  genealogy: {
    consume: Array<GenealogyRecord>;
    output: Array<GenealogyRecord>;
  };
  totalCount: number;
}

// LP Detail endpoint includes genealogy
GET /api/warehouse/license-plates/:id/genealogy
Response: {
  lpId: string;
  ancestors: [...];      // Backward trace (depth 3)
  descendants: [...];    // Forward trace (depth 3)
}
```

### Frontend Components

```
app/(authenticated)/warehouse/license-plates/[id]/
  page.tsx                              -- LP detail page
  components/
    LPGenealogyPanel.tsx               -- Genealogy tab/panel
    GenealogyTree.tsx                  -- Tree visualization (simple)
    GenealogyAncestors.tsx             -- Ancestors section
    GenealogyDescendants.tsx           -- Descendants section
    GenealogyNode.tsx                  -- Single node in tree
    GenealogyEmptyState.tsx            -- No genealogy message
    GenealogyLoadingSkeleton.tsx       -- Loading state
```

### Services

```typescript
// lib/services/lp-genealogy-service.ts

export interface GenealogyLink {
  id: string;
  orgId: string;
  parentLpId: string;
  childLpId: string;
  operationType: 'consume' | 'output' | 'split' | 'merge';
  quantity: number;
  operationDate: Date;
  woId?: string;
  operationId?: string;
  isReversed: boolean;
}

export interface GenealogyNode {
  lpId: string;
  lpNumber: string;
  productName: string;
  operationType: 'consume' | 'output' | 'split' | 'merge';
  quantity: number;
  operationDate: string;
  depth: number;
}

export interface GenealogyTraceResult {
  lpId: string;
  nodes: GenealogyNode[];
  hasMoreLevels: boolean;
  totalCount: number;
}

/**
 * Link a consumed LP to an output LP in production context
 * Called by Epic 04 Consumption (04.6a-e)
 */
export async function linkConsumption(
  parentLpId: string,
  childLpId: string,
  woId: string,
  quantity: number,
  operationId?: string
): Promise<GenealogyLink> {
  // Validate LPs exist and belong to same org
  const [parentLP, childLP] = await Promise.all([
    getLicensePlate(parentLpId),
    getLicensePlate(childLpId),
  ]);

  if (!parentLP) throw new NotFoundError('Parent LP not found');
  if (!childLP) throw new NotFoundError('Child LP not found');
  if (parentLP.orgId !== childLP.orgId) {
    throw new ForbiddenError('LPs belong to different organizations');
  }

  // Check for self-reference
  if (parentLpId === childLpId) {
    throw new ValidationError('Cannot create self-referencing genealogy link');
  }

  // Check for duplicate
  const existing = await checkDuplicateLink(parentLpId, childLpId, 'consume');
  if (existing) {
    throw new ConflictError('Genealogy link already exists between these LPs');
  }

  // Create genealogy record
  const { data, error } = await supabase
    .from('lp_genealogy')
    .insert({
      org_id: parentLP.orgId,
      parent_lp_id: parentLpId,
      child_lp_id: childLpId,
      operation_type: 'consume',
      quantity,
      wo_id: woId,
      operation_id: operationId,
      operation_date: new Date().toISOString(),
    })
    .select()
    .single();

  if (error) throw error;
  return data;
}

/**
 * Link multiple consumed LPs to a single output LP
 * Called by Epic 04 Output Registration (04.7a-d)
 */
export async function linkOutput(
  consumedLpIds: string[],
  outputLpId: string,
  woId: string
): Promise<GenealogyLink[]> {
  const orgId = await getOrgIdFromContext();

  // Validate output LP exists
  const outputLP = await getLicensePlate(outputLpId);
  if (!outputLP) throw new NotFoundError('Output LP not found');

  // Create batch of genealogy records
  const records = consumedLpIds.map(consumedLpId => ({
    org_id: orgId,
    parent_lp_id: consumedLpId,
    child_lp_id: outputLpId,
    operation_type: 'output',
    quantity: 0, // Quantity tracked in wo_consumption records
    wo_id: woId,
    operation_date: new Date().toISOString(),
  }));

  const { data, error } = await supabase
    .from('lp_genealogy')
    .insert(records)
    .select();

  if (error) throw error;
  return data;
}

/**
 * Link a split operation (source LP -> new LP)
 * Called by Story 05.6 Split/Merge
 */
export async function linkSplit(
  sourceLpId: string,
  newLpId: string,
  quantity: number
): Promise<GenealogyLink> {
  const orgId = await getOrgIdFromContext();

  const { data, error } = await supabase
    .from('lp_genealogy')
    .insert({
      org_id: orgId,
      parent_lp_id: sourceLpId,
      child_lp_id: newLpId,
      operation_type: 'split',
      quantity,
      operation_date: new Date().toISOString(),
    })
    .select()
    .single();

  if (error) throw error;
  return data;
}

/**
 * Link a merge operation (source LPs -> target LP)
 * Called by Story 05.6 Split/Merge
 */
export async function linkMerge(
  sourceLpIds: string[],
  targetLpId: string
): Promise<GenealogyLink[]> {
  const orgId = await getOrgIdFromContext();

  // Get quantities from source LPs
  const sourceLPs = await Promise.all(
    sourceLpIds.map(id => getLicensePlate(id))
  );

  const records = sourceLpIds.map((sourceLpId, idx) => ({
    org_id: orgId,
    parent_lp_id: sourceLpId,
    child_lp_id: targetLpId,
    operation_type: 'merge',
    quantity: sourceLPs[idx]?.quantity || 0,
    operation_date: new Date().toISOString(),
  }));

  const { data, error } = await supabase
    .from('lp_genealogy')
    .insert(records)
    .select();

  if (error) throw error;
  return data;
}

/**
 * Mark a genealogy link as reversed (for corrections)
 */
export async function reverseLink(genealogyId: string): Promise<void> {
  const userId = await getUserIdFromContext();

  const { error } = await supabase
    .from('lp_genealogy')
    .update({
      is_reversed: true,
      reversed_at: new Date().toISOString(),
      reversed_by: userId,
    })
    .eq('id', genealogyId);

  if (error) throw error;
}

/**
 * Get forward trace - all descendants of an LP
 */
export async function getForwardTrace(
  lpId: string,
  maxDepth: number = 10,
  includeReversed: boolean = false
): Promise<GenealogyTraceResult> {
  const orgId = await getOrgIdFromContext();

  // Use RPC for recursive CTE query
  const { data, error } = await supabase.rpc('get_lp_forward_trace', {
    p_lp_id: lpId,
    p_org_id: orgId,
    p_max_depth: Math.min(maxDepth, 10), // Enforce max 10 levels
    p_include_reversed: includeReversed,
  });

  if (error) throw error;

  const hasMoreLevels = data.some((node: any) => node.depth === maxDepth);

  return {
    lpId,
    nodes: data,
    hasMoreLevels,
    totalCount: data.length,
  };
}

/**
 * Get backward trace - all ancestors of an LP
 */
export async function getBackwardTrace(
  lpId: string,
  maxDepth: number = 10,
  includeReversed: boolean = false
): Promise<GenealogyTraceResult> {
  const orgId = await getOrgIdFromContext();

  // Use RPC for recursive CTE query
  const { data, error } = await supabase.rpc('get_lp_backward_trace', {
    p_lp_id: lpId,
    p_org_id: orgId,
    p_max_depth: Math.min(maxDepth, 10),
    p_include_reversed: includeReversed,
  });

  if (error) throw error;

  const hasMoreLevels = data.some((node: any) => node.depth === maxDepth);

  return {
    lpId,
    nodes: data,
    hasMoreLevels,
    totalCount: data.length,
  };
}

/**
 * Get full genealogy tree (both directions)
 */
export async function getFullTree(
  lpId: string,
  direction: 'forward' | 'backward' | 'both' = 'both',
  maxDepth: number = 5
): Promise<{
  ancestors: GenealogyNode[];
  descendants: GenealogyNode[];
  hasMoreLevels: { ancestors: boolean; descendants: boolean };
}> {
  const [forwardResult, backwardResult] = await Promise.all([
    direction !== 'backward' ? getForwardTrace(lpId, maxDepth) : null,
    direction !== 'forward' ? getBackwardTrace(lpId, maxDepth) : null,
  ]);

  return {
    ancestors: backwardResult?.nodes || [],
    descendants: forwardResult?.nodes || [],
    hasMoreLevels: {
      ancestors: backwardResult?.hasMoreLevels || false,
      descendants: forwardResult?.hasMoreLevels || false,
    },
  };
}

/**
 * Get all genealogy records for a Work Order
 */
export async function getGenealogyByWO(woId: string): Promise<{
  consume: GenealogyLink[];
  output: GenealogyLink[];
}> {
  const { data, error } = await supabase
    .from('lp_genealogy')
    .select(`
      *,
      parent_lp:license_plates!parent_lp_id(lp_number, product:products(name)),
      child_lp:license_plates!child_lp_id(lp_number, product:products(name))
    `)
    .eq('wo_id', woId)
    .eq('is_reversed', false);

  if (error) throw error;

  const grouped = {
    consume: data.filter(g => g.operation_type === 'consume'),
    output: data.filter(g => g.operation_type === 'output'),
  };

  return grouped;
}
```

### Validation (Zod)

```typescript
// lib/validation/lp-genealogy-schemas.ts

import { z } from 'zod';

export const OperationTypeEnum = z.enum(['consume', 'output', 'split', 'merge']);

export const LinkConsumptionSchema = z.object({
  parentLpId: z.string().uuid('Invalid parent LP ID'),
  childLpId: z.string().uuid('Invalid child LP ID'),
  woId: z.string().uuid('Invalid Work Order ID'),
  quantity: z.number().positive('Quantity must be positive'),
  operationId: z.string().uuid().optional(),
}).refine(data => data.parentLpId !== data.childLpId, {
  message: 'Parent and child LP cannot be the same',
});

export const LinkOutputSchema = z.object({
  consumedLpIds: z.array(z.string().uuid()).min(1, 'At least one consumed LP required'),
  outputLpId: z.string().uuid('Invalid output LP ID'),
  woId: z.string().uuid('Invalid Work Order ID'),
});

export const LinkSplitSchema = z.object({
  sourceLpId: z.string().uuid('Invalid source LP ID'),
  newLpId: z.string().uuid('Invalid new LP ID'),
  quantity: z.number().positive('Quantity must be positive'),
}).refine(data => data.sourceLpId !== data.newLpId, {
  message: 'Source and new LP cannot be the same',
});

export const LinkMergeSchema = z.object({
  sourceLpIds: z.array(z.string().uuid()).min(1, 'At least one source LP required'),
  targetLpId: z.string().uuid('Invalid target LP ID'),
});

export const TraceQuerySchema = z.object({
  maxDepth: z.coerce.number().int().min(1).max(10).default(10),
  includeReversed: z.coerce.boolean().default(false),
});

export const GenealogyDirectionSchema = z.enum(['forward', 'backward', 'both']).default('both');
```

### Key Business Rules

1. **Operation Types:**
   - `consume`: LP consumed as material in production (parent -> child)
   - `output`: Links all consumed LPs to the output LP
   - `split`: LP split into smaller LP (parent -> new child)
   - `merge`: Multiple LPs merged into one (parents -> child)

2. **Immutability:** Genealogy records are never deleted, only marked as `is_reversed = true`

3. **Self-Reference Prevention:** `parent_lp_id` cannot equal `child_lp_id`

4. **Depth Limit:** Recursive queries limited to 10 levels for performance

5. **Cycle Detection:** Recursive CTEs detect cycles and terminate safely

6. **RLS Enforcement:** All queries filtered by `org_id` via RLS policies

7. **WO Reference:** Production genealogy (consume/output) requires `wo_id`; split/merge do not

8. **Quantity Tracking:** `quantity` field tracks amount transferred in the operation

9. **Reversal Audit:** Reversed links maintain full audit trail with `reversed_at` and `reversed_by`

10. **Epic 04 Contract:**
    - `linkConsumption()` called when material is consumed from LP
    - `linkOutput()` called when output LP is registered
    - Both operations receive `wo_id` for traceability

---

## Deliverables

### Database Migration
- `supabase/migrations/YYYYMMDDHHMMSS_create_lp_genealogy.sql`
  - Table creation
  - Indexes
  - RLS policies
  - Check constraints

### Database Functions (RPC)
- `get_lp_forward_trace(p_lp_id, p_org_id, p_max_depth, p_include_reversed)`
- `get_lp_backward_trace(p_lp_id, p_org_id, p_max_depth, p_include_reversed)`

### API Routes
- `POST /api/warehouse/genealogy/link-consumption`
- `POST /api/warehouse/genealogy/link-output`
- `POST /api/warehouse/genealogy/link-split`
- `POST /api/warehouse/genealogy/link-merge`
- `POST /api/warehouse/genealogy/:id/reverse`
- `GET /api/warehouse/genealogy/forward-trace/:lpId`
- `GET /api/warehouse/genealogy/backward-trace/:lpId`
- `GET /api/warehouse/genealogy/full-tree/:lpId`
- `GET /api/warehouse/genealogy/by-wo/:woId`
- `GET /api/warehouse/license-plates/:id/genealogy`

### Frontend Components
- `app/(authenticated)/warehouse/license-plates/[id]/components/`
  - `LPGenealogyPanel.tsx`
  - `GenealogyTree.tsx`
  - `GenealogyAncestors.tsx`
  - `GenealogyDescendants.tsx`
  - `GenealogyNode.tsx`
  - `GenealogyEmptyState.tsx`
  - `GenealogyLoadingSkeleton.tsx`

### Services
- `lib/services/lp-genealogy-service.ts` (full implementation)

### Validation
- `lib/validation/lp-genealogy-schemas.ts`

### Tests
- **Unit Tests** (Vitest):
  - `lp-genealogy-service.test.ts` - All service functions
  - `genealogy-validation.test.ts` - Schema validation
  - `genealogy-recursive-queries.test.ts` - CTE query tests
  - `genealogy-edge-cases.test.ts` - Cycle detection, depth limits
  - Target: >80% coverage

- **Integration Tests**:
  - Multi-level forward trace (5 levels)
  - Multi-level backward trace (5 levels)
  - Complex tree with multiple children/parents
  - Cycle detection handling
  - RLS policy enforcement

- **E2E Tests** (Playwright):
  - `genealogy-panel.spec.ts` - LP detail genealogy panel
  - `genealogy-navigation.spec.ts` - Click through genealogy tree
  - `genealogy-empty-state.spec.ts` - No genealogy display

---

## Definition of Done

- [ ] `lp_genealogy` table created with all columns and constraints
- [ ] RLS policy verified (org_id isolation)
- [ ] All indexes created for performance
- [ ] Database functions (RPCs) for recursive queries
- [ ] `linkConsumption()` service method working
- [ ] `linkOutput()` service method working (batch)
- [ ] `linkSplit()` service method working
- [ ] `linkMerge()` service method working
- [ ] `reverseLink()` service method working
- [ ] `getForwardTrace()` returns correct descendants (10 level limit)
- [ ] `getBackwardTrace()` returns correct ancestors (10 level limit)
- [ ] `getFullTree()` returns both directions
- [ ] `getGenealogyByWO()` returns WO-specific genealogy
- [ ] API endpoints implemented and documented
- [ ] Zod validation schemas in place
- [ ] Desktop UI: Genealogy panel in LP detail view
- [ ] Empty state handled gracefully
- [ ] Loading state with skeleton
- [ ] Self-reference prevention validated
- [ ] Duplicate link prevention validated
- [ ] Cycle detection working in recursive CTEs
- [ ] Unit tests passing (>80% coverage)
- [ ] E2E test for genealogy panel
- [ ] Performance: Forward/backward trace <500ms for 10 levels
- [ ] Performance: Complex tree (100+ nodes) <1 second
- [ ] **Epic 04 service contract verified**
- [ ] Code review completed
- [ ] Documentation updated

---

## Future Phases (Not in This Story)

### Phase 3 - Story 05.31: LP Genealogy Tree View
- Interactive tree visualization with drag/zoom
- Expand/collapse nodes dynamically
- Filter by operation type
- Time-based animation (show genealogy growth over time)
- Print/export tree diagram

### Phase 4 - Reports
- Genealogy analytics dashboard
- Most common genealogy patterns
- Average genealogy depth by product
- Genealogy coverage report (% of LPs with genealogy)

### Future
- Cross-batch traceability reports
- Recall impact analysis (given affected LP, find all downstream products)
- Genealogy-based quality alerts
- Real-time genealogy updates via WebSocket

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-12-16 | Initial story created - CRITICAL for Epic 04.7 | Claude (Opus 4.5) |
