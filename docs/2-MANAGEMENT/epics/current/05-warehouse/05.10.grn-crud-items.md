# 05.10 - GRN CRUD + Items (Goods Receipt Note)

| Field | Value |
|-------|-------|
| **Story ID** | 05.10 |
| **Epic** | 05 - Warehouse |
| **Status** | Ready |
| **Phase** | Phase 1 (Goods Receipt) |
| **Priority** | P1 |
| **Complexity** | L (Large) |
| **Estimate** | 4-5 days |
| **Type** | Backend + Frontend |
| **Model** | OPUS |

---

## Overview

Goods Receipt Note (GRN) is the foundational document for all inbound inventory operations. This story implements the `grns` and `grn_items` master-detail pattern with LP creation capability. GRNs record goods received from multiple sources (PO, TO, Production, Return, Adjustment) and serve as the audit trail for inventory additions.

**Key Concepts:**
- **GRN (Master):** Header document with source reference, warehouse, and status
- **GRN Items (Detail):** Line items with product, quantity, batch, expiry, and LP reference
- **LP Creation:** Each GRN item can create a License Plate on completion
- **Source Types:** PO, TO, Production, Return, Adjustment

**Note:** The actual LP creation logic and PO integration workflow is covered in Story 05.11 (GRN from PO). This story focuses on the core GRN data model, CRUD operations, and basic LP creation infrastructure.

---

## PRD References

| FR ID | Requirement | Priority | Coverage |
|-------|-------------|----------|----------|
| WH-FR-001 | LP Creation (auto/manual numbering) | P0 | Partial (LP creation via GRN) |
| WH-FR-003 | GRN from PO | P0 | Partial (data model, basic CRUD) |
| WH-FR-004 | GRN from TO | P0 | Partial (data model, source type) |
| WH-FR-009 | Batch Tracking | P0 | Full (grn_items.batch_number) |
| WH-FR-010 | Expiry Tracking | P0 | Full (grn_items.expiry_date) |
| WH-FR-029 | Over-Receipt Control | P1 | Partial (validation infrastructure) |

**Primary PRD:** `docs/1-BASELINE/product/modules/warehouse.md`
**Architecture:** `docs/1-BASELINE/architecture/modules/warehouse.md`

---

## MVP Scope

### In Scope (This Story)

1. **Database Infrastructure**
   - `grns` table with all columns and constraints
   - `grn_items` table with LP reference
   - GRN number auto-generation function (`GRN-YYYY-NNNNN`)
   - Indexes for performance
   - RLS policies for multi-tenancy
   - FK constraints to license_plates, products, locations, etc.

2. **Service Layer**
   - GRN CRUD operations (create, read, update, delete/cancel)
   - GRN Item CRUD operations
   - GRN completion workflow (create LPs)
   - GRN cancellation workflow
   - Transaction handling for master-detail operations
   - Status transitions: draft -> completed -> cancelled

3. **API Endpoints**
   - List GRNs (paginated, filtered by status, source_type, date range)
   - Get GRN by ID (with items and LP references)
   - Create GRN with items
   - Update GRN (draft only)
   - Add/update/remove GRN items (draft only)
   - Complete GRN (creates LPs, locks document)
   - Cancel GRN (reverses LPs if needed)

4. **Desktop UI**
   - GRN list page with DataTable (filters, search, pagination)
   - GRN creation form (source selection, items entry)
   - GRN detail page (view mode with items, LPs)
   - GRN edit form (draft items management)
   - Status badges and action buttons
   - Print GRN summary

5. **Zod Validation Schemas**
   - Create GRN schema
   - Update GRN schema
   - GRN item schemas
   - Query params schema

6. **LP Creation (Basic)**
   - Create LP for each GRN item on completion
   - Link LP to GRN via `grn_id` field
   - Set LP source = 'receipt'
   - Apply default QA status from settings

### Out of Scope (Other Stories)

| Feature | Deferred To | Reason |
|---------|-------------|--------|
| PO integration (select from PO, update PO received_qty) | 05.11 | Complex integration workflow |
| TO integration (receive from TO) | 05.12 | Separate source type workflow |
| ASN pre-population | 05.13 | Advanced feature |
| Scanner receive workflow | 05.17 | Phase 2 |
| Over-receipt tolerance validation | 05.11, 05.13 | PO-specific logic |
| Label printing on receipt | 05.14 | Separate feature |
| GS1 barcode parsing | 05.24 | Phase 3 |
| Catch weight entry | 05.27 | Phase 3 |

---

## Epic 04 Dependency Status

- [ ] **CRITICAL - Unblocks Epic 04 Phase 1**
- [x] NOT CRITICAL - Can defer

This story does NOT directly unblock Epic 04. However, it provides the foundational receiving infrastructure that Production will use for material tracking. Epic 04 depends on:
- 05.1 (LP Table) - CRITICAL
- 05.2 (LP Genealogy) - CRITICAL
- 05.3 (LP Reservations) - CRITICAL

---

## Goal

Create the complete Goods Receipt Note (GRN) system with master-detail pattern, enabling warehouse operations to record inbound inventory from multiple sources with full audit trail and LP creation capability.

---

## User Story

As a **Warehouse Operator**, I want to **create and manage Goods Receipt Notes to record incoming inventory** so that **I can track what was received, when, from where, and have License Plates automatically created for traceability**.

---

## Dependencies

| Dependency | Story/Epic | Type | Status | Notes |
|------------|------------|------|--------|-------|
| 05.0 | Warehouse Settings | HARD | Ready | QA defaults, number formats |
| 05.1 | LP Table + Basic Service | HARD | Ready | LP creation on GRN complete |
| 01.1 | Org Context + RLS | HARD | Ready | Multi-tenancy patterns |
| 01.8 | Warehouses CRUD | HARD | Ready | FK to warehouses |
| 01.9 | Locations CRUD | HARD | Ready | FK to locations |
| 02.1 | Products CRUD | HARD | Ready | FK to products |

**Dependents (What This Unblocks):**
- 05.11 (GRN from PO) - Uses GRN infrastructure + PO integration
- 05.12 (GRN from TO) - Uses GRN infrastructure + TO integration
- 05.13 (ASN Management) - Pre-populates GRN
- 05.14 (Label Printing) - Print on receipt
- 05.15 (Warehouse Dashboard) - GRN metrics
- 05.17 (Scanner Receive) - Scanner GRN creation

---

## Acceptance Criteria (Given/When/Then)

### AC-1: GRN Table Creation

```gherkin
Scenario: GRNs table exists with all required columns
  Given database migration runs
  When schema is inspected
  Then grns table has columns:
    | Column | Type | Nullable | Default |
    | id | UUID | NO | gen_random_uuid() |
    | org_id | UUID | NO | - |
    | grn_number | TEXT | NO | - |
    | source_type | TEXT | NO | - |
    | po_id | UUID | YES | - |
    | to_id | UUID | YES | - |
    | asn_id | UUID | YES | - |
    | supplier_id | UUID | YES | - |
    | receipt_date | TIMESTAMPTZ | NO | NOW() |
    | warehouse_id | UUID | NO | - |
    | location_id | UUID | NO | - |
    | status | TEXT | NO | 'draft' |
    | notes | TEXT | YES | - |
    | total_items | INTEGER | NO | 0 |
    | total_qty | DECIMAL(15,4) | NO | 0 |
    | created_at | TIMESTAMPTZ | NO | NOW() |
    | created_by | UUID | YES | - |
    | completed_at | TIMESTAMPTZ | YES | - |
    | completed_by | UUID | YES | - |
    | cancelled_at | TIMESTAMPTZ | YES | - |
    | cancelled_by | UUID | YES | - |
    | cancellation_reason | TEXT | YES | - |
  And UNIQUE constraint exists on (org_id, grn_number)
  And CHECK constraint validates source_type IN ('po', 'to', 'production', 'return', 'adjustment')
  And CHECK constraint validates status IN ('draft', 'completed', 'cancelled')
```

### AC-2: GRN Items Table Creation

```gherkin
Scenario: GRN Items table exists with all required columns
  Given database migration runs
  When schema is inspected
  Then grn_items table has columns:
    | Column | Type | Nullable | Default |
    | id | UUID | NO | gen_random_uuid() |
    | grn_id | UUID | NO | - |
    | product_id | UUID | NO | - |
    | po_line_id | UUID | YES | - |
    | to_line_id | UUID | YES | - |
    | ordered_qty | DECIMAL(15,4) | NO | 0 |
    | received_qty | DECIMAL(15,4) | NO | - |
    | uom | TEXT | NO | - |
    | lp_id | UUID | YES | - |
    | batch_number | TEXT | YES | - |
    | supplier_batch_number | TEXT | YES | - |
    | gtin | TEXT | YES | - |
    | catch_weight_kg | DECIMAL(10,3) | YES | - |
    | expiry_date | DATE | YES | - |
    | manufacture_date | DATE | YES | - |
    | location_id | UUID | NO | - |
    | qa_status | TEXT | NO | 'pending' |
    | notes | TEXT | YES | - |
    | line_number | INTEGER | NO | - |
  And FK constraint to grns(id) with ON DELETE CASCADE
  And FK constraint to license_plates(id)
  And FK constraint to products(id)
  And FK constraint to locations(id)
```

### AC-3: GRN Number Auto-Generation

```gherkin
Scenario: Generate GRN number with year and sequence
  Given GRN number generation function exists
  When new GRN is created without grn_number
  Then system generates GRN number 'GRN-2025-00001' format
  And next GRN gets 'GRN-2025-00002'

Scenario: GRN number sequence resets per year
  Given current year is 2026
  And previous GRN was 'GRN-2025-99999'
  When new GRN is created
  Then system generates 'GRN-2026-00001'

Scenario: GRN number uniqueness validation
  Given GRN 'GRN-2025-00001' exists in org A
  When user creates another GRN with same number in org A
  Then system returns 409 Conflict error "GRN number already exists"

Scenario: Same GRN number allowed across orgs
  Given GRN 'GRN-2025-00001' exists in org A
  When user creates GRN 'GRN-2025-00001' in org B
  Then GRN created successfully (different org_id)
```

### AC-4: Create GRN with Items

```gherkin
Scenario: Create draft GRN with single item
  Given valid warehouse_id, location_id, product_id
  When POST /api/warehouse/grns with:
    | source_type | manual |
    | warehouse_id | {valid_uuid} |
    | location_id | {valid_uuid} |
    | items | [{ product_id, received_qty: 100, uom: 'KG' }] |
  Then GRN created with status = 'draft'
  And grn_number auto-generated
  And grn_items record created with line_number = 1
  And response includes GRN with items
  And response time < 500ms

Scenario: Create GRN with multiple items
  Given valid GRN data
  When POST /api/warehouse/grns with 5 items
  Then GRN created with 5 grn_items records
  And line_number assigned sequentially (1, 2, 3, 4, 5)
  And total_items = 5
  And total_qty = sum of all received_qty

Scenario: Create GRN with batch and expiry
  Given product requires batch tracking
  When creating GRN item with batch_number = 'BATCH-001', expiry_date = '2026-01-01'
  Then grn_item saved with batch and expiry

Scenario: Create GRN with source type
  Given source_type = 'po'
  When creating GRN with po_id = {valid_po_uuid}
  Then GRN created with source_type = 'po' and po_id reference

Scenario: Validation - required fields
  Given incomplete GRN data (missing warehouse_id)
  When POST /api/warehouse/grns
  Then 400 error returned with validation message
```

### AC-5: Read GRN Operations

```gherkin
Scenario: List GRNs with pagination
  Given 100 GRNs exist
  When GET /api/warehouse/grns?page=1&limit=20
  Then response returns 20 GRNs with pagination metadata
  And response time < 500ms

Scenario: Filter GRNs by status
  Given 50 draft GRNs and 30 completed GRNs
  When GET /api/warehouse/grns?status=completed
  Then only 30 completed GRNs returned

Scenario: Filter GRNs by source_type
  Given 40 PO GRNs and 20 TO GRNs
  When GET /api/warehouse/grns?source_type=po
  Then only 40 PO GRNs returned

Scenario: Filter GRNs by date range
  Given GRNs with various receipt_dates
  When GET /api/warehouse/grns?from_date=2025-01-01&to_date=2025-01-31
  Then only GRNs within date range returned

Scenario: Search GRNs by number
  Given GRNs: GRN-2025-00001, GRN-2025-00002, GRN-2025-00100
  When GET /api/warehouse/grns?search=GRN-2025-001
  Then GRN-2025-00001, GRN-2025-00100 returned (prefix match)

Scenario: Get GRN detail with items
  Given GRN with 3 items exists
  When GET /api/warehouse/grns/{id}
  Then response includes GRN header
  And response includes 3 grn_items with product details
  And response includes created LP references (if completed)
  And response time < 200ms
```

### AC-6: Update GRN (Draft Only)

```gherkin
Scenario: Update draft GRN header
  Given GRN with status = 'draft'
  When PUT /api/warehouse/grns/{id} with updated notes
  Then GRN notes updated

Scenario: Update GRN location
  Given draft GRN with location A
  When PUT /api/warehouse/grns/{id} with location_id = B
  Then GRN.location_id updated to B

Scenario: Block update on completed GRN
  Given GRN with status = 'completed'
  When PUT /api/warehouse/grns/{id} with any changes
  Then 400 error: "Cannot modify completed GRN"

Scenario: Block update on cancelled GRN
  Given GRN with status = 'cancelled'
  When PUT /api/warehouse/grns/{id} with any changes
  Then 400 error: "Cannot modify cancelled GRN"
```

### AC-7: GRN Item CRUD

```gherkin
Scenario: Add item to draft GRN
  Given draft GRN with 2 items
  When POST /api/warehouse/grns/{id}/items with new item
  Then grn_items record created with line_number = 3
  And GRN.total_items = 3
  And GRN.total_qty updated

Scenario: Update GRN item quantity
  Given draft GRN with item (received_qty = 100)
  When PUT /api/warehouse/grns/{id}/items/{itemId} with received_qty = 150
  Then grn_item.received_qty = 150
  And GRN.total_qty recalculated

Scenario: Update GRN item batch and expiry
  Given draft GRN item without batch
  When PUT /api/warehouse/grns/{id}/items/{itemId} with batch_number = 'NEW-BATCH'
  Then grn_item.batch_number = 'NEW-BATCH'

Scenario: Remove item from draft GRN
  Given draft GRN with 3 items
  When DELETE /api/warehouse/grns/{id}/items/{itemId}
  Then grn_item deleted
  And GRN.total_items = 2
  And GRN.total_qty recalculated
  And remaining items line_numbers NOT renumbered

Scenario: Block item modification on completed GRN
  Given completed GRN with items
  When POST/PUT/DELETE /api/warehouse/grns/{id}/items
  Then 400 error: "Cannot modify items on completed GRN"
```

### AC-8: Complete GRN Workflow

```gherkin
Scenario: Complete GRN creates License Plates
  Given draft GRN with 2 items (no batch required, no expiry required)
  When POST /api/warehouse/grns/{id}/complete
  Then GRN.status = 'completed'
  And GRN.completed_at = current timestamp
  And GRN.completed_by = current user
  And 2 new license_plates created
  And each grn_item.lp_id set to created LP
  And each LP has source = 'receipt', grn_id = GRN.id
  And operation completes in < 1 second (transaction)

Scenario: Complete GRN - LP inherits item data
  Given draft GRN item with batch_number, expiry_date, qa_status = 'passed'
  When GRN completed
  Then created LP has:
    | Field | Value |
    | product_id | from grn_item |
    | quantity | from grn_item.received_qty |
    | uom | from grn_item.uom |
    | batch_number | from grn_item |
    | expiry_date | from grn_item |
    | qa_status | from grn_item |
    | location_id | from grn_item |
    | warehouse_id | from GRN |
    | source | 'receipt' |
    | grn_id | GRN.id |

Scenario: Complete GRN - validation required fields
  Given draft GRN item missing required batch (require_batch_on_receipt = true)
  When POST /api/warehouse/grns/{id}/complete
  Then 400 error: "Batch number required for product {name}"
  And GRN remains in draft status
  And no LPs created

Scenario: Complete GRN - validation required expiry
  Given draft GRN item missing required expiry (require_expiry_on_receipt = true)
  When POST /api/warehouse/grns/{id}/complete
  Then 400 error: "Expiry date required for product {name}"
  And GRN remains in draft status

Scenario: Complete empty GRN blocked
  Given draft GRN with 0 items
  When POST /api/warehouse/grns/{id}/complete
  Then 400 error: "Cannot complete GRN with no items"

Scenario: Complete GRN - transaction rollback on failure
  Given draft GRN with 3 items, item 2 has invalid data
  When POST /api/warehouse/grns/{id}/complete
  Then error returned for item 2
  And GRN remains in draft status
  And no LPs created (all rolled back)
```

### AC-9: Cancel GRN Workflow

```gherkin
Scenario: Cancel draft GRN
  Given draft GRN
  When POST /api/warehouse/grns/{id}/cancel with reason = "Entered in error"
  Then GRN.status = 'cancelled'
  And GRN.cancelled_at = current timestamp
  And GRN.cancelled_by = current user
  And GRN.cancellation_reason = "Entered in error"

Scenario: Cancel completed GRN - marks LPs as consumed
  Given completed GRN with 2 created LPs
  And both LPs have status = 'available' (not used yet)
  When POST /api/warehouse/grns/{id}/cancel with reason
  Then GRN.status = 'cancelled'
  And both LPs status updated to 'consumed' (removed from inventory)
  And LPs.consumed_by_wo_id set to null but status shows consumed

Scenario: Cancel completed GRN - block if LP in use
  Given completed GRN with LP
  And LP.status = 'reserved' (allocated to WO)
  When POST /api/warehouse/grns/{id}/cancel
  Then 400 error: "Cannot cancel GRN - LP {lp_number} is reserved"
  And GRN remains completed

Scenario: Cancel completed GRN - block if LP consumed
  Given completed GRN with LP
  And LP.status = 'consumed' (used in production)
  When POST /api/warehouse/grns/{id}/cancel
  Then 400 error: "Cannot cancel GRN - LP {lp_number} has been consumed"

Scenario: Cancel already cancelled GRN
  Given cancelled GRN
  When POST /api/warehouse/grns/{id}/cancel
  Then 400 error: "GRN is already cancelled"
```

### AC-10: RLS Policy Enforcement

```gherkin
Scenario: Org isolation on GRN list
  Given User A from Org A
  And User B from Org B
  And GRNs exist in both orgs
  When User A requests /api/warehouse/grns
  Then only Org A GRNs returned

Scenario: Cross-tenant GRN access returns 404
  Given GRN belongs to Org B
  When User A from Org A requests /api/warehouse/grns/{orgB_grn_id}
  Then 404 Not Found returned (not 403)

Scenario: RLS on GRN items
  Given grn_items inherit org_id via grns FK
  When User A queries grn_items
  Then only items from User A's org returned
```

### AC-11: GRN List UI

```gherkin
Scenario: View GRN list page
  Given user navigates to /warehouse/receiving
  When page loads
  Then GRN DataTable displays within 500ms
  And columns show: GRN Number, Source, Supplier/Reference, Items, Total Qty, Status, Date

Scenario: GRN status badges
  Given GRNs with different statuses
  When viewing list
  Then status badges display with colors:
    | Status | Color |
    | draft | Yellow |
    | completed | Green |
    | cancelled | Gray |

Scenario: Source type icons
  Given GRNs with different source_types
  When viewing list
  Then source icons display:
    | Source Type | Icon |
    | po | Package icon |
    | to | Truck icon |
    | production | Factory icon |
    | return | Undo icon |
    | adjustment | PlusMinus icon |

Scenario: Filter GRNs by multiple criteria
  Given filter panel open
  When user selects status, source_type, date range
  Then list filters by all selected criteria

Scenario: Search GRNs by number
  Given search input visible
  When user types 'GRN-2025-001'
  Then list filters to matching GRN numbers (debounced 300ms)

Scenario: Sort GRN list by column
  Given GRN list displayed
  When user clicks "Receipt Date" column header
  Then list sorts by receipt_date (asc/desc toggle)
```

### AC-12: GRN Create Form

```gherkin
Scenario: Open GRN creation modal
  Given user on GRN list page
  When user clicks "New GRN" button
  Then GRN creation form opens
  And source type selector displayed
  And warehouse/location dropdowns pre-populated from settings

Scenario: Select source type
  Given GRN form open
  When user selects source_type = 'adjustment'
  Then form shows relevant fields for adjustment
  And PO/TO selection hidden

Scenario: Add item to GRN
  Given GRN form open
  When user clicks "Add Item"
  Then item row added
  And product selector displayed
  And quantity input enabled

Scenario: Product selector with search
  Given item row displayed
  When user types in product selector
  Then products filtered by name/code
  And product selected populates UoM

Scenario: Remove item from GRN form
  Given GRN form with 3 items
  When user clicks remove on item 2
  Then item 2 removed from form
  And 2 items remain

Scenario: Save draft GRN
  Given GRN form with valid data
  When user clicks "Save as Draft"
  Then GRN created with status = 'draft'
  And success toast displayed
  And user redirected to GRN detail page

Scenario: Save and complete GRN
  Given GRN form with valid data
  When user clicks "Save and Complete"
  Then GRN created and completed
  And LPs created
  And success toast shows LP numbers created
```

### AC-13: GRN Detail Page

```gherkin
Scenario: View completed GRN detail
  Given completed GRN with 3 items
  When user navigates to /warehouse/receiving/{id}
  Then GRN header displayed (number, date, status, source, warehouse)
  And items table shows all 3 items
  And each item shows LP number (clickable link)
  And "Edit" button disabled (completed)
  And "Print" button enabled

Scenario: View draft GRN detail
  Given draft GRN with items
  When viewing detail page
  Then "Edit" button enabled
  And "Complete" button enabled
  And "Cancel" button enabled

Scenario: Click LP link navigates to LP detail
  Given completed GRN with LP
  When user clicks LP number in items table
  Then navigates to /warehouse/license-plates/{lp_id}

Scenario: Print GRN summary
  Given any GRN
  When user clicks "Print" button
  Then print-friendly view opens with:
    | GRN Number, Date, Status |
    | Source reference |
    | Items table with batch, expiry, qty |
    | Total items and quantity |
```

### AC-14: GRN Edit Form (Draft)

```gherkin
Scenario: Edit draft GRN
  Given draft GRN
  When user clicks "Edit" on detail page
  Then edit form opens with current values
  And items are editable
  And "Save Changes" button visible

Scenario: Add item during edit
  Given draft GRN in edit mode
  When user clicks "Add Item"
  Then new item row added
  And can be saved with GRN

Scenario: Remove item during edit
  Given draft GRN in edit mode with 3 items
  When user removes item 2
  And saves changes
  Then GRN updated with 2 items

Scenario: Update item quantity
  Given draft GRN in edit mode
  When user changes item quantity and saves
  Then grn_item updated
  And total_qty recalculated
```

### AC-15: Performance Requirements

```gherkin
Scenario: GRN list with filters
  Given 1000 GRNs in warehouse
  When GET /api/warehouse/grns with filters
  Then response time < 500ms

Scenario: GRN detail with items
  Given GRN with 50 items
  When GET /api/warehouse/grns/{id}
  Then response time < 300ms

Scenario: GRN completion transaction
  Given draft GRN with 10 items
  When POST /api/warehouse/grns/{id}/complete
  Then all LPs created in < 2 seconds
  And atomic transaction (all or nothing)

Scenario: GRN creation
  Given valid GRN data with 5 items
  When POST /api/warehouse/grns
  Then response time < 500ms
```

### AC-16: Indexes for Performance

```gherkin
Scenario: Indexes exist for common queries
  Given grns table
  Then indexes exist for:
    | Index Name | Columns |
    | idx_grns_org_status | (org_id, status) |
    | idx_grns_org_number | (org_id, grn_number) |
    | idx_grns_org_source | (org_id, source_type) |
    | idx_grns_receipt_date | (receipt_date) |
    | idx_grns_po | (po_id) WHERE po_id IS NOT NULL |
    | idx_grns_to | (to_id) WHERE to_id IS NOT NULL |
    | idx_grn_items_grn | (grn_id) |
    | idx_grn_items_product | (product_id) |
    | idx_grn_items_lp | (lp_id) WHERE lp_id IS NOT NULL |
```

---

## Technical Specification

### Database Schema

```sql
-- =============================================================================
-- GRN Number Sequence per Organization per Year
-- =============================================================================

CREATE TABLE grn_number_sequences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  year INTEGER NOT NULL,
  current_value BIGINT NOT NULL DEFAULT 0,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(org_id, year)
);

ALTER TABLE grn_number_sequences ENABLE ROW LEVEL SECURITY;

CREATE POLICY "grn_seq_org" ON grn_number_sequences
FOR ALL TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- =============================================================================
-- GRNs Table (Master)
-- =============================================================================

CREATE TABLE grns (
  -- Identity
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  grn_number TEXT NOT NULL,

  -- Source Reference
  source_type TEXT NOT NULL
    CHECK (source_type IN ('po', 'to', 'production', 'return', 'adjustment')),
  po_id UUID REFERENCES purchase_orders(id),
  to_id UUID REFERENCES transfer_orders(id),
  asn_id UUID REFERENCES asns(id),
  supplier_id UUID REFERENCES suppliers(id),

  -- Receipt Info
  receipt_date TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  warehouse_id UUID NOT NULL REFERENCES warehouses(id),
  location_id UUID NOT NULL REFERENCES locations(id),

  -- Status
  status TEXT NOT NULL DEFAULT 'draft'
    CHECK (status IN ('draft', 'completed', 'cancelled')),

  -- Aggregates (denormalized for performance)
  total_items INTEGER NOT NULL DEFAULT 0,
  total_qty DECIMAL(15,4) NOT NULL DEFAULT 0,

  -- Notes
  notes TEXT,

  -- Audit - Creation
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_by UUID REFERENCES users(id),

  -- Audit - Completion
  completed_at TIMESTAMPTZ,
  completed_by UUID REFERENCES users(id),

  -- Audit - Cancellation
  cancelled_at TIMESTAMPTZ,
  cancelled_by UUID REFERENCES users(id),
  cancellation_reason TEXT,

  -- Constraints
  CONSTRAINT grn_org_number_unique UNIQUE(org_id, grn_number),
  CONSTRAINT grn_po_check CHECK (
    (source_type = 'po' AND po_id IS NOT NULL) OR
    (source_type != 'po')
  ),
  CONSTRAINT grn_to_check CHECK (
    (source_type = 'to' AND to_id IS NOT NULL) OR
    (source_type != 'to')
  )
);

-- Indexes
CREATE INDEX idx_grns_org_status ON grns(org_id, status);
CREATE INDEX idx_grns_org_number ON grns(org_id, grn_number);
CREATE INDEX idx_grns_org_source ON grns(org_id, source_type);
CREATE INDEX idx_grns_receipt_date ON grns(receipt_date);
CREATE INDEX idx_grns_warehouse ON grns(warehouse_id);
CREATE INDEX idx_grns_po ON grns(po_id) WHERE po_id IS NOT NULL;
CREATE INDEX idx_grns_to ON grns(to_id) WHERE to_id IS NOT NULL;
CREATE INDEX idx_grns_asn ON grns(asn_id) WHERE asn_id IS NOT NULL;
CREATE INDEX idx_grns_supplier ON grns(supplier_id) WHERE supplier_id IS NOT NULL;

-- RLS
ALTER TABLE grns ENABLE ROW LEVEL SECURITY;

CREATE POLICY "grn_select_org" ON grns
FOR SELECT TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

CREATE POLICY "grn_insert_org" ON grns
FOR INSERT TO authenticated
WITH CHECK (
  org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  AND warehouse_id IN (
    SELECT id FROM warehouses
    WHERE org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  )
);

CREATE POLICY "grn_update_org" ON grns
FOR UPDATE TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()))
WITH CHECK (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

CREATE POLICY "grn_delete_org" ON grns
FOR DELETE TO authenticated
USING (org_id = (SELECT org_id FROM users WHERE id = auth.uid()));

-- =============================================================================
-- GRN Items Table (Detail)
-- =============================================================================

CREATE TABLE grn_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  grn_id UUID NOT NULL REFERENCES grns(id) ON DELETE CASCADE,

  -- Product
  product_id UUID NOT NULL REFERENCES products(id),

  -- Source Line Reference (for PO/TO integration)
  po_line_id UUID REFERENCES purchase_order_lines(id),
  to_line_id UUID REFERENCES transfer_order_lines(id),

  -- Quantities
  ordered_qty DECIMAL(15,4) NOT NULL DEFAULT 0,  -- Expected qty (from PO/TO)
  received_qty DECIMAL(15,4) NOT NULL CHECK (received_qty >= 0),
  uom TEXT NOT NULL,

  -- Created LP Reference
  lp_id UUID REFERENCES license_plates(id),

  -- Tracking
  batch_number TEXT,
  supplier_batch_number TEXT,
  gtin TEXT,
  catch_weight_kg DECIMAL(10,3),
  expiry_date DATE,
  manufacture_date DATE,

  -- Location (can differ from GRN header)
  location_id UUID NOT NULL REFERENCES locations(id),

  -- QA Status (applied to created LP)
  qa_status TEXT NOT NULL DEFAULT 'pending'
    CHECK (qa_status IN ('pending', 'passed', 'failed', 'quarantine')),

  -- Line Info
  line_number INTEGER NOT NULL,
  notes TEXT
);

-- Indexes
CREATE INDEX idx_grn_items_grn ON grn_items(grn_id);
CREATE INDEX idx_grn_items_product ON grn_items(product_id);
CREATE INDEX idx_grn_items_lp ON grn_items(lp_id) WHERE lp_id IS NOT NULL;
CREATE INDEX idx_grn_items_po_line ON grn_items(po_line_id) WHERE po_line_id IS NOT NULL;
CREATE INDEX idx_grn_items_to_line ON grn_items(to_line_id) WHERE to_line_id IS NOT NULL;

-- RLS (inherits from grns via FK)
ALTER TABLE grn_items ENABLE ROW LEVEL SECURITY;

CREATE POLICY "grn_items_via_grn" ON grn_items
FOR ALL TO authenticated
USING (
  grn_id IN (
    SELECT id FROM grns
    WHERE org_id = (SELECT org_id FROM users WHERE id = auth.uid())
  )
);

-- =============================================================================
-- GRN Number Generation Function
-- =============================================================================

CREATE OR REPLACE FUNCTION generate_grn_number(p_org_id UUID)
RETURNS TEXT AS $$
DECLARE
  v_year INTEGER;
  v_next_val BIGINT;
  v_grn_number TEXT;
BEGIN
  -- Get current year
  v_year := EXTRACT(YEAR FROM NOW());

  -- Upsert sequence and get next value
  INSERT INTO grn_number_sequences (org_id, year, current_value)
  VALUES (p_org_id, v_year, 1)
  ON CONFLICT (org_id, year)
  DO UPDATE SET
    current_value = grn_number_sequences.current_value + 1,
    updated_at = NOW()
  RETURNING current_value INTO v_next_val;

  -- Format GRN number: GRN-YYYY-NNNNN
  v_grn_number := 'GRN-' || v_year::TEXT || '-' || LPAD(v_next_val::TEXT, 5, '0');

  RETURN v_grn_number;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- Trigger to Update GRN Aggregates
-- =============================================================================

CREATE OR REPLACE FUNCTION update_grn_aggregates()
RETURNS TRIGGER AS $$
BEGIN
  -- Update totals on grns table
  UPDATE grns
  SET
    total_items = (SELECT COUNT(*) FROM grn_items WHERE grn_id = COALESCE(NEW.grn_id, OLD.grn_id)),
    total_qty = (SELECT COALESCE(SUM(received_qty), 0) FROM grn_items WHERE grn_id = COALESCE(NEW.grn_id, OLD.grn_id))
  WHERE id = COALESCE(NEW.grn_id, OLD.grn_id);

  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_grn_items_aggregates
AFTER INSERT OR UPDATE OR DELETE ON grn_items
FOR EACH ROW EXECUTE FUNCTION update_grn_aggregates();
```

### API Endpoints

```
# GRN CRUD
GET    /api/warehouse/grns                          - List GRNs (paginated, filtered)
GET    /api/warehouse/grns/:id                      - Get GRN detail with items
POST   /api/warehouse/grns                          - Create GRN with items
PUT    /api/warehouse/grns/:id                      - Update GRN (draft only)
POST   /api/warehouse/grns/:id/complete             - Complete GRN (creates LPs)
POST   /api/warehouse/grns/:id/cancel               - Cancel GRN
POST   /api/warehouse/grns/:id/print                - Print GRN summary

# GRN Items CRUD
POST   /api/warehouse/grns/:id/items                - Add item to GRN
PUT    /api/warehouse/grns/:id/items/:itemId        - Update GRN item
DELETE /api/warehouse/grns/:id/items/:itemId        - Remove GRN item

# Utility
GET    /api/warehouse/grns/generate-number          - Generate next GRN number (preview)
```

**Query Parameters (List):**
- `search` - GRN number prefix search
- `status` - Filter by status (draft, completed, cancelled)
- `source_type` - Filter by source type (po, to, production, return, adjustment)
- `warehouse_id` - Filter by warehouse UUID
- `from_date` - Filter receipt_date >= value
- `to_date` - Filter receipt_date <= value
- `supplier_id` - Filter by supplier UUID
- `sort` - Sort field (grn_number, receipt_date, created_at, total_qty)
- `order` - Sort order (asc, desc)
- `page` - Page number (default 1)
- `limit` - Items per page (default 50, max 100)

### Service Layer

```typescript
// lib/services/grn-service.ts

export type GRNStatus = 'draft' | 'completed' | 'cancelled';
export type GRNSourceType = 'po' | 'to' | 'production' | 'return' | 'adjustment';
export type QAStatus = 'pending' | 'passed' | 'failed' | 'quarantine';

export interface GRN {
  id: string;
  org_id: string;
  grn_number: string;
  source_type: GRNSourceType;
  po_id: string | null;
  to_id: string | null;
  asn_id: string | null;
  supplier_id: string | null;
  receipt_date: string;
  warehouse_id: string;
  location_id: string;
  status: GRNStatus;
  total_items: number;
  total_qty: number;
  notes: string | null;
  created_at: string;
  created_by: string | null;
  completed_at: string | null;
  completed_by: string | null;
  cancelled_at: string | null;
  cancelled_by: string | null;
  cancellation_reason: string | null;
  // Joined fields
  warehouse?: { name: string; code: string };
  location?: { full_path: string };
  supplier?: { name: string };
  items?: GRNItem[];
}

export interface GRNItem {
  id: string;
  grn_id: string;
  product_id: string;
  po_line_id: string | null;
  to_line_id: string | null;
  ordered_qty: number;
  received_qty: number;
  uom: string;
  lp_id: string | null;
  batch_number: string | null;
  supplier_batch_number: string | null;
  gtin: string | null;
  catch_weight_kg: number | null;
  expiry_date: string | null;
  manufacture_date: string | null;
  location_id: string;
  qa_status: QAStatus;
  line_number: number;
  notes: string | null;
  // Joined fields
  product?: { name: string; code: string; uom: string };
  location?: { full_path: string };
  lp?: { lp_number: string };
}

export interface CreateGRNInput {
  source_type: GRNSourceType;
  warehouse_id: string;
  location_id: string;
  po_id?: string;
  to_id?: string;
  asn_id?: string;
  supplier_id?: string;
  receipt_date?: string;
  notes?: string;
  items: CreateGRNItemInput[];
}

export interface CreateGRNItemInput {
  product_id: string;
  ordered_qty?: number;
  received_qty: number;
  uom: string;
  po_line_id?: string;
  to_line_id?: string;
  batch_number?: string;
  supplier_batch_number?: string;
  gtin?: string;
  catch_weight_kg?: number;
  expiry_date?: string;
  manufacture_date?: string;
  location_id?: string;  // Defaults to GRN location
  qa_status?: QAStatus;  // Defaults from settings
  notes?: string;
}

export interface UpdateGRNInput {
  location_id?: string;
  notes?: string;
}

export interface UpdateGRNItemInput {
  received_qty?: number;
  batch_number?: string;
  supplier_batch_number?: string;
  expiry_date?: string;
  manufacture_date?: string;
  location_id?: string;
  qa_status?: QAStatus;
  notes?: string;
}

export interface GRNListParams {
  search?: string;
  status?: GRNStatus;
  source_type?: GRNSourceType;
  warehouse_id?: string;
  from_date?: string;
  to_date?: string;
  supplier_id?: string;
  sort?: 'grn_number' | 'receipt_date' | 'created_at' | 'total_qty';
  order?: 'asc' | 'desc';
  page?: number;
  limit?: number;
}

export interface PaginatedResult<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    total_pages: number;
  };
}

export interface CompleteGRNResult {
  grn: GRN;
  created_lps: LicensePlate[];
}

export class GRNService {
  // ==========================================================================
  // CRUD Operations
  // ==========================================================================

  /**
   * List GRNs with filtering, sorting, pagination
   */
  static async list(params: GRNListParams): Promise<PaginatedResult<GRN>>;

  /**
   * Get single GRN by ID with items
   */
  static async getById(id: string): Promise<GRN | null>;

  /**
   * Create new GRN with items
   * Auto-generates GRN number
   * Validates all items and creates in transaction
   */
  static async create(data: CreateGRNInput): Promise<GRN>;

  /**
   * Update GRN (draft only)
   * Throws if GRN is not in draft status
   */
  static async update(id: string, data: UpdateGRNInput): Promise<GRN>;

  /**
   * Generate next GRN number (preview, doesn't commit)
   */
  static async generateGRNNumber(): Promise<string>;

  // ==========================================================================
  // Item Operations
  // ==========================================================================

  /**
   * Add item to GRN (draft only)
   */
  static async addItem(grnId: string, item: CreateGRNItemInput): Promise<GRNItem>;

  /**
   * Update GRN item (draft only)
   */
  static async updateItem(grnId: string, itemId: string, data: UpdateGRNItemInput): Promise<GRNItem>;

  /**
   * Remove item from GRN (draft only)
   */
  static async removeItem(grnId: string, itemId: string): Promise<void>;

  // ==========================================================================
  // Workflow Operations
  // ==========================================================================

  /**
   * Complete GRN
   * - Validates all items have required fields
   * - Creates LP for each item
   * - Updates GRN status to 'completed'
   * - All in transaction
   */
  static async complete(id: string): Promise<CompleteGRNResult>;

  /**
   * Cancel GRN
   * - Draft: Simply marks cancelled
   * - Completed: Validates LPs not in use, then consumes them
   * - Updates status to 'cancelled'
   */
  static async cancel(id: string, reason: string): Promise<GRN>;

  // ==========================================================================
  // Validation Helpers
  // ==========================================================================

  /**
   * Validate GRN can be modified (is in draft status)
   */
  static async validateDraftStatus(id: string): Promise<void>;

  /**
   * Validate all items have required fields for completion
   */
  static async validateForCompletion(grn: GRN): Promise<{ valid: boolean; errors: string[] }>;

  /**
   * Validate GRN can be cancelled (LPs not in use)
   */
  static async validateForCancellation(grn: GRN): Promise<{ valid: boolean; errors: string[] }>;

  // ==========================================================================
  // LP Creation (Internal)
  // ==========================================================================

  /**
   * Create LP from GRN item (internal)
   * Called during complete workflow
   */
  private static async createLPFromItem(
    grn: GRN,
    item: GRNItem
  ): Promise<LicensePlate>;

  // ==========================================================================
  // Utility Methods
  // ==========================================================================

  /**
   * Check if GRN exists and belongs to current org
   */
  static async exists(id: string): Promise<boolean>;

  /**
   * Get GRNs by PO ID
   */
  static async getByPOId(poId: string): Promise<GRN[]>;

  /**
   * Get GRNs by TO ID
   */
  static async getByTOId(toId: string): Promise<GRN[]>;

  /**
   * Get total received qty for PO line
   */
  static async getTotalReceivedForPOLine(poLineId: string): Promise<number>;
}
```

### Validation Schema (Zod)

```typescript
// lib/validation/grn.ts
import { z } from 'zod';

export const grnSourceTypeEnum = z.enum(['po', 'to', 'production', 'return', 'adjustment']);
export const grnStatusEnum = z.enum(['draft', 'completed', 'cancelled']);
export const qaStatusEnum = z.enum(['pending', 'passed', 'failed', 'quarantine']);

export const createGRNItemSchema = z.object({
  product_id: z.string().uuid("Invalid product ID"),
  ordered_qty: z.number().nonnegative().default(0),
  received_qty: z.number().positive("Received quantity must be positive"),
  uom: z.string().min(1, "UoM is required").max(20),
  po_line_id: z.string().uuid().nullable().optional(),
  to_line_id: z.string().uuid().nullable().optional(),
  batch_number: z.string().max(100).nullable().optional(),
  supplier_batch_number: z.string().max(100).nullable().optional(),
  gtin: z.string().length(14, "GTIN must be 14 digits").nullable().optional(),
  catch_weight_kg: z.number().positive().nullable().optional(),
  expiry_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).nullable().optional(),
  manufacture_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).nullable().optional(),
  location_id: z.string().uuid().optional(),  // Defaults to GRN location
  qa_status: qaStatusEnum.default('pending'),
  notes: z.string().max(500).nullable().optional(),
});

export const createGRNSchema = z.object({
  source_type: grnSourceTypeEnum,
  warehouse_id: z.string().uuid("Invalid warehouse ID"),
  location_id: z.string().uuid("Invalid location ID"),
  po_id: z.string().uuid().nullable().optional(),
  to_id: z.string().uuid().nullable().optional(),
  asn_id: z.string().uuid().nullable().optional(),
  supplier_id: z.string().uuid().nullable().optional(),
  receipt_date: z.string().datetime().optional(),
  notes: z.string().max(1000).nullable().optional(),
  items: z.array(createGRNItemSchema).min(1, "At least one item is required"),
}).refine(data => {
  // If source_type is 'po', po_id should be provided
  if (data.source_type === 'po' && !data.po_id) {
    return false;
  }
  return true;
}, { message: "PO ID required for PO source type" })
.refine(data => {
  // If source_type is 'to', to_id should be provided
  if (data.source_type === 'to' && !data.to_id) {
    return false;
  }
  return true;
}, { message: "TO ID required for TO source type" });

export const updateGRNSchema = z.object({
  location_id: z.string().uuid().optional(),
  notes: z.string().max(1000).nullable().optional(),
});

export const updateGRNItemSchema = z.object({
  received_qty: z.number().positive().optional(),
  batch_number: z.string().max(100).nullable().optional(),
  supplier_batch_number: z.string().max(100).nullable().optional(),
  expiry_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).nullable().optional(),
  manufacture_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).nullable().optional(),
  location_id: z.string().uuid().optional(),
  qa_status: qaStatusEnum.optional(),
  notes: z.string().max(500).nullable().optional(),
});

export const cancelGRNSchema = z.object({
  reason: z.string().min(1, "Cancellation reason required").max(500),
});

export const grnQuerySchema = z.object({
  search: z.string().min(1).optional(),
  status: grnStatusEnum.optional(),
  source_type: grnSourceTypeEnum.optional(),
  warehouse_id: z.string().uuid().optional(),
  from_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  to_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  supplier_id: z.string().uuid().optional(),
  sort: z.enum(['grn_number', 'receipt_date', 'created_at', 'total_qty']).default('created_at'),
  order: z.enum(['asc', 'desc']).default('desc'),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(50),
});

export type CreateGRNInput = z.infer<typeof createGRNSchema>;
export type UpdateGRNInput = z.infer<typeof updateGRNSchema>;
export type CreateGRNItemInput = z.infer<typeof createGRNItemSchema>;
export type UpdateGRNItemInput = z.infer<typeof updateGRNItemSchema>;
export type GRNQueryParams = z.infer<typeof grnQuerySchema>;
```

---

## UI Components

```
app/(authenticated)/warehouse/
  receiving/
    page.tsx                           -- GRN list page
    new/page.tsx                       -- GRN creation page
    [id]/page.tsx                      -- GRN detail page
    [id]/edit/page.tsx                 -- GRN edit page (draft)

components/warehouse/grn/
  GRNDataTable.tsx                     -- DataTable with sorting, pagination
  GRNFilters.tsx                       -- Filter panel (status, source, date, warehouse)
  GRNSearchInput.tsx                   -- GRN number search with debounce
  GRNStatusBadge.tsx                   -- Status badge (draft/completed/cancelled)
  GRNSourceBadge.tsx                   -- Source type badge with icon
  GRNForm.tsx                          -- Create/edit form
  GRNItemsTable.tsx                    -- Editable items table
  GRNItemRow.tsx                       -- Single item row with inline editing
  GRNProductSelector.tsx               -- Product search/select dropdown
  GRNDetailHeader.tsx                  -- GRN header section
  GRNDetailItems.tsx                   -- Read-only items list
  GRNDetailActions.tsx                 -- Action buttons (Complete, Cancel, Print)
  GRNPrintView.tsx                     -- Print-friendly layout
  GRNEmptyState.tsx                    -- No GRNs message
```

### Badge Colors (TailwindCSS)

| Status | Badge Class |
|--------|-------------|
| draft | `bg-yellow-100 text-yellow-800` |
| completed | `bg-green-100 text-green-800` |
| cancelled | `bg-gray-100 text-gray-500` |

| Source Type | Icon | Color |
|-------------|------|-------|
| po | Package | blue |
| to | Truck | purple |
| production | Factory | orange |
| return | Undo | yellow |
| adjustment | PlusMinus | gray |

---

## Key Business Rules

1. **GRN Number Format:** `GRN-YYYY-NNNNN` (e.g., GRN-2025-00001)
2. **Number Sequence:** Per organization, per year, resets at year boundary
3. **Status Transitions:**
   - draft -> completed (via complete action)
   - draft -> cancelled (via cancel action)
   - completed -> cancelled (only if LPs not in use)
4. **Immutability:** Completed/cancelled GRNs cannot be modified
5. **Item Line Numbers:** Sequential per GRN, not renumbered on delete
6. **LP Creation:**
   - One LP per GRN item on completion
   - LP inherits: product, qty, uom, batch, expiry, qa_status, location
   - LP source = 'receipt', grn_id set
   - LP number auto-generated from warehouse settings
7. **Validation on Complete:**
   - At least one item required
   - Batch required if `require_batch_on_receipt = true`
   - Expiry required if `require_expiry_on_receipt = true`
8. **Cancellation Rules:**
   - Draft: Simple status change
   - Completed: Validate all LPs are 'available', then consume them
   - Block if any LP is reserved or already consumed
9. **Transaction Handling:**
   - GRN + items created in single transaction
   - Completion (LP creation) in single transaction
   - Rollback on any failure

---

## Deliverables

### Database
- [ ] Migration: `grn_number_sequences` table
- [ ] Migration: `grns` table with all columns and constraints
- [ ] Migration: `grn_items` table with FK constraints
- [ ] Function: `generate_grn_number(org_id)`
- [ ] Trigger: `tr_grn_items_aggregates`
- [ ] RLS policies for both tables
- [ ] All performance indexes

### API Routes
- [ ] `GET /api/warehouse/grns` - List with filters
- [ ] `GET /api/warehouse/grns/:id` - Get detail with items
- [ ] `POST /api/warehouse/grns` - Create with items
- [ ] `PUT /api/warehouse/grns/:id` - Update (draft)
- [ ] `POST /api/warehouse/grns/:id/items` - Add item
- [ ] `PUT /api/warehouse/grns/:id/items/:itemId` - Update item
- [ ] `DELETE /api/warehouse/grns/:id/items/:itemId` - Remove item
- [ ] `POST /api/warehouse/grns/:id/complete` - Complete GRN
- [ ] `POST /api/warehouse/grns/:id/cancel` - Cancel GRN
- [ ] `POST /api/warehouse/grns/:id/print` - Print summary
- [ ] `GET /api/warehouse/grns/generate-number` - Preview next number

### Service Layer
- [ ] `GRNService.list()`
- [ ] `GRNService.getById()`
- [ ] `GRNService.create()`
- [ ] `GRNService.update()`
- [ ] `GRNService.addItem()`
- [ ] `GRNService.updateItem()`
- [ ] `GRNService.removeItem()`
- [ ] `GRNService.complete()` - **WITH LP CREATION**
- [ ] `GRNService.cancel()`
- [ ] `GRNService.validateForCompletion()`
- [ ] `GRNService.validateForCancellation()`
- [ ] `GRNService.generateGRNNumber()`

### Validation
- [ ] `createGRNSchema`
- [ ] `updateGRNSchema`
- [ ] `createGRNItemSchema`
- [ ] `updateGRNItemSchema`
- [ ] `cancelGRNSchema`
- [ ] `grnQuerySchema`

### Frontend
- [ ] GRN list page (`/warehouse/receiving`)
- [ ] GRN DataTable with sorting/pagination
- [ ] GRN filter panel
- [ ] GRN search input
- [ ] GRN create page (`/warehouse/receiving/new`)
- [ ] GRN form with items entry
- [ ] GRN detail page (`/warehouse/receiving/{id}`)
- [ ] GRN edit page (`/warehouse/receiving/{id}/edit`)
- [ ] Status/source badges
- [ ] Action buttons (Complete, Cancel, Print)
- [ ] Print-friendly view

### Tests
- [ ] Unit tests: GRN service methods (>80% coverage)
- [ ] Unit tests: Validation schemas
- [ ] Integration tests: All API endpoints
- [ ] Integration tests: Complete workflow with LP creation
- [ ] Integration tests: Cancel workflow
- [ ] RLS tests: Multi-tenancy isolation
- [ ] E2E tests: GRN list, create, detail, complete flow

---

## Test Cases

### Unit Tests

**File:** `__tests__/unit/services/grn-service.test.ts`

| Test Case | Description |
|-----------|-------------|
| `create()` generates GRN number | Verify GRN-YYYY-NNNNN format |
| `create()` creates items with line numbers | Sequential 1, 2, 3... |
| `create()` updates aggregates | total_items, total_qty |
| `create()` validates required fields | 400 on missing warehouse |
| `update()` succeeds on draft | Notes updated |
| `update()` blocks on completed | Error returned |
| `update()` blocks on cancelled | Error returned |
| `addItem()` increments line number | New item gets max+1 |
| `addItem()` updates aggregates | Totals recalculated |
| `removeItem()` updates aggregates | Totals recalculated |
| `complete()` creates LPs | One LP per item |
| `complete()` sets status = completed | Status change |
| `complete()` sets completed_at/by | Audit fields |
| `complete()` validates batch required | Error if missing |
| `complete()` validates expiry required | Error if missing |
| `complete()` validates at least one item | Error if empty |
| `complete()` rollback on LP creation failure | All or nothing |
| `cancel()` draft succeeds | Status = cancelled |
| `cancel()` completed with available LPs | LPs consumed |
| `cancel()` blocks if LP reserved | Error returned |
| `cancel()` blocks if LP consumed | Error returned |

### Integration Tests

**File:** `__tests__/integration/api/warehouse/grns.test.ts`

| Test Case | Description |
|-----------|-------------|
| GET `/grns` returns paginated list | Pagination works |
| GET `/grns?status=completed` filters | Status filter |
| GET `/grns?source_type=po` filters | Source filter |
| GET `/grns?from_date=...` filters | Date range |
| GET `/grns?search=GRN-2025` searches | Prefix search |
| GET `/grns/:id` returns GRN with items | Detail returned |
| GET `/grns/:id` with invalid ID returns 404 | Not found |
| POST `/grns` creates GRN with items | GRN + items created |
| PUT `/grns/:id` updates draft GRN | GRN updated |
| PUT `/grns/:id` blocks on completed | 400 returned |
| POST `/grns/:id/items` adds item | Item added |
| PUT `/grns/:id/items/:itemId` updates item | Item updated |
| DELETE `/grns/:id/items/:itemId` removes item | Item removed |
| POST `/grns/:id/complete` creates LPs | LPs created |
| POST `/grns/:id/complete` validates | Errors on invalid |
| POST `/grns/:id/cancel` cancels draft | Status = cancelled |
| POST `/grns/:id/cancel` cancels completed | LPs consumed |
| Cross-org access returns 404 | RLS enforced |
| Response times meet requirements | < 500ms |

### E2E Tests

**File:** `__tests__/e2e/warehouse/grn.spec.ts`

| Test Case | Description |
|-----------|-------------|
| View GRN list page | Page loads, table displays |
| Filter GRNs by status | Filter applies |
| Search GRNs by number | Search works |
| Create new GRN with items | Form submits, GRN created |
| View GRN detail | Detail page renders |
| Edit draft GRN | Edit form works |
| Complete GRN flow | Complete action, LPs created |
| Cancel draft GRN | Cancel action works |
| Print GRN | Print view renders |

---

## Definition of Done

### Database
- [ ] `grns` table created with all columns
- [ ] `grn_items` table created with FK constraints
- [ ] `grn_number_sequences` table created
- [ ] `generate_grn_number()` function works correctly
- [ ] Aggregate trigger works for totals
- [ ] All indexes created for performance
- [ ] RLS policies enforce org isolation

### API
- [ ] All endpoints return correct HTTP status codes
- [ ] Validation errors return 400 with messages
- [ ] Cross-tenant access returns 404
- [ ] Response times meet requirements:
  - GRN list: < 500ms
  - GRN detail: < 300ms
  - GRN create: < 500ms
  - GRN complete: < 2s (with LP creation)

### Service
- [ ] Complete workflow creates LPs correctly
- [ ] Cancel workflow handles LP status correctly
- [ ] Validation catches all required field issues
- [ ] Transaction rollback on failure

### Frontend
- [ ] GRN list page with DataTable
- [ ] Filters work (status, source, date, warehouse)
- [ ] Search works with debounce
- [ ] Create form with item entry
- [ ] Detail page shows all information
- [ ] Edit form works for draft GRNs
- [ ] Complete action creates LPs with confirmation
- [ ] Cancel action with reason input
- [ ] Print view formatted correctly
- [ ] Status/source badges display correctly

### Testing
- [ ] Unit tests: >80% coverage on service
- [ ] Integration tests: All endpoints covered
- [ ] RLS tests: Multi-tenancy verified
- [ ] E2E tests: Critical flows passing

### Documentation
- [ ] API endpoints documented
- [ ] Service methods documented with JSDoc
- [ ] Zod schemas have field descriptions

---

## Future Phases (Not in This Story)

### Story 05.11 - GRN from PO
- Select from approved POs
- Pre-populate items from PO lines
- Update po_lines.received_qty
- Over-receipt tolerance validation
- PO status transitions (partial -> received)

### Story 05.12 - GRN from TO
- Select from shipped TOs
- Transit LP handling
- Variance recording
- TO status transitions

### Story 05.13 - ASN Management
- Pre-receive notification
- ASN to GRN pre-population
- Expected vs actual comparison

### Story 05.14 - Label Printing
- Print LP labels on GRN complete
- ZPL template
- Printer configuration

### Story 05.17 - Scanner Receive
- Mobile receive workflow
- Barcode scanning
- Quick GRN creation

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| LP creation failure mid-transaction | HIGH | LOW | Full transaction rollback |
| Performance with many items | MEDIUM | MEDIUM | Batch insert, indexes |
| RLS policy gaps | HIGH | LOW | Comprehensive RLS tests |
| GRN number sequence conflicts | MEDIUM | LOW | Atomic upsert with row lock |
| Cancellation affects downstream | HIGH | MEDIUM | Validate LP status before cancel |

---

## Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-12-16 | Initial story creation with master-detail pattern and LP creation | OPUS |
