# Story 5.27: Scanner Session Timeout

**ID:** 5.27
**Batch:** 5C-1 (Scanner Core)
**Story Points:** 3
**Effort:** 3-4 hours
**Status:** Todo

---

## User Story

> As a **Warehouse manager**, I want automatic session timeout for unattended scanner devices, so that if a worker walks away, the session doesn't stay active indefinitely (security & data integrity).

---

## Acceptance Criteria

### AC 1: Default Idle Timeout
- **Given** creating new scanner session
- **When** session starts
- **Then**:
  - Set idle_duration_seconds = 300 (5 minutes default)
  - Set expires_at = NOW() + 300 seconds
  - Start activity tracking: last_activity_at = NOW()

### AC 2: Activity Tracking
- **Given** user scanning barcode or tapping button
- **When** activity occurs
- **Then**:
  - Call PATCH /api/scanner/sessions/:id/activity endpoint
  - Update last_activity_at = NOW()
  - Calculate idle_time = NOW() - last_activity_at
  - Return: idle_seconds_remaining

### AC 3: Idle Timeout Calculation
- **Given** session with 300s idle duration
- **When** checking session status
- **Then**:
  - Calculate idle_time = NOW() - last_activity_at
  - If idle_time < 270s: normal operation (green)
  - If 270s <= idle_time < 300s: warning (yellow)
  - If idle_time >= 300s: expired (red)
  - Show: "X seconds remaining" (countdown)

### AC 4: Warning Banner
- **Given** idle_time >= 270 seconds (30 seconds before timeout)
- **When** rendering UI
- **Then**:
  - Show warning banner: "Session expiring in 30 seconds"
  - Banner color: orange/yellow (prominent)
  - Include large button: "Extend Session"
  - Include countdown timer: "00:30" → "00:01"
  - Banner appears as overlay above all content

### AC 5: Extend Session
- **Given** warning banner displayed
- **When** user clicks "Extend Session"
- **Then**:
  - Call PATCH /api/scanner/sessions/:id/activity
  - Reset last_activity_at = NOW()
  - Reset idle timer: countdown disappears
  - Auto-extend for another 300 seconds (configurable)
  - Show success message: "Session extended for 5 minutes"

### AC 6: Session Expiration
- **Given** idle_time >= idle_duration_seconds
- **When** session expires
- **Then**:
  - Update scanner_sessions.status = 'timeout'
  - Show logout screen: "Session Expired"
  - Message: "For security, idle sessions are closed automatically"
  - Button: "Log In Again" → redirect to /scanner
  - Data loss prevention: See Story 5.36a AC6 (queue operations preserved on timeout)

### AC 7: Configurable Timeout Duration
- **Given** warehouse manager opening scanner settings
- **When** configuring session timeout
- **Then**:
  - Show timeout duration selector:
    - ○ 2 minutes (120s)
    - ○ 3 minutes (180s)
    - ● 5 minutes (300s) [default]
    - ○ 10 minutes (600s)
    - ○ 15 minutes (900s)
    - ○ Custom: [_____] seconds
  - Save to scanner_workflow_configs or user preferences
  - New sessions use selected duration

### AC 8: Prevent Data Loss
- **Given** session expires during workflow
- **When** session closes
- **Then**:
  - Save pending barcode validations to IndexedDB queue
  - Mark session as status='timeout' (not discarded)
  - On re-login: offer "Resume" option if within 24 hours
  - Show summary: "5 items processed before timeout"
  - Option to complete workflow or start over

### AC 9: Security Considerations
- **Given** session about to timeout
- **When** 30 seconds before expiry
- **Then**:
  - Don't auto-logout without warning (give user chance to extend)
  - Session key tied to device_id (anti-theft)
  - Clear sensitive data from memory on logout (auth token, etc)
  - No sensitive data in IndexedDB (encrypted or minimal)

### AC10: Offline Timeout Handling
- **Given** device offline
- **When** idle_duration_seconds exceeded
- **Then**:
  - Timeout still enforced (time tracking offline)
  - Session status updated when online
  - Pending validations preserved (not lost)
  - User re-logs in when online

---

## Technical Tasks

### Backend

- [ ] Create `PATCH /api/scanner/sessions/:id/activity` endpoint
  - Accept: nothing (uses auth context)
  - Calculate: idle_time = NOW() - last_activity_at
  - Update: last_activity_at = NOW()
  - Return: {last_activity_at, idle_seconds_remaining, warning_active}
  - If idle_time >= idle_duration: also update status='timeout'

- [ ] Create session timeout job (background process)
  - Run every 30 seconds
  - Find sessions where NOW() - last_activity_at >= idle_duration_seconds
  - Update status='timeout'
  - Mark for cleanup (soft delete or archive)

- [ ] Create `GET /api/scanner/sessions/:id/status` endpoint
  - Return: session status (active, paused, timeout, completed)
  - Return: idle_time, idle_seconds_remaining
  - Return: warning_active (boolean: is within 30s of timeout?)

- [ ] Create `POST /api/scanner/sessions/:id/extend` endpoint
  - Extend session by another idle_duration_seconds
  - Update: last_activity_at = NOW(), expires_at = NOW() + idle_duration
  - Return: {last_activity_at, idle_seconds_remaining}

- [ ] Create offline timeout validation
  - Client tracks time locally (doesn't rely on server)
  - On re-sync: validate local time hasn't been manipulated (sign with nonce)

### Frontend

- [ ] Create useSessionTimeout hook
  - Poll /api/scanner/sessions/:id/status every 10 seconds
  - Track idle_time locally for responsive countdown
  - Update last_activity_at on user interaction:
    - Keyboard input (barcode scan)
    - Button click
    - Screen touch/tap
  - Not on mouse movement (mobile/scanner not mouse-driven)

- [ ] Create SessionTimeoutWarning component
  - Props: session_id, idle_seconds_remaining, onExtend
  - Display: "Session expiring in 30 seconds"
  - Show countdown timer: minutes:seconds format
  - Large button: "Extend Session" (green, 60px)
  - Position: fixed top banner, z-index high
  - On extend click: call PATCH /api/scanner/sessions/:id/activity

- [ ] Create SessionExpiredScreen component
  - Full screen: "Session Expired"
  - Message: "For security, idle sessions are closed"
  - Sub-message: "5 items processed before timeout"
  - Buttons: "Log In Again" (primary), "View Queue" (secondary)
  - Show summary of pending validations count

- [ ] Create activity tracking service
  - Listen to: scanEvent, clickEvent, touchEvent, keyEvent
  - On any activity: call PATCH /api/scanner/sessions/:id/activity
  - Debounce: don't send more than 1x per 10 seconds (avoid spam)
  - Offline: track locally, send batch when online

- [ ] Implement offline timeout
  - Use Date.now() for local time tracking
  - Calculate idle_time locally = Date.now() - last_activity_timestamp
  - Compare against session's idle_duration_seconds
  - Timeout enforced client-side (don't wait for server)
  - On reconnect: sync with server to verify

- [ ] Create timeout settings UI
  - Add to /scanner/settings page
  - Selector: 2min, 3min, 5min (default), 10min, 15min, custom
  - Save to localStorage (user preference)
  - Use selected duration in next session

- [ ] Implement session recovery
  - On login: check for expired sessions (status='timeout')
  - Show: "Resume previous session? (5 items processed)"
  - If resume: restore pending validations, continue workflow
  - If start new: create fresh session, queue old validations for later

- [ ] Create data preservation on timeout
  - Before logout: save pending validations to IndexedDB
  - Save session context (current step, items processed)
  - On re-login: offer recovery option
  - Validations persisted up to 24 hours

### Database

- [ ] Ensure scanner_sessions.expires_at column exists
- [ ] Ensure scanner_sessions.idle_duration_seconds column exists
- [ ] Add index: (org_id, expires_at) for timeout job
- [ ] Create background job to clean up expired sessions (retention: 7 days)

---

## Testing

### Unit Tests
- Idle time calculation: (NOW() - last_activity_at) = idle_time
- Warning threshold: idle_time >= (idle_duration - 30s) triggers warning
- Timeout threshold: idle_time >= idle_duration triggers expiration
- Countdown timer: counts down 30→0 correctly
- Offline timeout: Date.now() based calculation works offline

### Integration Tests
- PATCH /api/scanner/sessions/:id/activity resets last_activity_at
- GET /api/scanner/sessions/:id/status returns correct idle_time
- POST /api/scanner/sessions/:id/extend extends expires_at correctly
- Background job marks expired sessions as status='timeout'
- Offline timeouts validated on sync

### E2E Tests
- Create session with 300s timeout → idle_time = 0
- Wait 270 seconds → warning banner appears with "30 seconds"
- Click "Extend Session" → idle_time resets → warning gone
- Let session idle 300s (no extend) → "Session Expired" screen
- Session Expired screen offers "Log In Again" button
- Session recovery: show "Resume previous (5 items)"
- Settings: change timeout to 2 minutes → next session uses 120s
- Offline timeout: disable internet → idle 5min → timeout enforced locally
- Resume session: within 24h → show recovery option
- Discard session: skip recovery → start fresh session

---

## Acceptance Criteria Checklist

- ✅ Default idle timeout: 300 seconds (5 minutes)
- ✅ Activity tracking: updates last_activity_at on user interaction
- ✅ Idle calculation: idle_time = NOW() - last_activity_at
- ✅ Warning banner: shows at 30s before timeout
- ✅ Extend session: resets idle timer, extends duration
- ✅ Session expiration: logout with confirmation screen
- ✅ Configurable timeout: 2/3/5/10/15 min options
- ✅ Data preservation: pending validations saved on timeout
- ✅ Security: session key tied to device, sensitive data cleared
- ✅ Offline support: timeout enforced locally, synced on reconnect
- ✅ Session recovery: resume option for recent timeouts

---

## Dependencies

**Requires:** Story 5.23 (Guided Workflows), Story 5.26 (Operations Menu)

**Enables:** Complete scanner core functionality

---

## Notes

- **Default 5 minutes**: Balances security (auto-logout) with usability (not too strict)
- **30-second warning**: Gives user time to extend before forced logout
- **Activity tracking**: Only on user action (scan, tap), not passive (timer)
- **Configurable duration**: Different warehouse areas may need different timeouts
- **Data preservation**: Never lose pending validations (crucial for audit trail)
- **Offline-first timeout**: Device enforces timeout locally (security) + syncs when online
- **Security consideration**: Session key tied to device_id (anti-theft if device stolen)
- **Recovery window**: 24-hour retention allows resuming after timeout
- **Background cleanup**: Expired sessions archived, not deleted (audit trail)
- **No sensitive data in queue**: IndexedDB stores only validation data (barcode + status, no auth tokens)
