<?xml version="1.0" encoding="UTF-8"?>
<storyContext>
  <metadata>
    <storyId>1.5</storyId>
    <storyTitle>Warehouse Configuration</storyTitle>
    <batchId>01B-infrastructure-config</batchId>
    <epicId>Epic 1 - Settings</epicId>
    <status>done</status>
    <priority>P1</priority>
    <estimatedEffort>8h</estimatedEffort>
    <dateCreated>2025-11-20</dateCreated>
    <dateCompleted>2025-11-21</dateCompleted>
    <approvalStatus>APPROVED FOR PRODUCTION</approvalStatus>
    <dependencies>
      <prerequisite>Story 1.1 - Organization Configuration (org_id needed)</prerequisite>
      <prerequisite>Story 1.2 - User Management (created_by/updated_by)</prerequisite>
      <blockedBy>None</blockedBy>
      <blocks>Story 1.6 - Location Management</blocks>
    </dependencies>
  </metadata>

  <storyDescription>
    <userStory>
      As an **Admin**,
      I want to define warehouses with default locations,
      so that inventory can be properly organized.
    </userStory>
    <businessValue>
      - Enables organization of inventory into hierarchical warehouse structure
      - Provides foundation for Epic 3 (PO receiving), Epic 5 (LP storage), Epic 7 (SO shipping)
      - Default locations streamline operational workflows (auto-select receiving/shipping locations)
      - Multi-tenant isolation ensures data security across organizations
    </businessValue>
  </storyDescription>

  <acceptanceCriteria>
    <criterion id="AC-004.1" status="IMPLEMENTED">
      <title>Admin mo≈ºe stworzyƒá warehouse</title>
      <description>
        - Navigate to /settings/warehouses
        - Click "Add Warehouse" button
        - Form fields:
          * code: required, unique per org, uppercase alphanumeric + hyphens (e.g., WH-01)
          * name: required, max 100 chars
          * address: optional, multi-line text (with city, postal_code, country)
          * is_active: toggle, default true
        - Validation: code unique constraint checked, show error if duplicate
        - On save: warehouse created with default_*_location_id = NULL initially
      </description>
      <testEvidence>
        - Unit tests: warehouse-schemas.test.ts (validation)
        - Integration tests: warehouses.test.ts (duplicate code error)
        - E2E tests: warehouses.spec.ts (create flow)
      </testEvidence>
    </criterion>

    <criterion id="AC-004.2" status="IMPLEMENTED">
      <title>Default locations nullable initially</title>
      <description>
        - default_receiving_location_id: FK ‚Üí locations (nullable)
        - default_shipping_location_id: FK ‚Üí locations (nullable)
        - transit_location_id: FK ‚Üí locations (nullable)
        - These are set after locations are created (Story 1.6)
        - Circular dependency resolution: create warehouse ‚Üí create locations ‚Üí update defaults
      </description>
      <technicalNotes>
        Migration 003_create_warehouses_table.sql defines nullable FK constraints.
        Service layer validates that default location IDs belong to the warehouse when updating.
      </technicalNotes>
    </criterion>

    <criterion id="AC-004.3" status="IMPLEMENTED">
      <title>Warehouses list view</title>
      <description>
        - Table columns: Code, Name, Address, Receiving Location, Shipping Location, Transit Location, Active, Actions
        - Search by code or name
        - Filter by is_active (Active, Inactive, All)
        - Sort by code, name, created_at (asc/desc toggle)
        - Location columns show location code or "Not set" if NULL
      </description>
      <testEvidence>
        - E2E tests: warehouses.spec.ts (search, filter, sort)
      </testEvidence>
    </criterion>

    <criterion id="AC-004.4" status="IMPLEMENTED">
      <title>Cannot delete warehouse with constraints</title>
      <description>
        - FK constraint ON DELETE RESTRICT prevents deletion if:
          * Warehouse has active POs (Epic 3)
          * Warehouse has active LPs (Epic 5)
          * Warehouse has active locations (Story 1.6)
        - Error message: "Cannot delete warehouse - it has X active entities. Archive it instead."
        - Archive option: set is_active = false (soft disable)
      </description>
      <technicalNotes>
        Database FK constraints enforce referential integrity.
        Service layer catches constraint errors and returns friendly messages.
      </technicalNotes>
    </criterion>

    <criterion id="AC-004.5" status="IMPLEMENTED">
      <title>Edit warehouse</title>
      <description>
        - Click Edit action ‚Üí drawer opens with form
        - All fields editable (code, name, address, default locations, is_active)
        - Default location dropdowns filtered to locations within this warehouse
        - Can update default locations after locations created
        - Validation: code still unique per org
        - On save: warehouse updated, cache invalidated
      </description>
      <testEvidence>
        - Integration tests: warehouses.test.ts (update with location IDs)
        - E2E tests: warehouses.spec.ts (edit flow)
      </testEvidence>
    </criterion>

    <criterion id="AC-004.6" status="IMPLEMENTED">
      <title>Inline location creation</title>
      <description>
        - When selecting default locations, show "+ Create Location" option
        - Opens location creation modal (from Story 1.6)
        - After creating location, it's auto-selected in dropdown
        - Enables quick setup: create warehouse ‚Üí create key locations ‚Üí assign defaults
      </description>
      <implementation>
        LocationFormModal.tsx component opens from WarehouseFormModal location dropdowns.
        After successful location creation, dropdown refreshes and auto-selects new location.
      </implementation>
    </criterion>

    <criterion id="AC-004.7" status="IMPLEMENTED">
      <title>Warehouse card/list view toggle</title>
      <description>
        - Default: Table view (compact, sortable, searchable)
        - Toggle to Card view (visual, shows more details per warehouse)
        - Card shows: code, name, address, default locations, active status
        - Card actions: Edit, Archive/Activate, View Locations
        - View preference persisted in localStorage
      </description>
      <implementation>
        WarehouseCard.tsx component with grid layout.
        View toggle button in page header (TableIcon / GridIcon).
      </implementation>
    </criterion>

    <criterion id="AC-004.8" status="IMPLEMENTED">
      <title>Cache invalidation events</title>
      <description>
        - On warehouse create/update/delete: emit 'warehouse.updated' event
        - Epic 3, 5, 7 invalidate warehouse cache on event
        - Redis cache TTL: 5 min
        - Cache key: `warehouses:{org_id}`
      </description>
      <implementation>
        Redis client (redis-client.ts) + warehouse cache layer (warehouse-cache.ts).
        Cache invalidation on create/update/delete operations.
        Graceful fallback to direct DB query if Redis unavailable.
      </implementation>
    </criterion>
  </acceptanceCriteria>

  <databaseSchema>
    <table name="warehouses">
      <migration>003_create_warehouses_table.sql</migration>
      <columns>
        <column name="id" type="UUID" constraints="PRIMARY KEY DEFAULT gen_random_uuid()" />
        <column name="org_id" type="UUID" constraints="NOT NULL REFERENCES organizations(id)" />
        <column name="code" type="VARCHAR(50)" constraints="NOT NULL CHECK (code ~ '^[A-Z0-9-]+$')" />
        <column name="name" type="VARCHAR(100)" constraints="NOT NULL CHECK (char_length(name) >= 1 AND char_length(name) <= 100)" />
        <column name="address" type="TEXT" constraints="NULL" />
        <column name="city" type="VARCHAR(100)" constraints="NULL" />
        <column name="postal_code" type="VARCHAR(20)" constraints="NULL" />
        <column name="country" type="VARCHAR(100)" constraints="NULL" />
        <column name="default_receiving_location_id" type="UUID" constraints="REFERENCES locations(id) ON DELETE RESTRICT" />
        <column name="default_shipping_location_id" type="UUID" constraints="REFERENCES locations(id) ON DELETE RESTRICT" />
        <column name="transit_location_id" type="UUID" constraints="REFERENCES locations(id) ON DELETE RESTRICT" />
        <column name="created_by" type="UUID" constraints="REFERENCES users(id)" />
        <column name="updated_by" type="UUID" constraints="REFERENCES users(id)" />
        <column name="created_at" type="TIMESTAMPTZ" constraints="NOT NULL DEFAULT now()" />
        <column name="updated_at" type="TIMESTAMPTZ" constraints="NOT NULL DEFAULT now()" />
      </columns>
      <constraints>
        <unique>(org_id, code)</unique>
      </constraints>
      <indexes>
        <index name="idx_warehouses_org_id" columns="org_id" purpose="RLS query performance" />
        <index name="idx_warehouses_code" columns="org_id, code" purpose="Unique constraint enforcement" />
      </indexes>
      <rlsPolicy>
        ALTER TABLE warehouses ENABLE ROW LEVEL SECURITY;
        CREATE POLICY "warehouses_tenant_isolation" ON warehouses
          FOR ALL
          USING (
            current_setting('request.jwt.claims', true)::json->>'role' = 'service_role'
            OR org_id = (auth.jwt() ->> 'org_id')::uuid
          );
      </rlsPolicy>
    </table>
  </databaseSchema>

  <apiEndpoints>
    <endpoint method="GET" path="/api/settings/warehouses">
      <description>Get list of warehouses for current organization</description>
      <queryParams>
        <param name="is_active" type="boolean" optional="true" description="Filter by active status" />
        <param name="search" type="string" optional="true" description="Search by code or name" />
        <param name="sort_by" type="string" optional="true" description="Sort column: code, name, created_at" />
        <param name="sort_direction" type="string" optional="true" description="asc or desc" />
      </queryParams>
      <response>Warehouse[] with location names for defaults</response>
      <auth>Authenticated user</auth>
      <cache>Redis 5 min TTL (key: warehouses:{org_id})</cache>
      <file>apps/frontend/app/api/settings/warehouses/route.ts</file>
    </endpoint>

    <endpoint method="POST" path="/api/settings/warehouses">
      <description>Create new warehouse</description>
      <requestBody>CreateWarehouseInput (Zod validated)</requestBody>
      <response>Created Warehouse object</response>
      <auth>Admin only</auth>
      <validation>
        - Code unique per org (database constraint)
        - Code format: uppercase alphanumeric + hyphens
        - Name required, max 100 chars
      </validation>
      <cacheInvalidation>warehouses:{org_id}</cacheInvalidation>
      <file>apps/frontend/app/api/settings/warehouses/route.ts</file>
    </endpoint>

    <endpoint method="PUT" path="/api/settings/warehouses/:id">
      <description>Update existing warehouse</description>
      <requestBody>UpdateWarehouseInput (Zod validated)</requestBody>
      <response>Updated Warehouse object</response>
      <auth>Admin only</auth>
      <validation>
        - Code still unique if changed
        - Default location IDs belong to this warehouse
      </validation>
      <cacheInvalidation>warehouses:{org_id}</cacheInvalidation>
      <file>apps/frontend/app/api/settings/warehouses/[id]/route.ts</file>
    </endpoint>

    <endpoint method="DELETE" path="/api/settings/warehouses/:id">
      <description>Delete warehouse (soft delete via archive preferred)</description>
      <response>
        Success: { success: true }
        Error: { error: "Cannot delete - has active dependencies" }
      </response>
      <auth>Admin only</auth>
      <constraints>
        FK constraints prevent deletion if warehouse has:
        - Active locations
        - Active purchase orders (Epic 3)
        - Active license plates (Epic 5)
      </constraints>
      <cacheInvalidation>warehouses:{org_id}</cacheInvalidation>
      <file>apps/frontend/app/api/settings/warehouses/[id]/route.ts</file>
    </endpoint>
  </apiEndpoints>

  <zodSchemas>
    <schema name="CreateWarehouseSchema">
      <file>apps/frontend/lib/validation/warehouse-schemas.ts</file>
      <definition>
        code: z.string().regex(/^[A-Z0-9-]+$/).min(2).max(50)
        name: z.string().min(1).max(100)
        address: z.string().optional()
        city: z.string().max(100).optional()
        postal_code: z.string().max(20).optional()
        country: z.string().max(100).optional()
        is_active: z.boolean().default(true)
      </definition>
    </schema>

    <schema name="UpdateWarehouseSchema">
      <file>apps/frontend/lib/validation/warehouse-schemas.ts</file>
      <definition>
        Extends CreateWarehouseSchema with:
        default_receiving_location_id: z.string().uuid().optional()
        default_shipping_location_id: z.string().uuid().optional()
        transit_location_id: z.string().uuid().optional()
      </definition>
    </schema>

    <schema name="WarehouseFiltersSchema">
      <file>apps/frontend/lib/validation/warehouse-schemas.ts</file>
      <definition>
        is_active: z.boolean().optional()
        search: z.string().optional()
        sort_by: z.enum(['code', 'name', 'created_at']).optional()
        sort_direction: z.enum(['asc', 'desc']).default('asc')
      </definition>
    </schema>
  </zodSchemas>

  <services>
    <service name="WarehouseService">
      <file>apps/frontend/lib/services/warehouse-service.ts</file>
      <methods>
        <method name="createWarehouse">
          <params>input: CreateWarehouseInput, userId: string</params>
          <returns>Warehouse</returns>
          <logic>
            1. Validate code unique per org (query database)
            2. Validate code format (uppercase, alphanumeric, hyphens)
            3. Insert warehouse record (default locations = NULL)
            4. Emit cache event: 'warehouse.created'
            5. Invalidate Redis cache
            6. Return warehouse object
          </logic>
        </method>

        <method name="updateWarehouse">
          <params>id: string, input: UpdateWarehouseInput, userId: string</params>
          <returns>Warehouse</returns>
          <logic>
            1. Validate warehouse exists, belongs to org
            2. Validate code still unique if changed
            3. Validate default location IDs belong to this warehouse
            4. Update warehouse record
            5. Emit cache event: 'warehouse.updated'
            6. Invalidate Redis cache
            7. Return updated warehouse
          </logic>
        </method>

        <method name="getWarehouses">
          <params>orgId: string, filters?: WarehouseFilters</params>
          <returns>Warehouse[]</returns>
          <logic>
            1. Check Redis cache (key: warehouses:{org_id})
            2. If cache miss: Query warehouses WHERE org_id = orgId
            3. Apply filters: is_active, search (code/name)
            4. Include related locations (for default location names)
            5. Sort by specified column + direction
            6. Cache result (5 min TTL)
            7. Return warehouses array
          </logic>
        </method>

        <method name="deleteWarehouse">
          <params>id: string, orgId: string</params>
          <returns>{ success: boolean } or { error: string }</returns>
          <logic>
            1. Validate warehouse exists, belongs to org
            2. Try DELETE (FK constraints will prevent if has dependencies)
            3. Catch constraint error ‚Üí return friendly error message
            4. Alternative: soft delete (is_active = false)
            5. Emit cache event: 'warehouse.deleted'
            6. Invalidate Redis cache
          </logic>
        </method>
      </methods>
    </service>
  </services>

  <frontendComponents>
    <component name="WarehousesPage">
      <file>apps/frontend/app/settings/warehouses/page.tsx</file>
      <description>Main list page with table/card view toggle</description>
      <features>
        - Fetch warehouses using SWR (auto-refresh every 5 min)
        - View toggle (table/card) persisted in localStorage
        - Search input (filters by code/name)
        - Active filter dropdown (All, Active, Inactive)
        - Sort dropdown (code, name, created_at) with asc/desc toggle
        - "Add Warehouse" button (opens WarehouseFormModal)
        - Loading state, error state
      </features>
    </component>

    <component name="WarehousesTable">
      <file>apps/frontend/components/settings/WarehousesTable.tsx</file>
      <description>Table view with sortable columns</description>
      <columns>
        - Code (sortable)
        - Name (sortable)
        - Address (city, postal_code, country)
        - Receiving Location (code or "Not set")
        - Shipping Location (code or "Not set")
        - Transit Location (code or "Not set")
        - Active (badge: green/gray)
        - Actions (Edit, Archive/Activate, View Locations)
      </columns>
    </component>

    <component name="WarehouseCard">
      <file>apps/frontend/components/settings/WarehouseCard.tsx</file>
      <description>Card view with visual warehouse details</description>
      <layout>
        Grid layout (responsive: 1 col mobile, 2 cols tablet, 3 cols desktop)
        Each card shows:
        - Code + Name (header)
        - Address (multi-line)
        - Default locations (badges)
        - Active status (badge)
        - Actions (Edit, Archive/Activate, View Locations buttons)
      </layout>
    </component>

    <component name="WarehouseFormModal">
      <file>apps/frontend/components/settings/WarehouseFormModal.tsx</file>
      <description>Create/edit form modal</description>
      <fields>
        - Code: uppercase input, validation feedback
        - Name: text input
        - Address: textarea
        - City: text input
        - Postal Code: text input
        - Country: text input
        - Default Receiving Location: searchable dropdown + inline creation
        - Default Shipping Location: searchable dropdown + inline creation
        - Transit Location: searchable dropdown + inline creation
        - Is Active: toggle switch
      </fields>
      <validation>
        React Hook Form + Zod schema validation
        Client-side + server-side validation
      </validation>
      <inlineCreation>
        Each location dropdown has "+ Create Location" option
        Opens LocationFormModal (from Story 1.6) with warehouse_id pre-filled
        After creating location, refresh dropdown and auto-select new location
      </inlineCreation>
    </component>
  </frontendComponents>

  <circularDependencyResolution>
    <title>Warehouses ‚Üî Locations Circular Dependency</title>
    <problem>
      Warehouses need default location IDs (default_receiving_location_id, default_shipping_location_id, transit_location_id)
      BUT locations need warehouse_id to be created.
    </problem>
    <solution>
      3-Step Flow:
      1. Create warehouse with default locations = NULL
      2. Create locations (Story 1.6) with warehouse_id FK
      3. Update warehouse ‚Üí set default location IDs
    </solution>
    <validation>
      Service layer validates:
      - Default location IDs must exist
      - Default locations must belong to the warehouse (WHERE warehouse_id = :warehouse_id)
      - Enforced in WarehouseService.updateWarehouse()
    </validation>
    <uiGuidance>
      After creating warehouse without locations:
      - Show banner: "Add locations to this warehouse to set default receiving/shipping/transit locations"
      - Button: "Add Location" (links to location creation)
      - Inline location creation from warehouse form enables quick setup
    </uiGuidance>
  </circularDependencyResolution>

  <cacheStrategy>
    <redisIntegration>
      <file>apps/frontend/lib/cache/redis-client.ts</file>
      <file>apps/frontend/lib/cache/warehouse-cache.ts</file>
      <cacheKey>warehouses:{org_id}</cacheKey>
      <ttl>5 minutes (300 seconds)</ttl>
      <invalidation>
        On warehouse create/update/delete:
        1. Emit Supabase Realtime event (channel: warehouse-updates)
        2. Invalidate Redis cache key: warehouses:{org_id}
        3. Frontend SWR cache also invalidated
      </invalidation>
      <gracefulFallback>
        If Redis unavailable, fall back to direct database query.
        Log error but do not block user operation.
      </gracefulFallback>
    </redisIntegration>

    <consumerEpics>
      - Epic 3 (Planning): Refetch warehouses on create PO
      - Epic 5 (Warehouse): Refetch warehouses on LP moves
      - Epic 7 (Shipping): Refetch warehouses on create SO
    </consumerEpics>
  </cacheStrategy>

  <testingStrategy>
    <unitTests>
      <file>apps/frontend/__tests__/validation/warehouse-schemas.test.ts</file>
      <coverage>
        - Code format validation (uppercase, alphanumeric, hyphens only)
        - Code length validation (min 2, max 50 chars)
        - Name validation (required, max 100 chars)
        - Address fields optional
        - Filter schema validation
        - Update schema with location IDs
      </coverage>
      <testCount>297 lines, comprehensive edge case coverage</testCount>
    </unitTests>

    <integrationTests>
      <file>apps/frontend/__tests__/api/warehouses.test.ts</file>
      <coverage>
        - POST warehouse ‚Üí created with NULL defaults
        - POST warehouse with duplicate code ‚Üí error
        - PUT warehouse ‚Üí update defaults with valid location IDs
        - PUT warehouse ‚Üí error if location not in warehouse
        - DELETE warehouse with locations ‚Üí FK constraint error
        - Archive warehouse ‚Üí is_active = false
        - RLS policy: User A cannot access User B's warehouses
        - Cache invalidation on create/update/delete
      </coverage>
      <testCount>27 tests</testCount>
    </integrationTests>

    <e2eTests>
      <file>tests/e2e/warehouses.spec.ts</file>
      <coverage>
        - Create warehouse flow (form ‚Üí save ‚Üí appears in list)
        - Edit warehouse (change name, update defaults)
        - Archive/activate warehouse (badge changes, filter works)
        - Cannot delete warehouse with dependencies (error modal)
        - Inline location creation from warehouse form
        - Search and filter warehouses
        - Sort warehouses by code/name/created_at
        - Card view toggle (localStorage persistence)
      </coverage>
      <testCount>10 tests</testCount>
    </e2eTests>
  </testingStrategy>

  <performanceTargets>
    <target metric="Warehouse list load (100 warehouses)" p95="200ms" actual="Met" notes="Redis cache deferred to Story 1.14" />
    <target metric="Create warehouse" p95="300ms" actual="Met" />
    <target metric="Update warehouse" p95="250ms" actual="Met" />
    <target metric="Cache hit rate" target="80%" actual="Pending" notes="Redis integration complete, monitoring in progress" />
  </performanceTargets>

  <securityConsiderations>
    <rlsPolicies>
      ‚úÖ RLS enabled on warehouses table
      ‚úÖ Multi-tenant isolation via org_id
      ‚úÖ Service role bypasses RLS (used in services)
    </rlsPolicies>

    <authentication>
      ‚úÖ Session checks in all API routes
      ‚úÖ Admin role verification for mutations (create/update/delete)
      ‚úÖ org_id isolation enforced
    </authentication>

    <inputValidation>
      ‚úÖ Zod schemas for client + server validation
      ‚úÖ Regex validation for codes (uppercase, alphanumeric, hyphens)
      ‚úÖ SQL injection protection (parameterized queries via Supabase client)
      ‚úÖ Search filter properly escaped (SQL injection vulnerability fixed)
    </inputValidation>

    <dataProtection>
      ‚úÖ Multi-tenant isolation
      ‚úÖ Audit trail (created_by, updated_by, timestamps)
      ‚úÖ FK constraints prevent accidental data loss (ON DELETE RESTRICT)
    </dataProtection>
  </securityConsiderations>

  <fileReferences>
    <migrations>
      <file>apps/frontend/lib/supabase/migrations/003_create_warehouses_table.sql</file>
    </migrations>

    <services>
      <file>apps/frontend/lib/services/warehouse-service.ts</file>
    </services>

    <validation>
      <file>apps/frontend/lib/validation/warehouse-schemas.ts</file>
    </validation>

    <api>
      <file>apps/frontend/app/api/settings/warehouses/route.ts</file>
      <file>apps/frontend/app/api/settings/warehouses/[id]/route.ts</file>
    </api>

    <pages>
      <file>apps/frontend/app/settings/warehouses/page.tsx</file>
    </pages>

    <components>
      <file>apps/frontend/components/settings/WarehousesTable.tsx</file>
      <file>apps/frontend/components/settings/WarehouseCard.tsx</file>
      <file>apps/frontend/components/settings/WarehouseFormModal.tsx</file>
      <file>apps/frontend/components/settings/LocationFormModal.tsx</file>
    </components>

    <cache>
      <file>apps/frontend/lib/cache/redis-client.ts</file>
      <file>apps/frontend/lib/cache/warehouse-cache.ts</file>
    </cache>

    <tests>
      <file>apps/frontend/__tests__/validation/warehouse-schemas.test.ts</file>
      <file>apps/frontend/__tests__/api/warehouses.test.ts</file>
      <file>tests/e2e/warehouses.spec.ts</file>
    </tests>

    <scripts>
      <file>scripts/apply-migration-003.mjs</file>
    </scripts>

    <documentation>
      <file>docs/batches/01B-infrastructure-config/stories/1.5-warehouse-configuration.md</file>
      <file>docs/batches/01B-infrastructure-config/tech-spec.md</file>
      <file>docs/RLS_AND_SUPABASE_CLIENTS.md</file>
    </documentation>
  </fileReferences>

  <lessonsLearned>
    <whatWorkedWell>
      ‚úÖ 3-step circular dependency resolution (warehouse ‚Üí locations ‚Üí defaults)
      ‚úÖ Comprehensive test coverage (unit + integration + E2E)
      ‚úÖ RLS policies enforced from day 1
      ‚úÖ FK constraints prevent accidental data loss
      ‚úÖ Archive (soft delete) preferred over hard delete
      ‚úÖ Redis caching with graceful fallback
    </whatWorkedWell>

    <challenges>
      ‚ö†Ô∏è SQL injection vulnerability initially present in search filter (fixed)
      ‚ö†Ô∏è Validation schema discrepancies between frontend and database (aligned)
      ‚ö†Ô∏è Duplicate migration code (cleaned up)
      ‚ö†Ô∏è Missing inline location creation (implemented)
    </challenges>

    <improvementsForNext>
      üí° Always implement caching layer early (deferred to Story 1.14 created debt)
      üí° Add performance benchmarks to CI/CD
      üí° Test RLS policies thoroughly from day 1 (avoid security gaps)
    </improvementsForNext>
  </lessonsLearned>

  <reviewOutcome>
    <initialReview>
      <date>2025-11-21</date>
      <reviewer>Mariusz</reviewer>
      <outcome>CHANGES REQUESTED</outcome>
      <highSeverityIssues>3</highSeverityIssues>
      <mediumSeverityIssues>7</mediumSeverityIssues>
      <lowSeverityIssues>5</lowSeverityIssues>
    </initialReview>

    <finalReview>
      <date>2025-11-21</date>
      <reviewer>Mariusz</reviewer>
      <outcome>APPROVED FOR PRODUCTION</outcome>
      <summary>
        All HIGH and MEDIUM severity issues resolved.
        Story 1.5 (Warehouse Configuration) is production-ready with:
        - Complete implementation of all 8 acceptance criteria
        - Comprehensive test coverage (37 tests total)
        - No critical security vulnerabilities
        - Redis caching with graceful fallback
        - Performance targets met
      </summary>
      <acCoverage>8/8 (100% IMPLEMENTED)</acCoverage>
      <testCoverage>37 tests (unit + integration + E2E)</testCoverage>
      <securityStatus>All critical issues resolved</securityStatus>
      <performanceStatus>All targets met</performanceStatus>
    </finalReview>
  </reviewOutcome>
</storyContext>
