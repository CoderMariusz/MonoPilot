<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <story-id>04-11</story-id>
    <story-title>Over-Consumption Control</story-title>
    <epic>4 - Production Execution</epic>
    <status>drafted</status>
    <priority>P0</priority>
    <story-points>2</story-points>
    <effort>1 day</effort>
    <created>2025-11-27</created>
  </metadata>

  <!-- ========================================== -->
  <!-- STORY CONTENT -->
  <!-- ========================================== -->
  <story-content>
    <user-story>
      <as>Admin</as>
      <i-want>to control over-consumption</i-want>
      <so-that>we don't waste materials</so-that>
    </user-story>

    <problem-statement>
      Material over-consumption (consuming more than BOM-required quantity) must be controlled to prevent
      waste and ensure cost accuracy. The system must detect when consumed_qty > required_qty and either
      block or warn based on production_settings.allow_over_consumption flag. This validation must happen
      during output registration (Story 4.12) which triggers auto-consumption. Variance must be tracked
      for reporting and costing analysis.
    </problem-statement>

    <acceptance-criteria>
      <ac id="AC-4.11.1" title="Over-Consumption Warning (not blocking)">
        Given output qty would trigger over-consumption (consumed_qty > required_qty)
        When output is registered (Story 4.12 auto-consume triggered)
        Then system shows warning dialog:
        - "⚠️ Over-Consumption Detected!"
        - "Material 'Flour': Required 100kg, Reserved 80+40=120kg, Output triggers consumption of all"
        - Buttons: "Cancel" or "Accept Over-Consumption"
        Note: System WARNS but doesn't block - operator must confirm to proceed
      </ac>

      <ac id="AC-4.11.2" title="Over-Consumption Warning (When Allowed)">
        Given allow_over_consumption = true
        When consumed_qty > required_qty
        Then warning shown: "⚠️ Over-consumption: +X kg above required"
      </ac>

      <ac id="AC-4.11.3" title="Variance Tracking">
        Then wo_materials.consumed_qty tracked, variance = consumed - required recorded
      </ac>

      <ac id="AC-4.11.4" title="Transaction Atomicity - Output Registration Endpoint">
        Then POST /api/production/work-orders/:id/outputs with over-consumption check is atomic:
        1. VALIDATE: WO in_progress, reserved materials exist
        2. CALCULATE: total_consumed (cumulative across all outputs)
        3. CHECK over-consumption per material:
           - If total_consumed > required_qty for ANY material:
             - Return 400 error: "Over-consumption detected for Material X. Confirm to proceed?"
             - Frontend shows dialog with operator choice
           - If operator confirms: proceed with auto-consume (Story 4.12 AC-4.12.3)
           - If operator cancels: cancel output registration
        4. AUTO-CONSUME: Execute sequential LP allocation (Story 4.12 AC-4.12.3)
        5. CREATE genealogy links (Story 4.19)
        6. UPDATE work_orders.output_qty
        7. COMMIT or ROLLBACK (no partial updates)
      </ac>

      <ac id="AC-4.11.5" title="Rollback on Over-Consumption Blocked">
        When over-consumption blocked
        Then NO consumption record created, LP qty unchanged, error returned
      </ac>

      <ac id="AC-4.11.6" title="API Endpoint">
        Then POST /api/production/work-orders/:id/consume validates allow_over_consumption
      </ac>

      <ac id="AC-4.11.7" title="Settings Configuration">
        Then production_settings.allow_over_consumption toggle (Story 4.17)
      </ac>

      <ac id="AC-4.11.8" title="Error Messages">
        | Scenario | Message |
        |----------|---------|
        | Over-consumption blocked | "Cannot consume: Over-consumption not allowed. Required: 100kg, Consumed: 95kg, Requested: 10kg. Max allowed: 5kg more." |
        | QA Hold LP | "Cannot consume: LP on QA Hold" |
      </ac>
    </acceptance-criteria>

    <tasks>
      <task id="1" status="pending">Implement over-consumption check in OutputService</task>
      <task id="2" status="pending">Atomic transaction with proper rollback</task>
      <task id="3" status="pending">API validation and error responses</task>
      <task id="4" status="pending">Frontend warning/error display</task>
      <task id="5" status="pending">Variance tracking and reporting</task>
      <task id="6" status="pending">Tests (unit, integration, atomic transaction tests)</task>
    </tasks>

    <dev-notes>
      - Transaction atomicity required - Follow AC-4.11.4 exactly
      - Integration with 4.7-4.10 - Use same consumption endpoint
      - Reference: Sprint 0 Gap 6, AC Template Checklist
    </dev-notes>
  </story-content>

  <!-- ========================================== -->
  <!-- DESIGN CONTEXT -->
  <!-- ========================================== -->
  <design-context>
    <ux-design source="ux-design-production-module.md">
      <section name="Over-Consumption Alert in Production Dashboard">
        <wireframe>
          Alerts Feed (Bottom panel, 120px height):
          - Real-time alert feed shows over-consumption warnings
          - Alert card example:
            ┌────────────────────────────────────────────────────────────┐
            │ ⚠️ Over-Consumption - Beef Trimmings (+15%, +70 kg)        │
            │ WO-2025-0042 | 14:35 | View Details →                     │
            └────────────────────────────────────────────────────────────┘
          - Color: Amber background (yellow-200), amber-800 text
          - Click alert → opens WO Details Modal → Materials tab
        </wireframe>

        <interaction-pattern>
          When output registration triggers over-consumption:
          1. API returns 400 error with over-consumption details
          2. Frontend shows confirmation dialog (modal)
          3. Dialog shows:
             - Warning icon (⚠️)
             - Material name + variance details
             - "Required: 100kg, Reserved: 120kg, Consumed so far: 95kg, This output: 30kg → Total: 125kg (+25kg over)"
             - Checkbox: "I acknowledge this over-consumption"
             - Buttons: "Cancel" (gray-600) | "Accept Over-Consumption" (red-600)
          4. If accepted: Retry API call with override flag
          5. If cancelled: Close dialog, stay on output form
        </interaction-pattern>
      </section>

      <section name="WO Details Modal - Materials Tab">
        <wireframe>
          Materials Tab (in WO Details Modal):
          - Table columns: Material | Required | Reserved | Consumed | Variance | Status
          - Variance column shows:
            * Green "+5kg (+5%)" if under-consumed (consumed < required)
            * Red "-10kg (-10%)" if over-consumed (consumed > required)
            * Gray "0kg (0%)" if exact match
          - Over-consumed rows have red background (red-100)
          - Tooltip on variance: "Over-consumption: +10kg above BOM requirement"
        </wireframe>

        <color-coding>
          - Under-consumption: green-600 text
          - Exact match: gray-600 text
          - Over-consumption: red-600 text, red-100 background
        </color-coding>
      </section>

      <section name="Shared System Colors" source="ux-design-shared-system.md">
        <colors>
          PRIMARY (Create/CTA):     green-600   (#16a34a)
          DANGER (Delete/Error):    red-600     (#dc2626)
          WARNING:                  amber-500   (#f59e0b)

          STATUS BADGES:
          ├─ Warning/Over-Consumption: yellow-200 (#fef08a) bg + yellow-800 text
          └─ Error/Blocked:            red-200 (#fecaca) bg + red-800 text
        </colors>

        <typography>
          Dialog title:       Text-xl  (20px) - Card titles
          Warning message:    Text-base (16px) - Body text
          Variance values:    Text-lg  (18px) - Metric values
          Button text:        Text-sm  (14px) - Secondary text
        </typography>
      </section>
    </ux-design>
  </design-context>

  <!-- ========================================== -->
  <!-- DATABASE SCHEMA -->
  <!-- ========================================== -->
  <database-schema>
    <table name="wo_materials">
      <description>
        BOM snapshot for Work Order materials (created in Story 3.10).
        Tracks required qty vs consumed qty for variance analysis.
      </description>
      <columns>
        <column name="id" type="UUID" primary-key="true">PK</column>
        <column name="org_id" type="UUID" not-null="true">FK → organizations</column>
        <column name="wo_id" type="UUID" not-null="true">FK → work_orders</column>
        <column name="product_id" type="UUID" not-null="true">FK → products (material)</column>
        <column name="qty" type="NUMERIC" not-null="true">
          **Required quantity** (scaled from BOM based on WO output qty)
          This is the BOM-required amount for comparison
        </column>
        <column name="consumed_qty" type="NUMERIC" default="0">
          **Actual consumed quantity** (cumulative across all consumptions)
          Updated by Story 4.12 auto-consumption logic
          Variance = consumed_qty - qty
        </column>
        <column name="uom" type="VARCHAR" not-null="true">Unit of measure</column>
        <column name="scrap_percent" type="NUMERIC" default="0">Scrap allowance %</column>
        <column name="consume_whole_lp" type="BOOLEAN" default="false">
          Enforce full LP consumption (Story 4.9)
        </column>
        <column name="is_by_product" type="BOOLEAN" default="false">Output vs input material</column>
        <column name="yield_percent" type="NUMERIC" default="100">Expected yield %</column>
        <column name="status" type="VARCHAR" default="planned">
          planned | allocated | partially_consumed | consumed
        </column>
        <column name="created_at" type="TIMESTAMPTZ" not-null="true">Timestamp</column>
        <column name="updated_at" type="TIMESTAMPTZ" not-null="true">Timestamp</column>
      </columns>
      <constraints>
        <unique>(org_id, wo_id, product_id)</unique>
        <check>qty > 0</check>
        <check>consumed_qty >= 0</check>
        <check>scrap_percent >= 0 AND scrap_percent &lt;= 100</check>
        <check>yield_percent > 0 AND yield_percent &lt;= 100</check>
      </constraints>
      <indexes>
        <index>(org_id, wo_id)</index>
        <index>(product_id)</index>
      </indexes>
    </table>

    <table name="production_settings">
      <description>
        Production module configuration (Story 4.17).
        Controls behavior like over-consumption, auto-completion, etc.
      </description>
      <columns>
        <column name="id" type="UUID" primary-key="true">PK</column>
        <column name="org_id" type="UUID" not-null="true" unique="true">FK → organizations</column>
        <column name="allow_over_consumption" type="BOOLEAN" default="false">
          **KEY SETTING**: Allow consuming more than BOM-required qty
          - If false: Show blocking error dialog (operator cannot proceed)
          - If true: Show warning dialog (operator can confirm and proceed)
        </column>
        <column name="allow_pause_wo" type="BOOLEAN" default="true">Allow pausing WOs</column>
        <column name="require_operation_sequence" type="BOOLEAN" default="true">Enforce operation order</column>
        <column name="auto_complete_wo" type="BOOLEAN" default="false">Auto-complete WO when all ops done</column>
        <column name="auto_create_by_product_lp" type="BOOLEAN" default="true">Auto-create by-product LPs</column>
        <column name="dashboard_refresh_seconds" type="INTEGER" default="30">Dashboard auto-refresh interval</column>
        <column name="created_at" type="TIMESTAMPTZ" not-null="true">Timestamp</column>
        <column name="updated_at" type="TIMESTAMPTZ" not-null="true">Timestamp</column>
      </columns>
    </table>

    <table name="work_orders">
      <description>
        Work orders with output tracking.
      </description>
      <columns>
        <column name="id" type="UUID" primary-key="true">PK</column>
        <column name="org_id" type="UUID" not-null="true">FK → organizations</column>
        <column name="wo_number" type="VARCHAR" not-null="true">WO-YYYYMMDD-NNNN</column>
        <column name="product_id" type="UUID" not-null="true">FK → products (output product)</column>
        <column name="quantity" type="NUMERIC" not-null="true">Planned output quantity</column>
        <column name="output_qty" type="NUMERIC" default="0">
          **Cumulative output quantity** (sum of all outputs registered)
          Updated by Story 4.12 output registration
          Progress = output_qty / quantity × 100%
        </column>
        <column name="status" type="VARCHAR" default="draft">
          draft | in_progress | paused | completed | cancelled
        </column>
        <column name="line_id" type="UUID">FK → production_lines</column>
        <column name="scheduled_start" type="TIMESTAMPTZ">Planned start time</column>
        <column name="scheduled_end" type="TIMESTAMPTZ">Planned end time</column>
        <column name="actual_start" type="TIMESTAMPTZ">Actual start time (Story 4.2)</column>
        <column name="actual_end" type="TIMESTAMPTZ">Actual end time (Story 4.6)</column>
        <column name="created_at" type="TIMESTAMPTZ" not-null="true">Timestamp</column>
        <column name="updated_at" type="TIMESTAMPTZ" not-null="true">Timestamp</column>
      </columns>
    </table>

    <table name="license_plates">
      <description>
        Inventory units with quantity tracking.
      </description>
      <columns>
        <column name="id" type="UUID" primary-key="true">PK</column>
        <column name="org_id" type="UUID" not-null="true">FK → organizations</column>
        <column name="lp_number" type="VARCHAR" not-null="true">Unique barcode</column>
        <column name="product_id" type="UUID" not-null="true">FK → products</column>
        <column name="quantity" type="NUMERIC" not-null="true">Current quantity</column>
        <column name="uom" type="VARCHAR" not-null="true">Unit of measure</column>
        <column name="status" type="VARCHAR" default="available">
          available | reserved | consumed | quarantine
        </column>
        <column name="qa_status" type="VARCHAR">released | hold | rejected</column>
        <column name="batch_number" type="VARCHAR">Batch/Lot number</column>
        <column name="expiry_date" type="DATE">Expiry date</column>
      </columns>
    </table>

    <validation-logic>
      <query name="Check over-consumption for all materials">
        <sql>
          SELECT
            wm.id,
            wm.product_id,
            p.name AS product_name,
            wm.qty AS required_qty,
            wm.consumed_qty AS current_consumed_qty,
            wm.uom,
            (wm.consumed_qty - wm.qty) AS current_variance,
            -- Calculate total if this output is registered (cumulative consumption)
            (SELECT COALESCE(SUM(r.reserved_qty), 0)
             FROM wo_material_reservations r
             WHERE r.material_id = wm.id AND r.status = 'reserved') AS total_reserved_qty
          FROM wo_materials wm
          JOIN products p ON p.id = wm.product_id
          WHERE wm.wo_id = :wo_id
            AND wm.org_id = :org_id
            AND wm.is_by_product = false
        </sql>
        <purpose>
          Get all materials for WO with required vs consumed comparison.
          Used to detect over-consumption BEFORE committing output registration.
        </purpose>
      </query>

      <validation-rule name="Over-consumption check">
        <pseudo-code>
          FOR EACH material IN wo_materials:
            projected_consumed = material.consumed_qty + qty_from_this_output
            variance = projected_consumed - material.required_qty

            IF variance > 0:  // Over-consumption detected
              IF allow_over_consumption = false:
                RETURN 400 Error: "Cannot consume: Over-consumption not allowed. Required: {required_qty}, Consumed: {consumed_qty}, Requested: {qty}, Max allowed: {required_qty - consumed_qty}"
              ELSE:
                RETURN 400 Warning: "Over-consumption detected for Material {name}. Confirm to proceed?"
                // Frontend shows dialog, operator confirms/cancels
              END IF
            END IF
          END FOR
        </pseudo-code>
      </validation-rule>
    </validation-logic>
  </database-schema>

  <!-- ========================================== -->
  <!-- API PATTERNS -->
  <!-- ========================================== -->
  <api-patterns>
    <endpoint method="POST" path="/api/production/work-orders/:id/outputs">
      <description>
        Register production output (Story 4.12) with over-consumption validation.
        This is the MAIN endpoint where over-consumption check happens (AC-4.11.4).
      </description>

      <request-body>
        {
          "qty": 50.5,                    // Output quantity (required, > 0)
          "qa_status": "released",        // QA status (optional, if required in settings)
          "location_id": "uuid",          // Warehouse location (optional)
          "notes": "string (optional)",   // Notes
          "override_over_consumption": false  // If true, skip over-consumption block (only if operator confirmed)
        }
      </request-body>

      <validation-steps>
        1. Auth check: Verify user authenticated + has Production role
        2. Org isolation: Verify wo_id belongs to user's org_id
        3. WO status: Verify WO is 'in_progress' (not draft/completed)
        4. Input validation: Verify qty > 0
        5. Fetch production_settings: Get allow_over_consumption flag
        6. **Over-consumption check** (THIS STORY):
           a. Query wo_materials for all input materials
           b. Calculate projected consumed_qty for each material after this output
           c. FOR EACH material:
              - projected_consumed = current_consumed_qty + qty_to_consume_from_this_output
              - variance = projected_consumed - required_qty
              - IF variance > 0 AND allow_over_consumption = false AND !override_over_consumption:
                  RETURN 400 Error: "Over-consumption not allowed..."
              - IF variance > 0 AND allow_over_consumption = true AND !override_over_consumption:
                  RETURN 400 Warning: "Over-consumption detected. Confirm to proceed?"
                  // Frontend shows dialog with "Accept" button
                  // On accept, retry with override_over_consumption=true
           d. IF override_over_consumption = true:
              - Skip validation, proceed to auto-consumption
        7. AUTO-CONSUME: Execute sequential LP allocation (Story 4.12 AC-4.12.3)
        8. CREATE output LP: Generate LP with batch_number, expiry_date, etc.
        9. CREATE genealogy links: Update lp_genealogy records (Story 4.19)
        10. UPDATE work_orders.output_qty: Add registered qty
        11. UPDATE wo_materials.consumed_qty: Add consumed amounts per material
        12. COMMIT transaction (all-or-nothing)
      </validation-steps>

      <response-success status="201">
        {
          "id": "uuid",
          "wo_id": "uuid",
          "lp_id": "uuid",
          "lp_number": "LP-20251127-0001",
          "quantity": 50,
          "qa_status": "released",
          "consumed_materials": [
            {
              "material_id": "uuid",
              "product_name": "Flour",
              "consumed_qty": 50,
              "variance": 5,
              "variance_pct": 10.0,
              "over_consumption": true
            }
          ],
          "created_at": "2025-11-27T14:30:00Z"
        }
      </response-success>

      <response-error status="400" code="OVER_CONSUMPTION_NOT_ALLOWED">
        {
          "error": "OVER_CONSUMPTION_NOT_ALLOWED",
          "message": "Cannot consume: Over-consumption not allowed. Required: 100kg, Consumed: 95kg, Requested: 10kg. Max allowed: 5kg more.",
          "details": {
            "material_id": "uuid",
            "material_name": "Flour",
            "required_qty": 100,
            "consumed_qty": 95,
            "requested_qty": 10,
            "projected_consumed_qty": 105,
            "variance": 5,
            "allow_over_consumption": false
          }
        }
      </response-error>

      <response-error status="400" code="OVER_CONSUMPTION_WARNING">
        {
          "error": "OVER_CONSUMPTION_WARNING",
          "message": "Over-consumption detected for Material 'Flour'. Confirm to proceed?",
          "details": {
            "material_id": "uuid",
            "material_name": "Flour",
            "required_qty": 100,
            "consumed_qty": 95,
            "requested_qty": 10,
            "projected_consumed_qty": 105,
            "variance": 5,
            "allow_over_consumption": true,
            "requires_confirmation": true
          }
        }
      </response-error>

      <response-error status="400">
        {
          "error": "WO_NOT_IN_PROGRESS",
          "message": "WO not in progress",
          "details": {
            "wo_id": "uuid",
            "wo_status": "draft"
          }
        }
      </response-error>
    </endpoint>

    <service-layer source="lib/services/output-service.ts">
      <class name="OutputService">
        <method name="registerOutput" async="true">
          <parameters>
            woId: string
            qty: number
            qaStatus?: string
            locationId?: string
            notes?: string
            orgId: string
            overrideOverConsumption: boolean = false
          </parameters>
          <returns>Promise&lt;Output&gt;</returns>
          <steps>
            1. Fetch WO + verify status = 'in_progress'
            2. Fetch production_settings (allow_over_consumption)
            3. **Over-consumption validation** (THIS STORY):
               a. Query wo_materials for input materials
               b. Calculate projected consumed_qty for each
               c. FOR EACH material:
                  - IF projected_consumed > required AND !allow_over_consumption AND !override:
                      throw new OverConsumptionNotAllowedError(...)
                  - IF projected_consumed > required AND allow_over_consumption AND !override:
                      throw new OverConsumptionWarningError(...) // Frontend shows dialog
               d. IF override = true: skip check, proceed
            4. Begin transaction:
               a. Auto-consume reserved LPs (sequential allocation)
               b. Create output LP (batch_number, expiry_date, etc.)
               c. Update lp_genealogy records (set child_lp_id)
               d. Update work_orders.output_qty
               e. Update wo_materials.consumed_qty
            5. Commit transaction
            6. Return output details + consumed_materials summary
          </steps>
        </method>

        <method name="checkOverConsumption" private="true">
          <parameters>
            woId: string
            outputQty: number
            orgId: string
          </parameters>
          <returns>{ isOverConsumed: boolean, materials: Material[] }</returns>
          <steps>
            1. Fetch wo_materials for WO
            2. Calculate consumption per material based on BOM ratios
            3. FOR EACH material:
               - projected_consumed = consumed_qty + (outputQty * material.qty / wo.quantity)
               - variance = projected_consumed - material.qty
               - IF variance > 0: mark as over-consumed
            4. Return over-consumed materials list
          </steps>
        </method>
      </class>

      <error-classes>
        class OverConsumptionNotAllowedError extends Error {
          code: 'OVER_CONSUMPTION_NOT_ALLOWED'
          httpStatus: 400
          details: {
            material_id: string
            material_name: string
            required_qty: number
            consumed_qty: number
            requested_qty: number
            projected_consumed_qty: number
            variance: number
            allow_over_consumption: false
          }
        }

        class OverConsumptionWarningError extends Error {
          code: 'OVER_CONSUMPTION_WARNING'
          httpStatus: 400
          details: {
            material_id: string
            material_name: string
            required_qty: number
            consumed_qty: number
            requested_qty: number
            projected_consumed_qty: number
            variance: number
            allow_over_consumption: true
            requires_confirmation: true
          }
        }
      </error-classes>
    </service-layer>

    <existing-api-pattern source="apps/frontend/app/api/planning/work-orders/[id]/route.ts">
      <template>
        // apps/frontend/app/api/production/work-orders/[id]/outputs/route.ts

        import { createClient } from '@/lib/supabase/server'
        import { NextResponse } from 'next/server'
        import { OutputService } from '@/lib/services/output-service'

        export async function POST(
          request: Request,
          { params }: { params: { id: string } }
        ) {
          try {
            const supabase = await createClient()

            // 1. Auth check
            const { data: { user }, error: authError } = await supabase.auth.getUser()
            if (authError || !user) {
              return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
            }

            // 2. Get org_id
            const { data: userData } = await supabase
              .from('users')
              .select('org_id')
              .eq('id', user.id)
              .single()

            const orgId = userData?.org_id
            if (!orgId) {
              return NextResponse.json({ error: 'Organization not found' }, { status: 403 })
            }

            // 3. Parse request body
            const body = await request.json()
            const { qty, qa_status, location_id, notes, override_over_consumption } = body

            // 4. Validate input
            if (!qty || qty <= 0) {
              return NextResponse.json(
                { error: 'Output quantity must be > 0' },
                { status: 400 }
              )
            }

            // 5. Call service layer (over-consumption validation happens here)
            const service = new OutputService(supabase)
            const output = await service.registerOutput(
              params.id, // wo_id
              qty,
              qa_status,
              location_id,
              notes,
              orgId,
              override_over_consumption || false
            )

            return NextResponse.json(output, { status: 201 })

          } catch (error: any) {
            // Over-consumption errors
            if (error.code === 'OVER_CONSUMPTION_NOT_ALLOWED') {
              return NextResponse.json(
                { error: error.code, message: error.message, details: error.details },
                { status: 400 }
              )
            }
            if (error.code === 'OVER_CONSUMPTION_WARNING') {
              return NextResponse.json(
                { error: error.code, message: error.message, details: error.details },
                { status: 400 }
              )
            }

            // Other errors
            if (error.code === 'WO_NOT_IN_PROGRESS') {
              return NextResponse.json(
                { error: error.code, message: error.message },
                { status: 400 }
              )
            }

            return NextResponse.json(
              { error: 'Internal server error', message: error.message },
              { status: 500 }
            )
          }
        }
      </template>
    </existing-api-pattern>
  </api-patterns>

  <!-- ========================================== -->
  <!-- UI COMPONENTS -->
  <!-- ========================================== -->
  <ui-components>
    <component name="OutputRegistrationModal" location="apps/frontend/components/production/OutputRegistrationModal.tsx">
      <description>
        Modal for registering production output (Story 4.12).
        This story adds over-consumption error handling.
      </description>

      <props>
        {
          woId: string
          wo: {
            id: string
            wo_number: string
            product_name: string
            quantity: number
            output_qty: number
            status: string
          }
          onOutputRegistered: (output: Output) => void
          onClose: () => void
        }
      </props>

      <state>
        {
          qty: number | null
          qaStatus: string
          locationId: string
          notes: string
          loading: boolean
          error: string | null
          overConsumptionWarning: {
            materials: Material[]
            requiresConfirmation: boolean
          } | null
        }
      </state>

      <rendering-logic>
        // Over-consumption warning dialog (shows when API returns OVER_CONSUMPTION_WARNING)

        {overConsumptionWarning &amp;&amp; (
          &lt;div className="bg-yellow-100 border border-yellow-400 p-4 rounded-lg mb-4"&gt;
            &lt;div className="flex items-center gap-2 mb-2"&gt;
              &lt;AlertTriangle className="text-yellow-800" size={24} /&gt;
              &lt;h4 className="text-lg font-semibold text-yellow-800"&gt;
                ⚠️ Over-Consumption Detected
              &lt;/h4&gt;
            &lt;/div&gt;

            &lt;div className="space-y-2"&gt;
              {overConsumptionWarning.materials.map((material) => (
                &lt;div key={material.id} className="text-sm text-yellow-900"&gt;
                  &lt;p className="font-medium"&gt;Material: {material.name}&lt;/p&gt;
                  &lt;p&gt;Required: {material.required_qty} {material.uom}&lt;/p&gt;
                  &lt;p&gt;Consumed: {material.consumed_qty} {material.uom}&lt;/p&gt;
                  &lt;p&gt;This output: +{material.requested_qty} {material.uom}&lt;/p&gt;
                  &lt;p className="font-bold text-red-600"&gt;
                    Total: {material.projected_consumed_qty} {material.uom}
                    (+{material.variance} {material.uom} over)
                  &lt;/p&gt;
                &lt;/div&gt;
              ))}
            &lt;/div&gt;

            &lt;div className="mt-4 flex gap-3"&gt;
              &lt;button
                onClick={handleCancelOverConsumption}
                className="bg-gray-600 text-white px-4 py-2 rounded"
              &gt;
                Cancel
              &lt;/button&gt;
              &lt;button
                onClick={handleAcceptOverConsumption}
                className="bg-red-600 text-white px-4 py-2 rounded font-semibold"
              &gt;
                Accept Over-Consumption
              &lt;/button&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        )}

        // Error display (shows when API returns OVER_CONSUMPTION_NOT_ALLOWED)
        {error &amp;&amp; (
          &lt;div className="bg-red-100 border border-red-400 text-red-800 px-4 py-3 rounded mb-4"&gt;
            &lt;p className="font-semibold"&gt;⚠️ Error&lt;/p&gt;
            &lt;p className="text-sm mt-1"&gt;{error}&lt;/p&gt;
          &lt;/div&gt;
        )}
      </rendering-logic>

      <api-call>
        async function handleSubmit() {
          setLoading(true)
          setError(null)
          setOverConsumptionWarning(null)

          try {
            const response = await fetch(`/api/production/work-orders/${woId}/outputs`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                qty,
                qa_status: qaStatus,
                location_id: locationId,
                notes,
                override_over_consumption: false  // First attempt, no override
              })
            })

            if (!response.ok) {
              const error = await response.json()

              // Handle over-consumption warning (allow_over_consumption=true)
              if (error.error === 'OVER_CONSUMPTION_WARNING') {
                setOverConsumptionWarning({
                  materials: [error.details],
                  requiresConfirmation: true
                })
                return
              }

              // Handle over-consumption blocked (allow_over_consumption=false)
              if (error.error === 'OVER_CONSUMPTION_NOT_ALLOWED') {
                setError(error.message)
                return
              }

              throw new Error(error.message)
            }

            const output = await response.json()
            onOutputRegistered(output)
            onClose()
          } catch (err) {
            setError(err.message)
          } finally {
            setLoading(false)
          }
        }

        async function handleAcceptOverConsumption() {
          // Retry with override flag
          setLoading(true)
          setOverConsumptionWarning(null)

          try {
            const response = await fetch(`/api/production/work-orders/${woId}/outputs`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                qty,
                qa_status: qaStatus,
                location_id: locationId,
                notes,
                override_over_consumption: true  // Override over-consumption check
              })
            })

            if (!response.ok) {
              const error = await response.json()
              throw new Error(error.message)
            }

            const output = await response.json()
            onOutputRegistered(output)
            onClose()
          } catch (err) {
            setError(err.message)
          } finally {
            setLoading(false)
          }
        }

        function handleCancelOverConsumption() {
          setOverConsumptionWarning(null)
        }
      </api-call>
    </component>

    <component name="MaterialsVarianceTable" location="apps/frontend/components/production/MaterialsVarianceTable.tsx">
      <description>
        Table showing material consumption variance in WO Details Modal (Materials tab).
        Highlights over-consumption in red.
      </description>

      <props>
        {
          materials: {
            id: string
            product_name: string
            required_qty: number
            consumed_qty: number
            uom: string
            variance: number
            variance_pct: number
          }[]
        }
      </props>

      <rendering-logic>
        &lt;table className="w-full"&gt;
          &lt;thead&gt;
            &lt;tr className="border-b border-gray-200"&gt;
              &lt;th className="text-left py-2"&gt;Material&lt;/th&gt;
              &lt;th className="text-right"&gt;Required&lt;/th&gt;
              &lt;th className="text-right"&gt;Consumed&lt;/th&gt;
              &lt;th className="text-right"&gt;Variance&lt;/th&gt;
              &lt;th className="text-center"&gt;Status&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            {materials.map((material) => {
              const isOverConsumed = material.variance > 0
              const rowClass = isOverConsumed
                ? 'bg-red-100 border-l-4 border-red-600'
                : ''

              return (
                &lt;tr key={material.id} className={`border-b ${rowClass}`}&gt;
                  &lt;td className="py-2"&gt;{material.product_name}&lt;/td&gt;
                  &lt;td className="text-right"&gt;{material.required_qty} {material.uom}&lt;/td&gt;
                  &lt;td className="text-right"&gt;{material.consumed_qty} {material.uom}&lt;/td&gt;
                  &lt;td className={`text-right font-semibold ${
                    material.variance > 0 ? 'text-red-600' :
                    material.variance &lt; 0 ? 'text-green-600' :
                    'text-gray-600'
                  }`}&gt;
                    {material.variance > 0 ? '+' : ''}{material.variance} {material.uom}
                    ({material.variance_pct > 0 ? '+' : ''}{material.variance_pct.toFixed(1)}%)
                  &lt;/td&gt;
                  &lt;td className="text-center"&gt;
                    {isOverConsumed ? (
                      &lt;span className="inline-block px-2 py-1 bg-yellow-200 text-yellow-800 text-xs rounded"&gt;
                        Over-Consumed
                      &lt;/span&gt;
                    ) : material.variance === 0 ? (
                      &lt;span className="inline-block px-2 py-1 bg-green-200 text-green-800 text-xs rounded"&gt;
                        Exact
                      &lt;/span&gt;
                    ) : (
                      &lt;span className="inline-block px-2 py-1 bg-gray-200 text-gray-800 text-xs rounded"&gt;
                        Under-Consumed
                      &lt;/span&gt;
                    )}
                  &lt;/td&gt;
                &lt;/tr&gt;
              )
            })}
          &lt;/tbody&gt;
        &lt;/table&gt;
      </rendering-logic>
    </component>
  </ui-components>

  <!-- ========================================== -->
  <!-- TESTING STRATEGY -->
  <!-- ========================================== -->
  <testing-strategy>
    <unit-tests>
      <test file="lib/services/output-service.test.ts">
        <test-case name="Should block over-consumption when allow_over_consumption=false">
          const settings = { allow_over_consumption: false }
          const material = { required_qty: 100, consumed_qty: 95, uom: 'kg' }
          const outputQty = 10 // Would consume 105kg total

          expect(service.registerOutput(..., outputQty, override=false))
            .rejects.toThrow('Over-consumption not allowed')
        </test-case>

        <test-case name="Should warn over-consumption when allow_over_consumption=true">
          const settings = { allow_over_consumption: true }
          const material = { required_qty: 100, consumed_qty: 95, uom: 'kg' }
          const outputQty = 10

          expect(service.registerOutput(..., outputQty, override=false))
            .rejects.toThrow('Over-consumption detected. Confirm to proceed?')
        </test-case>

        <test-case name="Should allow over-consumption when override=true">
          const settings = { allow_over_consumption: true }
          const material = { required_qty: 100, consumed_qty: 95, uom: 'kg' }
          const outputQty = 10

          expect(service.registerOutput(..., outputQty, override=true))
            .resolves.toMatchObject({ qty: 10, consumed_materials: [{ variance: 5 }] })
        </test-case>

        <test-case name="Should track variance in wo_materials">
          const material = { required_qty: 100, consumed_qty: 95 }
          const outputQty = 10

          await service.registerOutput(..., outputQty, override=true)

          const updated = await fetchMaterial(material.id)
          expect(updated.consumed_qty).toBe(105)
          expect(updated.consumed_qty - updated.qty).toBe(5) // variance
        </test-case>
      </test>
    </unit-tests>

    <integration-tests>
      <test file="app/api/production/work-orders/[id]/outputs/route.test.ts">
        <test-case name="POST /outputs - 400 when over-consumption blocked">
          const response = await POST('/api/production/work-orders/WO-001/outputs', {
            qty: 10,  // Would trigger over-consumption
            override_over_consumption: false
          })

          expect(response.status).toBe(400)
          expect(response.body.error).toBe('OVER_CONSUMPTION_NOT_ALLOWED')
          expect(response.body.message).toContain('Over-consumption not allowed')
        </test-case>

        <test-case name="POST /outputs - 400 warning when allow_over_consumption=true">
          const response = await POST('/api/production/work-orders/WO-002/outputs', {
            qty: 10,
            override_over_consumption: false
          })

          expect(response.status).toBe(400)
          expect(response.body.error).toBe('OVER_CONSUMPTION_WARNING')
          expect(response.body.details.requires_confirmation).toBe(true)
        </test-case>

        <test-case name="POST /outputs - 201 when override=true">
          const response = await POST('/api/production/work-orders/WO-002/outputs', {
            qty: 10,
            override_over_consumption: true
          })

          expect(response.status).toBe(201)
          expect(response.body.consumed_materials[0].variance).toBeGreaterThan(0)
        </test-case>

        <test-case name="POST /outputs - Atomic transaction rollback">
          // Setup: Material with over-consumption blocked
          const response = await POST('/api/production/work-orders/WO-003/outputs', {
            qty: 10,
            override_over_consumption: false
          })

          expect(response.status).toBe(400)

          // Verify: No output LP created, no consumption records, no genealogy links
          const outputs = await fetchOutputs('WO-003')
          expect(outputs.length).toBe(0)

          const consumptions = await fetchConsumptions('WO-003')
          expect(consumptions.length).toBe(0)

          const genealogy = await fetchGenealogy('WO-003')
          expect(genealogy.filter(g => g.child_lp_id !== null).length).toBe(0)
        </test-case>
      </test>
    </integration-tests>

    <e2e-tests>
      <test file="tests/e2e/production-over-consumption.spec.ts">
        <test-case name="Should show over-consumption error dialog when blocked">
          await page.goto('/production/work-orders/WO-001')
          await page.click('button:has-text("Register Output")')
          await page.fill('input[name="qty"]', '10')
          await page.click('button:has-text("Confirm")')

          // Error dialog appears
          await expect(page.locator('text=Over-consumption not allowed')).toBeVisible()
          await expect(page.locator('button:has-text("Cancel")')).toBeVisible()

          // No "Accept" button when blocked
          await expect(page.locator('button:has-text("Accept Over-Consumption")')).not.toBeVisible()
        </test-case>

        <test-case name="Should show over-consumption warning dialog when allowed">
          await page.goto('/production/work-orders/WO-002')
          await page.click('button:has-text("Register Output")')
          await page.fill('input[name="qty"]', '10')
          await page.click('button:has-text("Confirm")')

          // Warning dialog appears
          await expect(page.locator('text=Over-Consumption Detected')).toBeVisible()
          await expect(page.locator('button:has-text("Cancel")')).toBeVisible()
          await expect(page.locator('button:has-text("Accept Over-Consumption")')).toBeVisible()
        </test-case>

        <test-case name="Should allow output registration when operator confirms">
          await page.goto('/production/work-orders/WO-002')
          await page.click('button:has-text("Register Output")')
          await page.fill('input[name="qty"]', '10')
          await page.click('button:has-text("Confirm")')

          // Warning appears
          await expect(page.locator('text=Over-Consumption Detected')).toBeVisible()

          // Accept over-consumption
          await page.click('button:has-text("Accept Over-Consumption")')

          // Success message
          await expect(page.locator('text=Output registered successfully')).toBeVisible()

          // Modal closes
          await expect(page.locator('text=Register Output')).not.toBeVisible()
        </test-case>

        <test-case name="Should show variance in Materials tab">
          await page.goto('/production/work-orders/WO-002')
          await page.click('button:has-text("View Details")')
          await page.click('button:has-text("Materials")')

          // Over-consumed material has red background
          const overConsumedRow = page.locator('tr:has(text="Flour")')
          await expect(overConsumedRow).toHaveClass(/bg-red-100/)

          // Variance shown in red
          await expect(overConsumedRow.locator('text=+5 kg (+10.0%)')).toHaveCSS('color', 'rgb(220, 38, 38)') // red-600
        </test-case>
      </test>
    </e2e-tests>
  </testing-strategy>

  <!-- ========================================== -->
  <!-- DEPENDENCIES & INTEGRATION -->
  <!-- ========================================== -->
  <dependencies>
    <prerequisite story="03-10" title="Work Order CRUD">
      wo_materials table with qty (required) and consumed_qty columns.
    </prerequisite>

    <prerequisite story="04-7" title="Material Reservation (Desktop)">
      wo_material_reservations table with reserved_qty for consumption.
    </prerequisite>

    <prerequisite story="04-12" title="Output Registration (Desktop)">
      This story EXTENDS 4.12 by adding over-consumption validation.
      Output registration endpoint (POST /outputs) is the main integration point.
    </prerequisite>

    <prerequisite story="04-17" title="Production Settings">
      production_settings table with allow_over_consumption flag.
    </prerequisite>

    <integration story="04-19" title="Genealogy Tree Creation">
      Genealogy links created during output registration.
      Over-consumption affects genealogy allocation.
    </integration>

    <integration story="04-9" title="1:1 Consumption Enforcement">
      consume_whole_lp flag also checked during over-consumption validation.
    </integration>
  </dependencies>

  <!-- ========================================== -->
  <!-- IMPLEMENTATION NOTES -->
  <!-- ========================================== -->
  <implementation-notes>
    <note priority="high">
      **Transaction Atomicity (AC-4.11.4):**
      Output registration must be atomic - over-consumption check happens BEFORE committing.
      If over-consumption blocked/cancelled, NO output LP, NO consumption, NO genealogy.
      Use Supabase transactions (.from().insert().then().commit() pattern).
    </note>

    <note priority="high">
      **Two-Step Validation:**
      1. First API call: Check over-consumption, return 400 warning/error
      2. If operator confirms: Second API call with override_over_consumption=true
      This pattern allows operator choice without complex state management.
    </note>

    <note priority="medium">
      **Variance Calculation:**
      Variance = consumed_qty - required_qty (positive = over-consumption)
      Variance % = (variance / required_qty) × 100%
      Track both absolute and percentage for reporting.
    </note>

    <note priority="medium">
      **Error Message Consistency:**
      Use exact message: "Cannot consume: Over-consumption not allowed. Required: 100kg, Consumed: 95kg, Requested: 10kg. Max allowed: 5kg more."
      This message helps operator understand the situation.
    </note>

    <note priority="low">
      **Production Settings Default:**
      Default allow_over_consumption = false (strict mode).
      Operators must explicitly enable in Settings → Production.
    </note>

    <note priority="low">
      **Future Enhancement:**
      Add over-consumption tolerance (e.g., allow +5% variance without warning).
      This would require production_settings.over_consumption_tolerance_pct column.
    </note>
  </implementation-notes>
</story-context>
