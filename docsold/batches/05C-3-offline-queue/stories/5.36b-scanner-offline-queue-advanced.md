# Story 5.36b: Scanner Offline Queue - Advanced Features

**ID:** 5.36b
**Batch:** 5C-3 (Offline Queue)
**Story Points:** 8
**Effort:** 8-10 hours
**Status:** Todo
**Sprint:** 0 (Gap 5)
**Predecessor:** Story 5.36a (Core)

---

## User Story

> As a **Warehouse Manager**, I want advanced offline queue features (failure handling, manual sync, multi-user isolation) so that complex offline scenarios are handled robustly.

---

## Acceptance Criteria

### AC 1: Partial Sync with Failure Handling

**Given** Scanner PWA with 100 queued operations
**And** Network reconnects but some operations fail validation (e.g., LP no longer exists)

**When** sync executes
**Then** verify failure handling:
- ‚úÖ Operations 1-70: Sync successfully
- ‚ùå Operation 71: Fails (LP-001 no longer exists) ‚Üí Marked as failed, moved to failed queue
- ‚úÖ Operations 72-100: Continue syncing (don't block entire queue)
- ‚úÖ UI shows: **"‚ö†Ô∏è 70/100 synced. 1 failed. 29 remaining."**
- ‚úÖ Failed operations shown in "Failed Queue" section (separate UI)
- ‚úÖ User can review failed operations and retry manually or discard

**Failed Queue UI:**
- Shows: Operation type, timestamp, error message, payload
- Actions: "Retry" or "Discard"
- Example: **"‚ùå LP Move failed: LP-001 no longer exists. (2025-01-20 14:32)"**

**Technical Notes:**
- Failed operations stored in separate IndexedDB key: `scanner_failed_queue`
- Max failed queue size: 50 operations (auto-purge oldest after 7 days)
- Dependency resolution: If operation B depends on A, and A fails, B blocked (user notified)

---

### AC 2: Manual Sync Trigger

**Given** Scanner PWA with queued operations
**And** Network connection available

**When** Operator clicks "Sync Now" button
**Then** verify manual sync:
- ‚úÖ Sync starts immediately (even if <80 operations)
- ‚úÖ UI shows progress indicator
- ‚úÖ Sync completes with success/failure summary
- ‚úÖ Button disabled during sync (prevent double-click)
- ‚úÖ Button re-enabled after sync complete

**Button Placement:**
- Top-right corner next to network status badge
- Only visible when offline queue has >0 operations

**Technical Notes:**
- Same sync logic as AC 3 in 5.36a (automatic sync)
- Button: "Sync Now (23)" showing queue count

---

### AC 3: Offline Operation Dependency Resolution

**Given** Scanner PWA with multiple queued operations with dependencies
**Example**: Split operation ‚Üí Move operation ‚Üí another Split

**When** sync executes
**Then** verify dependency order:
- ‚úÖ Operations synced in dependency order (DAG topological sort)
- ‚úÖ Parent operations sync BEFORE child operations
- ‚úÖ If parent fails: Child operations blocked and marked as failed
- ‚úÖ User notified: **"‚ö†Ô∏è Operation X depends on failed operation Y. Cannot proceed."**

**Dependency Chain Example:**
```
1. Create LP-001 (Receive)
2. Split LP-001 ‚Üí LP-002 + LP-003 (depends on #1)
3. Move LP-002 to WH-B (depends on #2)
4. Move LP-003 to WH-C (depends on #2)

Sync order: 1 ‚Üí 2 ‚Üí 3,4 (in parallel)
```

**Technical Notes:**
- Dependency graph built from operation payloads
- Topological sort ensures correct order
- If circular dependency detected: Log error, mark all as failed

---

### AC 4: Multi-User Queue Isolation

**Given** 2 operators using same scanner device with different user accounts
**And** User A has 20 queued operations, User B has 15 queued operations

**When** each user logs in
**Then** verify queue isolation:
- ‚úÖ User A sees: **"üì¶ Queue: 20"** (only their operations)
- ‚úÖ User B sees: **"üì¶ Queue: 15"** (only their operations)
- ‚úÖ Queues stored separately: `scanner_offline_queue_{org_id}_UserA`, `scanner_offline_queue_{org_id}_UserB`
- ‚úÖ On sync: Only current user's queue synced (not other users)
- ‚úÖ No cross-user visibility (data isolation for compliance)

**Technical Notes:**
- Queue keys include user_id for isolation
- On logout: Queue persists (not cleared, ready for re-login)
- Failed queues also isolated per user
- RLS policies enforce isolation (users can only see own queues)

---

### AC 5: Conflict Resolution - Concurrent Updates

**Given** Operator A and B both modify same LP offline
**Example**: Both try to split LP-001 simultaneously

**When** sync executes
**Then** verify conflict handling:
- ‚úÖ Operations synced in received order (timestamp based)
- ‚úÖ First operation succeeds (creates LP-002)
- ‚úÖ Second operation fails (LP-001 already split)
- ‚ùå Error message: **"LP-001 was already split by another user. Please refresh and retry."**
- ‚úÖ Failed operation moved to failed queue for manual review

**Conflict Detection:**
- Server compares: operation.parent_lp_id with current state
- If parent no longer in expected state: Conflict detected
- User must manually review and decide: retry or discard

**Technical Notes:**
- Optimistic locking at server (version numbers on LPs)
- On conflict: Return detailed error with actual state
- User can view conflicting operation details and make decision

---

### AC 6: Queue Performance & Optimization

**Given** Scanner PWA with 500+ queued operations over time
**And** IndexedDB growing large

**When** monitoring queue performance
**Then** verify optimization:
- ‚úÖ Queue operations don't slow down scanner UI (background sync)
- ‚úÖ IndexedDB compaction: Auto-purge failed operations after 7 days
- ‚úÖ Old synced operations: Archive after 30 days (remove from IndexedDB)
- ‚úÖ Memory usage: Monitor via DevTools, target < 50MB for full queue
- ‚úÖ UI responsive even with 500+ operations queued

**Optimization Techniques:**
- Lazy-load queue items (paginate in UI, not all at once)
- Use Web Workers for sync processing (don't block UI thread)
- Batch updates to UI (debounce queue count updates)

**Technical Notes:**
- Background sync via Service Worker
- Web Worker handles: JSON serialization, crypto ops, sync batching
- UI updates via postMessage (no blocking)

---

## Technical Tasks

### Conflict Resolution Engine

- [ ] Create ConflictResolver class
  - Detect conflicts: parent state changed
  - Handle: Report to user, move to failed queue
  - Implement: Automatic retry logic (optional)

### Dependency Resolution

- [ ] Create DependencyGraph class
  - Build dependency graph from operations
  - Topological sort for execution order
  - Detect circular dependencies

### Multi-User Isolation

- [ ] Update IndexedDB keys to include user_id
- [ ] Create RLS policies for queue tables
- [ ] Verify isolation in tests

### Performance Monitoring

- [ ] Add performance metrics to sync
  - Sync time, operations/sec, error rate
  - IndexedDB size, memory usage
- [ ] Dashboard: Show sync performance metrics
- [ ] Alerts: Warn if sync takes >2 minutes

---

## Testing

### Unit Tests
- Conflict detection: parent state changed
- Dependency graph: topological sort correct
- Multi-user isolation: separate queues respected
- Compression: old operations pruned

### Integration Tests
- Sync with failures in middle of queue (AC1)
- Multi-user simultaneous sync (AC4)
- Dependency resolution (AC3)
- Conflict detection (AC5)

### E2E Tests
- Full scenario: 100 ops, some fail, user retries, manual sync
- Multi-user: User A & B sync simultaneously
- Conflict: Both users modify same LP offline, sync triggers conflict

---

## Acceptance Criteria Checklist

- ‚úÖ Partial sync with failure handling (failed queue separate)
- ‚úÖ Manual sync trigger button
- ‚úÖ Offline operation dependency resolution (DAG)
- ‚úÖ Multi-user queue isolation
- ‚úÖ Conflict detection & user-friendly errors
- ‚úÖ Performance optimization (background sync, Web Workers)
- ‚úÖ Comprehensive error reporting in failed queue

---

## Dependencies

**Requires:** Story 5.36a (Offline Queue Core)

**Enables:** None directly (advanced features)

---

## Notes

- Dependency resolution ensures data consistency
- Conflict resolution preserves user intent
- Multi-user isolation critical for shared devices
- Performance optimization needed for long-running queues
- Failed queue acts as audit trail for sync errors
