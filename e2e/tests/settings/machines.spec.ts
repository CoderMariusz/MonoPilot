/**
 * Machines - CRUD Tests
 *
 * Tests:
 * - List view loads correctly
 * - Can create new item
 * - Can edit existing item
 * - Can delete item
 * - Search/filter works
 *
 * @generated by test-generator
 */

import { test, expect } from '@playwright/test';

const ROUTE = '/settings/machines';
const BASE_URL = process.env.BASE_URL || 'http://localhost:3000';

test.describe('Machines CRUD', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto(`${BASE_URL}${ROUTE}`);
    await page.waitForLoadState('networkidle');
  });

  test.describe('List View', () => {
    test('displays data table with headers', async ({ page }) => {
      // Assert table headers are visible - use text content locators
      await expect(page.locator('th', { hasText: 'Code' })).toBeVisible();
      await expect(page.locator('th', { hasText: 'Name' })).toBeVisible();
      await expect(page.locator('th', { hasText: 'Type' })).toBeVisible();
      await expect(page.locator('th', { hasText: 'Status' })).toBeVisible();
      await expect(page.locator('th', { hasText: 'Capacity' })).toBeVisible();
      await expect(page.locator('th', { hasText: 'Location' })).toBeVisible();
    });

    test('displays Add Machine button for authorized users', async ({ page }) => {
      // Assert Add Machine button exists
      const addButton = page.getByRole('button', { name: /Add Machine/i });
      await expect(addButton).toBeVisible();
    });

    test('shows empty state when no machines', async ({ page }) => {
      // Wait for any loading to complete
      await page.waitForLoadState('networkidle');

      // Check if empty state message appears when no data
      const noMachinesText = page.getByText(/No machines found|haven't created any machines/i);
      const hasEmptyState = await noMachinesText.count() > 0;

      // Either table has rows or empty state is shown
      const tableRows = page.locator('tbody tr');
      const hasRows = await tableRows.count() > 0;

      expect(hasEmptyState || hasRows).toBeTruthy();
    });

    test('can search machines by code', async ({ page }) => {
      // Get initial row count
      const initialRows = page.locator('tbody tr');
      const initialCount = await initialRows.count();

      // Only proceed if there are machines to search
      if (initialCount === 0) {
        test.skip();
      }

      // Find search input
      const searchInput = page.getByPlaceholder('Search machines...');

      // Enter search term
      await searchInput.fill('MIX');

      // Wait for search results (300ms debounce)
      await page.waitForTimeout(400);

      // Assert that results are filtered (either rows updated or empty state shows)
      const rowsAfterSearch = page.locator('tbody tr');
      const rowsCount = await rowsAfterSearch.count();
      expect(rowsCount >= 0).toBeTruthy();
    });

    test('can filter machines by type', async ({ page }) => {
      // Get initial row count
      const initialRows = page.locator('tbody tr');
      const initialCount = await initialRows.count();

      if (initialCount === 0) {
        test.skip();
      }

      // Find type filter
      const typeFilter = page.locator('select[aria-label="Filter by type"]');

      // Select first type option
      await typeFilter.selectOption('MIXER');

      // Wait for filter to apply
      await page.waitForTimeout(300);

      // Assert results changed or empty state shows
      const filteredRows = page.locator('tbody tr');
      const filteredCount = await filteredRows.count();
      expect(filteredCount >= 0).toBeTruthy();
    });

    test('can filter machines by status', async ({ page }) => {
      // Get initial row count
      const initialRows = page.locator('tbody tr');
      const initialCount = await initialRows.count();

      if (initialCount === 0) {
        test.skip();
      }

      // Find status filter
      const statusFilter = page.locator('select[aria-label="Filter by status"]');

      // Select first status option
      await statusFilter.selectOption('ACTIVE');

      // Wait for filter to apply
      await page.waitForTimeout(300);

      // Assert results changed or empty state shows
      const filteredRows = page.locator('tbody tr');
      const filteredCount = await filteredRows.count();
      expect(filteredCount >= 0).toBeTruthy();
    });

    test('can paginate through machines list', async ({ page }) => {
      // Check if pagination controls exist
      const nextButton = page.getByRole('button', { name: 'Next' });
      const prevButton = page.getByRole('button', { name: 'Previous' });

      // At least one pagination button should exist
      const nextExists = await nextButton.isVisible().catch(() => false);
      const prevExists = await prevButton.isVisible().catch(() => false);

      expect(nextExists || prevExists).toBeTruthy();
    });
  });

  test.describe('Create', () => {
    test('opens create modal when Add Machine clicked', async ({ page }) => {
      // Click Add Machine button
      const addButton = page.getByRole('button', { name: /Add Machine/i });
      await addButton.click();

      // Assert modal/dialog is visible
      const dialog = page.getByRole('dialog');
      await expect(dialog).toBeVisible();

      // Assert dialog title
      const title = page.getByRole('heading', { name: /Create Machine/i });
      await expect(title).toBeVisible();
    });

    test('validates required fields on submit', async ({ page }) => {
      // Click Add Machine button
      const addButton = page.getByRole('button', { name: /Add Machine/i });
      await addButton.click();

      // Wait for modal to appear
      const dialog = page.getByRole('dialog');
      await expect(dialog).toBeVisible();

      // Click submit without filling fields
      const submitButton = dialog.getByRole('button', { name: /Create Machine/i });
      await submitButton.click();

      // Assert validation error appears
      const errorMessages = page.locator('[class*="text-destructive"]');
      await page.waitForTimeout(300); // Wait for validation

      const errorCount = await errorMessages.count();
      expect(errorCount > 0).toBeTruthy();
    });

    test('creates new machine successfully', async ({ page }) => {
      // Click Add Machine button
      const addButton = page.getByRole('button', { name: /Add Machine/i });
      await addButton.click();

      // Wait for modal
      const dialog = page.getByRole('dialog');
      await expect(dialog).toBeVisible();

      // Fill required fields
      const timestamp = Date.now();
      const machineCode = `MN${timestamp}`;

      // Use ID-based selectors for form inputs
      const codeInput = page.locator('#code');
      await codeInput.waitFor({ state: 'visible' });
      await codeInput.fill(machineCode);

      const nameInput = page.locator('#name');
      await nameInput.fill(`Machine ${timestamp}`);

      // Select type - use the hidden select element for easier testing
      const typeSelect = page.locator('select[aria-label="Type"]');
      await typeSelect.selectOption('MIXER');

      // Wait for code validation and form to be ready
      await page.waitForTimeout(1500);

      // Click submit button
      const submitButton = dialog.getByRole('button', { name: /Create Machine/i });

      // Use Tab to focus the submit button, then press Enter
      await submitButton.focus();
      await submitButton.press('Enter');

      // Wait a bit for submission to process
      await page.waitForTimeout(2500);

      // Check success: modal should close or success message appears
      const isDialogHidden = await dialog.isHidden().catch(() => true);
      const hasSuccessMessage = await page.getByText(/created|success/i).isVisible().catch(() => false);

      expect(isDialogHidden || hasSuccessMessage).toBeTruthy();
    });

    test('shows code validation message', async ({ page }) => {
      // Click Add Machine button
      const addButton = page.getByRole('button', { name: /Add Machine/i });
      await addButton.click();

      // Wait for modal
      const dialog = page.getByRole('dialog');
      await expect(dialog).toBeVisible();

      // Enter a code and wait for validation
      const codeInput = page.getByLabel('Code');
      await codeInput.fill('TEST-VALIDATION');

      // Wait for async validation (300ms debounce + request time)
      await page.waitForTimeout(1000);

      // Check for validation message
      const validationMessage = page.getByText(/Checking availability|available|already exists/i);
      const hasValidation = await validationMessage.isVisible().catch(() => false);

      expect(hasValidation).toBeTruthy();
    });
  });

  test.describe('Edit', () => {
    test('opens edit modal when Edit action clicked', async ({ page }) => {
      // Get row count - skip if no machines
      const rows = page.locator('tbody tr');
      const rowCount = await rows.count();

      if (rowCount === 0) {
        test.skip();
      }

      // Click actions menu on first row
      const firstRow = rows.nth(0);
      const actionButton = firstRow.getByRole('button', { name: /Actions/i });
      await actionButton.click();

      // Click Edit option
      const editOption = page.getByRole('menuitem', { name: /Edit/i });
      await editOption.click();

      // Assert modal appears with Edit title
      const dialog = page.getByRole('dialog');
      await expect(dialog).toBeVisible();

      const title = page.getByRole('heading', { name: /Edit Machine/i });
      await expect(title).toBeVisible();
    });

    test('pre-fills form with existing machine data', async ({ page }) => {
      // Get row count - skip if no machines
      const rows = page.locator('tbody tr');
      const rowCount = await rows.count();

      if (rowCount === 0) {
        test.skip();
      }

      // Get first row's code value
      const firstRow = rows.nth(0);
      const codeCell = firstRow.locator('td').nth(0);
      const originalCode = await codeCell.textContent();

      // Click actions menu
      const actionButton = firstRow.getByRole('button', { name: /Actions/i });
      await actionButton.click();

      // Click Edit
      const editOption = page.getByRole('menuitem', { name: /Edit/i });
      await editOption.click();

      // Wait for modal
      const dialog = page.getByRole('dialog');
      await expect(dialog).toBeVisible();

      // Assert code is pre-filled using ID selector
      const codeInput = page.locator('#code');
      const codeValue = await codeInput.inputValue();
      expect(codeValue.length > 0).toBeTruthy();
    });

    test('updates machine successfully', async ({ page }) => {
      // Get row count - skip if no machines
      const rows = page.locator('tbody tr');
      const rowCount = await rows.count();

      if (rowCount === 0) {
        test.skip();
      }

      // Click actions menu on first row
      const firstRow = rows.nth(0);
      const actionButton = firstRow.getByRole('button', { name: /Actions/i });
      await actionButton.click();

      // Click Edit
      const editOption = page.getByRole('menuitem', { name: /Edit/i });
      await editOption.click();

      // Wait for modal
      const dialog = page.getByRole('dialog');
      await expect(dialog).toBeVisible();

      // Update name field using ID selector
      const timestamp = Date.now();
      const nameInput = page.locator('#name');
      await nameInput.waitFor({ state: 'visible' });
      await nameInput.fill(`Updated Name ${timestamp}`);

      // Wait for any debounced validations
      await page.waitForTimeout(500);

      // Click submit button
      const submitButton = dialog.getByRole('button', { name: /Save Changes/i });
      await submitButton.scrollIntoViewIfNeeded();
      await submitButton.click();

      // Wait a bit for submission to process
      await page.waitForTimeout(2000);

      // Check success: modal should close or success message appears
      const isDialogHidden = await dialog.isHidden().catch(() => true);
      const hasSuccessMessage = await page.getByText(/updated|success/i).isVisible().catch(() => false);

      expect(isDialogHidden || hasSuccessMessage).toBeTruthy();
    });
  });

  test.describe('Delete', () => {
    test('shows delete confirmation dialog', async ({ page }) => {
      // Get row count - skip if no machines
      const rows = page.locator('tbody tr');
      const rowCount = await rows.count();

      if (rowCount === 0) {
        test.skip();
      }

      // Click actions menu on first row
      const firstRow = rows.nth(0);
      const actionButton = firstRow.getByRole('button', { name: /Actions/i });
      await actionButton.click();

      // Click Delete
      const deleteOption = page.getByRole('menuitem', { name: /Delete/i });
      await deleteOption.click();

      // Check for browser confirm dialog
      page.once('dialog', async (dialog) => {
        expect(dialog.type()).toBe('confirm');
        expect(dialog.message()).toContain('Delete machine');
        await dialog.accept();
      });
    });

    test('deletes machine after confirmation', async ({ page }) => {
      // Get row count - skip if no machines
      let rows = page.locator('tbody tr');
      let rowCount = await rows.count();

      if (rowCount === 0) {
        test.skip();
      }

      // Get initial count
      const initialCount = rowCount;

      // Click actions menu on first row
      rows = page.locator('tbody tr');
      const firstRow = rows.nth(0);
      const actionButton = firstRow.getByRole('button', { name: /Actions/i });
      await actionButton.click();

      // Click Delete
      const deleteOption = page.getByRole('menuitem', { name: /Delete/i });

      // Set up dialog handler before clicking delete
      page.once('dialog', async (dialog) => {
        await dialog.accept();
      });

      await deleteOption.click();

      // Wait for deletion to complete
      await page.waitForTimeout(1000);

      // Assert success - either success toast or row count decreased
      const successToast = page.getByText(/deleted successfully/i);
      const toastVisible = await successToast.isVisible().catch(() => false);

      if (toastVisible) {
        expect(toastVisible).toBeTruthy();
      } else {
        // Verify row count decreased
        const updatedRows = page.locator('tbody tr');
        const updatedCount = await updatedRows.count();
        expect(updatedCount).toBeLessThanOrEqual(initialCount);
      }
    });

    test('cancels delete operation', async ({ page }) => {
      // Get row count - skip if no machines
      const rows = page.locator('tbody tr');
      const rowCount = await rows.count();

      if (rowCount === 0) {
        test.skip();
      }

      // Get initial count
      const initialCount = rowCount;

      // Click actions menu
      const firstRow = rows.nth(0);
      const actionButton = firstRow.getByRole('button', { name: /Actions/i });
      await actionButton.click();

      // Click Delete
      const deleteOption = page.getByRole('menuitem', { name: /Delete/i });

      // Set up dialog handler to cancel
      page.once('dialog', async (dialog) => {
        await dialog.dismiss();
      });

      await deleteOption.click();

      // Wait briefly
      await page.waitForTimeout(500);

      // Assert row count unchanged
      const updatedRows = page.locator('tbody tr');
      const updatedCount = await updatedRows.count();
      expect(updatedCount).toBe(initialCount);
    });
  });
});
