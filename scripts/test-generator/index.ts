#!/usr/bin/env npx tsx
/**
 * E2E Test Generator CLI
 *
 * Usage:
 *   pnpm test:gen <path> <type> [options]
 *
 * Examples:
 *   pnpm test:gen shipping/customers crud
 *   pnpm test:gen quality/inspections form --page InspectionForm
 *   pnpm test:gen production/wo-flow flow --steps 5
 *   pnpm test:gen settings/users auth --roles admin,manager
 *
 * Types:
 *   crud  - CRUD operations for DataTable pages
 *   form  - Form validation and submission
 *   flow  - Multi-step workflow
 *   auth  - Role-based access tests
 */

import * as fs from 'fs';
import * as path from 'path';
import * as readline from 'readline';

// Colors for terminal
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  red: '\x1b[31m',
  dim: '\x1b[2m',
};

const log = {
  info: (msg: string) => console.log(`${colors.blue}ℹ${colors.reset} ${msg}`),
  success: (msg: string) => console.log(`${colors.green}✓${colors.reset} ${msg}`),
  warn: (msg: string) => console.log(`${colors.yellow}⚠${colors.reset} ${msg}`),
  error: (msg: string) => console.log(`${colors.red}✗${colors.reset} ${msg}`),
};

// Parse command line arguments
function parseArgs(): {
  path: string;
  type: string;
  options: Record<string, string>;
} {
  const args = process.argv.slice(2);

  if (args.length < 2 || args[0] === '--help' || args[0] === '-h') {
    printHelp();
    process.exit(0);
  }

  const [testPath, type, ...rest] = args;
  const options: Record<string, string> = {};

  for (let i = 0; i < rest.length; i += 2) {
    const key = rest[i]?.replace(/^--?/, '');
    const value = rest[i + 1];
    if (key && value) {
      options[key] = value;
    }
  }

  return { path: testPath, type, options };
}

function printHelp() {
  console.log(`
${colors.blue}E2E Test Generator${colors.reset}

${colors.yellow}Usage:${colors.reset}
  pnpm test:gen <path> <type> [options]

${colors.yellow}Arguments:${colors.reset}
  path    Test file path (e.g., shipping/customers)
  type    Template type: crud, form, flow, auth

${colors.yellow}Options:${colors.reset}
  --page <name>     Page object class name
  --route <path>    Route path (default: derived from path)
  --steps <n>       Number of flow steps (for flow type)
  --roles <list>    Comma-separated roles (for auth type)

${colors.yellow}Examples:${colors.reset}
  pnpm test:gen shipping/customers crud
  pnpm test:gen quality/inspections form --page InspectionFormPage
  pnpm test:gen production/wo-complete flow --steps 4
  pnpm test:gen settings/users auth --roles admin,manager,planner

${colors.yellow}Templates:${colors.reset}
  ${colors.dim}crud${colors.reset}  - DataTable CRUD: list, create, edit, delete, search
  ${colors.dim}form${colors.reset}  - Form tests: validation, submit, reset, errors
  ${colors.dim}flow${colors.reset}  - Workflow: multi-step process with state
  ${colors.dim}auth${colors.reset}  - Auth: role-based access, permissions
`);
}

// Convert path to various naming conventions
function toNames(testPath: string) {
  const parts = testPath.split('/');
  const fileName = parts[parts.length - 1];
  const moduleName = parts[0];

  // kebab-case to PascalCase
  const toPascal = (s: string) =>
    s
      .split('-')
      .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
      .join('');

  // kebab-case to Title Case
  const toTitle = (s: string) =>
    s
      .split('-')
      .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
      .join(' ');

  return {
    fileName,
    moduleName,
    pascalName: toPascal(fileName),
    titleName: toTitle(fileName),
    route: `/${testPath.replace(/-/g, '-')}`,
    specPath: `e2e/tests/${testPath}.spec.ts`,
  };
}

// Template: CRUD tests
function generateCrudTemplate(names: ReturnType<typeof toNames>, options: Record<string, string>) {
  const pageName = options.page || `${names.pascalName}Page`;
  const route = options.route || names.route;

  return `/**
 * ${names.titleName} - CRUD Tests
 *
 * Tests:
 * - List view loads correctly
 * - Can create new item
 * - Can edit existing item
 * - Can delete item
 * - Search/filter works
 *
 * @generated by test-generator
 */

import { test, expect } from '@playwright/test';
import { DataTablePage } from '../../pages';

// TODO: Create page object if needed
// import { ${pageName} } from '../../pages/modules/${pageName}';

const ROUTE = '${route}';

test.describe('${names.titleName} CRUD', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto(ROUTE);
    await page.waitForLoadState('networkidle');
  });

  test.describe('List View', () => {
    test('displays data table', async ({ page }) => {
      const table = new DataTablePage(page);
      await table.expectTableVisible();
    });

    test('shows empty state when no data', async ({ page }) => {
      // TODO: Setup empty state condition
      const table = new DataTablePage(page);
      // await table.expectEmptyState();
    });

    test('can search items', async ({ page }) => {
      const table = new DataTablePage(page);

      // TODO: Replace with actual search term
      await table.search('test-search-term');

      // TODO: Assert search results
      // await table.expectRowWithText('expected-result');
    });

    test('can sort by column', async ({ page }) => {
      const table = new DataTablePage(page);

      // TODO: Replace with actual column name
      await table.sortByColumn('Name');

      // TODO: Assert sort order
    });
  });

  test.describe('Create', () => {
    test('opens create modal/form', async ({ page }) => {
      const table = new DataTablePage(page);
      await table.clickCreate();

      // TODO: Assert modal/form is visible
      await expect(page.locator('[role="dialog"]')).toBeVisible();
    });

    test('validates required fields', async ({ page }) => {
      const table = new DataTablePage(page);
      await table.clickCreate();

      // Submit without filling required fields
      await page.click('button[type="submit"]');

      // TODO: Assert validation errors
      // await expect(page.getByText('required')).toBeVisible();
    });

    test('creates new item successfully', async ({ page }) => {
      const table = new DataTablePage(page);
      await table.clickCreate();

      // TODO: Fill form fields
      // await page.getByLabel('Name').fill('Test Item');
      // await page.getByLabel('Code').fill('TEST-001');

      await page.click('button[type="submit"]');

      // TODO: Assert success
      // await expect(page.getByText('created successfully')).toBeVisible();
    });
  });

  test.describe('Edit', () => {
    test('opens edit modal with existing data', async ({ page }) => {
      const table = new DataTablePage(page);

      // TODO: Click on existing row or edit button
      await table.clickRowAction(0, 'Edit');

      // TODO: Assert form is pre-filled
      // await expect(page.getByLabel('Name')).toHaveValue('existing-value');
    });

    test('updates item successfully', async ({ page }) => {
      const table = new DataTablePage(page);
      await table.clickRowAction(0, 'Edit');

      // TODO: Modify fields
      // await page.getByLabel('Name').fill('Updated Name');

      await page.click('button[type="submit"]');

      // TODO: Assert success
      // await expect(page.getByText('updated successfully')).toBeVisible();
    });
  });

  test.describe('Delete', () => {
    test('shows confirmation dialog', async ({ page }) => {
      const table = new DataTablePage(page);
      await table.clickRowAction(0, 'Delete');

      // TODO: Assert confirmation dialog
      await expect(page.getByRole('alertdialog')).toBeVisible();
    });

    test('deletes item after confirmation', async ({ page }) => {
      const table = new DataTablePage(page);
      const initialCount = await table.getRowCount();

      await table.clickRowAction(0, 'Delete');
      await page.click('button:has-text("Confirm"), button:has-text("Delete")');

      // TODO: Assert item removed
      // await expect(table.getRowCount()).resolves.toBe(initialCount - 1);
    });

    test('cancels delete', async ({ page }) => {
      const table = new DataTablePage(page);
      const initialCount = await table.getRowCount();

      await table.clickRowAction(0, 'Delete');
      await page.click('button:has-text("Cancel")');

      // Item should still exist
      await expect(table.getRowCount()).resolves.toBe(initialCount);
    });
  });
});
`;
}

// Template: Form tests
function generateFormTemplate(names: ReturnType<typeof toNames>, options: Record<string, string>) {
  const pageName = options.page || `${names.pascalName}FormPage`;
  const route = options.route || `${names.route}/new`;

  return `/**
 * ${names.titleName} - Form Tests
 *
 * Tests:
 * - Form renders correctly
 * - Validation rules work
 * - Submit success flow
 * - Submit error handling
 * - Form reset
 *
 * @generated by test-generator
 */

import { test, expect } from '@playwright/test';
import { FormPage } from '../../pages';

const ROUTE = '${route}';

test.describe('${names.titleName} Form', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto(ROUTE);
    await page.waitForLoadState('networkidle');
  });

  test.describe('Rendering', () => {
    test('displays form with all fields', async ({ page }) => {
      // TODO: Add your form fields
      const fields = [
        // 'name',
        // 'email',
        // 'description',
      ];

      for (const field of fields) {
        await expect(page.locator(\`[name="\${field}"]\`)).toBeVisible();
      }
    });

    test('shows required field indicators', async ({ page }) => {
      // TODO: Check for required indicators (asterisks, aria-required)
      // await expect(page.getByLabel('Name *')).toBeVisible();
    });
  });

  test.describe('Validation', () => {
    test('shows error for empty required fields', async ({ page }) => {
      const form = new FormPage(page);
      await form.submit();

      // TODO: Assert validation errors
      // await form.expectFieldError('name', 'required');
    });

    test('validates email format', async ({ page }) => {
      const form = new FormPage(page);

      // TODO: Fill invalid email
      // await form.fillInput('email', 'invalid-email');
      // await form.submit();

      // await form.expectFieldError('email', 'valid email');
    });

    test('validates minimum length', async ({ page }) => {
      const form = new FormPage(page);

      // TODO: Fill too short value
      // await form.fillInput('name', 'ab');
      // await form.submit();

      // await form.expectFieldError('name', 'at least 3');
    });

    test('validates maximum length', async ({ page }) => {
      const form = new FormPage(page);

      // TODO: Fill too long value
      // await form.fillInput('name', 'a'.repeat(256));
      // await form.submit();

      // await form.expectFieldError('name', 'maximum');
    });

    test('clears errors on valid input', async ({ page }) => {
      const form = new FormPage(page);

      // Trigger error
      await form.submit();
      // await form.expectFieldError('name');

      // Fix error
      // await form.fillInput('name', 'Valid Name');
      // await form.expectNoFieldError('name');
    });
  });

  test.describe('Submit', () => {
    test('submits successfully with valid data', async ({ page }) => {
      const form = new FormPage(page);

      // TODO: Fill all required fields
      // await form.fillInput('name', 'Test Name');
      // await form.fillInput('email', 'test@example.com');

      await form.submit();

      // TODO: Assert success
      // await form.expectSuccessToast('created successfully');
    });

    test('shows loading state during submit', async ({ page }) => {
      const form = new FormPage(page);

      // TODO: Fill form
      // await form.fillFields({ name: 'Test', email: 'test@test.com' });

      // Check for loading indicator
      await form.submit();
      // await expect(page.locator('button[type="submit"]')).toBeDisabled();
    });

    test('handles server error gracefully', async ({ page }) => {
      // TODO: Mock API error response
      // await page.route('**/api/**', route => route.fulfill({ status: 500 }));

      const form = new FormPage(page);
      // await form.fillFields({ name: 'Test' });
      await form.submit();

      // await form.expectErrorToast('error');
    });
  });

  test.describe('Cancel/Reset', () => {
    test('cancel returns to previous page', async ({ page }) => {
      const form = new FormPage(page);
      const previousUrl = page.url();

      await form.cancel();

      // Should navigate away
      expect(page.url()).not.toBe(previousUrl);
    });

    test('reset clears all fields', async ({ page }) => {
      const form = new FormPage(page);

      // TODO: Fill some fields
      // await form.fillInput('name', 'Test Value');

      await form.reset();

      // TODO: Assert fields are empty
      // await expect(form.getFieldValue('name')).resolves.toBe('');
    });

    test('warns about unsaved changes', async ({ page }) => {
      const form = new FormPage(page);

      // TODO: Fill some fields to mark form as dirty
      // await form.fillInput('name', 'Test Value');

      // Try to navigate away
      // page.on('dialog', dialog => dialog.accept());
      // await page.goBack();
    });
  });
});
`;
}

// Template: Flow tests
function generateFlowTemplate(names: ReturnType<typeof toNames>, options: Record<string, string>) {
  const steps = parseInt(options.steps || '3', 10);
  const route = options.route || names.route;

  const stepTests = Array.from({ length: steps }, (_, i) => {
    const stepNum = i + 1;
    return `
    test('Step ${stepNum}: TODO description', async ({ page }) => {
      // TODO: Implement step ${stepNum}
      // Navigation or action
      // await page.click('button:has-text("Next")');

      // Assertions
      // await expect(page.getByText('Step ${stepNum}')).toBeVisible();
    });`;
  }).join('\n');

  return `/**
 * ${names.titleName} - Workflow Tests
 *
 * Tests multi-step workflow:
 * ${Array.from({ length: steps }, (_, i) => `* - Step ${i + 1}: TODO`).join('\n ')}
 *
 * @generated by test-generator
 */

import { test, expect } from '@playwright/test';

const ROUTE = '${route}';

test.describe('${names.titleName} Workflow', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto(ROUTE);
    await page.waitForLoadState('networkidle');
  });

  test.describe('Happy Path', () => {
    test('completes full workflow', async ({ page }) => {
      // TODO: Implement complete flow
      // Step 1
      // await page.fill('[name="field1"]', 'value1');
      // await page.click('button:has-text("Next")');

      // Step 2
      // await page.fill('[name="field2"]', 'value2');
      // await page.click('button:has-text("Next")');

      // ... more steps

      // Final step
      // await page.click('button:has-text("Complete")');
      // await expect(page.getByText('Success')).toBeVisible();
    });
  });

  test.describe('Step Navigation', () => {
    test('can navigate back to previous step', async ({ page }) => {
      // Go to step 2
      // await page.click('button:has-text("Next")');

      // Go back
      // await page.click('button:has-text("Back")');

      // Should be on step 1
      // await expect(page.getByText('Step 1')).toBeVisible();
    });

    test('preserves data when navigating back', async ({ page }) => {
      // Fill step 1
      // await page.fill('[name="field1"]', 'preserved-value');
      // await page.click('button:has-text("Next")');

      // Go back
      // await page.click('button:has-text("Back")');

      // Data should be preserved
      // await expect(page.locator('[name="field1"]')).toHaveValue('preserved-value');
    });
  });

  test.describe('Individual Steps', () => {${stepTests}
  });

  test.describe('Error Handling', () => {
    test('shows validation errors before proceeding', async ({ page }) => {
      // Try to proceed without filling required fields
      // await page.click('button:has-text("Next")');

      // Should show error
      // await expect(page.getByText('required')).toBeVisible();
    });

    test('can recover from errors', async ({ page }) => {
      // Cause an error
      // await page.click('button:has-text("Next")');

      // Fix the error
      // await page.fill('[name="field1"]', 'valid-value');
      // await page.click('button:has-text("Next")');

      // Should proceed
      // await expect(page.getByText('Step 2')).toBeVisible();
    });
  });

  test.describe('Cancel Flow', () => {
    test('can cancel at any step', async ({ page }) => {
      // Go to middle of flow
      // await page.click('button:has-text("Next")');

      // Cancel
      // await page.click('button:has-text("Cancel")');

      // Should return to start or list
      // await expect(page).toHaveURL(/list|start/);
    });
  });
});
`;
}

// Template: Auth tests
function generateAuthTemplate(names: ReturnType<typeof toNames>, options: Record<string, string>) {
  const roles = (options.roles || 'admin,manager,operator').split(',');
  const route = options.route || names.route;

  const roleTests = roles
    .map(
      (role) => `
  test.describe('${role.charAt(0).toUpperCase() + role.slice(1)} Role', () => {
    test.use({ storageState: '.auth/${role}.json' });

    test('can access ${names.titleName}', async ({ page }) => {
      await page.goto('${route}');

      // TODO: Assert page loads (or redirects if no access)
      // await expect(page).toHaveURL('${route}');
      // OR for no access:
      // await expect(page).toHaveURL('/unauthorized');
    });

    test('sees correct UI elements', async ({ page }) => {
      await page.goto('${route}');

      // TODO: Check role-specific UI
      // if (${role === 'admin'}) {
      //   await expect(page.getByRole('button', { name: 'Delete' })).toBeVisible();
      // } else {
      //   await expect(page.getByRole('button', { name: 'Delete' })).not.toBeVisible();
      // }
    });

    test('can perform allowed actions', async ({ page }) => {
      await page.goto('${route}');

      // TODO: Test role-specific actions
      // await page.click('button:has-text("Edit")');
      // await expect(page.locator('[role="dialog"]')).toBeVisible();
    });
  });`
    )
    .join('\n');

  return `/**
 * ${names.titleName} - Role-Based Access Tests
 *
 * Tests access control for roles:
 * ${roles.map((r) => `* - ${r}`).join('\n ')}
 *
 * @generated by test-generator
 */

import { test, expect } from '@playwright/test';

const ROUTE = '${route}';

test.describe('${names.titleName} - Access Control', () => {
  test.describe('Unauthenticated', () => {
    test.use({ storageState: { cookies: [], origins: [] } });

    test('redirects to login', async ({ page }) => {
      await page.goto('${route}');
      await expect(page).toHaveURL(/\\/login/);
    });
  });
${roleTests}

  test.describe('Permission Boundaries', () => {
    test('admin can delete', async ({ page }) => {
      // Use admin auth
      // TODO: Verify delete action works
    });

    test('operator cannot delete', async ({ page }) => {
      // Use operator auth
      // TODO: Verify delete button hidden or action blocked
    });
  });
});
`;
}

// Main generator function
function generateTest(testPath: string, type: string, options: Record<string, string>) {
  const names = toNames(testPath);

  let content: string;
  switch (type) {
    case 'crud':
      content = generateCrudTemplate(names, options);
      break;
    case 'form':
      content = generateFormTemplate(names, options);
      break;
    case 'flow':
      content = generateFlowTemplate(names, options);
      break;
    case 'auth':
      content = generateAuthTemplate(names, options);
      break;
    default:
      log.error(`Unknown template type: ${type}`);
      log.info('Available types: crud, form, flow, auth');
      process.exit(1);
  }

  // Create directory if needed
  const dir = path.dirname(names.specPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    log.info(`Created directory: ${dir}`);
  }

  // Check if file exists
  if (fs.existsSync(names.specPath)) {
    log.warn(`File already exists: ${names.specPath}`);
    log.info('Use --force to overwrite');
    if (!options.force) {
      process.exit(1);
    }
  }

  // Write file
  fs.writeFileSync(names.specPath, content);
  log.success(`Generated: ${names.specPath}`);

  // Print next steps
  console.log(`
${colors.yellow}Next steps:${colors.reset}
  1. Open ${colors.blue}${names.specPath}${colors.reset}
  2. Replace TODO comments with actual test logic
  3. Run: ${colors.dim}pnpm test:e2e --grep "${names.titleName}"${colors.reset}
`);
}

// Run
const { path: testPath, type, options } = parseArgs();
generateTest(testPath, type, options);
